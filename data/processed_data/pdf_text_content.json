{"1002-3469.pdf": "\u00a9 2006 Sunrom Technologies         http://www.sunrom.com                                         1  \n \n \nP89C51RD2 Controller Board with ICSP Programmer \n \n1. Overview \nVersatile, easy-to-use, general-purpose controller using the popular Philips P89C51RD2 microcontroller. \nThe board includes no more than is absolutely necessary for a basic controller, thus keeping the cost \nand board size to a minimum. All of the individual pins have been brought out to standard four .1\"-spaced \nheaders to accommodate interfacing to almost any kind of circuitry. It is designed for use in applications \nranging from robotics to industrial controller applications. \n2. Features \n\u2022 Philips P89C51RD2 with 11.0592 Mhz Crystal Oscillator \n\u2022 Operates over a wide range of supply voltage: 7 to 15 Volts \n\u2022 On-Board 1 Amp Power Supply & Power Indicator LED \n\u2022 On-Board Reset Switch \n\u2022 ICSP for In-System-Programming \n\u2022 On-Board RS232 Port for direct connection to PC's Serial Port \n3. Specifications \n\u2022 64 KB ISP Capable Flash Memory \n\u2022 1 KB RAM \n\u2022 80C51 Central Processing Unit \n\u2022 On-chip Flash Program Memory with In-System Programming \n\u2022 4 level priority interrupt \n\u2022 8 interrupt sources \n\u2022 Four 8-bit I/O ports \n\u2022 Full-duplex enhanced UART \n\u2022 Power down mode \n\u2022 Second DPTR register \n\u2022 Asynchronous port reset \n\u2022 Low EMI (inhibit ALE) \n\u2022 Programmable Counter Array (PCA) / PWM / Capture/compare \n\n\u00a9 2006 Sunrom Technologies         http://www.sunrom.com                                         2  4. Schematic \n \nP1.0\nP1.2P1.1\nRXDP3.0P1.3\nP1.6P1.5P1.4\nP3.7 P1.7P3.0\nP3.5P3.4\nP3.6P3.2\nP3.3P3.1P2.5\nP2.7P2.0\nP2.6P2.2\nP2.3P2.1\nP2.4\nC7\n10uF 16VC4\n100n\nP1\nDCON9-F594837261C3\n10uF 16V\nC5\n10uF 16V\nU2\nMAX232R2IN8\nT2IN10C+1\nC1-3C2+4\nC2-5\nV+2V-6\nR2OUT9\nT2OUT7VCC16GND15\nC6\n10uF 16VC2\n10uF 16VVCCU1\n89xx\nP3.1/TXD11\nP3.2/INT012\nP3.3/INT113\nP3.4/T014\nP3.5/T115\nP3.6/WR16\nP3.7/RD17XTAL218XTAL119GND20\nP2.0/A821\nP2.1/A922\nP2.2/A1023\nP2.3/A1124\nP2.4/A1225\nP2.5/A1326\nP2.6/A1427\nP2.7/A1528\nPSEN29\nALE/PROG30EA/VPP31P0.7/AD732P0.6/AD633P0.5/AD534P0.4/AD435P0.3/AD336P0.2/AD237P0.1/AD138P0.0/AD039\nVCC40\nP1.0/T21\nP1.1/T2EX2\nP1.23\nP1.34\nP1.4/SS5\nP1.5/MOSI6\nP1.6/MISO7\nP1.7/SCK8\nRST9P3.0/RXD10RN1\n10K Resistor Array9\n8\n7\n6\n5\n4\n3\n2 1\nY1\n11.0592C1\n100n\nC9\n33pC8\n33pVCC\nVCCVCC\nCN2\n20 Pin FRC2\n4\n6\n8\n10\n12\n14\n16\n18\n201\n3\n5\n7\n9\n11\n13\n15\n17\n19P0.0\nP0.3P0.2P0.1\nP0.6P0.5P0.4\nVCCP0.7P0.0\nGND GND\nVDDVCCP0.1\nP0.6\nRXD\nVCCP0.3P0.2\nRSTTXD\nPSEN\nCN9\nDC SOCKETP0.7P0.5P0.4\nC11\n100nCN3\nBH10\n1 2\n3 4\n5 6\n7 8\n9 10PORT1PORT0\nGNDP1.6P1.0\nD5Philips 10-way ISP Header\nVCC\nP1.1\nP1.7P1.4\nGNDVCC\nC12\n100n+\nC13\n10uF 16V D4CN4\n20 Pin FRC2\n4\n6\n8\n10\n12\n14\n16\n18\n201\n3\n5\n7\n9\n11\n13\n15\n17\n19\nINOUT\nGND\nU3\nLM7805P1.2\nVCCP1.2\nP1.3P1.0\nD2P1.6P1.4P1.3\nP1.5P1.1\nP1.5\nD1P3.2P1.7\n+\nC101000uF 25VPORT2\nGND\nP3.6PORT3\nP2.6P2.0\nPOWER INPUT AND REGULATOR\nP3.4P2.4\nR2\n470EP3.4P2.1\nP2.7\nD3\nLEDVCC\nGNDP3.1VCC\nP3.0\nP3.1GND\nCN7\n2 Pin Screw TerminalCN8\n2 Pin Screw TerminalCN5\n20 Pin FRC2\n4\n6\n8\n10\n12\n14\n16\n18\n201\n3\n5\n7\n9\n11\n13\n15\n17\n19\nVDD VCCP2.2\nVCCP2.2\nUnregulated Output VoltageP3.2P2.0\nP3.3\nPOWER OUT\nRegulated 5V Output VoltageP3.7P2.3\n+5V +VP2.4P2.3\nP3.0P2.6\nP3.5P3.3\nP3.7P2.5\nCN6\n20 Pin FRC2\n4\n6\n8\n10\n12\n14\n16\n18\n201\n3\n5\n7\n9\n11\n13\n15\n17\n19P3.5P2.1\nVCCP2.5\nGNDP3.6P2.7VCC\nJ1\nJUMPER3PRSTP0.7P0.4\nP0.5P0.0\nP0.3P0.1\nP0.2\nP0.6RST\nSCKP1.7\nMISOP1.6CN1\nBH10\n1 2\n3 4\n5 6\n7 8\n9 10\nAtmel 10-way ISP Header\nMOSIP1.5VCCIn System Programming\nRS232\nRST\nTitle\nCodeRev\nDate:Sheet\nof\n1002-346918051 Microcontroller Development BoardSunrom Technologies               http://www.sunrom.com\n11 Monday, December 04, 2006SW1\nRESET SW\nVCCPSEN\nR1\n10KTXDP3.1\n\n\u00a9 2006 Sunrom Technologies         http://www.sunrom.com                                         3  5. Programming software \nStart setup by clicking FlashMagic.exe, and follow setup instructions. \nOnce installed start Flash Magic from Start Menu > All Programs > Flash Magic \nFollowing main screen is displayed, Change options on main screen as shown below. \nSelect appropriate serial port present on your PC. \n \n \n \nAdditional Setup includes going to Options > Advanced Options and setting as below \n \n \n\n\u00a9 2006 Sunrom Technologies         http://www.sunrom.com                                         4  6. Package Includes \n \n\u2022 Fully Assembled and Tested Controller Board and ICSP Programmer Board \n\u2022 Flat Ribbon Cable connecting between Controller Board and Programmer \n\u2022 Serial Port Cable for Programmer \n\u2022 CDROM containing Schematic, Programming Software and User Manual \n7. Ordering Information \nPart Number Description  \n1002-3469 Philips P89C51RD2 Controller Board with ICSP Programmer \n1002-3468A Atmel AT89S52 Controller Board with ICSP Programmer \n8. Also Available \nAtmel AT89S52 Controller Board with ICSP Programmer \nhttp://www.sunrom.com/index.php?main_page=product_info&cPath=35&products_id=139  \n \n\n\u00a9 2006 Sunrom Technologies         http://www.sunrom.com                                         5  9. Disclaimer \nCopyright \u00a9 Sunrom Technologies , 2006 \n \nNeither the whole nor any part of the information contained in, or the product described in this manual, \nmay be adapted or reproduced in any material or electronic form without the prior written consent of the \ncopyright holder. \n \nThis product and its documentation are supplied on an as-is basis and no warranty as to their suitability \nfor any particular purpose is either made or implied. \n \nSunrom Technologies will not accept any claim for damages howsoever arising as a result of use or \nfailure of this product. Your statutory rights are not affected. \n \nThis product or any variant of it is not intended for use in any medical appliance, device or system in \nwhich the failure of the product might reasonably be expected to result in personal injury. \n \nThis document provides preliminary information that may be subject to change without notice. \n \n10. Contact Sunrom Technologies \n \n \n \n \nSunrom Technologies \n33, 1st Flr, Yash Niketan Khokhra Circle, Maninagar, \nAhmedabad - 380026, Gujarat, India \nPhone (+91) 9825 858 509 \n \n \nWebsite URL : http://www.sunrom.com/  \n \n \n", "80c2051.pdf": "Features\n\u2022Compatible with MCS\u00ae-51Products\n\u007f2K Bytes of Reprogrammable Flash Memory\n\u2013 Endurance: 1,000 Write/Erase Cycles\n\u007f2.7V to 6V Operating Range\n\u007fFully Static Operation: 0 Hz to 24 MHz\n\u007fTwo-level Program Memory Lock\n\u007f128 x 8-bit Internal RAM\n\u007f15 Programmable I/O Lines\n\u007fTwo 16-bit Timer/Counters\n\u007fSix Interrupt Sources\n\u007fProgrammable Serial UART Channel\n\u007fDirect LED Drive Outputs\n\u007fOn-chip Analog Comparator\n\u007fLow-power Idle and Power-down Modes\n\u007fGreen (Pb/Halide-free) Packaging Option\n1. Description\nThe AT89C2051 is a low-voltage, high-performance CMOS 8-bit microcomputer with \n2K bytes of Flash programmable and erasable read-only memory (PEROM). The \ndevice is manufactured using Atmel\u2019s high-density nonvolatile memory technology and is compatible with the industry-standard MCS-51 instruction set. By combining a \nversatile 8-bit CPU with Flash on a monolithic chip, the Atmel AT89C2051 is a power-\nful microcomputer which provides a highly-flexible and cost-effective solution to many embedded control applications.\nThe AT89C2051 provides the following standard features: 2K bytes of Flash, 128 \nbytes of RAM, 15 I/O lines, two 16-bit timer/counters, a five vector two-level interrupt architecture, a full duplex serial port, a precision analog comparator, on-chip oscillator \nand clock circuitry. In addition, the AT89C2051 is designed with static logic for opera-\ntion down to zero frequency and supports two software selectable power saving modes. The Idle Mode stops the CPU while allowing the RAM, timer/counters, serial \nport and interrupt system to continue functioning. The power-down mode saves the \nRAM contents but freezes the oscillator disabling all other chip functions until the next hardware reset.8-bit \nMicrocontroller with 2K Bytes \nFlash\nAT89C2051\n 0368G\u2013MICRO\u20136/05\n\n 2\n0368G\u2013MICRO\u20136/05AT89C2051 2. Pin Configuration\n2.1 20-lead PDIP/SOIC\n3. Block Diagram1\n234567891020\n191817161514131211\nRST/VPP\n(RXD) P3.0\n(TXD) P3.1\nXTAL2XTAL1\n(INT0) P3.2(INT1) P3.3\n(TO) P3.4\n(T1) P3.5\nGNDVCC\nP1.7P1.6P1.5P1.4P1.3P1.2P1.1 (AIN1)P1.0 (AIN0)P3.7\n\n 3\n0368G\u2013MICRO\u20136/05 AT89C2051\n4. Pin Description\n4.1 VCC\nSupply voltage.\n4.2 GND\nGround.\n4.3 Port 1\nThe Port 1 is an 8-bit bi-directional I/O port. Port pins P1.2 to P1.7 provide internal pull-ups. P1.0 \nand P1.1 require external pull-ups. P1.0 and P1.1 also serve as the positive input (AIN0) and the negative input (AIN1), respectively, of the on-chip precision analog comparator. The Port 1 out-\nput buffers can sink 20 mA and can drive LED displays directly. When 1s are written to Port 1 \npins, they can be used as inputs. When pins P1.2 to P1.7 are used as inputs and are externally \npulled low, they will source current (I\nIL) because of the internal pull-ups.\nPort 1 also receives code data during Flash programming and verification. \n4.4 Port 3\nPort 3 pins P3.0 to P3.5, P3.7 are seven bi-directional I/O pins with internal pull-ups. P3.6 is \nhard-wired as an input to the output of the on-chip comparator and is not accessible as a gen-\neral-purpose I/O pin. The Port 3 output buffers can sink 20 mA. When 1s are written to Port 3 \npins they are pulled high by the internal pull- ups and can be used as inputs. As inputs, Port 3 \npins that are externally being pulled low will source current (IIL) because of the pull-ups.\nPort 3 also serves the functions of various special features of the AT89C2051 as listed below:\nPort 3 also receives some control signals for Flash programming and verification. \n4.5 RST\nReset input. All I/O pins are reset to 1s as soon as RST goes high. Holding the RST pin high for \ntwo machine cycles while the oscillator is running resets the device. \nEach machine cycle takes 12 oscillator or clock cycles.\n4.6 XTAL1\nInput to the inverting oscillator amplifier and input to the internal clock operating circuit. Port Pin Alternate Functions\nP3.0 RXD (serial input port)\nP3.1 TXD (serial output port)P3.2 INT0\n (external interrupt 0)\nP3.3 INT1  (external interrupt 1)\nP3.4 T0 (timer 0 external input)P3.5 T1 (timer 1 external input)\n\n 4\n0368G\u2013MICRO\u20136/05AT89C2051 4.7 XTAL2\nOutput from the inverting oscillator amplifier.\n5. Oscillator Characteristics \nThe XTAL1 and XTAL2 are the input and output, respectively, of an inverting amplifier which can \nbe configured for use as an on-chip oscillator, as shown in Figure 5-1 . Either a quartz crystal or \nceramic resonator may be used. To drive the device from an external clock source, XTAL2 \nshould be left unconnected while XTAL1 is driven as shown in Figure 5-2 . There are no require-\nments on the duty cycle of the external clock signal, since the input to the internal clocking \ncircuitry is through a divide-by-two flip-flop, but minimum and maximum voltage high and low \ntime specifications must be observed.\nFigure 5-1. Oscillator Connections\nNote: C1, C2 = 30 pF \u00b1 10 pF for Crystals  \n= 40 pF \u00b1 10 pF for Ceramic Resonators\nFigure 5-2. External Clock Drive Configuration\n\n 5\n0368G\u2013MICRO\u20136/05 AT89C2051\n6. Special Function Registers\nA map of the on-chip memory area called the Special Function Register (SFR) space is shown in \nthe table below.\nNote that not all of the addresses are occupied, and unoccupied addresses may not be imple-\nmented on the chip. Read accesses to these addresses will in general return random data, and \nwrite accesses will have an indeterminate effect.\nUser software should not write 1s to these unlisted locations, since they may be used in future \nproducts to invoke new features. In that case, the reset or inactive values of the new bits will \nalways be 0.\nTable 6-1. AT89C2051 SFR Map and Reset Values\n0F8H 0FFH\n0F0HB\n000000000F7H\n0E8H 0EFH\n0E0HACC\n000000000E7H\n0D8H 0DFH\n0D0HPSW\n000000000D7H\n0C8H 0CFH\n0C0H 0C7H\n0B8HIP\nXXX000000BFH\n0B0HP3\n111111110B7H\n0A8HIE\n0XX000000AFH\n0A0H 0A7H\n98HSCON\n00000000SBUF\nXXXXXXXX9FH\n90HP1\n1111111197H\n88HTCON\n00000000TMOD\n00000000TL0\n00000000TL1\n00000000TH0\n00000000TH1\n000000008FH\n80HSP\n00000111DPL\n00000000DPH\n00000000PCON\n0XXX000087H\n\n 6\n0368G\u2013MICRO\u20136/05AT89C2051 7. Restrictions on Certain Instructions \nThe AT89C2051 and is an economical and cost-effective member of Atmel\u2019s growing family of \nmicrocontrollers. It contains 2K bytes of Flash pr ogram memory. It is fully compatible with the \nMCS-51 architecture, and can be programmed using the MCS-51 instruction set. However, there are a few considerations one must keep in mind when utilizing certain instructions to pro-\ngram this device. \nAll the instructions related to jumping or branching should be restricted such that the destination \naddress falls within the physical program memory space of the device, which is 2K for the \nAT89C2051. This should be the responsibility of the software programmer. For example, LJMP \n7E0H would be a valid instruction for the AT89C2051 (with 2K of memory), whereas LJMP 900H would not. \n7.1 Branching Instructions\nLCALL, LJMP, ACALL, AJMP, SJMP, JMP @A+DPTR  \u2013 These unconditional branching \ninstructions will execute correctly as long as the programmer keeps in mind that the destination branching address must fall within the physical boundaries of the program memory size (loca-\ntions 00H to 7FFH for the 89C2051). Violating the physical space limits may cause unknown \nprogram behavior.\nCJNE [...], DJNZ [...], JB, JNB, JC, JNC, JBC, JZ, JNZ  \u2013 With these conditional branching \ninstructions the same rule above applies. Again, violating the memory boundaries may cause \nerratic execution.\nFor applications involving interrupts the normal interrupt service routine address locations of the \n80C51 family architecture have been preserved.\n7.2 MOVX-related Instructions, Data Memory\nThe AT89C2051 contains 128 bytes of internal data memory. Thus, in the AT89C2051 the stack \ndepth is limited to 128 bytes, the amount of ava ilable RAM. External DATA memory access is \nnot supported in this device, nor is external PROGRAM memory execution. Therefore, no MOVX \n[...] instructions should be included in the program.\nA typical 80C51 assembler will still assemble instructions, even if they are written in violation of \nthe restrictions mentioned above. It is the responsibility of the controller user to know the physi-\ncal features and limitations of the devic e being used and adjust the instructions used \ncorrespondingly.\n8. Program Memory Lock Bits\nOn the chip are two lock bits which can be left unprogrammed (U) or can be programmed (P) to obtain the additional features listed in the Table 8-1 .\nNote: 1. The Lock Bits can only be erased with the Chip Erase operation.Table 8-1. Lock Bit Protection Modes(1)\nProgram Lock Bits\nLB1 LB2 Protection Type\n1 U U No program lock features2 P U Further programming of the Flash is disabled\n3 P P Same as mode 2, also verify is disabled\n\n 7\n0368G\u2013MICRO\u20136/05 AT89C2051\n9. Idle Mode \nIn idle mode, the CPU puts itself to sleep while all the on-chip peripherals remain active. The \nmode is invoked by software. The content of the on-chip RAM and all the special functions regis-ters remain unchanged during this mode. The idle mode can be terminated by any enabled \ninterrupt or by a hardware reset. \nThe P1.0 and P1.1 should be set to \u201c0\u201d if no external pull-ups are used, or set to \u201c1\u201d if \nexternal pull-ups are used.\nIt should be noted that when idle is terminated by a hardware reset, the device normally \nresumes program execution, from where it left off, up to two machine cycles before the internal reset algorithm takes control. On-chip hardware inhibits access to internal RAM in this event, but \naccess to the port pins is not inhibited. To e liminate the possibility of an unexpected write to a \nport pin when Idle is terminated by reset, the instruction following the one that invokes Idle \nshould not be one that writes to a port pin or to external memory.\n10. Power-down Mode \nIn the power-down mode the oscillator is stopped, and the instruction that invokes power-down \nis the last instruction executed. The on-chip RAM and Special Function Registers retain their \nvalues until the power-down mode is terminated. The only exit from power-down is a hardware \nreset. Reset redefines the SFRs but does not change the on-chip RAM. The reset should not be activated before V\nCC is restored to its normal operating level and must be held active long \nenough to allow the oscillator to restart and stabilize.\nThe P1.0 and P1.1 should be set to \u201c0\u201d if no external pull-ups are used, or set to \u201c1\u201d if \nexternal pull-ups are used.\n11. Programming The Flash\nThe AT89C2051 is shipped with the 2K bytes of on-chip PEROM code memory array in the erased state (i.e., contents = FFH) and ready to be programmed. The code memory array is pro-grammed one byte at a time. Once the array is programmed, to re-program any non-blank byte, \nthe entire memory array needs to be erased electrically.\nInternal Address Counter: The AT89C2051 contains an internal PEROM address counter \nwhich is always reset to 000H on the rising edge of RST and is advanced by applying a positive \ngoing pulse to pin XTAL1.\nProgramming Algorithm:  To program the AT89C2051, the following sequence is \nrecommended.\n1. Power-up sequence:  \nApply power between V\nCC and GND pins  \nSet RST and XTAL1 to GND\n2. Set pin RST to \u201cH\u201d  \nSet pin P3.2 to \u201cH\u201d\n3. Apply the appropriate combination of \u201cH\u201d or \u201cL\u201d logic  \nlevels to pins P3.3, P3.4, P3.5, P3.7 to select one of the programming operations shown in the PEROM Programming Modes table.\n\n 8\n0368G\u2013MICRO\u20136/05AT89C2051 To Program and Verify the Array:\n4. Apply data for Code byte at location 000H to P1.0 to P1.7.\n5. Raise RST to 12V to enable programming.6. Pulse P3.2 once to program a byte in the PEROM array or the lock bits. The byte-write \ncycle is self-timed and typically takes 1.2 ms.\n7. To verify the programmed data, lower RST from 12V to logic \u201cH\u201d level and set pins P3.3 \nto P3.7 to the appropriate levels. Output data can be read at the port P1 pins.\n8. To program a byte at the next address location, pulse XTAL1 pin once to advance the \ninternal address counter. Apply new data to the port P1 pins.\n9. Repeat steps 6 through 8, changing data and advancing the address counter for the \nentire 2K bytes array or until the end of the object file is reached.\n10. Power-off sequence:  \nset XTAL1 to \u201cL\u201d  \nset RST to \u201cL\u201d  \nTur n V\nCC power off\nData  Polling:  The AT89C2051 features Data  Polling to indicate the end of a write cycle. During \na write cycle, an attempted read of the last byte written will result in the complement of the writ-\nten data on P1.7. Once the write cycle has been completed, true data is valid on all outputs, and \nthe next cycle may begin. Data  Polling may begin any time after a write cycle has been initiated.\nReady/Busy : The Progress of byte programming can also be monitored by the RDY/BSY  output \nsignal. Pin P3.1 is pulled low after P3.2 goes High during programming to indicate BUSY. P3.1 is \npulled High again when programming is done to indicate READY.\nProgram Verify:  If lock bits LB1 and LB2 have not been programmed code data can be read \nback via the data lines for verification:\n1. Reset the internal address counter to 000H by bringing RST from \u201cL\u201d to \u201cH\u201d.\n2. Apply the appropriate control signals for Read Code data and read the output data at \nthe port P1 pins.\n3. Pulse pin XTAL1 once to advance the internal address counter.4. Read the next code data byte at the port P1 pins.5. Repeat steps 3 and 4 until the entire array is read.\nThe lock bits cannot be verified directly. Verification of the lock bits is achieved by observing that \ntheir features are enabled.\nChip Erase:  The entire PEROM array (2K bytes) and the two Lock Bits are erased electrically \nby using the proper combination of control signals and by holding P3.2 low for 10 ms. The code array is written with all \u201c1\u201ds in the Chip Erase operation and must be executed before any non-\nblank memory byte can be re-programmed.\nReading the Signature Bytes: The signature bytes are read by the same procedure as a nor-\nmal verification of locations 000H, 001H, and 002H, except that P3.5 and P3.7 must be pulled to \na logic low. The values returned are as follows. \n  (000H) = 1EH indicates manufactured by Atmel  \n  (001H) = 21H indicates 89C2051\n\n 9\n0368G\u2013MICRO\u20136/05 AT89C2051\n12. Programming Interface\nEvery code byte in the Flash array can be writt en and the entire array can be erased by using \nthe appropriate combination of control signals. The write operation cycle is self-timed and once initiated, will automatically time itself to completion.\nMost major worldwide programming vendors offer support for the Atmel AT89 microcontroller \nseries. Please contact your local programming vendor for the appropriate software revision.\nNotes: 1. The internal PEROM address counter is reset to 000H on the rising edge of RST and is advanced by a positive pulse at \nXTAL1 pin.\n2. Chip Erase requires a 10 ms PROG  pulse.\n3. P3.1 is pulled Low during programming to indicate RDY/BSY .13. Flash Programming Modes\nMode RST/VPP P3.2/PROG P3.3 P3.4 P3.5 P3.7\nWrite Code Data(1)(3)12V L H H H\nRead Code Data(1)HH L L H H\nWrite Lock B i t  -  1 1 2 V HHHH\nBit - 2 12V H H L L\nChip Erase 12V H L L L\nRead Signature Byte H H L L L L(2)\n\n 10\n0368G\u2013MICRO\u20136/05AT89C2051 Figure 13-1. Programming the Flash Memory\nFigure 13-2. Verifying the Flash MemoryPP\n\n 11\n0368G\u2013MICRO\u20136/05 AT89C2051\nNote: 1.  Only used in 12-volt programming mode.\n15. Flash Programming and Verification Waveforms14. Flash Programming and Verification Characteristics \nTA = 0\u00b0C to 70\u00b0C, VCC = 5.0 \u00b1 10%\nSymbol Parameter Min Max Units\nVPP Programming Enable Voltage 11.5 12.5 V\nIPP Programming Enable Current 250 \u00b5A\ntDVGL Data Setup to PROG  Low 1.0 \u00b5s\ntGHDX Data Hold after PROG 1.0 \u00b5s\ntEHSH P3.4 (ENABLE ) High to VPP 1.0 \u00b5s\ntSHGL VPP Setup to PROG  Low 10 \u00b5s\ntGHSL VPP Hold after PROG 10 \u00b5s\ntGLGH PROG  Width 1 110 \u00b5s\ntELQV ENABLE  Low to Data Valid 1.0 \u00b5s\ntEHQZ Data Float after ENABLE 01 . 0 \u00b5 s\ntGHBL PROG  High to BUSY  Low 50 ns\ntWC Byte Write Cycle Time 2.0 ms\ntBHIH RDY/BSY \\ to Increment Clock Delay 1.0 \u00b5s\ntIHIL Increment Clock High 200 ns\n\n 12\n0368G\u2013MICRO\u20136/05AT89C2051 Notes: 1. Under steady state (non-transient) conditions, IOL must be externally limited as follows:  \nMaximum IOL per port pin: 20 mA  \nMaximum total IOL for all output pins: 80 mA  \nIf IOL exceeds the test condition, VOL may exceed the related specification. Pins are not guaranteed to sink current greater \nthan the listed test conditions.\n2. Minimum VCC for Power-down is 2V.16. Absolute Maximum Ratings*\nOperating Temperature ................................. -55\u00b0C to +125\u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or any other conditions beyond those indicated in the \noperational sections of this specification is not \nimplied. Exposure to absolute maximum rating conditions for extended periods may affect device \nreliability.Storage Temperature..................................... -65\u00b0C to +150\u00b0C\nVoltage on Any Pin  \nwith Respect to Ground .....................................-1.0V to +7.0V\nMaximum Operating Voltage ............................................ 6.6VDC Output Current...................................................... 25.0 mA\n17. DC Characteristics\nTA = -40\u00b0C to 85\u00b0C, VCC = 2.7V to 6.0V (unless otherwise noted)\nSymbol Parameter Condition Min Max Units\nVIL Input Low-voltage -0.5 0.2 VCC - 0.1 V\nVIH Input High-voltage (Except XTAL1, RST) 0.2 VCC + 0.9 VCC + 0.5 V\nVIH1 Input High-voltage (XTAL1, RST) 0.7 VCC VCC + 0.5 V\nVOLOutput Low-voltage(1)\n(Ports 1, 3)IOL = 20 mA, VCC = 5V  \nIOL = 10 mA, VCC = 2.7V0.5 V\nVOHOutput High-voltage  \n(Ports 1, 3)IOH = -80 \u00b5A, VCC = 5V \u00b1 10% 2.4 V\nIOH = -30 \u00b5A 0.75 VCC V\nIOH = -12 \u00b5A 0.9 VCC V\nIILLogical 0 Input Current  \n(Ports 1, 3)VIN = 0.45V -50 \u00b5A\nITLLogical 1 to 0 Transition Current \n(Ports 1, 3)VIN = 2V, VCC = 5V \u00b1 10% -750 \u00b5A\nILIInput Leakage Current  \n(Port P1.0, P1.1)0 < VIN < VCC \u00b110 \u00b5A\nVOS Comparator Input Offset Voltage VCC = 5V 20 mV\nVCMComparator Input Common \nMode Voltage0VCC V\nRRST Reset Pull-down Resistor 50 300 k \u2126\nCIO Pin Capacitance Test Freq. = 1 MHz, TA = 25\u00b0C 10 pF\nICCPower Supply CurrentActive Mode, 12 MHz, VCC = 6V/3V 15/5.5 mA\nIdle Mode, 12 MHz, VCC = 6V/3V \nP1.0 & P1.1 = 0V or VCC5/1 mA\nPower-down Mode(2)VCC = 6V, P1.0 & P1.1 = 0V or VCC 100 \u00b5A\nVCC = 3V, P1.0 & P1.1 = 0V or VCC 20 \u00b5A\n\n 13\n0368G\u2013MICRO\u20136/05 AT89C2051\n18. External Clock Drive Waveforms\n()19. External Clock Drive\nSymbol ParameterVCC = 2.7V to 6.0V VCC = 4.0V to 6.0V\nUnits Min Max Min Max\n1/tCLCL Oscillator Frequency 0 12 0 24 MHz\ntCLCL Clock Period 83.3 41.6 ns\ntCHCX High Time 30 15 ns\ntCLCX Low Time 30 15 ns\ntCLCH Rise Time 20 20 ns\ntCHCL Fall Time 20 20 ns\n20. Serial Port Timing: Shift Register Mode Test Conditions\nVCC = 5.0V \u00b1 20%; Load Capacitance = 80 pF\nSymbol Parameter12 MHz Osc Variable Oscillator\nUnits Min Max Min Max\ntXLXL Serial Port Clock Cycle Time 1.0 12 tCLCL \u00b5s\ntQVXH Output Data Setup to Clock Rising Edge 700 10 tCLCL-133 ns\ntXHQX Output Data Hold after Clock Rising Edge 50 2 tCLCL-117 ns\ntXHDX Input Data Hold after Clock Rising Edge 0 0 ns\ntXHDV Clock Rising Edge to Input Data Valid 700 10 tCLCL-133 ns\n\n 14\n0368G\u2013MICRO\u20136/05AT89C2051 21. Shift Register Mode Timing Waveforms\n22. AC Testing Input/Output Waveforms(1)\nNote: 1. AC Inputs during testing are driven at VCC - 0.5V for a logic 1 and 0.45V for a logic 0. Timing measurements are made at VIH \nmin. for a logic 1 and VIL max. for a logic 0.\n23. Float Waveforms(1)\nNote: 1. For timing purposes, a port pin is no longer floating when a 100 mV change from load voltage occurs. A port pin begins t o \nfloat when 100 mV change from the loaded VOH/VOL level occurs.\n\n 15\n0368G\u2013MICRO\u20136/05 AT89C2051\n24. ICC (Active Mode) Measurements\n25. ICC (Idle Mode) Measurements\n26. ICC (Power Down Mode) MeasurementsAT89C2051\nTYPICAL ICC - ACTIVE (85\u00b0C)\n05101520\n0 6 12 18 24\nFREQUENCY (MHz)I\nC\nC\nm\nAVcc=6.0V\nVcc=5.0V\nVcc=3.0V\nAT89C2051\nTYPICAL ICC - IDLE (85\u00b0C)\n0123\n0369 1 2FREQUENCY (MHz)I\nC\nC\nm\nAVcc=6.0V\nVcc=5.0V\nVcc=3.0V\nAT89C2051\nTYPICAL ICC vs. VOLTAGE- POWER DOWN (85\u00b0C)\n05101520\n3.0V 4.0V 5.0V 6.0V\nVcc VOLTAGEI\nCC\n\u00b5\nA\nNotes: 1. XTAL1 tied to GND\n2. P .1.0 and P1.1 = VCC or GND\n3. Lock bits programmed\n\n 16\n0368G\u2013MICRO\u20136/05AT89C2051 27. Ordering Information\n27.1 Standard Package\nSpeed\n(MHz)Power\nSupply Ordering Code Package Operation Range\n12 2.7V to 6.0VAT89C2051-12PC\nAT89C2051-12SC20P3\n20SCommercial\n(0\u00b0C to 70 \u00b0C)\nAT89C2051-12PI\nAT89C2051-12SI20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n24 4.0V to 6.0VAT89C2051-24PC\nAT89C2051-24SC20P3\n20SCommercial\n(0\u00b0C to 70 \u00b0C)\nAT89C2051-24PI\nAT89C2051-24SI20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n27.2 Green Package Option (Pb/Halide-free)\nSpeed\n(MHz)Power\nSupply Ordering Code Package Operation Range\n12 2.7V to 6.0VAT89C2051-12PU\nAT89C2051-12SU20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n24 4.0V to 6.0VAT89C2051-24PU\nAT89C2051-24SU20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\nPackage Type\n20P3 20-lead, 0.300\u201d Wide, Plastic Dual In-line Package (PDIP)\n20S 20-lead, 0.300\u201d Wide, Plastic Gull Wing Small Outline (SOIC)\n\n 17\n0368G\u2013MICRO\u20136/05 AT89C2051\n28. Package Information\n28.1 20P3 \u2013 PDIP\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n20P3 , 20-lead (0.300\"/7.62 mm Wide) Plastic Dual \nInline Package (PDIP)  D 20P31/23/04PIN\n1\nE1\nA1\nB\nEB1\nCLSEATING PLANEAD\ne\neBeCCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nA \u2013 \u2013 5.334\nA1 0.381 \u2013 \u2013D 24.892 \u2013          26.924    Note 2E 7.620 \u2013  8.255E1  6.096 \u2013  7.112 Note 2B 0.356 \u2013 0.559B1 1.270 \u2013 1.551L 2.921 \u2013 3.810C 0.203 \u2013 0.356eB \u2013 \u2013 10.922eC 0.000 \u2013 1.524\n  e                             2.540 TYPNotes: 1. This package conforms to JEDEC reference MS-001, Variation AD. \n2. Dimensions D and E1 do not include mold Flash or Protrusion.\nMold Flash or Protrusion shall not exceed 0.25 mm (0.010\"). \n\n 18\n0368G\u2013MICRO\u20136/05AT89C2051 28.2 20S \u2013 SOIC\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n20S, 20-lead, 0.300\" Body, Plastic Gull Wing Small Outline (SOIC)B 20S10/23/037.60 (0.2992)\n7.40 (0.2914)0.51(0.020)0.33(0.013)\n10.65 (0.419)10.00 (0.394)\nPIN 1 ID\n1.27 (0.050) BSC\n13.00 (0.5118)\n12.60 (0.4961)\n0.30(0.0118)\n0.10 (0.0040)2.65 (0.1043)2.35 (0.0926)\n0\u00ba ~ 8\u00ba\n1.27 (0.050)0.40 (0.016)0.32 (0.0125)0.23 (0.0091)PIN 1Dimensions in Millimeters and (Inches). \nControlling dimension: Inches.JEDEC Standard MS-013\n\n 19\n0368G\u2013MICRO\u20136/05 AT89C2051\n\n Printed on recycled paper.\n0368G\u2013MICRO\u20136/05 xMDisclaimer:  The information in this document is provided in connection wit h Atmel products. No license, express or implied, by estoppel or  otherwise, to any \nintellectual property right is granted by this docum ent or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN ATMEL \u2019S TERMS AND CONDI-\nTIONS OF SALE LOCATED ON ATMEL\u2019S WEB SITE, ATMEL ASSUMES NO LI ABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTOR Y \nWARRANTY RELATING TO ITS PRODUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICU LAR \nPURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUE NTIAL, PUNITIVE, SPECIAL OR I NCIDEN-\nTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING  OUT \nOF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no \nrepresentations or warranties with respect to the accuracy or co mpleteness of the contents of this document and reserves the ri ght to make changes to specifications \nand product descriptions at any time without notice. Atmel does not make any commitment to update the information contained her ein.  Atmel\u2019s products are not \nintended, authorized, or warranted for use as components in applications intended to support or sustain life. Atmel Corporation Atmel Operations\n2325 Orchard Parkway\nSan Jose, CA 95131, USATel: 1(408) 441-0311\nFax: 1(408) 487-2600\nRegional Headquarters\nEurope\nAtmel Sarl\nRoute des Arsenaux 41\nCase Postale 80\nCH-1705 FribourgSwitzerland\nTel: (41) 26-426-5555\nFax: (41) 26-426-5500\nAsia\nRoom 1219\nChinachem Golden Plaza\n77 Mody Road TsimshatsuiEast Kowloon\nHong Kong\nTel: (852) 2721-9778Fax: (852) 2722-1369\nJapan\n9F, Tonetsu Shinkawa Bldg.1-24-8 ShinkawaChuo-ku, Tokyo 104-0033\nJapan\nTel: (81) 3-3523-3551Fax: (81) 3-3523-7581Memory\n2325 Orchard ParkwaySan Jose, CA 95131, USATel: 1(408) 441-0311\nFax: 1(408) 436-4314\nMicrocontrollers\n2325 Orchard Parkway\nSan Jose, CA 95131, USA\nTel: 1(408) 441-0311\nFax: 1(408) 436-4314\nLa Chantrerie\nBP 7060244306 Nantes Cedex 3, France\nTel: (33) 2-40-18-18-18\nFax: (33) 2-40-18-19-60\nASIC/ASSP/Smart Cards\nZone Industrielle\n13106 Rousset Cedex, France\nTel: (33) 4-42-53-60-00Fax: (33) 4-42-53-60-01\n1150 East Cheyenne Mtn. Blvd.\nColorado Springs, CO 80906, USA\nTel: 1(719) 576-3300\nFax: 1(719) 540-1759\nScottish Enterprise Technology Park\nMaxwell BuildingEast Kilbride G75 0QR, Scotland \nTel: (44) 1355-803-000\nFax: (44) 1355-242-743RF/Automotive\nTheresienstrasse 2Postfach 353574025 Heilbronn, Germany\nTel: (49) 71-31-67-0\nFax: (49) 71-31-67-2340\n1150 East Cheyenne Mtn. Blvd.\nColorado Springs, CO 80906, USATel: 1(719) 576-3300\nFax: 1(719) 540-1759\nBiometrics/Imaging/Hi-Rel MPU/  \nHigh Speed Converters/RF Datacom\nAvenue de Rochepleine\nBP 123\n38521 Saint-Egreve Cedex, France\nTel: (33) 4-76-58-30-00Fax: (33) 4-76-58-34-80\nLiterature Requests\nwww.atmel.com/literature\n\u00a9 Atmel Corporation 2005 . All rights reserved. Atmel\u00ae, logo and combinations thereof, Everywhere Y ou Are\u00ae and others, are \nregistered trademarks or trademarks of Atmel Corporation or it s subsidiaries. Other terms and product names may be trademarks o f others.", "AT89C4051.pdf": "Features\n\u2022Compatible with MCS\u00ae51 Products\n\u007f4K Bytes of Reprogrammable Flash Memory\n\u2013 Endurance: 1,000 Write/Erase Cycles\n\u007f2.7V to 6V Operating Range\n\u007fFully Static Operation: 0 Hz to 24 MHz\n\u007fTwo-level Program Memory Lock\n\u007f128 x 8-bit Internal RAM\n\u007f15 Programmable I/O Lines\n\u007fTwo 16-bit Timer/Counters\n\u007fSix Interrupt Sources\n\u007fProgrammable Serial UART Channel\n\u007fDirect LED Drive Outputs\n\u007fOn-chip Analog Comparator\n\u007fLow-power Idle and Power-down Modes\n\u007fBrown-out Detection\n\u007fPower-On Reset (POR)\n\u007fGreen (Pb/Halide-free/RoHS Compliant) Packaging \n1. Description\nThe AT89C4051 is a low-voltage, high-performance CMOS 8-bit microcontroller with \n4K bytes of Flash programmable and erasable read-only memory. The device is man-\nufactured using Atmel\u2019s high-density nonvolatile memory technology and is \ncompatible with the industry-standard MCS-51 instruction set. By combining a versa-tile 8-bit CPU with Flash on a monolithic chip, the Atmel AT89C4051 is a powerful \nmicrocontroller which provides a highly-flexible and cost-effective solution to many \nembedded control applications.\nThe AT89C4051 provides the following standard features: 4K bytes of Flash, \n128 bytes of RAM, 15 I/O lines, two 16-bit timer/counters, a five-vector, two-level inter-\nrupt architecture, a full duplex serial port, a precision analog comparator, on-chip oscillator and clock circuitry. In addition, the AT89C4051 is designed with static logic \nfor operation down to zero frequency and supports two software-selectable power \nsaving modes. The Idle Mode stops the CPU while allowing the RAM, timer/counters, serial port and interrupt system to continue functioning. The power-down mode saves \nthe RAM contents but freezes the oscillator disabling all other chip functions until the \nnext hardware reset.8-bit \nMicrocontroller with 4K Bytes \nFlash\nAT89C4051\n 1001E\u2013MICRO\u20136/05\n\n 2\n1001E\u2013MICRO\u20136/05AT89C4051 2. Pin Configuration\n2.1 PDIP/SOIC\n3. Block Diagram1\n234567891020\n191817161514131211\nRST/VPP\n(RXD) P3.0\n(TXD) P3.1\nXTAL2XTAL1\n(INT0) P3.2(INT1) P3.3\n(TO) P3.4\n(T1) P3.5\nGNDVCC\nP1.7P1.6P1.5P1.4P1.3P1.2P1.1 (AIN1)P1.0 (AIN0)P3.7\n\n 3\n1001E\u2013MICRO\u20136/05 AT89C4051\n4. Pin Description\n4.1 VCC\nSupply voltage.\n4.2 GND\nGround.\n4.3 Port 1\nPort 1 is an 8-bit bi-directional I/O port. Port pins P1.2 to P1.7 provide internal pullups. P1.0 and \nP1.1 require external pullups. P1.0 and P1.1 also serve as the positive input (AIN0) and the neg-ative input (AIN1), respectively, of the on-chip precision analog comparator. The Port 1 output \nbuffers can sink 20 mA and can drive LED displays directly. When 1s are written to Port 1 pins, \nthey can be used as inputs. When pins P1.2 to P1.7 are used as inputs and are externally pulled \nlow, they will source current (I\nIL) because of the internal pullups.\nPort 1 also receives code data during Flash programming and verification. \n4.4 Port 3\nPort 3 pins P3.0 to P3.5, P3.7 are seven bi-dir ectional I/O pins with internal pullups. P3.6 is \nhard-wired as an input to the output of the on-chip comparator and is not accessible as a gen-\neral-purpose I/O pin. The Port 3 output buffers can sink 20 mA. When 1s are written to Port 3 \npins they are pulled high by the internal pullups and can be used as inputs. As inputs, Port 3 pins \nthat are externally being pulled low will source current (IIL) because of the pullups.\nPort 3 also serves the functions of various special features of the AT89C4051 as listed below:\nPort 3 also receives some control signals for Flash programming and verification.\n4.5 RST\nReset input. All I/O pins are reset to 1s as soon as RST goes high. Holding the RST pin high for \ntwo machine cycles while the oscillator is running resets the device.\nEach machine cycle takes 12 oscillator or clock cycles.\n4.6 XTAL1\nInput to the inverting oscillator amplifier and input to the internal clock operating circuit.Port Pin Alternate Functions\nP3.0 RXD (serial input port)\nP3.1 TXD (serial output port)P3.2 INT0\n (external interrupt 0)\nP3.3 INT1  (external interrupt 1)\nP3.4 T0 (timer 0 external input)P3.5 T1 (timer 1 external input)\n\n 4\n1001E\u2013MICRO\u20136/05AT89C4051 4.7 XTAL2\nOutput from the inverting oscillator amplifier.\n5. Oscillator Characteristics\nXTAL1 and XTAL2 are the input and output, respectively, of an inverting amplifier which can be \nconfigured for use as an on-chip oscillator, as shown in Figure 5-1 . Either a quartz crystal or \nceramic resonator may be used. To drive the device from an external clock source, XTAL2 \nshould be left unconnected while XTAL1 is driven as shown in Figure 5-2 . There are no require-\nments on the duty cycle of the external clock signal, since the input to the internal clocking \ncircuitry is through a divide-by-two flip-flop, but minimum and maximum voltage high and low \ntime specifications must be observed.\nFigure 5-1. Oscillator Connections\nNote: C1, C2 = 30 pF \u00b1 10 pF for Crystals  \n           = 40 pF \u00b1 10 pF for Ceramic Resonators\nFigure 5-2. External Clock Drive Configuration\n\n 5\n1001E\u2013MICRO\u20136/05 AT89C4051\n6. Special Function Registers\nA map of the on-chip memory area called the Special Function Register (SFR) space is shown in \nthe Table 6-1 .\nNote that not all of the addresses are occupied, and unoccupied addresses may not be imple-\nmented on the chip. Read accesses to these addresses will in general return random data, and \nwrite accesses will have an indeterminate effect.\nUser software should not write 1s to these unlisted locations, since they may be used in future \nproducts to invoke new features. In that case, the reset or inactive values of the new bits will \nalways be 0.\nTable 6-1. AT89C4051 SFR Map and Reset Values\n0F8H 0FFH\n0F0HB\n000000000F7H\n0E8H 0EFH\n0E0HACC\n000000000E7H\n0D8H 0DFH\n0D0HPSW\n000000000D7H\n0C8H  0CFH\n0C0H 0C7H\n0B8HIP\nXXX000000BFH\n0B0HP3\n111111110B7H\n0A8HIE\n0XX000000AFH\n0A0H  0A7H\n98HSCON\n00000000SBUF\nXXXXXXXX9FH\n90HP1\n1111111197H\n88HTCON\n00000000TMOD\n00000000TL0\n00000000TL1\n00000000TH0\n00000000TH1\n000000008FH\n80HSP\n00000111DPL\n00000000DPH\n00000000PCON\n0XXX000087H\n\n 6\n1001E\u2013MICRO\u20136/05AT89C4051 7. Restrictions on Certain Instructions\nThe AT89C4051 is an economical and cost-effective member of Atmel\u2019s growing family of micro-\ncontrollers. It contains 4K bytes of Flash program memory. It is fully compatible with the MCS-51 \narchitecture, and can be programmed using the MCS-51 instruction set. However, there are a few considerations one must keep in mind when utilizing certain instructions to program this \ndevice.\nAll the instructions related to jumping or branching should be restricted such that the destination \naddress falls within the physical program memory space of the device, which is 4K for the \nAT89C4051. This should be the responsibility of the software programmer. For example, LJMP \n0FE0H would be a valid instruction for the AT89C4051 (with 4K of memory), whereas LJMP 1000H would not.\n7.1 Branching Instructions\nLCALL, LJMP, ACALL, AJMP, SJMP, JMP @A+DPTR . These unconditional branching instruc-\ntions will execute correctly as long as the programmer keeps in mind that the destination \nbranching address must fall within the physical boundaries of the program memory size (loca-\ntions 00H to FFFH for the 89C4051). Violating the physical space limits may cause unknown \nprogram behavior.\nCJNE [...], DJNZ [...], JB, JNB, JC, JNC, JBC, JZ, JNZ.  With these conditional branching \ninstructions the same rule above applies. Again, violating the memory boundaries may cause \nerratic execution.\nFor applications involving interrupts, the normal interrupt service routine address locations of the \n80C51 family architecture have been preserved.\n7.2 MOVX-related Instructions, Data Memory\nThe AT89C4051 contains 128 bytes of internal data memory. Thus, in the AT89C4051 the stack \ndepth is limited to 128 bytes, the amount of ava ilable RAM. External DATA memory access is \nnot supported in this device, nor is external Program memory execution. Therefore, no MOVX \n[...] instructions should be included in the program.\nA typical 80C51 assembler will still assemble instructions, even if they are written in violation of \nthe restrictions mentioned above. It is the responsibility of the controller user to know the physi-\ncal features and limitations of the devic e being used and adjust the instructions used \ncorrespondingly.\n8. Program Memory Lock Bits\nOn the chip are two lock bits which can be left unprogrammed (U) or can be programmed (P) to obtain the additional features listed in the Table 8-1 .\nNote: 1. The Lock Bits can only be erased with the Chip Erase operation.Table 8-1. Lock Bit Protection Modes(1)\nProgram Lock Bits\nProtection Type LB1 LB2\n1 U U No program lock features\n2 P U Further programming of the Flash is disabled3 P P Same as mode 2, also verify is disabled\n\n 7\n1001E\u2013MICRO\u20136/05 AT89C4051\n9. Idle Mode\nIn idle mode, the CPU puts itself to sleep while all the on-chip peripherals remain active. The \nmode is invoked by software. The content of the on-chip RAM and all the special functions regis-ters remain unchanged during this mode. The idle mode can be terminated by any enabled \ninterrupt or by a hardware reset.\nP1.0 and P1.1 should be set to \u201c0\u201d if no external pullups are used, or set to \u201c1\u201d if external \npullups are used.\nIt should be noted that when idle is terminated by a hardware reset, the device normally \nresumes program execution, from where it left off, up to two machine cycles before the internal reset algorithm takes control. On-chip hardware inhibits access to internal RAM in this event, but \naccess to the port pins is not inhibited. To e liminate the possibility of an unexpected write to a \nport pin when Idle is terminated by reset, the instruction following the one that invokes Idle \nshould not be one that writes to a port pin or to external memory.\n10. Power-down Mode\nIn the power-down mode the oscillator is stopped and the instruction that invokes power-down is \nthe last instruction executed. The on-chip RAM and Special Function Registers retain their val-\nues until the power-down mode is terminated. The only exit from power-down is a hardware \nreset. Reset redefines the SFRs but does not change the on-chip RAM. The reset should not be activated before V\nCC is restored to its normal operating level and must be held active long \nenough to allow the oscillator to restart and stabilize.\nP1.0 and P1.1 should be set to \u201c0\u201d if no external pullups are used, or set to \u201c1\u201d if external \npullups are used.\n11. Brown-out Detection\nWhen VCC drops below the detection threshold, all port pins (except P1.0 and P1.1) are weakly \npulled high. When VCC goes back up again, an internal Reset is automatically generated after a \ndelay of typically 15 msec. The nominal brown-out detection threshold is 2.1V \u00b1 10%.\nVCC2.1V 2.1V\nPORT PIN\nINTERNAL RESET\n15 msec.\n\n 8\n1001E\u2013MICRO\u20136/05AT89C4051 12. Programming The Flash\nThe AT89C4051 is shipped with the 4K bytes of on-chip PEROM code memory array in the \nerased state (i.e., contents = FFH) and ready to be programmed. The code memory array is pro-grammed one byte at a time. Once the array is programmed, to re-program any non-blank byte, \nthe entire memory array needs to be erased electrically.\nInternal Address Counter: The AT89C4051 contains an internal PEROM address counter \nwhich is always reset to 000H on the rising edge of RST and is advanced by applying a positive \ngoing pulse to pin XTAL1.\nProgramming Algorithm:  To program the AT89C4051, the following sequence is \nrecommended.\n1. Power-up sequence:  \nApply power between VCC\n and GND pins  \nSet RST and XTAL1 to GND\n2. Set pin RST to \u201cH\u201d  \nSet pin P3.2 to \u201cH\u201d\n3. Apply the appropriate combination of \u201cH\u201d or \u201cL\u201d logic  \nlevels to pins P3.3, P3.4, P3.5, P3.7 to select one of the programming operations shown in the PEROM Programming Modes table.\nTo Program and Verify the Array:\n4. Apply data for Code byte at location 000H to P1.0 to P1.7.\n5. Raise RST to 12V to enable programming.6. Pulse P3.2 once to program a byte in the PEROM array or the lock bits. The byte-write \ncycle is self-timed and typically takes 1.2 ms.\n7. To verify the programmed data, lower RST from 12V to logic \u201cH\u201d level and set pins P3.3 \nto P3.7 to the appropriate levels. Output data can be read at the port P1 pins.\n8. To program a byte at the next address location, pulse XTAL1 pin once to advance the \ninternal address counter. Apply new data to the port P1 pins.\n9. Repeat steps 6 through 8, changing data and advancing the address counter for the \nentire 4K bytes array or until the end of the object file is reached.\n10. Power-off sequence:  \nset XTAL1 to \u201cL\u201d  \nset RST to \u201cL\u201d  \nTur n V\nCC power off\nData  Polling:  The AT89C4051 features Data  Polling to indicate the end of a write cycle. During \na write cycle, an attempted read of the last byte written will result in the complement of the writ-\nten data on P1.7. Once the write cycle has been completed, true data is valid on all outputs, and the next cycle may begin. Data\n Polling may begin any time after a write cycle has been initiated.\nReady/Busy : The Progress of byte programming can also be monitored by the RDY/BSY  output \nsignal. Pin P3.1 is pulled low after P3.2 goes High during programming to indicate BUSY. P3.1 is pulled High again when programming is done to indicate READY.\n\n 9\n1001E\u2013MICRO\u20136/05 AT89C4051\nProgram Verify: If lock bits LB1 and LB2 have not been programmed code data can be read \nback via the data lines for verification:\n1. Reset the internal address counter to 000H by bringing RST from \u201cL\u201d to \u201cH\u201d.\n2. Apply the appropriate control signals for Read Code data and read the output data at \nthe port P1 pins.\n3. Pulse pin XTAL1 once to advance the internal address counter.4. Read the next code data byte at the port P1 pins.5. Repeat steps 3 and 4 until the entire array is read.\nThe lock bits cannot be verified directly. Verification of the lock bits is achieved by observing that \ntheir features are enabled.\nChip Erase:  The entire PEROM array (4K bytes) and the two Lock Bits are erased electrically \nby using the proper combination of control signals and by holding P3.2 low for 10 ms. The code \narray is written with all \u201c1\u201ds in the Chip Erase operation and must be executed before any non-\nblank memory byte can be re-programmed.\nReading the Signature Bytes: The signature bytes are read by the same procedure as a nor-\nmal verification of locations 000H, 001H, and 002H, except that P3.5 and P3.7 must be pulled to \na logic low. The values returned are as follows. \n(000H) = 1EH indicates manufactured by Atmel\n(001H) = 41H indicates AT89C4051\n13. Programming Interface\nEvery code byte in the Flash array can be writt en and the entire array can be erased by using \nthe appropriate combination of control signals. The write operation cycle is self-timed and once \ninitiated, will automatically time itself to completion.\nMost major worldwide programming vendors offer support for the Atmel AT89 microcontroller \nseries. Please contact your local programming vendor for the appropriate software revision.\nNotes: 1. The internal PEROM address counter is reset to 000H on the rising edge of RST and is advanced by a positive pulse at \nXTAL1 pin.\n2. Chip Erase requires a 10-ms PROG  pulse.\n3. P3.1 is pulled Low during programming to indicate RDY/BSY .13.1 Flash Programming Modes\nMode RST/VPP P3.2/PROG P3.3 P3.4 P3.5 P3.7\nWrite Code Data(1)(3)12V L H H H\nRead Code Data(1)HH L L H H\nWrite Lock B i t  -  1 1 2 V HHHH\nBit - 2 12V H H L L\nChip Erase 12V H L L L\nRead Signature Byte H H L L L L(2)\n\n 10\n1001E\u2013MICRO\u20136/05AT89C4051 Figure 13-1. Programming the Flash Memory\nFigure 13-2. Verifying the Flash MemoryPPAT89C4051\nP3.1RDY/BSY\nAT89C4051\n\n 11\n1001E\u2013MICRO\u20136/05 AT89C4051\nNote: 1. Only used in 12-volt programming mode.\n15. Flash Programming and Verification Waveforms14. Flash Programming and Verification Characteristics\nTA = 20\u00b0C to 30\u00b0C, VCC = 5.0 \u00b1 10%\nSymbol Parameter Min Max Units\nVPP Programming Enable Voltage 11.5 12.5 V\nIPP Programming Enable Current 250 \u00b5A\ntDVGL Data Setup to PROG  Low 1.0 \u00b5s\ntGHDX Data Hold after PROG 1.0 \u00b5s\ntEHSH P3.4 (ENABLE ) High to VPP 1.0 \u00b5s\ntSHGL VPP Setup to PROG  Low 10 \u00b5s\ntGHSL VPP Hold after PROG 10 \u00b5s\ntGLGH PROG  Width 1 110 \u00b5s\ntELQV ENABLE  Low to Data Valid 1.0 \u00b5s\ntEHQZ Data Float after ENABLE 01 . 0 \u00b5 s\ntGHBL PROG  High to BUSY  Low 50 ns\ntWC Byte Write Cycle Time 2.0 ms\ntBHIH RDY/BSY \\ to Increment Clock Delay 1.0 \u00b5s\ntIHIL Increment Clock High 200 ns\n\n 12\n1001E\u2013MICRO\u20136/05AT89C4051 Notes: 1. Under steady state (non-transient) conditions, IOL must be externally limited as follows:  \nMaximum IOL per port pin: 20 mA  \nMaximum total IOL for all output pins: 80 mA  \nIf IOL exceeds the test condition, VOL may exceed the related specification. Pins are not guaranteed to sink current greater \nthan the listed test conditions.\n2. Minimum VCC for Power-down is 2V.16. Absolute Maximum Ratings*\nOperating Temperature ................................. -55\u00b0C to +125\u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or any other conditions beyond those indicated in the \noperational sections of this specification is not \nimplied. Exposure to absolute maximum rating conditions for extended periods may affect device \nreliability.Storage Temperature..................................... -65\u00b0C to +150\u00b0C\nVoltage on Any Pin  \nwith Respect to Ground .....................................-1.0V to +7.0V\nMaximum Operating Voltage ............................................ 6.6VDC Output Current...................................................... 25.0 mA\n17. DC Characteristics\nTA = -40\u00b0C to 85\u00b0C, VCC = 2.7V to 6.0V (unless otherwise noted)\nSymbol Parameter Condition Min Max Units\nVIL Input Low-voltage -0.5 0.2 VCC - 0.1 V\nVIH Input High-voltage (Except XTAL1, RST) 0.2 VCC + 0.9 VCC + 0.5 V\nVIH1 Input High-voltage (XTAL1, RST) 0.7 VCC VCC + 0.5 V\nVOLOutput Low-voltage(1)\n(Ports 1, 3)IOL = 20 mA, VCC = 5V  \nIOL = 10 mA, VCC = 2.7V0.5 V\nVOHOutput High-voltage  \n(Ports 1, 3)IOH = -80 \u00b5A, VCC = 5V \u00b1 10% 2.4 V\nIOH = -30 \u00b5A 0.75 VCC V\nIOH = -12 \u00b5A 0.9 VCC V\nIILLogical 0 Input Current  \n(Ports 1, 3)VIN = 0.45V -50 \u00b5A\nITLLogical 1 to 0 Transition Current \n(Ports 1, 3)VIN = 2V, VCC = 5V \u00b1 10% -750 \u00b5A\nILIInput Leakage Current  \n(Port P1.0, P1.1)0 < VIN < VCC \u00b110 \u00b5A\nVOS Comparator Input Offset Voltage VCC = 5V 20 mV\nVCMComparator Input Common \nMode Voltage0VCC V\nRRST Reset Pulldown Resistor 50 300 K \u2126\nCIO Pin Capacitance Test Freq. = 1 MHz, TA = 25\u00b0C 10 pF\nICCPower Supply CurrentActive Mode, 12 MHz, VCC = 6V/3V 15/5.5 mA\nIdle Mode, 12 MHz, VCC = 6V/3V \nP1.0 & P1.1 = 0V or VCC5/1 mA\nPower-down Mode(2)VCC = 6V, P1.0 & P1.1 = 0V or VCC 20 \u00b5A\nVCC = 3V, P1.0 & P1.1 = 0V or VCC 5\u00b5 A\n\n 13\n1001E\u2013MICRO\u20136/05 AT89C4051\n18. External Clock Drive Waveforms\n19. External Clock Drive\nSymbol ParameterVCC = 2.7V to 6.0V VCC = 4.0V to 6.0V\nUnits Min Max Min Max\n1/tCLCL Oscillator Frequency 0 12 0 24 MHz\ntCLCL Clock Period 83.3 41.6 ns\ntCHCX High Time 30 15 ns\ntCLCX Low Time 30 15 ns\ntCLCH Rise Time 20 20 ns\ntCHCL Fall Time 20 20 ns\n\n 14\n1001E\u2013MICRO\u20136/05AT89C4051 21. Shift Register Mode Timing Waveforms\n22. AC Testing Input/Output Waveforms(1)\nNote: 1. AC Inputs during testing are driven at VCC - 0.5V for a logic 1 and 0.45V for a logic 0. Timing measurements are made at VIH \nmin. for a logic 1 and VIL max. for a logic 0.\n23. Float Waveforms(1)\nNote: 1. For timing purposes, a port pin is no longer floating when a 100 mV change from load voltage occurs. A port pin begins t o \nfloat when 100 mV change from the loaded VOH/VOL level occurs.20. Serial Port Timing: Shift Register Mode Test Conditions\nVCC = 5.0V \u00b1 20%; Load Capacitance = 80 pF\nSymbol Parameter12 MHz Osc Variable Oscillator\nUnits Min Max Min Max\ntXLXL Serial Port Clock Cycle Time 1.0 12tCLCL \u00b5s\ntQVXH Output Data Setup to Clock Rising Edge 700 10tCLCL-133 ns\ntXHQX Output Data Hold after Clock Rising Edge 50 2tCLCL-117 ns\ntXHDX Input Data Hold after Clock Rising Edge 0 0 ns\ntXHDV Clock Rising Edge to Input Data Valid 700 10tCLCL-133 ns\n\n 15\n1001E\u2013MICRO\u20136/05 AT89C4051\n24. ICC (Active Mode) Measurements\n25. ICC (Idle Mode) Measurements\n26. ICC (Power Down Mode) Measurements\nNotes: 1. XTAL1 tied to GND\n2. P .1.0 and P1.1 = VCC or GND\n3. Lock bits programmedAT89C4051\nTYPICAL ICC - ACTIVE (85\u02daC)\n05101520\n0 6 12 18 24\nFREQUENCY (MHz)I\nC\nC\nm\nAVcc=6.0V\nVcc=5.0V\nVcc=3.0V\nAT89C4051\nTYPICAL ICC - IDLE (85\u02daC)\n0123\n0369 1 2FREQUENCY (MHz)I\nC\nC\nm\nAVcc=6.0V\nVcc=5.0V\nVcc=3.0V\nAT89C4051\nTYPICAL ICC vs. VOLTAGE- POWER DOWN (85\u02daC)\n05101520\n3.0V 4.0V 5.0V 6.0V\nVcc VOLTAGEI\nCC\n\u00b5\nA\n\n 16\n1001E\u2013MICRO\u20136/05AT89C4051 27. Ordering Information\n27.1 Standard Package\nSpeed\n(MHz)Power\nSupply Ordering Code Package Operation Range\n12 2.7V to 6.0VAT89C4051-12PC\nAT89C4051-12SC20P3\n20SCommercial\n(0\u00b0C to 70 \u00b0C)\nAT89C4051-12PI\nAT89C4051-12SI20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n24 4.0V to 6.0VAT89C4051-24PC\nAT89C4051-24SC20P3\n20SCommercial\n(0\u00b0C to 70 \u00b0C)\nAT89C4051-24PI\nAT89C4051-24SI20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n27.2 Green Package Option (Pb/Halide-free)\nSpeed\n(MHz)Power\nSupply Ordering Code Package Operation Range\n12 2.7V to 6.0VAT89C4051-12PU\nAT89C4051-12SU20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\n24 4.0V to 6.0VAT89C4051-24PU\nAT89C4051-24SU20P3\n20SIndustrial\n(-40\u00b0C to 85 \u00b0C)\nPackage Type\n20P3 20-lead, 0.300\u201d Wide, Plastic Dual In-line Package (PDIP)\n20S 20-lead, 0.300\u201d Wide, Plastic Gull Wing Small Outline (SOIC)\n\n 17\n1001E\u2013MICRO\u20136/05 AT89C4051\n28. Package Information\n28.1 20P3 \u2013 PDIP\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n20P3 , 20-lead (0.300\"/7.62 mm Wide) Plastic Dual \nInline Package (PDIP)  D 20P31/23/04PIN\n1\nE1\nA1\nB\nEB1\nCLSEATING PLANEAD\ne\neBeCCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nA \u2013 \u2013 5.334\nA1 0.381 \u2013 \u2013D 24.892 \u2013          26.924    Note 2E 7.620 \u2013  8.255E1  6.096 \u2013  7.112 Note 2B 0.356 \u2013 0.559B1 1.270 \u2013 1.551L 2.921 \u2013 3.810C 0.203 \u2013 0.356eB \u2013 \u2013 10.922eC 0.000 \u2013 1.524\n  e                             2.540 TYPNotes: 1. This package conforms to JEDEC reference MS-001, Variation AD. \n2. Dimensions D and E1 do not include mold Flash or Protrusion.\nMold Flash or Protrusion shall not exceed 0.25 mm (0.010\"). \n\n 18\n1001E\u2013MICRO\u20136/05AT89C4051 28.2 20S \u2013 SOIC\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n20S, 20-lead, 0.300\" Body, Plastic Gull Wing Small Outline (SOIC)B 20S10/23/037.60 (0.2992)\n7.40 (0.2914)0.51(0.020)0.33(0.013)\n10.65 (0.419)10.00 (0.394)\nPIN 1 ID\n1.27 (0.050) BSC\n13.00 (0.5118)\n12.60 (0.4961)\n0.30(0.0118)\n0.10 (0.0040)2.65 (0.1043)2.35 (0.0926)\n0\u00ba ~ 8\u00ba\n1.27 (0.050)0.40 (0.016)0.32 (0.0125)0.23 (0.0091)PIN 1Dimensions in Millimeters and (Inches). \nControlling dimension: Inches.JEDEC Standard MS-013\n\n Printed on recycled paper.\n1001E\u2013MICRO\u20136/05Disclaimer:  The information in this document is provided in connection wit h Atmel products. No license, express or implied, by estoppel or  otherwise, to any \nintellectual property right is granted by this docum ent or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN ATMEL \u2019S TERMS AND CONDI-\nTIONS OF SALE LOCATED ON ATMEL\u2019S WEB SITE, ATMEL ASSUMES NO LI ABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTOR Y \nWARRANTY RELATING TO ITS PRODUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICU LAR \nPURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUE NTIAL, PUNITIVE, SPECIAL OR I NCIDEN-\nTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING  OUT \nOF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no \nrepresentations or warranties with respect to the accuracy or co mpleteness of the contents of this document and reserves the ri ght to make changes to specifications \nand product descriptions at any time without notice. Atmel does not make any commitment to update the information contained her ein.  Atmel\u2019s products are not \nintended, authorized, or warranted for use as components in applications intended to support or sustain life. Atmel Corporation Atmel Operations\n2325 Orchard Parkway\nSan Jose, CA 95131, USATel: 1(408) 441-0311\nFax: 1(408) 487-2600\nRegional Headquarters\nEurope\nAtmel Sarl\nRoute des Arsenaux 41\nCase Postale 80\nCH-1705 FribourgSwitzerland\nTel: (41) 26-426-5555\nFax: (41) 26-426-5500\nAsia\nRoom 1219\nChinachem Golden Plaza\n77 Mody Road TsimshatsuiEast Kowloon\nHong Kong\nTel: (852) 2721-9778Fax: (852) 2722-1369\nJapan\n9F, Tonetsu Shinkawa Bldg.1-24-8 ShinkawaChuo-ku, Tokyo 104-0033\nJapan\nTel: (81) 3-3523-3551Fax: (81) 3-3523-7581Memory\n2325 Orchard ParkwaySan Jose, CA 95131, USATel: 1(408) 441-0311\nFax: 1(408) 436-4314\nMicrocontrollers\n2325 Orchard Parkway\nSan Jose, CA 95131, USA\nTel: 1(408) 441-0311\nFax: 1(408) 436-4314\nLa Chantrerie\nBP 7060244306 Nantes Cedex 3, France\nTel: (33) 2-40-18-18-18\nFax: (33) 2-40-18-19-60\nASIC/ASSP/Smart Cards\nZone Industrielle\n13106 Rousset Cedex, France\nTel: (33) 4-42-53-60-00Fax: (33) 4-42-53-60-01\n1150 East Cheyenne Mtn. Blvd.\nColorado Springs, CO 80906, USA\nTel: 1(719) 576-3300\nFax: 1(719) 540-1759\nScottish Enterprise Technology Park\nMaxwell BuildingEast Kilbride G75 0QR, Scotland \nTel: (44) 1355-803-000\nFax: (44) 1355-242-743RF/Automotive\nTheresienstrasse 2Postfach 353574025 Heilbronn, Germany\nTel: (49) 71-31-67-0\nFax: (49) 71-31-67-2340\n1150 East Cheyenne Mtn. Blvd.\nColorado Springs, CO 80906, USATel: 1(719) 576-3300\nFax: 1(719) 540-1759\nBiometrics/Imaging/Hi-Rel MPU/  \nHigh Speed Converters/RF Datacom\nAvenue de Rochepleine\nBP 123\n38521 Saint-Egreve Cedex, France\nTel: (33) 4-76-58-30-00Fax: (33) 4-76-58-34-80\nLiterature Requests\nwww.atmel.com/literature\n\u00a9 Atmel Corporation 2005 . All rights reserved. Atmel\u00ae, logo and combinations thereof, Everywhere Y ou Are\u00ae and others, are \nregistered trademarks or trademarks of Atmel Corporation or it s subsidiaries. Other terms and product names may be trademarks o f others.", "at89s52_ds.pdf": "1Features\n\u2022Compatible with MCS-51\u00ae Products\n\u007f8K Bytes of In-System Programmable (ISP) Flash Memory\n\u2013 Endurance: 1000 Write/Erase Cycles\n\u007f4.0V to 5.5V Operating Range\n\u007fFully Static Operation: 0 Hz to 33 MHz\n\u007fThree-level Program Memory Lock\n\u007f256 x 8-bit Internal RAM\n\u007f32 Programmable I/O Lines\n\u007fThree 16-bit Timer/Counters\n\u007fEight Interrupt Sources\n\u007fFull Duplex UART Serial Channel\n\u007fLow-power Idle and Power-down Modes\n\u007fInterrupt Recovery from Power-down Mode\n\u007fWatchdog Timer\n\u007fDual Data Pointer\n\u007fPower-off Flag\nDescription\nThe AT89S52 is a low-power, high-performance CMOS 8-bit microcontroller with 8K\nbytes of in-system programmable Flash memory. The device is manufactured usingAtmel\u2019s high-density nonvolatile memory technology and is compatible with the indus-try-standard 80C51 instruction set and pinout. The on-chip Flash allows the programmemory to be reprogrammed in-system or by a conventional nonvolatile memory pro-grammer. By combining a versatile 8-bit CPU with in-system programmable Flash ona monolithic chip, the Atmel AT89S52 is a powerful microcontroller which provides ahighly-flexible and cost-effective solution to many embedded control applications.\nThe AT89S52 provides the following standard features: 8K bytes of Flash, 256 bytes\nof RAM, 32 I/O lines, Watchdog timer, two data pointers, three 16-bit timer/counters, asix-vector two-level interrupt architecture, a full duplex serial port, on-chip oscillator,\nand clock circuitry. In addition, the AT89S52 is designed with static logic for operationdown to zero frequency and supports two software selectable power saving modes.The Idle Mode stops the CPU while allowing the RAM, timer/counters, serial port, andinterrupt system to continue functioning. The Power-down mode saves the RAM con-tents but freezes the oscillator, disabling all other chip functions until the next interruptor hardware reset.\nRev. 1919A-07/018-bit \nMicrocontroller with 8K Bytes In-System Programmable \nFlash\nAT89S52\n\nAT89S52 2TQFP\n1\n23456789101133\n32313029282726252423444342414039383736353412\n13141516171819202122(MOSI) P1.5(MISO) P1.6\n(SCK) P1.7\nRST\n(RXD) P3.0\nNC\n(TXD) P3.1\n(INT0) P3.2(INT1) P3.3\n(T0) P3.4(T1) P3.5P0.4 (AD4)P0.5 (AD5)P0.6 (AD6)P0.7 (AD7)EA/VPPNCALE/PROGPSENP2.7 (A15)P2.6 (A14)P2.5 (A13)P1.4P1.3P1.2P1.1 (T2 EX)P1.0 (T2)NCVCCP0.0 (AD0)P0.1 (AD1)P0.2 (AD2)P0.3 (AD3)(WR) P3.6\n(RD) P3.7\nXTAL2XTAL1\nGNDGND\n(A8) P2.0(A9) P2.1\n(A10) P2.2(A11) P2.3(A12) P2.4PLCC\n789101112131415161739\n38373635343332313029\n(MOSI) P1.5(MISO) P1.6\n(SCK) P1.7\nRST\n(RXD) P3.0\nNC\n(TXD) P3.1\n(INT0) P3.2(INT1) P3.3\n(T0) P3.4(T1) P3.5P0.4 (AD4)\nP0.5 (AD5)P0.6 (AD6)P0.7 (AD7)EA/VPPNCALE/PROGPSENP2.7 (A15)P2.6 (A14)P2.5 (A13)654321\n444342414018\n19202122232425262728(WR) P3.6\n(RD) P3.7\nXTAL2XTAL1\nGND\nNC\n(A8) P2.0(A9) P2.1\n(A10) P2.2(A11) P2.3(A12) P2.4P1.4 \nP1.3P1.2P1.1 (T2 EX)P1.0 (T2)NCVCCP0.0 (AD0)P0.1 (AD1)P0.2 (AD2)P0.3 (AD3)Pin Configurations\nPDIP\n123456789101112131415161718192040\n39383736353433323130292827262524232221\n(T2) P1.0\n(T2 EX) P1.1\nP1.2P1.3P1.4\n(MOSI) P1.5(MISO) P1.6\n(SCK) P1.7\nRST\n(RXD) P3.0\n(TXD) P3.1\n(INT0) P3.2(INT1) P3.3\n(T0) P3.4(T1) P3.5\n(WR) P3.6\n(RD) P3.7\nXTAL2XTAL1\nGNDVCC\nP0.0 (AD0)P0.1 (AD1)P0.2 (AD2)P0.3 (AD3)P0.4 (AD4)P0.5 (AD5)P0.6 (AD6)P0.7 (AD7)EA/VPPALE/PROGPSENP2.7 (A15)P2.6 (A14)P2.5 (A13)P2.4 (A12)P2.3 (A11)P2.2 (A10)P2.1 (A9)P2.0 (A8)\n\nAT89S52\n3Block Diagram\nPORT 2 DRIVERS\nPORT 2\nLATCHP2.0 - P2.7\nFLASHPORT 0\nLATCH RAM\nPROGRAM\nADDRESS\nREGISTER\nBUFFER\nPC\nINCREMENTER\nPROGRAM\nCOUNTER\nDUAL DPTRINSTRUCTION\nREGISTERB\nREGISTER\nINTERRUPT, SERIAL PORT,\nAND TIMER BLOCKSSTACK\nPOINTER ACC\nTMP2 TMP1\nALU\nPSW\nTIMING\nAND\nCONTROL\nPORT 1 DRIVERS\nP1.0 - P1.7PORT 3\nLATCH\nPORT 3 DRIVERS\nP3.0 - P3.7OSCGNDVCC\nPSEN\nALE/PROG\nEA / VPP\nRSTRAM ADDR.\nREGISTERPORT 0 DRIVERSP0.0 - P0.7\nPORT 1\nLATCHWATCH\nDOGISP\nPORTPROGRAM\nLOGIC\n\nAT89S52 4Pin Description\nVCC\nSupply voltage.\nGND\nGround.\nPort 0\nPort 0 is an 8-bit open drain bidirectional I/O port. As an\noutput port, each pin can sink eight TTL inputs. When 1s\nare written to port 0 pins, the pins can be used as high-\nimpedance inputs. \nPort 0 can also be configured to be the multiplexed low-\norder address/data bus during accesses to externalprogram and data memory. In this mode, P0 has internal\npullups.\nPort 0 also receives the code bytes during Flash program-\nming and outputs the code bytes during program verifica-tion. External pullups are required during program\nverification. \nPort 1\nPort 1 is an 8-bit bidirectional I/O port with internal pullups.\nThe Port 1 output buffers can sink/source four TTL inputs.When 1s are written to Port 1 pins, they are pulled high by\nthe internal pullups and can be used as inputs. As inputs,\nPort 1 pins that are exter nally being pulled low will source\ncurrent (I\nIL) because of the internal pullups. \nIn addition, P1.0 and P1.1 can be configured to be the\ntimer/counter 2 external count input (P1.0/T2) and thetimer/counter 2 trigger input (P1.1/T2EX), respectively, as\nshown in the following table.\nPort 1 also receives the low-order address bytes during\nFlash programming and verification.\nPort 2\nPort 2 is an 8-bit bidirectional I/O port with internal pullups.\nThe Port 2 output buffers can sink/source four TTL inputs.\nWhen 1s are written to Port 2 pins, they are pulled high bythe internal pullups and can be used as inputs. As inputs,\nPort 2 pins that are exter nally being pulled low will source\ncurrent (I\nIL) because of the internal pullups.\nPort 2 emits the high-order address byte during fetches\nfrom external program memory and during accesses toexternal data memory that use 16-bit addresses (MOVX @\nDPTR). In this application, Port 2 uses strong internal pul-\nlups when emitting 1s. During accesses to external data\nmemory that use 8-bit addresses (MOVX @ RI), Port 2emits the contents of the P2 Special Function Register.\nPort 2 also receives the high-order address bits and some\ncontrol signals during Flash programming and verification.\nPort 3\nPort 3 is an 8-bit bidirectional I/O port with internal pullups.\nThe Port 3 output buffers can sink/source four TTL inputs.\nWhen 1s are written to Port 3 pins, they are pulled high by\nthe internal pullups and can be used as inputs. As inputs,Port 3 pins that are extern ally being pulled low will source\ncurrent (I\nIL) because of the pullups.\nPort 3 also serves the functions of various special features\nof the AT89S52, as shown in the following table.\nPort 3 also receives some control signals for Flash pro-\ngramming and verification.\nRST\nReset input. A high on this pin for two machine cycles while\nthe oscillator is running resets the device. This pin drivesHigh for 96 oscillator periods after the Watchdog times out.\nThe DISRTO bit in SFR AUXR (address 8EH) can be used\nto disable this feature. In the default state of bit DISRTO,the RESET HIGH out feature is enabled.\nALE/PROG\nAddress Latch Enable (ALE) is an output pulse for latching\nthe low byte of the address during accesses to externalmemory. This pin is also the program pulse input (PROG\n)\nduring Flash programming. \nIn normal operation, ALE is emitted at a constant rate of\n1/6the oscillator frequency and may be used for external\ntiming or clocking purposes. Note, however, that oneALE pulse is skipped during each access to external datamemory. \nIf desired, ALE operation can be disabled by setting bit 0 of\nSFR location 8EH. With the bit set, ALE is active only dur-\ning a MOVX or MOVC instruction. Otherwise, the pin isPort Pin Alternate Functions\nP1.0 T2 (external count input to Timer/Counter 2), \nclock-out\nP1.1 T2EX (Timer/Counter 2 capture/reload trigger \nand direction control)\nP1.5 MOSI (used for In-System Programming)\nP1.6 MISO (used for In-System Programming)\nP1.7 SCK (used for In-System Programming)Port Pin Alternate FunctionsP3.0 RXD (serial input port)P3.1 TXD (serial output port)\nP3.2 INT0\n (external interrupt 0)\nP3.3 INT1  (external interrupt 1)\nP3.4 T0 (timer 0 external input)\nP3.5 T1 (timer 1 external input)\nP3.6 WR  (external data memory write strobe)\nP3.7 RD  (external data memory read strobe)\n\nAT89S52\n5weakly pulled high. Setting the ALE-disable bit has no\neffect if the microcontroller is in external execution mode.\nPSEN\nProgram Store Enable (PSEN)  is the read strobe to exter-\nnal program memory. \nWhen the AT89S52 is executi ng code from external pro-\ngram memory, PSEN  is activated twice each machine\ncycle, except that two PSEN  activations are skipped during\neach access to external data memory. \nEA/VPP\nExternal Access Enable. EA  must be strapped to GND in\norder to enable the device to fetch code from external pro-gram memory locations starting at 0000H up to FFFFH.Note, however, that if lock bit 1 is programmed, EA\n will be\ninternally latched on reset. \nEA should be strapped to VCC for internal program execu-\ntions.\nThis pin also receives the 12-volt programming enable volt-\nage (VPP) during Flash programming.\nXTAL1\nInput to the inverting oscillator amplifier and input to the\ninternal clock operating circuit.\nXTAL2\nOutput from the inverting oscillator amplifier.\nTable 1.  AT89S52 SFR Map and Reset Values\n0F8H 0FFH\n0F0HB\n000000000F7H\n0E8H 0EFH\n0E0HACC\n000000000E7H\n0D8H 0DFH\n0D0HPSW\n000000000D7H\n0C8HT2CON\n00000000T2MOD\nXXXXXX00RCAP2L\n00000000RCAP2H\n00000000TL2\n00000000TH2\n000000000CFH\n0C0H 0C7H\n0B8HIP\nXX0000000BFH\n0B0HP3\n111111110B7H\n0A8HIE\n0X0000000AFH\n0A0HP2\n11111111AUXR1\nXXXXXXX0WDTRST\nXXXXXXXX0A7H\n98HSCON\n00000000SBUF\nXXXXXXXX9FH\n90HP1\n1111111197H\n88HTCON\n00000000TMOD\n00000000TL0\n00000000TL1\n00000000TH0\n00000000TH1\n00000000AUXR\nXXX00XX08FH\n80HP0\n11111111SP\n00000111DP0L\n00000000DP0H\n00000000DP1L\n00000000DP1H\n00000000PCON\n0XXX000087H\n\nAT89S52 6Special Function Registers\nA map of the on-chip memory area called the Special Func-\ntion Register (SFR) space is shown in Table 1.\nNote that not all of the addresses are occupied, and unoc-\ncupied addresses may not be implemented on the chip.\nRead accesses to these addresses will in general return\nrandom data, and write accesses will have an indetermi-nate effect.\nUser software should not write 1s to these unlisted loca-\ntions, since they may be used in future products to invokenew features. In that case, the reset or inactive values of\nthe new bits will always be 0.\nTimer 2 Registers: Control and status bits are contained in\nregisters T2CON (shown in Table 2) and T2MOD (shown in\nTable 3) for Timer 2. The register pair (RCAP2H, RCAP2L)\nare the Capture/Reload registers for Timer 2 in 16-bit cap-ture mode or 16-bit auto-reload mode.\nInterrupt Registers: The individual interrupt enable bits\nare in the IE register. Two priorities can be set for each ofthe six interrupt sources in the IP register.\nTable 2.  T2CON \u2013 Timer/Counter 2 Control Register\nT2CON Address = 0C8H Reset Value = 0000 0000B\nBit Addressable\nBit TF2 EXF2 RCLK TCLK EXEN2 TR2 C/T2 CP/RL2\n76543210\nSymbol Function\nTF2 Timer 2 overflow flag set by a Timer 2 overflow and must be cleared by software. TF2 will not be set when either RCLK = 1 \nor TCLK = 1.\nEXF2 Timer 2 external flag set when either a capture or reload is caused by a negative transition on T2EX and EXEN2 = 1. \nWhen Timer 2 interrupt is enabled, EXF2 = 1 will cause the CPU to vector to the Timer 2 interrupt routine. EXF2 must be cleared by software. EXF2 does not cause an interrupt in up/down counter mode (DCEN = 1).\nRCLK Receive clock enable. When set, causes the serial port to use Timer 2 overflow pulses for its receive clock in serial port \nModes 1 and 3. RCLK = 0 causes Timer 1 overflow to be used for the receive clock.\nTCLK Transmit clock enable. When set, causes the serial port to use Timer 2 overflow pulses for its transmit clock in serial por t \nModes 1 and 3. TCLK = 0 causes Timer 1 overflows to be used for the transmit clock.\nEXEN2 Timer 2 external enable. When set, allows a capture or reload to occur as a result of a negative transition on T2EX if Tim er \n2 is not being used to clock the serial port. EXEN2 = 0 causes Timer 2 to ignore events at T2EX.\nTR2 Start/Stop control for Timer 2. TR2 = 1 starts the timer.\nC/T2\nTimer or counter select for Timer 2. C/T2  = 0 for timer function. C/T2  = 1 for external event counter (falling edge triggered).\nCP/RL2 Capture/Reload select. CP/RL2  = 1 causes captures to occur on negative transitions at T2EX if EXEN2 = 1. CP/RL2  = 0 \ncauses automatic reloads to occur when Timer 2 overflows or negative transitions occur at T2EX when EXEN2 = 1. When \neither RCLK or TCLK = 1, this bit is ignored and the timer is forced to auto-reload on Timer 2 overflow.\n\nAT89S52\n7Dual Data Pointer Registers: To facilitate accessing both\ninternal and external data memory, two banks of 16-bit\nData Pointer Registers are provided: DP0 at SFR address\nlocations 82H-83H and DP1 at 84H-85H. Bit DPS = 0in SFR AUXR1 selects DP0 and DPS = 1 selects DP1.The user should always initialize the DPS bit to theappropriate value before accessing the respective Data\nPointer Register.\nPower Off Flag: The Power Off Flag (POF) is located at bit\n4 (PCON.4) in the PCON SFR. POF is set to \u201c1\u201d duringpower up. It can be set and rest under software control andis not affected by reset.Table 3a.  AUXR: Auxiliary Register\nAUXR Address = 8EH Reset Value = XXX00XX0B\nNot Bit Addressable\n\u2013 \u2013 \u2013 WDIDLE DISRTO \u2013 \u2013 DISALE\nBit 7 6 5 4 3 2 1 0\n\u2013 Reserved for future expansion\nDISALE Disable/Enable ALE\nDISALE Operating Mode0 ALE is emitted at a constant rate of 1/6 the oscillator frequency\n1 ALE is active only during a MOVX or MOVC instruction\nDISRTO Disable/Enable Reset out\nDISRTO\n0 Reset pin is driven High after WDT times out\n1 Reset pin is input only\nWDIDLE Disable/Enable WDT in IDLE mode\nWDIDLE\n0 WDT continues to count in IDLE mode1 WDT halts counting in IDLE mode\nTable 3b.  AUXR1: Auxiliary Register 1\nAUXR1 Address = A2H Reset Value = XXXXXXX0B\nNot Bit Addressable\n\u2013\u2013\u2013\u2013 \u2013 \u2013 \u2013 D P S\nBit 7 6 5 4 3 2 1 0\n\u2013 Reserved for future expansion\nDPS Data Pointer Register Select\nDPS\n0 Selects DPTR Registers DP0L, DP0H\n1 Selects DPTR Registers DP1L, DP1H\n\nAT89S52 8Memory Organization\nMCS-51 devices have a separate address space for Pro-\ngram and Data Memory. Up to 64K bytes each of externalProgram and Data Memory can be addressed.\nProgram Memory\nIf the EA pin is connected to GND, all program fetches are\ndirected to external memory.\nOn the AT89S52, if EA  is connected to VCC, program\nfetches to addresses 0000H through 1FFFH are directed to\ninternal memory and fetches to addresses 2000H through\nFFFFH are to external memory.\nData Memory\nThe AT89S52 implements 256 bytes of on-chip RAM. The\nupper 128 bytes occupy a parallel address space to the\nSpecial Function Registers. This means that the upper 128bytes have the same addresses as the SFR space but arephysically separate from SFR space.When an instruction accesses an internal location above\naddress 7FH, the address mode used in the instructionspecifies whether the CPU accesses the upper 128 bytesof RAM or the SFR space. Instructions which use direct\naddressing access of the SFR space.\nFor example, the following direct addressing instruction\naccesses the SFR at location 0A0H (which is P2).\nMOV 0A0H, #data\nInstructions that use indirect addressing access the upper\n128 bytes of RAM. For example, the following indirect\naddressing instruction, where R0 contains 0A0H, accessesthe data byte at address 0A0H, rather than P2 (whoseaddress is 0A0H).\nMOV @R0, #data\nNote that stack operations are examples of indirectaddressing, so the upper 128 bytes of data RAM are avail-able as stack space.\n\nAT89S52\n9Watchdog Timer \n(One-time Enabled with Reset-out)\nThe WDT is intended as a recovery method in situations\nwhere the CPU may be subjected to software upsets. TheWDT consists of a 13-bit counter and the Watchdog TimerReset (WDTRST) SFR. The WDT is defaulted to disablefrom exiting reset. To enable the WDT, a user must write01EH and 0E1H in sequence to the WDTRST register(SFR location 0A6H). When the WDT is enabled, it willincrement every machine cycle while the oscillator is run-ning. The WDT timeout period is dependent on the externalclock frequency. There is no way to disable the WDTexcept through reset (either hardware reset or WDT over-flow reset). When WDT overflows, it will drive an output\nRESET HIGH pulse at the RST pin.\nUsing the WDT\nTo enable the WDT, a user must write 01EH and 0E1H in\nsequence to the WDTRST register (SFR location 0A6H).When the WDT is enabled, the user needs to service it bywriting 01EH and 0E1H to WDTRST to avoid a WDT over-flow. The 13-bit counter overflows when it reaches 8191(1FFFH), and this will reset the device. When the WDT isenabled, it will increment every machine cycle while theoscillator is running. This means the user must reset theWDT at least every 8191 machine cycles. To reset theWDT the user must write 01EH and 0E1H to WDTRST.WDTRST is a write-only register. The WDT counter cannotbe read or written. When WDT overflows, it will generate anoutput RESET pulse at the RST pin. The RESET pulseduration is 96xTOSC, where TOSC=1/FOSC. To make thebest use of the WDT, it should be serviced in those sec-tions of code that will periodically be executed within thetime required to prevent a WDT reset.\nWDT During Power-down and Idle\nIn Power-down mode the oscillator stops, which means theWDT also stops. While in Power-down mode, the userdoes not need to service the WDT. There are two methodsof exiting Power-down mode: by a hardware reset or via alevel-activated external interrupt which is enabled prior toentering Power-down mode. When Power-down is exitedwith hardware reset, servicing the WDT should occur as itnormally does whenever the AT89S52 is reset. ExitingPower-down with an interrupt is significantly different. Theinterrupt is held low long enough for the oscillator to stabi-lize. When the interrupt is brought high, the interrupt isserviced. To prevent the WDT from resetting the devicewhile the interrupt pin is held low, the WDT is not starteduntil the interrupt is pulled high. It is suggested that theWDT be reset during the interrupt service for the interruptused to exit Power-down mode.To ensure that the WDT does not overflow within a few\nstates of exiting Power-down, it is best to reset the WDT\njust before entering Power-down mode.\nBefore going into the IDLE mode, the WDIDLE bit in SFR\nAUXR is used to determine whether the WDT continues tocount if enabled. The WDT keeps counting during IDLE(WDIDLE bit = 0) as the default state. To prevent the WDT\nfrom resetting the AT89S52 while in IDLE mode, the user\nshould always set up a timer that will periodically exit IDLE,service the WDT, and reenter IDLE mode.\nWith WDIDLE bit enabled, the WDT will stop to count in\nIDLE mode and resumes the count upon exit from IDLE.\nUART\nThe UART in the AT89S52 operates the same way as the\nUART in the AT89C51 and AT89C52. For further informa-\ntion on the UART operation, refer to the ATMEL Web site(http://www.atmel.com). From the home page, select \u2018Prod-ucts\u2019, then \u20188051-Architecture Flash Microcontroller\u2019, then\u2018Product Overview\u2019. \nTimer 0 and 1\nTimer 0 and Timer 1 in the AT89S52 operate the same way\nas Timer 0 and Timer 1 in the AT89C51 and AT89C52. For\nfurther information on the timers\u2019 operation, refer to theATMEL Web site (http://www.atmel.com). From the homepage, select \u2018Products\u2019, then \u20188051-Architecture FlashMicrocontroller\u2019, then \u2018Product Overview\u2019. \nTimer 2\nTimer 2 is a 16-bit Timer/Counter that can operate as either\na timer or an event counter. The type of operation isselected by bit C/T2\n in the SFR T2CON (shown in Table 2).\nTimer 2 has three operating modes: capture, auto-reload(up or down counting), and baud rate generator. Themodes are selected by bits in T2CON, as shown in Table 3.Timer 2 consists of two 8-bit registers, TH2 and TL2. In theTimer function, the TL2 register is incremented everymachine cycle. Since a machine cycle consists of 12 oscil-lator periods, the count rate is 1/12 of the oscillatorfrequency.\nTable 3.  Timer 2 Operating Modes\nRCLK +TCLK CP/RL2 TR2 MODE\n0 0 1 16-bit Auto-reload\n0 1 1 16-bit Capture1 X 1 Baud Rate Generator\nX X 0 (Off)\n\nAT89S52 10In the Counter function, the register is incremented in\nresponse to a 1-to-0 transition at its corresponding external\ninput pin, T2. In this function, the external input is sampledduring S5P2 of every machine cycle. When the samplesshow a high in one cycle and a low in the next cycle, thecount is incremented. The new count value appears in theregister during S3P1 of the cycle following the one in which\nthe transition was detected. Since two machine cycles (24\noscillator periods) are required to recognize a 1-to-0 transi-tion, the maximum count rate is 1/24 of the oscillator fre-quency. To ensure that a given level is sampled at leastonce before it changes, the level should be held for at leastone full machine cycle.\nCapture Mode\nIn the capture mode, two options are selected by bitEXEN2 in T2CON. If EXEN2 = 0, Timer 2 is a 16-bit timeror counter which upon overflow sets bit TF2 in T2CON.This bit can then be used to generate an interrupt. If\nEXEN2 = 1, Timer 2 performs the same operation, but a 1-\nto-0 transition at external input T2EX also causes thecurrentvalue in TH2 and TL2 to be captured into RCAP2Hand RCAP2L, respectively. In  addition, the transition at\nT2EX causes bit EXF2 in T2CON to be set. The EXF2 bit,like TF2, can generate an interrupt. The capture mode is\nillustrated in Figure 5.\nAuto-reload (Up or Down Counter)\nTimer 2 can be programmed to count up or down when\nconfigured in its 16-bit auto-reload mode. This feature is\ninvoked by the DCEN (Down Counter Enable) bit located in\nthe SFR T2MOD (see Table 4). Upon reset, the DCEN bitis set to 0 so that timer 2 will default to count up. WhenDCEN is set, Timer 2 can count up or down, depending onthe value of the T2EX pin.\nFigure 5.  Timer in Capture Mode\nFigure 6 shows Timer 2 automatically counting up when\nDCEN=0. In this mode, two options are selected by bit\nEXEN2 in T2CON. If EXEN2 = 0, Timer 2 counts up to0FFFFH and then sets the TF2 bit upon overflow. Theoverflow also causes the timer registers to be reloaded withthe 16-bit value in RCAP2H and RCAP2L. The values inTimer in Capture ModeRCAP2H and RCAP2L are preset\nby software. If EXEN2 = 1, a 16-bit reload can be triggered\neither by an overflow or by a 1-to-0 transition at external\ninput T2EX. This transition also sets the EXF2 bit. Both theTF2 and EXF2 bits can generate an interrupt if enabled.\nSetting the DCEN bit enables Timer 2 to count up or down,\nas shown in Figure 6. In this mode, the T2EX pin controlsthe direction of the count. A logic 1 at T2EX makes Timer 2\ncount up. The timer will overflow at 0FFFFH and set the\nTF2 bit. This overflow also causes the 16-bit value inRCAP2H and RCAP2L to be reloaded into the timer regis-ters, TH2 and TL2, respectively.\nA logic 0 at T2EX makes Timer 2 count down. The timer\nunderflows when TH2 and TL2 equal the values stored in\nRCAP2H and RCAP2L. The underflow sets the TF2 bit and\ncauses 0FFFFH to be reloaded into the timer registers.\nThe EXF2 bit toggles whenever Timer 2 overflows or\nunderflows and can be used as a 17th bit of resolution. Inthis operating mode, EXF2 does not flag an interrupt.OSC\nEXF2 T2EX  PINT2  PINTR2\nEXEN2C/T2  =  0\nC/T2  =  1CONTROL\nCAPTUREOVERFLOW\nCONTROLTRANSITION\nDETECTORTIMER  2\nINTERRUPT\u00f712\nRCAP2L RCAP2HTH2 TL2 TF2\n\nAT89S52\n11Figure 6.  Timer 2 Auto Reload Mode (DCEN = 0)\nTable 4.  T2MOD \u2013 Timer 2 Mode Control RegisterOSC\nEXF2TF2\nT2EX  PINT2  PINTR2\nEXEN2C/T2  =  0\nC/T2  =  1CONTR OL\nRELOAD\nCONTROLTRANSITION\nDETECTORTIMER  2\nINTERRUPT\u00f712\nRCAP2L RCAP2HTH2 TL2\nOVERFLOW\nT2MOD Address = 0C9H Reset Value = XXXX XX00B\nNot Bit Addressable\n\u2013\u2013\u2013\u2013\u2013\u2013 T 2 O E D C E N\nB i t 76543210\nSymbol Function\n\u2013 Not implemented, reserved for futureT2OE Timer 2 Output Enable bit\nDCEN When set, this bit allows Timer 2 to be configured as an up/down counter\n\nAT89S52 12Figure 7.  Timer 2 Auto Reload Mode (DCEN = 1)\nFigure 8.  Timer 2 in Baud Rate Generator ModeOSCEXF2\nTF2\nT2EX  PINCOUNT\nDIRECTION1=UP0=DOWNT2  PINTR2CONTROLOVERFLO WTOGGLE\nTIMER  2\nINTERRUPT12\nRCAP2L RCAP2H0FFH 0FFH\nTH2 TL2C/T2  =  0\nC/T2  =  1\u00f7(DOWN COUNTING RELOAD VALUE)\n(UP COUNTING RELOAD VALUE)\nOSCSMOD1\nRCLK\nTCLKRx\nCLOCK\nTx\nCLOCK\nT2EX  PINT2  PINTR2CONTROL\"1\"\n\"1\"\"1\"\n\"0\"\n\"0\"\"0\"TIMER  1  OVERFLOW\nNOTE: OSC. FREQ. IS  DIVIDED  BY  2,  NOT  12\nTIMER  2\nINTERRUPT22\n16\n16RCAP2L RCAP2HTH2 TL2C/T2  =  0\nC/T2  =  1\nEXF2\nCONTROLTRANSITION\nDETECTOR\nEXEN2\u00f7\u00f7\n\u00f7\u00f7\n\nAT89S52\n13Baud Rate Generator\nTimer 2 is selected as the baud rate generator by setting\nTCLK and/or RCLK in T2CON (Table 2). Note that thebaud rates for transmit and receive can be different if Timer2 is used for the receiver or transmitter and Timer 1 is used\nfor the other function. Setting RCLK and/or TCLK puts\nTimer 2 into its baud rate generator mode, as shown in Fig-ure 8.\nThe baud rate generator mode is similar to the auto-reload\nmode, in that a rollover in TH2 causes the Timer 2 registersto be reloaded with the 16-bit value in registers RCAP2H\nand RCAP2L, which are preset by software.\nThe baud rates in Modes 1 and 3 are determined by Timer\n2\u2019s overflow rate according to the following equation.\nThe Timer can be configured for either timer or counter\noperation. In most applications, it is configured for timer\noperation (CP/T2\n = 0). The timer operation is different for\nTimer 2 when it is used as a baud rate generator. Normally,as a timer, it increments every machine cycle (at 1/12 theoscillator frequency). As a baud rate generator, however, itincrements every state time (at 1/2 the oscillator fre-\nquency). The baud rate formula is given below.\nwhere (RCAP2H, RCAP2L) is the content of RCAP2H and\nRCAP2L taken as a 16-bit unsigned integer.\nTimer 2 as a baud rate generator is shown in Figure 8. This\nfigure is valid only if RCLK or TCLK = 1 in T2CON. Notethat a rollover in TH2 does not set TF2 and will not gener-ate an interrupt. Note too, that if EXEN2 is set, a 1-to-0transition in T2EX will set EXF2 but will not cause a reload\nfrom (RCAP2H, RCAP2L) to (TH2, TL2). Thus, when Timer\n2 is in use as a baud rate generator, T2EX can be used asan extra external interrupt.\nNote that when Timer 2 is running (TR2 = 1) as a timer in\nthe baud rate generator mode, TH2 or TL2 should not beread from or written to. Under these conditions, the Timer is\nincremented every state time, and the results of a read or\nwrite may not be accurate. The RCAP2 registers may beread but should not be written to, because a write mightoverlap a reload and cause write and/or reload errors. Thetimer should be turned off (clear TR2) before accessing theTimer 2 or RCAP2 registers.\nFigure 9.  Timer 2 in Clock-Out ModeModes 1 and 3 Baud Rates Timer 2 Overflow Rate\n16----------------------------------------------------------- - =Modes 1 and 3\nBaud Rate---------------------------------------Oscillator Frequency\n32 x [65536-RCAP2H,RCAP2L)]------------------------------------------------------------------------------------- - =\nOSC\nEXF2P1.0\n(T2)\nP1.1\n(T2EX)TR2\nEXEN2C/T2  BIT\nTRANSITION\nDETECTOR\nTIMER  2\nINTERRUPTT2OE  (T2MOD.1)\u00f72TL2\n(8-BITS)\nRCAP2L RCAP2HTH2\n(8-BITS)\n\u00f72\n\nAT89S52 14Programmable Clock Out\nA 50% duty cycle clock can be programmed to come out on\nP1.0, as shown in Figure 9. This pin, besides being a regu-\nlar I/O pin, has two alternate functions. It can be pro-\ngrammed to input the external clock for Timer/Counter 2 orto output a 50% duty cycle clock ranging from 61 Hz to 4MHz at a 16  MHz operating frequency.\nTo configure the Timer/Counter 2 as a clock generator, bit\nC/T2\n (T2CON.1) must be cleared and bit T2OE (T2MOD.1)\nmust be set. Bit TR2 (T2CON.2) starts and stops the timer.\nThe clock-out frequency depends on the oscillator fre-\nquency and the reload value of Timer 2 capture registers(RCAP2H, RCAP2L), as shown in the following equation.\nIn the clock-out mode, Timer 2 roll-overs will not generate\nan interrupt. This behavior is similar to when Timer 2 is\nused as a baud-rate generator. It is possible to use Timer 2\nas a baud-rate generator and a clock generator simulta-neously. Note, however, that the baud-rate and clock-outfrequencies cannot be determined independently from oneanother since they both use RCAP2H and RCAP2L.\nInterrupts\nThe AT89S52 has a total of six interrupt vectors: two exter-\nnal interrupts (INT0  and INT1 ), three timer interrupts (Tim-\ners 0, 1, and 2), and the serial port interrupt. Theseinterrupts are all shown in Figure 10.\nEach of these interrupt sources can be individually enabled\nor disabled by setting or clearing a bit in Special FunctionRegister IE. IE also contains a global disable bit, EA, which\ndisables all interrupts at once.\nNote that Table 5 shows that bit position IE.6 is unimple-\nmented. In the AT89S52, bit position IE.5 is also unimple-mented. User software should not write 1s to these bitpositions, since they may be used in future AT89 products.\nTimer 2 interrupt is generated by the logical OR of bits TF2\nand EXF2 in register T2CON. Neither of these flags is\ncleared by hardware when the service routine is vectoredto. In fact, the service routine may have to determinewhether it was TF2 or EXF2 that generated the interrupt,and that bit will have to be cleared in software.\nThe Timer 0 and Timer 1 flags, TF0 and TF1, are set at\nS5P2 of the cycle in which the timers overflow. The values\nare then polled by the circuitry in the next cycle. However,the Timer 2 flag, TF2, is set at S2P2 and is polled in thesame cycle in which the timer overflows.Table 5.  Interrupt Enable (IE) Register\nFigure 10.  Interrupt SourcesClock-Out FrequencyOscillator Frequency\n4 x [65536-(RCAP2H,RCAP2L)]------------------------------------------------------------------------------------ - =      (MSB)                                                                                         (LSB)\nEA \u2013 ET2 ES ET1 EX1 ET0 EX0\n       Enable Bit = 1 enables the interrupt.\n       Enable Bit = 0 disables the interrupt.\nSymbol Position Function\nEA IE.7 Disables all interrupts. If EA=0, \nno interrupt is acknowledged. If \nEA = 1, each interrupt source is \nindividually enabled or disabled by setting or clearing its enable \nbit.\n\u2013 IE.6 Reserved.ET2 IE.5 Timer 2 interrupt enable bit.\nES IE.4 Serial Port interrupt enable bit.\nET1 IE.3 Timer 1 interrupt enable bit.EX1 IE.2 External interrupt 1 enable bit.\nET0 IE.1 Timer 0 interrupt enable bit.\nEX0 IE.0 External interrupt 0 enable bit.User software should never write 1s to unimplemented bits, \nbecause they may be used in future AT89 products.\nIE1IE0\n11\n00\nTF1TF0\nINT1INT0\nTI\nRI\nTF2\nEXF2\n\nAT89S52\n15Oscillator Characteristics \nXTAL1 and XTAL2 are the input and output, respectively,\nof an inverting amplifier that can be configured for use asan on-chip oscillator, as shown in Figure 11. Either a quartzcrystal or ceramic resonator may be used. To drive the\ndevice from an external clock source, XTAL2 should be left\nunconnected while XTAL1 is driven, as shown in Figure 12.There are no requirements on the duty cycle of the externalclock signal, since the input to the internal clocking circuitryis through a divide-by-two flip-flop, but minimum and maxi-mum voltage high and low time specifications must be\nobserved.\nIdle Mode \nIn idle mode, the CPU puts itself to sleep while all the on-\nchip peripherals remain active. The mode is invoked bysoftware. The content of the on-chip RAM and all the spe-cial functions registers remain unchanged during thismode. The idle mode can be terminated by any enabled\ninterrupt or by a hardware reset. \nNote that when idle mode is terminated by a hardware\nreset, the device normally resumes program executionfrom where it left off, up to two machine cycles before theinternal reset algorithm takes control. On-chip hardwareinhibits access to internal RAM in this event, but access to\nthe port pins is not inhibited. To eliminate the possibility of\nan unexpected write to a port pin when idle mode is termi-nated by a reset, the instruction following the one thatinvokes idle mode should not write to a port pin or to exter-nal memory.\nPower-down Mode \nIn the Power-down mode, the oscillator is stopped, and the\ninstruction that invokes Power-down is the last instruction\nexecuted. The on-chip RAM and Special Function Regis-ters retain their values until the Power-down mode is termi-nated. Exit from Power-down mode can be initiated eitherby a hardware reset or by an enabled external interrupt.Reset redefines the SFRs but does not change the on-chip\nRAM. The reset should not be activated before V\nCC is\nrestored to its normal operating level and must be heldactive long enough to allow the oscillator to restart\nandstabilize.\nFigure 11.  Oscillator Connections\nNote:  C1, C2 = 30 pF \u00b1 10 pF for Crystals\n= 40 pF \u00b1 10 pF for Ceramic Resonators\nFigure 12.  External Clock Drive Configuration\n C2\nXTAL2\nGNDXTAL1C1\nXTAL2\nXTAL1\nGNDNC\nEXTERNAL\nOSCILLATOR\nSIGNAL\nTable 6.  Status of External Pins During Idle and Power-down Modes\nMode Program Memory ALE PSEN PORT0 PORT1 PORT2 PORT3\nIdle Internal 1 1 Data Data Data Data\nIdle External 1 1 Float Data Address DataPower-down Internal 0 0 Data Data Data Data\nPower-down External 0 0 Float Data Data Data\n\nAT89S52 16Program Memory Lock Bits \nThe AT89S52 has three lock bits that can be left unpro-\ngrammed (U) or can be programmed (P) to obtain the addi-tional features listed in the following table.\nWhen lock bit 1 is programmed, the logic level at the EA\n pin\nis sampled and latched during reset. If the device is pow-ered up without a reset, the latch initializes to a randomvalue and holds that value until reset is activated. Thelatched value of EA\n must agree with the current logic level\nat that pin in order for the device to function properly.\nProgramming the Flash \u2013 Parallel Mode\nThe AT89S52 is shipped with the on-chip Flash memory\narray ready to be programmed. The programming interface\nneeds a high-voltage (12-volt) program enable signal andis compatible with conventional third-party Flash orEPROM programmers.\nThe AT89S52 code memory array is programmed byte-by-\nbyte.\nProgramming Algorithm: Before programming the\nAT89S52, the address, data, and control signals should beset up according to the Flash programming mode table andFigures 13 and 14. To program the AT89S52, take the fol-lowing steps:\n1. Input the desired memory location on the address \nlines.\n2. Input the appropriate data byte on the data lines.3. Activate the correct combination of control signals. 4. Raise EA\n/VPP to 12V. \n5. Pulse ALE/PROG  once to program a byte in the \nFlash array or the lock bits. The byte-write cycle is \nself-timed and typically takes no more than 50 \u00b5s. Repeat steps 1 through 5, changing the address \nand data for the entire array or until the end of the \nobject file is reached.\nData Polling: The AT89S52 features Data  Polling to indi-\ncate the end of a byte write cycle. During a write cycle, anattempted read of the last byte written will result in the com-plement of the written data on P0.7. Once the write cycle\nhas been completed, true data is valid on all outputs, and\nthe next cycle may begin. Data\n Polling may begin any time\nafter a write cycle has been initiated. \nReady/Busy : The progress of byte programming can also\nbe monitored by the RDY/BSY  output signal. P3.0 is pulled\nlow after ALE goes high during programming to indicate\nBUSY. P3.0 is pulled high again when programming is\ndone to indicate READY.\nProgram Verify:  If lock bits LB1 and LB2 have not been\nprogrammed, the programmed code data can be read backvia the address and data lines for verification. The status of\nthe individual lock bits can be verified directly by reading\nthem back. \nReading the Signature Bytes:  The signature bytes are\nread by the same procedure as a normal verification oflocations 000H, 100H, and 200H, except that P3.6 andP3.7 must be pulled to a logic low. The values returned are\nas follows.\n(000H) = 1EH indicates manufactured by Atmel\n(100H) = 52H indicates 89S52(200H) = 06H\nChip Erase:  In the parallel programming mode, a chip\nerase operation is initiated by using the proper combinationof control signals and by pulsing ALE/PROG\n low for a dura-\ntion of 200 ns - 500 ns.\nIn the serial programming mode, a chip erase operation is\ninitiated by issuing the Chip Erase instruction. In this mode,chip erase is self-timed and takes about 500 ms.\nDuring chip erase, a serial read from any address location\nwill return 00H at the data output.\nProgramming the Flash \u2013 Serial Mode\nThe Code memory array can be programmed using theserial ISP interface while RST is pulled to V\nCC. The serial\ninterface consists of pins SCK, MOSI (input) and MISO(output). After RST is set high, the Programming Enableinstruction needs to be executed first before other opera-tions can be executed. Before a reprogramming sequencecan occur, a Chip Erase operation is required.\nThe Chip Erase operation turns the content of every mem-\nory location in the Code array into FFH.\nEither an external system clock can be supplied at pin\nXTAL1 or a crystal needs to be connected across pinsXTAL1 and XTAL2. The maximum serial clock (SCK)Table 7.  Lock Bit Protection Modes\nProgram Lock Bits\nLB1 LB2 LB3 Protection Type\n1 U U U No program lock features2 P U U MOVC instructions executed \nfrom external program \nmemory are disabled from fetching code bytes from \ninternal memory, EA\n is \nsampled and latched on reset, and further programming of \nthe Flash memory is disabled\n3 P P U Same as mode 2, but verify is \nalso disabled\n4 P P P Same as mode 3, but external \nexecution is also disabled\n\nAT89S52\n17frequencyshould be less than 1/16 of the crystal fre-\nquency. With a 33 MHz oscillator clock, the maximum SCKfrequency is 2 MHz.\nSerial Programming Algorithm\nTo program and verify the AT89S52 in the serial program-ming mode, the following sequence is recommended:\n1. Power-up sequence:\nApply power between VCC and GND pins.Set RST pin to \u201cH\u201d.If a crystal is not connected across pins XTAL1 and\nXTAL2, apply a 3 MHz to 33 MHz clock to XTAL1 pinand wait for at least 10 milliseconds.\n2. Enable serial programming by sending the Pro-\ngramming Enable serial instruction to pin MOSI/P1.5. The frequency of the shift clock sup-plied at pin SCK/P1.7 needs to be less than the CPU clock at XTAL1 divided by 16.\n3. The Code array is programmed one byte at a time \nby supplying the address and data together with the appropriate Write instruction. The write cycle is self-\ntimed and typically takes less than 1 ms at 5V.\n4. Any memory location can be verified by using the \nRead instruction which returns the content at the selected address at serial output MISO/P1.6.\n5. At the end of a programming session, RST can be \nset low to commence normal device operation.\nPower-off sequence (if needed):\nSet XTAL1 to \u201cL\u201d (if a crystal is not used).\nSet RST to \u201cL\u201d.Turn V\nCC power off.\nData Polling: The Data  Polling feature is also available in\nthe serial mode. In this mode, during a write cycle anattempted read of the last byte written will result in the com-plement of the MSB of the serial output byte on MISO.\nSerial Programming Instruction Set\nThe Instruction Set for Serial Programming follows a 4-byteprotocol and is shown in Table 10.\n\nAT89S52 18Programming Interface \u2013 Parallel Mode\nEvery code byte in the Flash array can be programmed by\nusing the appropriate combination of control signals. Thewrite operation cycle is self-timed and once initiated, willautomatically time itself to completion.All major programming vendors offer worldwide support for\nthe Atmel microcontroller series. Please contact your localprogramming vendor for the appropriate software revision.\nNotes: 1. Each PROG  pulse is 200 ns - 500 ns for Chip Erase.\n2. Each PROG  pulse is 200 ns - 500 ns for Write Code Data.\n3. Each PROG  pulse is 200 ns - 500 ns for Write Lock Bits.\n4. RDY/BSY  signal is output on P3.0 during programming.\n5. X = don\u2019t care.\nFigure 13.  Programming the Flash Memory \n (Parallel Mode)Figure 14.  Verifying the Flash Memory (Parallel Mode)Table 8.  Flash Programming Modes\nMode VCCRST PSENALE/\nPROGEA/\nVPPP2.6 P2.7 P3.3 P3.6 P3.7P0.7-0\nDataP2.4-0 P1.7-0\nAddress\nWrite Code Data 5V H L(2)\n1 2 VLHHHH DIN A12-8 A7-0\nRead Code Data 5V H L H H L L L H H DOUT A12-8 A7-0\nWrite Lock Bit 1 5V H L(3)\n1 2 VHHHHH X X X\nWrite Lock Bit 2 5V H L(3)\n12V H H H L L X X X\nWrite Lock Bit 3 5V H L(3)\n12V H L H H L X X X\nRead Lock Bits\n1, 2, 35V H L H H H H L H LP0.2,\nP0.3,\nP0.4 XX\nChip Erase 5V H L(1)\n1 2 VHLHLL X X X\nRead Atmel ID 5V H L H H LLLLL1 E H X  0000 00H\nRead Device ID 5V H L H H LLLLL5 2 H X  0001 00H\nRead Device ID 5V H L H H LLLLL0 6 H X  0010 00H\nP1.0-P1.7\nP2.6P3.6P2.0 - P2.4A0 - A7ADDR.\n0000H/1FFFH\nSEE FLASH\nPROGRAMMING\nMODES TABLE\n3-33 MHzP0V\nP2.7PGM\nDATA\nPROG\nV/ V\nIH PP\nVIHALE\nP3.7\nXTAL2 EA\nRST\nPSENXTAL 1\nGNDVCCAT89S52\nP3.3\nP3.0RDY/\nBSYA8 - A12CC\nP1.0-P1.7\nP2.6\nP3.6P2.0 - P2.4A0 - A7ADDR.\n0000H/1FFFH\nSEE FLASH\nPROGRAMMING\nMODES TABLE\n3-33 MHzP0\nP2.7PGM DATA\n(USE 10KPULLUPS)\nV\nIHVIHALE\nP3.7\nXTAL2 EA\nRST\nPSENXTAL1\nGNDVCCAT89S52\nP3.3A8 - A12VCC\n\nAT89S52\n19Figure 15.  Flash Programming and Verification Waveforms \u2013 Parallel Mode  Flash Programming and Verification Characteristics (Parallel Mode)\nTA = 20\u00b0C to 30\u00b0C, VCC = 4.5 to 5.5V\nSymbol Parameter Min Max Units\nVPP Programming Supply Voltage 11.5 12.5 V\nIPP Programming Supply Current 10 mA\nICC VCC Supply Current 30 mA\n1/tCLCL Oscillator Frequency 3 33 MHz\ntAVGL Address Setup to PROG  Low 48tCLCL\ntGHAX Address Hold After PROG 48tCLCL\ntDVGL Data Setup to PROG  Low 48tCLCL\ntGHDX Data Hold After PROG 48tCLCL\ntEHSH P2.7 (ENABLE ) High to VPP 48tCLCL\ntSHGL VPP Setup to PROG  Low 10 \u00b5s\ntGHSL VPP Hold After PROG 10 \u00b5s\ntGLGH PROG Width 0.2 1 \u00b5s\ntAVQV Address to Data Valid 48tCLCL\ntELQV ENABLE Low to Data Valid 48tCLCL\ntEHQZ Data Float After ENABLE 04 8 tCLCL\ntGHBL PROG High to BUSY  Low 1.0 \u00b5s\ntWC Byte Write Cycle Time 50 \u00b5s\ntGLGHtGHSLtAVGL\ntSHGLtDVGLtGHAXtAVQV\ntGHDX\ntEHSHtELQV\ntWCBUSY READYtGHBLtEHQZP1.0 - P1.7\nP2.0 - P2.5\nP3.4\nALE/PROGPORT 0\nLOGIC 1\nLOGIC 0 EA/VPPVPP\nP2.7\n(ENABLE)\nP3.0\n(RDY/BSY)PROGRAMMING\nADDRESSVERIFICATION\nADDRESS\nDATA IN DATA OUT\n\nAT89S52 20Figure 16.  Flash Memory Serial Downloading\nFlash Programming and Verification Waveforms \u2013 Serial Mode\nFigure 17.  Serial Programming WaveformsP1.7/SCKDATA  OUTPUTINSTRUCTION\nINPUT\nCLOCK  IN\n3-33  MHzP1.5/MOSI\nVIHXTAL2\nRST XTAL1\nGNDVCCAT89S52\nP1.6/MISOVCC\n76543210\n\nAT89S52\n21Notes: 1. The signature bytes are not readable in Lock Bit Modes 3 and 4.\n2. B1 = 0, B2 = 0 ---> Mode 1, no lock protection\nB1 = 0, B2 = 1 ---> Mode 2, lock bit 1 activated\nB1 = 1, B2 = 0 ---> Mode 3, lock bit 2 activated\nB1 = 1, B1 = 1 ---> Mode 4, lock bit 3 activated\nAfter Reset signal is high, SCK should be low for at least 64\nsystem clocks before it goes high to clock in the enabledata bytes. No pulsing of Reset signal is necessary. SCKshould be no faster than 1/16 of the system clock atXTAL1.For Page Read/Write, the data always starts from byte 0 to\n255. After the command byte and upper address byte arelatched, each byte thereafter is treated as data until all 256bytes are shifted in/out. Then the next instruction will beready to be decoded.Table 9.  Serial Programming Instruction Set\nInstructionInstruction \nFormat\nOperation Byte 1 Byte 2 Byte 3 Byte 4\nProgramming Enable 1010 1100 0101 0011 xxxx xxxx xxxx xxxx\n0110 1001 (Output)Enable Serial Programming \nwhile RST is high\nChip Erase 1010 1100 100x xxxx xxxx xxxx xxxx xxxx Chip Erase Flash memory \narray\nRead Program Memory\n(Byte Mode)0010 0000 xxx Read data from Program \nmemory in the byte mode\nWrite Program Memory\n(Byte Mode)0100 0000 xxx Write data to Program \nmemory in the byte mode\nWrite Lock Bits\n(2)1010 1100 1110 00 xxxx xxxx xxxx xxxx Write Lock bits. See Note (2).\nRead Lock Bits 0010 0100 xxxx xxxx xxxx xxxx xx xx Read back current status of \nthe lock bits (a programmed \nlock bit reads back as a \u20181\u2019)\nRead Signature Bytes(1)0010 1000 xxx xxx xxxx Signature Byte Read Signature Byte\nRead Program Memory\n(Page Mode)0011 0000 xxx Byte 0 Byte 1... \nByte 255Read data from Program \nmemory in the Page Mode (256 bytes)\nWrite Program Memory\n(Page Mode)0101 0000 xxx Byte 0 Byte 1... \nByte 255Write data to Program \nmemory in the Page Mode (256 bytes)D7\nD6\nD5\nD4\nD3\nD2\nD1\nD0A7A6\nA5A4\nA3A2\nA1A0A12\nA11\nA10\nA9\nA8 B2B1A12\nA11\nA10\nA9\nA8\nA7A6\nA5A4\nA3A2\nA1A0\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0LB3\nLB2\nLB1A5\nA4\nA3\nA2\nA1A0A12\nA11\nA10\nA9\nA8A12\nA11\nA10\nA9\nA8\n}Each of the lock bits needs to be activated sequentially before \nMode 4 can be executed.\n\nAT89S52 22Serial Programming Characteristics\nFigure 18.  Serial Programming Timing\nMOSI\nMISOSCKtOVSH\ntSHSLtSLSH tSHOX\ntSLIV\nTable 10.  Serial Programming Characteristics, TA = -40\u00b0C to 85\u00b0C, VCC = 4.0 - 5.5V (Unless otherwise noted)\nSymbol Parameter Min Typ Max Units\n1/tCLCL Oscillator Frequency 0 33 MHz\ntCLCL Oscillator Period 30 ns\ntSHSL SCK Pulse Width High 2 tCLCL ns\ntSLSH SCK Pulse Width Low 2 tCLCL ns\ntOVSH MOSI Setup to SCK High tCLCL ns\ntSHOX MOSI Hold after SCK High 2 tCLCL ns\ntSLIV SCK Low to MISO Valid 10 16 32 ns\ntERASE Chip Erase Instruction Cycle Time 500 ms\ntSWC Serial Byte Write Cycle Time 64 tCLCL + 400 \u00b5s\n\nAT89S52\n23Notes: 1. Under steady state (non-transient) conditions, IOL must be externally limited as follows:\nMaximum IOL per port pin: 10 mA\nMaximum IOL per 8-bit port:\nPort 0: 26 mA          Ports 1, 2, 3: 15 mA\nMaximum total IOL for all output pins: 71 mA\nIf IOL exceeds the test condition, VOL may exceed the related specification. Pins are not guaranteed to sink current greater \nthan the listed test conditions.\n2. Minimum VCC for Power-down is 2V.Absolute Maximum Ratings*\nOperating Temperature..................................-55\u00b0C to +125\u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and functional operation of the device at these or any \nother conditions beyond those indicated in the \noperational sections of this specification is not implied. Exposure to absolute maximum rating \nconditions for extended periods may affect \ndevice reliability.Storage Temperature.....................................-65\u00b0C to +150\u00b0C\nVoltage on Any Pin\nwith Respect to Ground.....................................-1.0V to +7.0V\nMaximum Operating Voltage............................................6.6VDC Output Current......................................................15.0 mA\nDC Characteristics\nThe values shown in this table are valid for TA = -40\u00b0C to 85\u00b0C and VCC = 4.0V to 5.5V, unless otherwise noted.\nSymbol Parameter Condition Min Max Units\nVIL Input Low Voltage (Except EA )- 0 . 5 0 . 2  VCC-0.1 V\nVIL1 Input Low Voltage (EA )- 0 . 5 0 . 2  VCC-0.3 V\nVIH Input High Voltage (Except XTAL1, RST) 0.2 VCC+0.9 VCC+0.5 V\nVIH1 Input High Voltage (XTAL1, RST) 0.7 VCC VCC+0.5 V\nVOL Output Low Voltage(1) (Ports 1,2,3) IOL = 1.6 mA 0.45 V\nVOL1Output Low Voltage(1)\n(Port 0, ALE, PSEN )IOL = 3.2 mA 0.45 V\nVOHOutput High Voltage\n(Ports 1,2,3, ALE, PSEN )IOH = -60 \u00b5A, VCC = 5V \u00b1 10% 2.4 V\nIOH = -25 \u00b5A 0.75 VCC V\nIOH = -10 \u00b5A 0.9 VCC V\nVOH1Output High Voltage\n(Port 0 in External Bus Mode)IOH = -800 \u00b5A, VCC = 5V \u00b1 10% 2.4 V\nIOH = -300 \u00b5A 0.75 VCC V\nIOH = -80 \u00b5A 0.9 VCC V\nIIL Logical 0 Input Current (Ports 1,2,3) VIN = 0.45V -50 \u00b5A\nITLLogical 1 to 0 Transition Current \n(Ports 1,2,3)VIN = 2V, VCC = 5V \u00b1 10% -650 \u00b5A\nILI Input Leakage Current (Port 0, EA ) 0.45 < VIN < VCC \u00b110 \u00b5A\nRRST Reset Pulldown Resistor 10 30 K \u2126\nCIO Pin Capacitance Test Freq. = 1 MHz, TA = 25\u00b0C 10 pF\nICCPower Supply CurrentActive Mode, 12 MHz 25 mA\nIdle Mode, 12 MHz 6.5 mA\nPower-down Mode(1)VCC = 5.5V 50 \u00b5A\n\nAT89S52 24AC Characteristics \nUnder operating conditions, load capacitance for Port 0, ALE/PROG , and PSEN  = 100 pF; load capacitance for all other\noutputs = 80 pF.\nExternal Program and Data Memory Characteristics\nSymbol Parameter12 MHz Oscillator Variable Oscillator\nUnits Min Max Min Max\n1/tCLCL Oscillator Frequency 0 33 MHz\ntLHLL ALE Pulse Width 127 2tCLCL-40 ns\ntAVLL Address Valid to ALE Low 43 tCLCL-25 ns\ntLLAX Address Hold After ALE Low 48 tCLCL-25 ns\ntLLIV ALE Low to Valid Instruction In 233 4tCLCL-65 ns\ntLLPL ALE Low to PSEN  Low 43 tCLCL-25 ns\ntPLPH PSEN Pulse Width 205 3tCLCL-45 ns\ntPLIV PSEN Low to Valid Instruction In 145 3tCLCL-60 ns\ntPXIX Input Instruction Hold After PSEN 00 n s\ntPXIZ Input Instruction Float After PSEN 59 tCLCL-25 ns\ntPXAV PSEN to Address Valid 75 tCLCL-8 ns\ntAVIV Address to Valid Instruction In 312 5tCLCL-80 ns\ntPLAZ PSEN Low to Address Float 10 10 ns\ntRLRH RD Pulse Width 400 6tCLCL-100 ns\ntWLWH WR Pulse Width 400 6tCLCL-100 ns\ntRLDV RD Low to Valid Data In  252 5tCLCL-90 ns\ntRHDX Data Hold After RD 00 n s\ntRHDZ Data Float After RD 97 2tCLCL-28 ns\ntLLDV ALE Low to Valid Data In 517 8tCLCL-150 ns\ntAVDV Address to Valid Data In 585 9tCLCL-165 ns\ntLLWL ALE Low to RD  or WR Low 200 300 3tCLCL-50 3tCLCL+50 ns\ntAVWL Address to RD  or WR Low 203 4tCLCL-75 ns\ntQVWX Data Valid to WR  Transition 23 tCLCL-30 ns\ntQVWH Data Valid to WR  High 433 7tCLCL-130 ns\ntWHQX Data Hold After WR 33 tCLCL-25 ns\ntRLAZ RD Low to Address Float 0 0 ns\ntWHLH RD or WR High to ALE High 43 123 tCLCL-25 tCLCL+25 ns\n\nAT89S52\n25External Program Memory Read Cycle\nExternal Data Memory Read CycletLHLL\ntLLIV\ntPLIV\ntLLAXtPXIZtPLPH\ntPLAZtPXAVtAVLLtLLPL\ntAVIVtPXIXALE\nPSEN\nPORT 0\nPORT 2 A8 - A15A0 - A7 A0 - A7\nA8 - A15INSTR IN\ntLHLL\ntLLDV\ntLLWL\ntLLAXtWHLH\ntAVLLtRLRH\ntAVDVtAVWLtRLAZ tRHDXtRLDVtRHDZ\nA0  -  A7  FROM  RI  OR  DPLALE\nPSEN\nRD\nPORT  0\nPORT  2 P2.0  -  P2.7  OR  A8  -  A15  FROM  DPHA0  -  A7  FROM  PCL\nA8  -  A15  FROM  PCHDATA  IN INSTR  IN\n\nAT89S52 26External Data Memory Write Cycle\nExternal Clock Drive WaveformstLHLL\ntLLWL\ntLLAXtWHLH\ntAVLLtWLWH\ntAVWLtQVWXtQVWHtWHQX\nA0  -  A7  FROM  RI  OR  DPLALE\nPSEN\nWR\nPORT  0\nPORT  2 P2.0  -  P2.7  OR  A8  -  A15  FROM  DPHA0  -  A7  FROM  PCL\nA8  -  A15  FROM  PCHDATA  OUT INSTR  IN\ntCHCXtCHCX\ntCLCX\ntCLCLtCHCL tCLCHV     -  0.5VCC\n0.45V0.2  V -  0.1VCC0.7 VCC\nExternal Clock Drive\nSymbol Parameter Min Max Units\n1/tCLCL Oscillator Frequency 0 33 MHz\ntCLCL Clock Period 30 ns\ntCHCX High Time 12 ns\ntCLCX Low Time 12 ns\ntCLCH Rise Time 5 ns\ntCHCL Fall Time 5 ns\n\nAT89S52\n27Shift Register Mode Timing Waveforms\nAC Testing Input/Output Waveforms(1)\nNote: 1. AC Inputs during testing are driven at VCC - 0.5V \nfor a logic 1 and 0.45V for a logic 0. Timing mea-\nsurements are made at VIH min. for a logic 1 and VIL \nmax. for a logic 0.Float Waveforms(1)\nNote: 1. For timing purposes, a port pin is no longer floating \nwhen a 100 mV change from load voltage occurs. A port pin begins to float when a 100 mV change from \nthe loaded V\nOH/VOL level occurs.Serial Port Timing: Shift Register Mode Test Conditions\nThe values in this table are valid for VCC = 4.0V to 5.5V and Load Capacitance = 80 pF.\nSymbol Parameter12 MHz Osc Variable Oscillator\nUnits Min Max Min Max\ntXLXL Serial Port Clock Cycle Time 1.0 12tCLCL \u00b5s\ntQVXH Output Data Setup to Clock Rising Edge 700 10tCLCL-133 ns\ntXHQX Output Data Hold After Clock Rising Edge 50 2tCLCL-80 ns\ntXHDX Input Data Hold After Clock Rising Edge 0 0 ns\ntXHDV Clock Rising Edge to Input Data Valid 700 10tCLCL-133 ns\ntXHDVtQVXHtXLXL\ntXHDXtXHQXALE\nINPUT DATACLEAR RIOUTPUT DATAWRITE TO SBUFINSTRUCTION\nCLOCK0\n01\n12\n23\n34\n45\n56\n67\n7\nSET TI\nSET RI8\nVALID VALID VALID VALID VALID VALID VALID VALID\n0.45VTEST  POINTSV     -  0.5VCC0.2  V     +  0.9VCC\n0.2  V     -  0.1VCCVLOAD+ 0.1V\nTiming  Reference\nPointsV\nLOAD- 0.1VLOAD\nV VOL+ 0.1VVOL- 0.1V\n\nAT89S52 28Ordering Information\nSpeed\n(MHz)Power\nSupply Ordering Code Package Operation Range\n24 4.0V to 5.5V AT89S52-24AC\nAT89S52-24JC\nAT89S52-24PC44A\n44J\n40P6Commercial\n(0\u00b0C to 70\u00b0C)\nAT89S52-24AI\nAT89S52-24JIAT89S52-24PI44A\n44J40P6Industrial\n(-40\u00b0C to 85\u00b0C)\n33 4.5V to 5.5V AT89S52-33AC\nAT89S52-33JC\nAT89S52-33PC44A\n44J\n40P6Commercial\n(0\u00b0C to 70\u00b0C)\n= Preliminary Availability\nPackage Type\n44A 44-lead, Thin Plastic Gull Wing Quad Flatpack (TQFP)\n44J 44-lead, Plastic J-leaded Chip Carrier (PLCC)\n40P6 40-pin, 0.600\" Wide, Plastic Dual Inline Package (PDIP)\n\nAT89S52 29Packaging Information\n*Controlling dimension: millimeters1.20(0.047) MAX10.10(0.394)\n9.90(0.386)SQ12.21(0.478)\n11.75(0.458)SQ\n0.75(0.030)\n0.45(0.018)0.15(0.006)\n0.05(0.002)0.20(.008)\n0.09(.003)0\n70.80(0.031) BSCPIN 1 ID\n0.45(0.018)\n0.30(0.012).045(1.14) X 45\u00b0 PIN NO.1\nIDENTIFY.045(1.14) X 30\u00b0 - 45\u00b0.012(.305)\n.008(.203)\n.021(.533)\n.013(.330).630(16.0)\n.590(15.0)\n.043(1.09)\n.020(.508)\n.120(3.05)\n.090(2.29)\n.180(4.57)\n.165(4.19).500(12.7) REF SQ.032(.813)\n.026(.660)\n.050(1.27) TYP\n.022(.559) X 45\u00b0 MAX (3X).656(16.7)\n.650(16.5)\n.695(17.7)\n.685(17.4)SQSQ\n2.07(52.6)\n2.04(51.8) PIN\n1\n.566(14.4)\n.530(13.5)\n.090(2.29)\nMAX\n.005(.127)\nMIN\n.065(1.65)\n.015(.381)\n.022(.559)\n.014(.356).065(1.65)\n.041(1.04)\n0\n15REF\n.690(17.5)\n.610(15.5).630(16.0)\n.590(15.0)\n.012(.305)\n.008(.203).110(2.79)\n.090(2.29).161(4.09)\n.125(3.18)SEATING\nPLANE.220(5.59)\nMAX1.900(48.26) REF44A, 44-lead, Thin (1.0 mm) Plastic Gull Wing Quad \nFlat Package (TQFP)\nDimensions in Millimeters and (Inches)*44J, 44-lead, Plastic J-leaded Chip Carrier (PLCC)\nDimensions in Inches and (Millimeters)\n40P6, 40-pin, 0.600\" Wide, Plastic Dual Inline \nPackage (PDIP)Dimensions in Inches and (Millimeters)\nJEDEC STANDARD MS-011 AC\n\n\u00a9 Atmel Corporation 2001.\nAtmel Corporation makes no warranty for the use of its products, other than those expressly contained in the Company\u2019s standard  warranty\nwhich is detailed in Atmel\u2019s Terms and Conditions located on t he Company\u2019s web site. The Company assumes no responsibility for any errors\nwhich may appear in this document, reserves the right to change de vices or specifications detailed herein at any time without n otice, and does\nnot make any commitment to update the information contained herein.  No licenses to patents or other intellectual property of At mel are granted\nby the Company in connection with the sale of Atmel products, ex pressly or by implication. At mel\u2019s products are not authorized for use as critical\ncomponents in life support devices or systems.Atmel Headquarters Atmel Product Operations\nCorporate Headquarters\n2325 Orchard Parkway\nSan Jose, CA 95131TEL (408) 441-0311\nFAX (408) 487-2600\nEurope\nAtmel SarL\nRoute des Arsenaux 41Casa Postale 80\nCH-1705 Fribourg\nSwitzerlandTEL (41) 26-426-5555\nFAX (41) 26-426-5500\nAsia\nAtmel Asia, Ltd.\nRoom 1219Chinachem Golden Plaza\n77 Mody Road Tsimhatsui\nEast KowloonHong Kong\nTEL (852) 2721-9778\nFAX (852) 2722-1369\nJapan\nAtmel Japan K.K.9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033Japan\nTEL (81) 3-3523-3551\nFAX (81) 3-3523-7581Atmel Colorado Springs\n1150 E. Cheyenne Mtn. Blvd.Colorado Springs, CO 80906TEL (719) 576-3300\nFAX (719) 540-1759\nAtmel Grenoble\nAvenue de Rochepleine\nBP 12338521 Saint-Egreve Cedex, France\nTEL (33) 4-7658-3000\nFAX (33) 4-7658-3480\nAtmel Heilbronn\nTheresienstrasse 2POB 3535\nD-74025 Heilbronn, Germany\nTEL (49) 71 31 67 25 94FAX (49) 71 31 67 24 23\nAtmel Nantes\nLa Chantrerie\nBP 70602\n44306 Nantes Cedex 3, FranceTEL (33) 0 2 40 18 18 18\nFAX (33) 0 2 40 18 19 60\nAtmel Rousset\nZone Industrielle\n13106 Rousset Cedex, FranceTEL (33) 4-4253-6000\nFAX (33) 4-4253-6001\nAtmel Smart Card ICs\nScottish Enterprise Technology Park\nEast Kilbride, Scotland G75 0QRTEL (44) 1355-357-000\nFAX (44) 1355-242-743\nFax-on-Demand\nNorth America:\n1-(800) 292-8635\nInternational:\n1-(408) 441-0732e-mail\nliterature@atmel.com\nWeb Site\nhttp://www.atmel.com\nBBS\n1-(408) 436-4309\n Printed on recycled paper.\nRev.1919A-07/01/xMATMEL\u00ae is the registered trademark of Atmel.\nMCS-51\u00ae is the registered trademark of Intel Corporati on. Terms and product names in this document may be\ntrademarks of others.", "atmega 1280.pdf": "Features\n\u2022High Performance, Low Power Atmel\u00ae AVR\u00ae 8-Bit Microcontroller\n\u0081Advanced RISC Architecture\n\u2013 135 Powerful Instructions \u2013 Most Single Clock Cycle Execution\n\u2013 32 \u00d7 8 General Purpose Working Registers\n\u2013 Fully Static Operation\u2013 Up to 16 MIPS Throughput at 16MHz\u2013 On-Chip 2-cycle Multiplier\n\u0081High Endurance Non-volatile Memory Segments\n\u2013 64K/128K/256KBytes of In-System Self-Programmable Flash \n\u2013 4Kbytes EEPROM\n\u2013 8Kbytes Internal SRAM\u2013 Write/Erase Cycles:10,000 Flash/100,000 EEPROM\u2013 Data retention: 20 years at 85 \u00b0C/ 100 years at 25 \u00b0C\n\u2013 Optional Boot Code Section with Independent Lock Bits\n\u0081 In-System Programming by On-chip Boot Program\n\u0081 True Read-While-Write Operation\n\u2013 Programming Lock for Software Security\n\u0081 Endurance: Up to 64Kbytes Optional External Memory Space\n\u0081Atmel\u00ae QTouch\u00ae library support\n\u2013 Capacitive touch buttons, sliders and wheels\u2013 QTouch and QMatrix\u00ae acquisition\n\u2013 Up to 64 sense channels\n\u0081JTAG (IEEE std. 1149.1 compliant) Interface\n\u2013 Boundary-scan Capabilities According to the JTAG Standard\u2013 Extensive On-chip Debug Support\u2013 Programming of Flash, EEPROM, Fuses, and Lock Bits through the JTAG Interface\n\u0081Peripheral Features\n\u2013 Two 8-bit Timer/Counters with Separate Prescaler and Compare Mode\u2013 Four 16-bit Timer/Counter with Separate Prescaler, Compare- and Capture Mode\u2013 Real Time Counter with Separate Oscillator\u2013 Four 8-bit PWM Channels\u2013 Six/Twelve PWM Channels with Programmable Resolution from 2 to 16 Bits\n(ATmega1281/2561, ATmega640/1280/2560)\n\u2013 Output Compare Modulator\u2013 8/16-channel, 10-bit ADC (ATmega1281/2561, ATmega640/1280/2560)\u2013 Two/Four Programmable Serial USART (ATmega1281/2561, ATmega640/1280/2560)\u2013 Master/Slave SPI Serial Interface\u2013 Byte Oriented 2-wire Serial Interface\n\u2013 Programmable Watchdog Timer with Separate On-chip Oscillator\n\u2013 On-chip Analog Comparator\u2013 Interrupt and Wake-up on Pin Change\n\u0081Special Microcontroller Features\n\u2013 Power-on Reset and Programmable Brown-out Detection\u2013 Internal Calibrated Oscillator\n\u2013 External and Internal Interrupt Sources\n\u2013 Six Sleep Modes: Idle, ADC Noise Reduction, Power-save, Power-down, Standby,\nand Extended Standby\n\u0081I/O and Packages\n\u2013 54/86 Programmable I/O Lines (ATmega1281/2561, ATmega640/1280/2560)\u2013 64-pad QFN/MLF, 64-lead TQFP (ATmega1281/2561)\n\u2013 100-lead TQFP, 100-ball CBGA (ATmega640/1280/2560)\n\u2013 RoHS/Fully Green\n\u0081Temperature Range:\n\u2013- 4 0 \u00b0C to 85 \u00b0C Industrial\n\u0081Ultra-Low Power Consumption\n\u2013 Active Mode: 1MHz, 1.8V: 500\u00b5A\n\u2013 Power-down Mode: 0.1\u00b5A at 1.8V\n\u0081Speed Grade:\n\u2013 ATmega640V/ATmega1280V/ATmega1281V:\n\u0081 0 - 4MHz @ 1.8V - 5.5V, 0 - 8MHz @ 2.7V - 5.5V\n\u2013 ATmega2560V/ATmega2561V:\n\u0081 0 - 2MHz @ 1.8V - 5.5V, 0 - 8MHz @ 2.7V - 5.5V\n\u2013 ATmega640/ATmega1280/ATmega1281:\n\u0081 0 - 8MHz @ 2.7V - 5.5V, 0 - 16MHz @ 4.5V - 5.5V\n\u2013 ATmega2560/ATmega2561:\n\u0081 0 - 16MHz @ 4.5V - 5.5V8-bit Atmel \nMicrocontroller with 64K/128K/256K Bytes In-SystemProgrammable \nFlash\nATmega640/V\nATmega1280/VATmega1281/VATmega2560/VATmega2561/V\nPreliminary\n 2549N\u2013AVR\u201305/11\n\n2\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1. Pin Configurations\nFigure 1-1. TQFP-pinout ATmega640/1280/2560\nGND\nVCCPA0 (AD0) PA1 (AD1) PA2 (AD2)\nPA3 (AD3)\nPA4 (AD4)PA5 (AD5)PA6 (AD6)PA7 (AD7)\nPG2 (ALE)AVCC\nGND\nAREF PF0 (ADC0) PF1 (ADC1) PF2 (ADC2) PF3 (ADC3) PF4 (ADC4/TCK) PF5 (ADC5/TMS) PF6 (ADC6/TDO) PF7 (ADC7/TDI)\n100 99 9897 96 95 94 93 92 91 908988878685848382818079 7877 76\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n2575\n74\n73\n72\n71\n70\n69\n68\n67\n66\n65\n64\n63\n62\n61\n60\n59\n58\n57\n56\n55\n54\n53\n52\n51\n26 2829 31 27 36 30 32 35 37 33 34 3839 40 41 42 43 44 45 46 47 4849 50PK0 (ADC8/PCINT16)\nPK1 (ADC9/PCINT17)\nPK2 (ADC10/PCINT18)\nPK3 (ADC11/PCINT19)\nPK4 (ADC12/PCINT20)\nPK5 (ADC13/PCINT21)\nPK6 (ADC14/PCINT22)\nPK7 (ADC15/PCINT23)\n(OC2B) PH6\n(TOSC2) PG3 (TOSC1) PG4 RESET (T4) PH7\n(ICP4) PL0VCCGND\nXTAL2 XTAL1PL6 PL7GND\nVCC(OC0B) PG5\nVCC\nGND\n(RXD2) PH0\n(TXD2) PH1\n(XCK2) PH2\n(OC4A) PH3\n(OC4B) PH4\n(OC4C) PH5(RXD0/PCI NT8) PE0\n(TXD0) PE1\n(XCK0/AI N0) PE2\n(OC3A/AI N1) PE3\n(OC3B/I NT4) PE4\n(OC3C/I NT5) PE5\n(T3/INT6) PE6\n(CLKO/ICP3/I NT7) PE7\n(SS/PCI NT0) PB0\n(SCK/PCI NT1) PB1\n(MOSI/PCI NT2) PB2\n(MISO/PCI NT3) PB3\n(OC2A/PCI NT4) PB4\n(OC1A/PCI NT5) PB5\n(OC1B/PCI NT6) PB6\n(OC0A/OC1C/PCINT7) PB7PC7 (A15)\nPC6 (A14)\nPC5 (A13)\nPC4 (A12)\nPC3 (A11)\nPC2 (A10)\nPC1 (A9)\nPC0 (A 8)\nPG1 (RD)\nPG0 (WR)\n(TXD1/INT3) PD3\n(ICP1) PD4(XCK1) PD5(T1) PD6 (T0) PD7\n(SCL/INT0) PD0\n(SDA/INT1) PD1\n(RXD1/INT2) PD2\n(ICP5) PL1(T5) PL2\n(OC5A) PL3 (OC5B) PL4PJ6 (PCI NT15)\nPJ5 (PCI NT14)\nPJ4 (PCI NT13)\nPJ3 (PCI NT12)\nPJ2 (XCK3/PCI NT11)\nPJ1 (TXD3/PCI NT10)\nPJ0 (RXD3/PCI NT9)PJ7\n(OC5C) PL5INDEX COR NER\n\n3\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 1-2. CBGA-pinout ATmega640/1280/2560 \nNote: The functions for each pin is the same as for the 100 pin packages shown in Figure 1-1 on page 2 .A\nBCDEFGHJK1234567891 0\nA\nBCDEFGHJK1 098765432 1\nTop view Bottom view\nTable 1-1. CBGA-pinout ATmega640/1280/2560\n1 2 3 4 5 678 91 0\nA GND AREF PF0 PF2 PF5 PK0 PK3 PK6 GND VCC\nB AVCC PG5 PF1 PF3 PF6 PK1 PK4 PK7 PA0 PA2\nC PE2 PE0 PE1 PF4 PF7 PK2 PK5 PJ7 PA1 PA3\nD PE3 PE4 PE5 PE6 PH2 PA4 PA5 PA6 PA7 PG2\nE PE7 PH0 PH1 PH3 PH5 PJ6 PJ5 PJ4 PJ3 PJ2\nF VCC PH4 PH6 PB0 PL4 PD1 PJ1 PJ0 PC7 GND\nG GND PB1 PB2 PB5 PL2 PD0 PD5 PC5 PC6 VCC\nH PB3 PB4 RESET PL1 PL3 PL7 PD4 PC4 PC3 PC2\nJ PH7 PG3 PB6 PL0 XTAL2 PL6 PD3 PC1 PC0 PG1\nK PB7 PG4 VCC GND XTAL1 PL5 PD2 PD6 PD7 PG0\n\n4\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 1-3. Pinout ATmega1281/2561\nNote: The large center pad underneath the QFN/ML F package is made of metal and internally con-\nnected to GND. It should be soldered or glued to  the board to ensure good mechanical stability. If \nthe center pad is left unc onnected, the package might loosen from the board.(RXD0/PCI NT8/PDI) PE0\n(TXD0/PDO) PE1\n(XCK0/AI N0) PE2\n(OC3A/AI N1) PE3\n(OC3B/I NT4) PE4\n(OC3C/I NT5) PE5\n(T3/INT6) PE6\n(ICP3/CLKO/I NT7) PE7\n(SS/PCI NT0) PB0(OC0B) PG5\n(SCK/PCI NT1) PB1\n(MOSI/PCI NT2) PB2\n(MISO/PCI NT3) PB3\n(OC2A/ PCI NT4) PB4\n(OC1A/PCI NT5) PB5\n(OC1B/PCI NT6) PB6\n(OC0A/OC1C/PCINT7) PB7\n(TOSC2) PG3(TOSC1) PG4 RESETVCCGND\nXTAL2 XTAL1\n(SCL/INT0) PD0\n(SDA/INT1) PD1\n(RXD1/INT2) PD2\n(TXD1/INT3) PD3\n(ICP1) PD4(XCK1) PD5PA3 (AD3)\nPA4 (AD4)\nPA5 (AD5)PA6 (AD6)PA7 (AD7)\nPG2 (ALE)\nPC7 (A15)\nPC6 (A14)\nPC5 (A13)\nPC4 (A12)PC3 (A11)\nPC2 (A10)\nPC1 (A9)\nPC0 (A 8)\nPG1 (RD)PG0 (WR)AVCC\nGND\nAREF PF0 (ADC0) PF1 (ADC1) PF2 (ADC2) PF3 (ADC3) PF4 (ADC4/TCK) PF5 (ADC5/TMS) PF6 (ADC6/TDO) PF7 (ADC7/TDI) GND\nVCCPA0 (AD0) PA1 (AD1) PA2 (AD2)\n(T1) PD6 (T0) PD7INDEX COR NER1\n2\n345\n6\n7\n8\n9\n1011\n12\n13\n14\n15\n1664 63 62 61 60 59 5857 56 55 54 53 52 51 50 49\n48\n47\n46\n45\n44\n43\n42\n41\n403938\n37\n36\n35\n34\n33\n17 1819 20 21 22 23 24 25 26 27 2829 30 31 32\n\n5\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2. Overview\nThe ATmega640/1280/1281/2560/2561 is a low-power CMOS 8-bit microcontroller based on the\nAVR enhanced RISC architecture. By executing pow erful instructions in a single clock cycle, the\nATmega640/1280/1281/2560/2561 achieves throughputs approaching 1 MIPS per MHz allowingthe system designer to optimize power consumption versus processing speed.\n2.1 Block Diagram\nFigure 2-1. Block Diagram\n CPUGNDVCC\nRESETPo w er\nS upervision\nPOR /  BOD &\nRESET\nWatchdog\nOscillatorWatchdog\nTimer\nOscillator\nCi rcu i t s /\nCl ock\nGenerat i onXTAL1\nXTAL2\nPC7..0 PORT C (8)P A7..0 PORT A (8)\nPORT D (8)\nPD7..0PORT B (8)\nPB7..0PORT E (8)PE7..0\nPORT F (8)PF7..0\nPORT J (8)PJ7..0\nPG5..0 PORT G (6)\nPORT H (8)\nPH7..0PORT K (8)PK7..0\nPORT L (8)\nPL7..0XRAM\nTWI SPIEEPROMJTAG\n8 bit T/C 0 8 bit T/C 216 bit T/C 116 bit T/C 3\nSRAM FLASH16 bit T/C 416 bit T/C 5\nUSART 2USART 1USART 0\nInternal \nBandgap referenceAnalog \nCo m p ar at o rA/D\nCo n ver t er\nUSART 3\nNOTE:Shaded parts only availablein the 100-pin version. \nC omplete functionality for\nt h e ADC, T/ C4, an d  T/ C5 on l y available in the 100-pin version.\n\n6\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Atmel\u00ae AVR\u00ae core combines a rich instruction set with 32 general purpose working regis-\nters. All the 32 registers are directly connected to  the Arithmetic Logic Unit (ALU), allowing two\nindependent registers to be accessed in one single instruction executed in one clock cycle. The\nresulting architecture is more code efficient wh ile achieving throughputs up to ten times faster\nthan conventional CISC microcontrollers.\nThe ATmega640/1280/1281/2560/2561 provides the following features: 64K/128K/256K bytes of\nIn-System Programmable Flash with Read- While-Write capabilities, 4Kbytes EEPROM, 8\nKbytes SRAM, 54/86 general purpose I/O lines, 32 general purpose working registers, Real\nTime Counter (RTC), six flexible Timer/Counters with compare modes and P WM, 4 USARTs, a\nbyte oriented 2-wire Serial Interface, a 16-c hannel, 10-bit ADC with optional differential input\nstage with programmable gain, programmable Watchdog Timer with Internal Oscillator, an SPI\nserial port, IEEE\u00ae std. 1149.1 compliant JTAG test interface, also used for accessing the On-\nchip Debug system and programming and six software selectable power saving modes. The Idlemode stops the CPU while allowing the SRAM, Timer/Counters, SPI port, and interrupt system\nto continue functioning. The Power-down mode saves the register contents but freezes the\nOscillator, disabling all other ch ip functions until the next interr upt or Hardware Reset. In Power-\nsave mode, the asynchronous timer continues to run, allowing the user to maintain a timer base\nwhile the rest of the device is sleeping. The ADC Noise Reduction mode stops the CPU and all\nI/O modules except Asynchronous Timer and ADC, to minimize switching noise during ADCconversions. In Standby mode, the Crystal/Resonato r Oscillator is running while the rest of the\ndevice is sleeping. This allows very fast st art-up combined with lo w power consumption. In\nExtended Standby mode, bo th the main Oscillator and the Asynchronous Ti mer continue to run.\nAtmel offers the QTouch\n\u00ae library for embedding capacitive touch buttons, sliders and wheels-\nfunctionality into AVR microcontrollers. The patented charge-transfer signal acquisition\noffersrobust sensing and includes fully debounced reporting of touch keys and includes AdjacentKeySuppression\n\u00ae (AKS\u2122) technology for unambiguous detection of key events. The easy-to-use\nQTouch Suite toolchain allows you to explore, develop and debug your own touch applications.\nThe device is manufactured using Atmel\u2019s high- density nonvolatile memory technology. The On-\nchip ISP Flash allows the prog ram memory to be repr ogrammed in-system th rough an SPI serial\ninterface, by a conventional nonvolatile memory programmer, or by an On-chip Boot program\nrunning on the AVR core. The boot program can use any interface to download the application\nprogram in the applicatio n Flash memory. Software in the Boot  Flash section will continue to run\nwhile the Application Flash section is updated, providing true Read- While-Write operation. By\ncombining an 8-bit RISC CPU with In-System Self-Programmable Flash on a monolithic chip,\nthe Atmel ATmega640/1280/1281/2560/2561 is a powerful microcontroller that provides a highlyflexible and cost effective solution to many embedded control applications.\nThe ATmega640/1280/1281/2560/2561 AVR is supported with a full suite of program and sys-\ntem development tools including: C compilers, macro assemblers, programdebugger/simulators, in-circuit emulators, and evaluation kits.\n\n7\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2.2 Comparison Between ATme ga1281/2561 and AT mega640/1280/2560\nEach device in the ATmega640/1280/1281/2560/2561 family differs only in memory size and\nnumber of pins. Table 2-1  summarizes the different configurations for the six devices.\n2.3 Pin Descriptions\n2.3.1 VCC\nDigital supply voltage.\n2.3.2 GND\nGround.\n2.3.3 Port A (PA7..PA0)\nPort A is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort A output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port A pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port A pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort A also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 78 .\n2.3.4 Port B (PB7..PB0)\nPort B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort B output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port B pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port B pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort B has better driving capabilities than the other ports.\nPort B also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 79 .\n2.3.5 Port C (PC7..PC0)\nPort C is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort C output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port C pi ns that are externally pulled lo w will source current if the pull-upTable 2-1. Configuration Summary\nDevice Flash EEPROM RAMGeneral\nPurpose I/O pins16 bits resolution\nPWM channelsSerial\nUSARTsADC\nChannels\nATmega640 64KB 4KB 8KB 86 12 4 16\nATmega1280 128KB 4KB 8KB 86 12 4 16ATmega1281 128KB 4KB 8KB 54 6 2 8\nATmega2560 256KB 4KB 8KB 86 12 4 16\nATmega2561 256KB 4KB 8KB 54 6 2 8\n\n8\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nresistors are activated. The Port C pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort C also serves the functions of special features of the ATmega640/1280/1281/2560/2561 as\nlisted on page 82 .\n2.3.6 Port D (PD7..PD0)\nPort D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort D output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port D pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port D pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort D also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 83 .\n2.3.7 Port E (PE7..PE0)\nPort E is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort E output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port E pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port E pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort E also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 86 .\n2.3.8 Port F (PF7..PF0)\nPort F serves as analog inputs to the A/D Converter.\nPort F also serves as an 8-bit bi-directional I/O port, if the A/D Converter is not used. Port pins\ncan provide internal pull-up resistors (selected for each bit). The Port F output buffers have sym-\nmetrical drive characteristics with both high sink  and source capa bility. As inputs, Port F pins\nthat are externally pulled low will source current if the pull-up resistors are ac tivated. The Port F\npins are tri-stated when a reset condition becomes active, even if the clock is not running. If the\nJTAG interface is enabled, the pull-up resistors on pins PF7( TDI), PF5(TMS), and PF4(TCK) will\nbe activated even if a reset occurs.\nPort F also serves the functions of the JTAG interface.\n2.3.9 Port G (PG5..PG0)\nPort G is a 6-bit I/O port with internal pull-up resistors (selected for each bit). The Port G output\nbuffers have symmetrical drive characteristic s with both high sink and source capability. As\ninputs, Port G pins that are externally pulled lo w will source current if the pull-up resistors are\nactivated. The Port G pins are tri-stated when a reset condition becomes active, even if the clock\nis not running.\nPort G also serves the functions of  various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 90 .\n2.3.10 Port H (PH7..PH0)\nPort H is a 8-bit bi-directional I/O port with inte rnal pull-up resistors (selected for each bit). The\nPort H output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port H pi ns that are externally pulled lo w will source current if the pull-up\n\n9\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nresistors are activated. The Port H pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort H also serves the functions of various  special features of the ATmega640/1280/2560 as\nlisted on page 92 .\n2.3.11 Port J (PJ7..PJ0)\nPort J is a 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort J output buffers have symmetrical drive characteristics with both high sink and source capa-\nbility. As inputs, Port J pins that are externally pulled low will source current if the pull-up\nresistors are activated. The Port J pins are tr i-stated when a reset condition becomes active,\neven if the clock is not running.\nPort J also serves the functions of various special features of the ATmega640/1280/2560 as\nlisted on page 94 .\n2.3.12 Port K (PK7..PK0)\nPort K serves as analog inputs to the A/D Converter.\nPort K is a 8-bit bi-directional I/O port with inte rnal pull-up resistors (selected for each bit). The\nPort K output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port K pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port K pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort K also serves the functions of vari ous special features of the ATmega640/1280/2560 as\nlisted on page 96 .\n2.3.13 Port L (PL7..PL0)\nPort L is a 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort L output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port L pins  that are externally pulled low will source current  if the pull-up\nresistors are activated. The Port L pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort L also serves the functions of variou s special features of the ATmega640/1280/2560 as\nlisted on page 98 .\n2.3.14 RESET\nReset input. A low level on this pin for longer than the minimum pulse length will generate a\nreset, even if the clock is not runni ng. The minimum pulse length is given in \u201cSystem and Reset\nCharacteristics\u201d on page 372 . Shorter pulses are not guaranteed to generate a reset.\n2.3.15 XTAL1\nInput to the inverting Oscillato r amplifier and input to the in ternal clock operating circuit.\n2.3.16 XTAL2\nOutput from the invert ing Oscillator amplifier.\n\n10\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2.3.17 AVCC\nAVCC is the supply voltage pin for Port F and the A/D Converter. It should be externally con-\nnected to VCC, even if the ADC is not used. If the ADC is used, it should be connected to VCC\nthrough a low-pass filter.\n2.3.18 AREF\nThis is the analog reference pin for the A/D Converter.\n\n11\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n3. Resources\nA comprehensive set of development tools a nd application notes, and datasheets are available\nfor download on http://www.atmel.com/avr .\n4. About Code Examples\nThis documentation contains simple code examples  that briefly show how to use various parts of\nthe device. Be aware that not all C compiler vendors include bit definitions in the header files\nand interrupt handling in C is compiler dependent. Please confirm with the C compiler documen-\ntation for more details.\nThese code examples assume that the part specific header file is included before compilation.\nFor I/O registers located in extended I/O map, \"I N\", \"OUT\", \"SBIS\", \"SBIC\", \"CBI\", and \"SBI\"\ninstructions must be replaced with instructio ns that allow access to extended I/O. Typically\n\"LDS\" and \"STS\" combined with \"SBRS\", \"SBRC\", \"SBR\", and \"CBR\".\n5. Data Retention\nReliability Qualification results show that the pr ojected data retention failure rate is much less\nthan 1 ppm over 20 years at 85\u00b0C or 100 years at 25\u00b0C.\n6. Capacitive touch sensing\nThe Atmel\u00aeQTouch\u00ae Library provides a simple to use so lution to realize touch sensitive inter-\nfaces on most Atmel AVR\u00ae microcontrollers. The QTouch Library includes support for the\nQTouch and QMatrix\u00ae acquisition methods.\nTouch sensing can be added to any application by linking the appropriate Atmel QTouch Library\nfor the AVR Microcontroller. This is done by using a simple set of APIs to define the touch chan-\nnels and sensors, and then calling the touch sens ing API\u2019s to retrieve the channel information\nand determine the touch sensor states.\nThe QTouch Library is FREE and downloadable from the Atmel website at the following location:\nwww.atmel.com/qtouchlibrary . For implementation details and other information, refer to the\nAtmel QTouch Library User Guide  - also available for download from the Atmel website.\n\n12\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7. AVR CPU Core\n7.1 Introduction\nThis section discusses the AVR core architecture in general. The main function of the CPU core\nis to ensure correct program execution. The CPU must therefore be able to access memories,perform calculations, control peripherals, and handle interrupts.\n7.2 Architectural Overview\nFigure 7-1. Block Diagram of the AVR Architecture \nIn order to maximize performance and parallelism, the AVR uses a Harvard architecture \u2013 with\nseparate memories and buses for program and data. Instructions in the program memory are\nexecuted with a sing le level pipelining. While one instruction is being executed, the next instruc-\ntion is pre-fetched from the program memory. This concept enables instructions to be executed\nin every clock cycle. The program memory is In-System Reprogrammable Flash memory.Flash\nProgram\nMemory\nInstruction\nReg i st er\nInstruction\nDecoderProgram\nCoun t er\nC ontrol Lines32 x 8\nGeneral\nPurp ose\nReg i st er s\nALUSt at u s\nand Control\nI/O LinesEEPROMData Bus 8-bit \nData\nSRAMDirect Addressing Indirect AddressingInterrupt\nUnit\nSPI\nUnit\nWatchdog\nTimer\nAnalog\nComparator\nI/O Module 2I/O Module1\nI/O Module n\n\n13\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe fast-access Register File contains 32 \u00d7 8-bit general purpose working registers with a single\nclock cycle access time. This allows single-cycle Ar ithmetic Logic Unit (ALU ) operation. In a typ-\nical ALU operation, two operands are output from the Register File, the operation is executed,\nand the result is stored back in the Register File \u2013 in one clock cycle.\nSix of the 32 registers can be used as three 16-b it indirect address register pointers for Data\nSpace addressing \u2013 enabling efficient address calculations. One of the these address pointers\ncan also be used as an address pointer for look up tables in Flash program memory. Theseadded function registers are the 16-bit X-, Y-, and Z-register, described later in this section.\nThe ALU supports arithmetic and logic operations between registers or between a constant and\na register. Single register operations can also be executed in the ALU. After an arithmetic opera-tion, the Status Register is updated to reflect information about the result of the operation.\nProgram flow is provided by conditional and uncon ditional jump and call instructions, able to\ndirectly address the whole address space. Most AVR instructions have a single 16-bit word for-\nmat. Every program memory address contains a 16-bit or 32-bit instruction.\nProgram Flash memory space is divided in two sections, the Boot Program section and the\nApplication Program section. Both sections have dedicated Lock bits for write and read/write\nprotection. The SPM instruction that writes into the Application Flash memory section must\nreside in the Boot Program section.\nDuring interrupts and subroutine calls, the return address Program Counter (PC) is stored on the\nStack. The Stack is effectively allocated in the general data SRAM, and consequently the Stack\nsize is only limited by the to tal SRAM size and the usage of the SRAM. All user programs must\ninitialize the SP in the Reset routine (before subroutines or interrupts are executed). The Stack\nPointer (SP) is read/write accessible in the I/O space. The data SRAM can easily be accessed\nthrough the five different addressing modes supported in the AVR architecture.\nThe memory spaces in the AVR  architecture are all linear and regular memory maps.\nA flexible interrupt module has its control r egisters in the I/O space with an additional Global\nInterrupt Enable bit in the Status  Register. All interrupts have a separate Interrupt Vector in the\nInterrupt Vector table. The interrupts have priority in accordance with their Interrupt Vector posi-tion. The lower the Interrupt Vector address, the higher the priority.\nThe I/O memory space contains 64 addresses for CPU peripheral functi ons as Control Regis-\nters, SPI, and other I/O functions. The I/O Memory can be accessed directly, or as the Data\nSpace locations following those of the Register File, 0x20 - 0x5F. In addition, theATmega640/1280/1281/2560/2561 has Extended I/O space from 0x60 - 0x1FF in SRAM where\nonly the ST/STS/STD and LD/LDS/LDD instructions can be used.\n7.3 ALU \u2013 Arithm etic Logic Unit\nThe high-performance AVR ALU operates in dire ct connection with all the 32 general purpose\nworking registers. Within a single clock cycle, arithmetic operations between general purpose\nregisters or between a register and an immediate are executed. The ALU operations are divided\ninto three main categories \u2013 arithmetic, logical, and bit-functions. Some implementations of thearchitecture also provide a powerful multiplier supporting both signed/unsigned multiplication\nand fractional format. See the \u201cInstruction Set Summary\u201d on page 416  for a detailed description.\n\n14\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.4 Status Register\nThe Status Register contains information about the result of the most recently executed arithme-\ntic instruction. This information can be used for altering program flow in order to perform\nconditional operations. Note that the Status Register is updated after all ALU operations, asspecified in the \u201cInstruction Set Summary\u201d on page 416 . This will in many cases remove the\nneed for using the dedicated compare instructions, resulting in faster and more compact code.\nThe Status Register is not automatically stored when entering an interrupt routine and restored\nwhen returning from an interrupt. This must be handled by software.\n7.4.1 SREG \u2013 AVR Status Register\nThe AVR Status Register \u2013 SREG \u2013 is defined as:\n\u0081 Bit 7 \u2013 I: Global Interrupt Enable\nThe Global Interrupt Enable bit must be set for th e interrupts to be enabled. The individual inter-\nrupt enable control is then performed in separate control registers. If the Global Interrupt Enable\nRegister is cleared, none of the interrupts are enabled independent of the individual interruptenable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by\nthe RETI instruction to enable subsequent interrupts. The I-bit can also be set and cleared by\nthe application with the SEI and CLI instructions, as described in the \u201cInstruction Set Summary\u201d\non page 416 .\n\u0081 Bit 6 \u2013 T: Bit Copy Storage\nThe Bit Copy instructions BLD (Bit LoaD) and BST (B it STore) use the T-bit as source or desti-\nnation for the operated bit. A bit from a register in  the Register File can be copied into T by the\nBST instruction, and a bit in T can be copied into a bit in a register in the Register File by theBLD instruction.\n\u0081 Bit 5 \u2013 H: Half Carry Flag \nThe Half Carry Flag H indicates a Half Carry in so me arithmetic operations.  Half Carry Is useful\nin BCD arithmetic. See the \u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 4 \u2013 S: Sign Bit, S = N\n \u2295 V\nThe S-bit is always an exclusive or between the Negative Flag N and the Two\u2019s Complement\nOverflow Flag V. See the \u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 3 \u2013 V: Two\u2019s Complement Overflow Flag\nThe Two\u2019s Complement Overflow Flag V suppor ts two\u2019s complement arithmetics. See the\n\u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 2 \u2013 N: Negative Flag\nThe Negative Flag N indicates a negative result in an arithmetic or logic operation. See the\n\u201cInstruction Set Summary\u201d on page 416  for detailed information.B i t 76543210\n0x3F (0x5F) IT H S V N Z C S R E G\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n15\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1 \u2013 Z: Zero Flag\nThe Zero Flag Z indicates a zero result in an arithmetic or logic operation. See the \u201cInstruction\nSet Summary\u201d on page 416  for detailed information.\n\u0081 Bit 0 \u2013 C: Carry Flag\nThe Carry Flag C indicates a carry in an arithmetic or logic operation. See the \u201cInstruction Set\nSummary\u201d on page 416  for detailed information.\n7.5 General Purpose Register File\nThe Register File is optimized for the AVR Enhanc ed RISC instruction set. In order to achieve\nthe required performance and flex ibility, the following in put/output schemes ar e supported by the\nRegister File:\n\u0081 One 8-bit output operand and one 8-bit result input\n\u0081 Two 8-bit output operands and one 8-bit result input\u0081 Two 8-bit output operands and one 16-bit result input\u0081 One 16-bit output operand and one 16-bit result inputFigure 7-2  shows the structure of the 32 general purpose working registers in the CPU.\nFigure 7-2. AVR CPU General Purpose Working Registers\nMost of the instructions operating on the Register File have direct access to all registers, and\nmost of them are single cycle instructions.\nAs shown in Figure 7-2 , each register is also assigned a data memory address, mapping them\ndirectly into the first 32 locations of the user  Data Space. Although not being physically imple-\nmented as SRAM locations, this memory organization provides great flexibility in access of theregisters, as the X-, Y- and Z-pointer registers can be set to index any register in the file.\n7.5.1 The X-register, Y-register, and Z-register\nThe registers R26..R31 have some added functions to their general purpose usage. These reg-\nisters are 16-bit address pointers for indirect addressing of the data space. The three indirect\naddress registers X, Y, and Z are defined as described in Figure 7-3 on page 16 .7 0 Addr.\nR0 0x00\nR1 0x01R2 0x02\n\u2026\nR13 0x0D\nGeneral R14 0x0E\nPurpose R15 0x0F\nWorking R16 0x10\nRegisters R17 0x11\n\u2026\nR26 0x1A X-register Low Byte\nR27 0x1B X-register High Byte\nR28 0x1C Y-register Low ByteR29 0x1D Y-register High ByteR30 0x1E Z-register Low ByteR31 0x1F Z-register High Byte\n\n16\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 7-3. The X-, Y -, and Z-registers\nIn the different addressing modes these address registers have functions as fixed displacement,\nautomatic increment, and automatic decrement (see the \u201cInstruction Set Summary\u201d on page 416\nfor details).\n7.6 Stack Pointer\nThe Stack is mainly used for storing temporary data, for storing local variables and for storing\nreturn addresses after interrupts and subroutine calls. The Stack Pointer Register always points\nto the top of the Stack. Note that the Stack is implemented as growing from higher memory loca-tions to lower memory locations. This implies that a Stack PUSH command decreases the Stack\nPointer.\nThe Stack Pointer points to the data SRAM Stack area where the Subroutine and Interrupt\nStacks are located. This Stack space in the data SRAM must be defined by the program before\nany subroutine calls are executed or interrupts are enabled. The Stack Pointer must be set to\npoint above 0x0200. The initial value of the stack pointer is the last address of the internalSRAM. The Stack Pointer is decremented by one when data is pushed onto the Stack with the\nPUSH instruction, and it is decremented by two for ATmega640/1280/1281 and three for\nATmega2560/2561 when the return address is pushed onto the Stack with subroutine call orinterrupt. The Stack Pointer is incremented by one when data is popped from the Stack with the\nPOP instruction, and it is incremented by two for ATmega640/1280/1281 and three for\nATmega2560/2561 when data is popped from the Stack with return from subroutine RET orreturn from interrupt RETI.\nThe AVR Stack Pointer is implemented as two 8- bit registers in the I/O space. The number of\nbits actually used is implementation dependent. Note that the data space in some implementa-\ntions of the AVR architecture is so small that only SPL is needed. In this case, the SPH Register\nwill not be present.15 XH XL 0\nX-register 70 7 0\nR27 (0x1B) R26 (0x1A)\n15 YH YL 0\nY-register 70 7 0\nR29 (0x1D) R28 (0x1C)\n15 ZH ZL 0\nZ-register 70 7 0\nR31 (0x1F) R30 (0x1E)\nB i t 1 51 41 31 21 11 0 9 80x3E (0x5E) SP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 SPH\n0x3D (0x5D) SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 SPL\n76543210\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 1 0 0 0 0 1\n11111111\n\n17\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.6.1 RAMPZ \u2013 Extended Z-pointer Register for ELPM/SPM\nFor ELPM/SPM instructions, the Z-pointer is a concatenation of RAMPZ, ZH, and ZL, as shown\nin Figure 7-4.  Note that LPM is not affected by the RAMPZ setting.\nFigure 7-4. The Z-pointer used by ELPM and SPM\nThe actual number of bits is  implementation depen dent. Unused bits in an implementation will\nalways read as zero. For compatibility with future devices, be su re to write these bits to zero.\n7.6.2 EIND \u2013 Extended Indirect Register\nFor EICALL/EIJMP instructions, the Indirect-pointer  to the subroutine/routine is a concatenation\nof EIND, ZH, and ZL, as shown in Figure 7-5.  Note that ICALL and IJMP are not affected by the\nEIND setting.\nFigure 7-5. The Indirect-pointer used by EICALL and EIJMP\nThe actual number of bits is  implementation depen dent. Unused bits in an implementation will\nalways read as zero. For compatibility with future devices, be su re to write these bits to zero.\n7.7 Instruction Execution Timing\nThis section describes the general access timi ng concepts for instruction execution. The AVR\nCPU is driven by the CPU clock clkCPU, directly generated from the selected clock source for the\nchip. No internal clo ck division is used.\nFigure 7-6 on page 18  shows the parallel instruction fetches and instruction executions enabled\nby the Harvard architecture and the fast-access R egister File concept. This is the basic pipelin-\ning concept to obtain up to 1 MIPS per MHz with the corresponding unique results for functions\nper cost, functions per clocks, and functions per power-unit.B i t 765432 1 0\n0x3B (0x5B) RAMPZ7 RAMPZ6 RAMPZ5 RAMPZ4 RAMPZ3 RAMPZ2 RAMPZ1 RAMPZ0 RAMPZ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nBit (\nIndividually)70 7 0 7 0\nRAMPZ ZH ZL\nBit (Z-pointer) 23 16 15 8 7 0\nB i t 765432 1 0\n0x3C (0x5C) EIND7 EIND6 EIND5 EIND4 EI ND3 EIND2 EIND1 EIND0 EIND\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nBit (Individual-\nly)70 70 70\nEIND ZH ZL\nBit (Indirect-\npointer)23 16 15 8 7 0\n\n18\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 7-6. The Parallel Instruction Fetches and Instruction Executions\nFigure 7-7  shows the internal timing concept for the Register File. In a single clock cycle an ALU\noperation using two register operands  is executed, and the result is stored back to the destina-\ntion register.\nFigure 7-7. Single Cycle ALU Operation\n7.8 Reset and Inte rrupt Handling\nThe AVR provides several different interrupt sources. These interrupts and the separate Reset\nVector each have a separate program vector in the program memory space. All interrupts are\nassigned individual enable bits which must be written logic one together with the Global Interrupt\nEnable bit in the Status Register in orde r to enable the interrupt. Depending on the Program\nCounter value, interrupts may be automatically disabled when Boot Lock bits BLB02 or BLB12\nare programmed. This feature improves software security. See the section \u201cMemory Program-\nming\u201d on page 335  for details.\nThe lowest addresses in the program memory space are by default defined as the Reset and\nInterrupt Vectors. The complete list of vectors is shown in \u201cInterrupts\u201d on page 105 . The list also\ndetermines the priority levels of the different interrupts. The lower the address the higher is the\npriority level. RESET has the highest priority, and  next is INT0 \u2013 the External Interrupt Request\n0. The Interrupt Vectors can be moved to the start of the Boot Flash section by setting the IVSEL\nbit in the MCU Control Register (MCUCR). Refer to \u201cInterrupts\u201d on page 105  for more informa-\ntion. The Reset Vector can also be moved to the start of the Boot Flash section by programmingthe BOOTRST Fuse, see \u201cMemory Programming\u201d on page 335 .\nWhen an interrupt occurs, the Global Interrupt Enable I-bit is cleared and all interrupts are dis-\nabled. The user software can write logic one to the I-bit to enable nested interrupts. All enabledinterrupts can then interrupt the current interrupt routine. The I-bit is automatically set when a\nReturn from Interrupt instruction \u2013 RETI \u2013 is executed.clk\n1st Instruction Fetch\n1st Instruction Execute\n2nd Instruction Fetch\n2nd Instruction Execute\n3rd Instruction Fetch\n3rd Instruction Execute\n4th Instruction FetchT1 T2 T3 T4\nCPU\nTotal Execution Time\nRegister Operands Fetch\nALU Operation Execute\nResult Write BackT1 T2 T3 T4\nclkCPU\n\n19\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThere are basically two types of interrupts. The fi rst type is triggered by an event that sets the\nInterrupt Flag. For these interrupts, the Program Counter is vectored to the actual Interrupt Vec-\ntor in order to execute the interrupt handling routine, and hardware clears the corresponding\nInterrupt Flag. Interrupt Flags can also be cleared by writing a logic one to the flag bit position(s)to be cleared. If an interrupt condition occurs while the corresponding interrupt enable bit is\ncleared, the Interrupt Fl ag will be set and remember ed until the interrupt is  enabled, or the flag is\ncleared by software. Similarly, if one or more interrupt conditions occur while the Global InterruptEnable bit is clea red, the corres ponding Interrupt Fl ag(s) will be set and remembered until the\nGlobal Interrupt Enable bit is set, and will then be exec uted by order of priority.\nThe second type of interrupts will trigger as long as the interrupt condition is present. These\ninterrupts do not necessarily have Interrupt Flags. If the interrupt condition disappears before the\ninterrupt is enabled, the in terrupt will not be triggered.\nWhen the AVR exits from an interrupt, it will alwa ys return to the main program and execute one\nmore instruction before any pending interrupt is served.\nNote that the Status Register is not automatica lly stored when entering an interrupt routine, nor\nrestored when returning from an interrupt routine. This must be handled by software.\nWhen using the CLI instruction to disable interrupts, the interrup ts will be immediately disabled.\nNo interrupt will be executed af ter the CLI instruction,  even if it occurs simultaneously with the\nCLI instruction. The following example shows how this can be used to avoid interrupts during thetimed EEPROM write sequence.\nWhen using the SEI instruction to enable interrupt s, the instruction following SEI will be exe-\ncuted before any pending interrupts, as shown in this example.Assembly Code Example\ninr16, SREG ; store SREG value\ncli ; disable interrupts during timed sequence\nsbiEECR, EEMPE ; start EEPROM write\nsbiEECR, EEPE\noutSREG, r16 ; restore SREG value (I-bit)\nC Code Example\nchar cSREG;\ncSREG = SREG; /* store SREG value */\n/* disable interrupts during timed sequence */\n__disable_interrupt(); \nEECR |= (1<<EEMPE); /* start EEPROM write */\nEECR |= (1<<EEPE);\nSREG = cSREG; /* restore SREG value (I-bit) */\n\n20\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.8.1 Interrupt Response Time\nThe interrupt execution response for all the enab led AVR interrupts is five clock cycles minimum.\nAfter five clock cycles the program vector address for the actual interrupt handling routine is exe-\ncuted. During these five clock cycle period, the Program Counter is pushed onto the Stack. Thevector is normally a jump to the interrupt routine, and this jump takes three clock cycles. If an\ninterrupt occurs during execution of a multi-cycle instruction, this instruction is completed before\nthe interrupt is served. If an interrupt occurs w hen the MCU is in sleep mode, the interrupt exe-\ncution response time is increased by five cloc k cycles. This increase comes in addition to the\nstart-up time from the selected sleep mode.\nA return from an interrupt handling routine takes fi ve clock cycles. During these five clock cycles,\nthe Program Counter (three bytes) is popped back from the Stack, the Stack Pointer is incre-\nmented by three, and the I-bit in SREG is set.Assembly Code Example\nsei; set Global Interrupt Enable\nsleep; enter sleep, waiting for interrupt\n; note: will enter sleep before any pending \n; interrupt(s)\nC Code Example\n__enable_interrupt(); /* set Global Interrupt Enable */\n__sleep(); /* enter sleep, waiting for interrupt */\n/* note: will enter sleep before any pending interrupt(s) */\n\n21\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8. AVR Memories\nThis section describes the different memories in the ATmega640/1280/1281/2560/2561. The\nAVR architecture has two main memory spaces, the Data Memory and the Program Memory\nspace. In addition, the ATme ga640/1280/1281/2560 /2561 features an EEPROM Memory for\ndata storage. All three memory spaces are linear and regular.\n8.1 In-System Reprogrammable Flash Program Memory\nThe ATmega640/1280/1281/2560/2561 contains 64K /128K/256K bytes On-chip In-System\nReprogrammable Flash memory for program storage, see Figure 8-1 . Since all AVR instructions\nare 16 bit or 32 bit wide, the Flash is organiz ed as 32K/64K/128K \u00d7 16. For software security,\nthe Flash Program memory space is divided into two sections, Boot Program section and Appli-\ncation Program section.\nThe Flash memory has an endurance of at least 10,000 write/erase cycles. The\nATmega640/1280/1281/2560/2561 Program Counter (PC) is 15/16/17 bits wide, thus addressing\nthe 32K/64K/128K program memory locations. The operation of Boot Program section and asso-ciated Boot Lock bits for software pr otection are described in detail in \u201cBoot Loader Support \u2013\nRead- While-Write Self-Programming\u201d on page 317 . \u201cMemory Programming\u201d on page 335  con-\ntains a detailed description on Flash data seri al downloading using the SPI pins or the JTAG\ninterface.\nConstant tables can be allocated within the entire program memory address space (see the LPM\n\u2013 Load Program Memory instruction description and ELPM - Extended Load Program Memoryinstruction description).\nTiming diagrams for instruction fetch and execution are presented in \u201cInstruction Execution Tim-\ning\u201d on page 17 .\n8.2 SRAM Data Memory\nFigure 8-2 on page 23  shows how the ATmega640/1280/1281/2560/2561 SRAM Memory is\norganized.\nThe ATmega640/1280/1281/2560/2561 is a complex microcontroller with more peripheral units\nthan can be supported within the 64 location reserved in the Opcode for the IN and OUT instruc-\ntions. For the Extended I/O space from $060 - $1FF in SRAM, only the ST/STS/STD and\nLD/LDS/LDD instructions can be used.\nThe first 4,608/8,704 Data Memory locations address both the Register File, the I/O Memory,\nExtended I/O Memory, and the internal data SR AM. The first 32 locations address the Register\nfile, the next 64 location the standard I/O Memory, then 416 locations of Extended I/O memoryand the next 8,192 locations address the internal data SRAM.Figure 8-1. Program Flash Memory Map\nAddress (HEX)\n0\nApplication Flash Section\nBoot Flash Section\n0x7FFF/0xFFFF/0x1FFFF\n\n22\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nAn optional external data SRAM can be used with the ATmega640/1280/1281/2560/2561. This\nSRAM will occupy an area in the remaining addr ess locations in the 64K address space. This\narea starts at the address following the internal SRAM. The Register file, I/O, Extended I/O and\nInternal SRAM occupies the lowest 4,608/8, 704 bytes, so when using 64Kbytes (65,536 bytes)\nof External Memory, 60,478/56,832 Bytes of  External Memory are available. See \u201cExternal\nMemory Interface\u201d on page 28  for details on how to take advantage of the external memory map.\nWhen the addresses accessing the SRAM memory space exceeds the internal data memory\nlocations, the external data SRAM is accessed using the same instructions as for the internal\ndata memory access. When the internal data memories are accessed, the read and write strobe\npins (PG0 and PG1) are inacti ve during the whole access cycl e. External SRAM operation is\nenabled by setting the SRE bit in the XMCRA Register.\nAccessing external SRAM takes one additional clock cycle per byte compared to access of the\ninternal SRAM. This means that the commands LD, ST, LDS, STS, LDD, STD, PUSH, and POPtake one additional clock cycle. If the Stack is placed in external SRAM, interrupts, subroutine\ncalls and returns take three clock cycles extra because the three-byte program counter is\npushed and popped, and external memory access does not take advantage of the internal pipe-\nline memory access. When external SRAM interface is used with wait-state, one-byte external\naccess takes two, three, or four additional cl ock cycles for one, two, and three wait-states\nrespectively. Interrupts, subroutine calls and returns will need  five, seven, or nine clock cycles\nmore than specified in the instruction set manual  for one, two, and three wait-states.\nThe five different addressing modes for the data memory cover: Direct, Indirect with Displace-\nment, Indirect, Indirect with Pre-decrement, and Indirect with Post-increment. In the Register file,registers R26 to R31 feature the indirect addressing pointer registers.\nThe direct addressing reaches the entire data space.\nThe Indirect with Displacement mode reaches 63 address locations from the base address given\nby the Y-register or Z-register.\nWhen using register indirect addressing modes with automatic pre-decrement and post-incre-\nment, the address registers X, Y, and Z are decremented or incremented.\nThe 32 general purpose working registers, 64 I/O registers, and the 4,196/8,192 bytes of internal\ndata SRAM in the ATmega640/1280/1281/2560/2561 are all accessible through all these\naddressing modes. The Register File is described in \u201cGeneral Purpose Register File\u201d on page\n15.\n\n23\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.2.1 Data Memory Access Times\nThis section describes the general access timi ng concepts for internal memory access. The\ninternal data SRAM access is performed in two clkCPU cycles as described in Figure 8-3 .\nFigure 8-3. On-chip Data SRAM Access Cycles\n8.3 EEPROM Data Memory\nThe ATmega640/1280/1281/2560/2561 contains 4Kbytes of data EEPROM memory. It is orga-\nnized as a separate data spac e, in which single bytes can be read and written. The EEPROM\nhas an endurance of at least 100,000 write/erase cycles. The access between the EEPROM and\nthe CPU is described in the following, specif ying the EEPROM Address Registers, the EEPROM\nData Register, and the EEPROM Control Register.\nFor a detailed description of SPI, JTAG and Parallel data downloading to the EEPROM, see\n\u201cSerial Downloading\u201d on page 349 , \u201cProgramming via the JTAG Interface\u201d on page 354 , and\n\u201cProgramming the EEPROM\u201d on page 343  respectively.Figure 8-2. Data Memory Map\nAddress (HEX)\n0 - 1F 32 Registers\n20 - 5F 64 I/O Registers\n60 - 1FF 416 External I/O Registers\n200Internal SRAM\n(8192 \u00d7 8)21FF\n2200External SRAM\n(0 - 64K \u00d7 8)\nFFFF\nclk\nWR\nRDData\nDataAddress Address validT1 T2 T3\nCompute Address\nReadWriteCPU\nMemory Access Instruction Next Instruction\n\n24\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.3.1 EEPROM Read/Write Access\nThe EEPROM Access Registers are accessible in the I/O space, see \u201cRegister Description\u201d on\npage 35 .\nThe write access time for the EEPROM is given in Table 8-1 . A self-timing function, however,\nlets the user software detect when the next byte can be written. If the user code contains instruc-\ntions that write the EEPROM, some precautions must be taken. In heavily filtered powersupplies, V\nCC is likely to rise or fall slowly on po wer-up/down. This causes the device for some\nperiod of time to run at a voltage lower than specified as minimum for the clock frequency used.\nSee \u201cPreventing EEPROM Co rruption\u201d on page 26.  for details on how to avoid problems in these\nsituations.\nIn order to prevent unintentional EEPROM writes, a specific write procedure must be followed.\nSee the description of the EEPROM Cont rol Register for details on this; \u201cRegister Description\u201d\non page 35 .\nWhen the EEPROM is read, the CPU is halted for four  clock cycles before the next in struction is\nexecuted. When the EEPROM is written, the CPU is halted for two clock cycles before the next\ninstruction is executed.\nThe calibrated Oscillator is used to time the EEPROM accesses. Table 8-1  lists the typical pro-\ngramming time for EEPROM access from the CPU.\nThe following code examples show one assembly and one C function for writing to the\nEEPROM. The examples assume that interrupts are controlled (for example by disabling inter-rupts globally) so that no inte rrupts will occur during execution of these functi ons. The examples\nalso assume that no Flash Boot Loader is present in the software. If such code is present, the\nEEPROM write function must also wait fo r any ongoing SPM co mmand to finish.Table 8-1. EEPROM Programming Time\nSymbol Number of Calibrated RC Osc illator Cycles Typ Programming Time\nEEPROM write \n(from CPU)26,368 3.3ms\n\n25\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nEEPROM_write:\n; Wait for completion of previous write\nsbic EECR,EEPE\nrjmp EEPROM_write    \n; Set up address (r18:r17) in address register\nout EEARH, r18\nout EEARL, r17\n; Write data (r16) to Data Register\nout EEDR,r16\n; Write logical one to EEMPE\nsbi EECR,EEMPE\n; Start eeprom write by setting EEPEsbi EECR,EEPE\nret\nC Code Example(1)\nvoid EEPROM_write( unsigned int  uiAddress, unsigned char  ucData)\n{\n/* Wait for completion of previous write  */\nwhile(EECR & (1<<EEPE))\n;\n/* Set up address and Data Registers */\nEEAR = uiAddress;EEDR = ucData;\n/* Write logical one to EEMPE */\nEECR |= (1<<EEMPE);/* Start eeprom write by setting EEPE */\nEECR |= (1<<EEPE);\n}\n\n26\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe next code examples show assembly and C functions for reading the EEPROM. The exam-\nples assume that interrupts are controlled so that no interrupts will occur during execution of\nthese functions.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n8.3.2 Preventing EEPROM Corruption\nDuring periods of low VCC, the EEPROM data can be corrupted because the supply voltage is\ntoo low for the CPU and the EEPROM to operate properly. These issues are the same as for\nboard level systems using EEPR OM, and the same design so lutions should be applied.\nAn EEPROM data corruption can be caused by two situations when the voltage is too low. First,\na regular write sequence to the EEPROM requires a minimum voltage to operate correctly. Sec-\nondly, the CPU itself can execute instructions incorrectly, if the supp ly voltage is too low.\nEEPROM data corruption can ea sily be avoided by followin g this design recommendation:\nKeep the AVR RESET active (low) during periods of insufficient power su pply voltage. This can\nbe done by enabling the internal Brown-out Detector (BOD). If the detection level of the internal\nBOD does not match the needed detection level, an external low VCC reset Protection circuit can\nbe used. If a reset occurs while a write operation is in progress , the write operation will be com-\npleted provided that the power supply voltage is sufficient.Assembly Code Example(1)\nEEPROM_read:\n; Wait for completion of previous write\nsbic EECR,EEPE\nrjcmp EEPROM_read\n; Set up address (r18:r17) in address registerout EEARH, r18\nout EEARL, r17\n; Start eeprom read by writing EEREsbi EECR,EERE\n; Read data from Data Register\nin r16,EEDR\nret\nC Code Example(1)\nunsigned char  EEPROM_read( unsigned int  uiAddress)\n{\n/* Wait for completion of previous write */\nwhile(EECR & (1<<EEPE))\n;\n/* Set up address register */\nEEAR = uiAddress;\n/* Start eeprom read by writing EERE */\nEECR |= (1<<EERE);\n/* Return data from Data Register */\nreturn EEDR;\n}\n\n27\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.4 I/O Memory\nThe I/O space definition of the ATmega640/1280/1281/2560/2561 is shown in \u201cRegister Sum-\nmary\u201d on page 411 .\nAll ATmega640/1280/1281/2560/2561 I/Os and peripherals are placed in the I/O space. All I/O\nlocations may be accessed by the LD/LDS/LDD and ST/STS/STD instructions, transferring data\nbetween the 32 general purpose working registers and the I/O space. I/O Registers within the\naddress range 0x00 - 0x1F are directly bit-acce ssible using the SBI an d CBI instructions. In\nthese registers, the value of single bits can be checked by using the SBIS and SBIC instructions.\nRefer to the \u201cInstruction Set Summary\u201d on page 416  for more details. When using the I/O spe-\ncific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O\nRegisters as data space using LD and ST instructions, 0x20 must be added to these addresses.\nThe ATmega640/1280/1281/2560/2561 is a complex microcontroller with more peripheral units\nthan can be supported within the 64 location reserved in Opcode for the IN and OUT instruc-tions. For the Extended I/O space from 0x60 - 0x1FF in SRAM, only the ST/STS/STD and\nLD/LDS/LDD instructions can be used.\nFor compatibility with future devices, reserved  bits should be written to zero if accessed.\nReserved I/O memory addresses should never be written.\nSome of the Status Flags are cleared by writing a logical one to them. Note that, unlike most\nother AVRs, the CBI and SBI instructions will only  operate on the specified bit, and can therefore\nbe used on registers containing such Status Flags. The CBI and SBI instructions work with reg-\nisters 0x00 to 0x1F only.\nThe I/O and peripherals control registers are explained in later sections.\n8.4.1 General Purpose I/O Registers\nThe ATmega640/1280/1281/2560/2561 contains three General Purpose I/O Registers. These\nregisters can be used for storing any information, and they are particularly useful for storing\nglobal variables and Status Flags. General Pu rpose I/O Registers within the address range 0x00\n- 0x1F are directly bit-accessible using the SBI, CBI, SBIS, and SBIC instructions. See \u201cRegister\nDescription\u201d on page 35 .\n\n28\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9. External Memory Interface\nWith all the features the External Memory Interf ace provides, it is well suited to operate as an\ninterface to memory devices such as External  SRAM and Flash, and peripherals such as LCD-\ndisplay, A/D, and D/A. The main features are:\n\u0081Four different wait-s tate settings (includi ng no wait-state)\n\u0081Independent wait-state setting fo r different External Memory sect ors (configurable sector size)\n\u0081The number of bits dedicated to  address high byte is selectable\n\u0081Bus keepers on data lines to minimi ze current consumption (optional)\n9.1 Overview\nWhen the eXternal MEMory (XMEM) is enabled , address space outside the internal SRAM\nbecomes available using the dedicated External Memory pins (see Figure 1-3 on page 4 , Table\n13-3 on page 78 , Table 13-9 on page 82 , and Table 13-21 on page 90 ). The memory configura-\ntion is shown in Figure 9-1 .\nFigure 9-1. External Memory with Sector Select\nMemory Confi guration A\n0x0000\n0x21FF\nExtern al Memory\n(0 - 60K x 8)\n0xFFFFIntern al memory\nSRL[2..0]\nSRW11\nSRW10SRW01\nSRW00Lower sector\nUpper sector0x2200\n\n29\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9.1.1 Using the External Memory Interface\nThe interface consists of:\n\u0081 AD7:0: Multiplexed low-order address bus and data bus\n\u0081 A15:8: High-order address bus (configurable number of bits)\n\u0081 ALE: Address latch enable\n\u0081R D : Read strobe\n\u0081WR: Write strobe\nThe control bits for the External Memory Interface are located in two registers, the External\nMemory Control Register A \u2013 XMCRA, and the External Memory Control Register B \u2013 XMCRB.\nWhen the XMEM interface is enabled, the XMEM in terface will override th e setting in the data\ndirection registers that corresponds to the ports dedicated to the XMEM interface. For details\nabout the port override, see the alternate functions in section \u201cI/O-Ports\u201d on page 70 . The XMEM\ninterface will auto-detect wh ether an access is internal or extern al. If the access is external, the\nXMEM interface will output  address, data, and the control si gnals on the ports according to Fig-\nure 9-3 on page 31  (this figure shows the wave  forms without wait-states). When ALE goes from\nhigh-to-low, there is a valid address on AD7:0. ALE is low during a data transfer. When the\nXMEM interface is enabled, also an internal access will cause ac tivity on address, data and ALE\nports, but the RD  and WR strobes will not toggle during internal access. When the External\nMemory Interface is disabled, the normal pin and data direction settings are used. Note thatwhen the XMEM interface is disabled, the address space above the internal SRAM boundary is\nnot mapped into the internal SRAM. Figure 9-2 on page 30  illustrates how to connect an external\nSRAM to the AVR using an octal latch (typically \u201c74 \u00d7 573\u201d or equivalent) which is transparent\nwhen G is high.\n9.1.2 Address Latch Requirements\nDue to the high-speed operation of the XRAM interface, the address latch must be selected with\ncare for system frequencies above 8MHz @ 4V and 4MHz @ 2.7V. When operating at condi-\ntions above these frequencies, the typical old style 74HC series latch becomes inadequate. TheExternal Memory Interface is designed in compliance to the 74AHC series latch. However, most\nlatches can be used as long they comply with the main timing parameters. The main parameters\nfor the address latch are:\n\u0081 D to Q propagation delay (t\nPD)\n\u0081 Data setup time before G low (tSU)\n\u0081 Data (address) hold time after G low (TH)\nThe External Memory Interface is designed to guaranty minimum address hold time after G is\nasserted low of th = 5ns. Refer to tLAXX_LD /tLLAXX_ST  in \u201cExternal Data Memory Timing\u201d  Tables 31-\n11 through Tables 31-18  on pages 379 - 382. The D-to-Q propagation delay (tPD) must be taken\ninto consideration when calculating the access time requirement of the external component. Thedata setup time before G low (t\nSU) must not exceed address valid to ALE low (tAVLLC ) minus PCB\nwiring delay (dependent on the capacitive load).\n\n30\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-2. External SRAM Connected to the AVR\n9.1.3 Pull-up and Bus-keeper\nThe pull-ups on the AD7:0 ports may be activated if the corresponding Port register is written to\none. To reduce power consumption in sleep mode, it is recommended to disable the pull-ups by\nwriting the Port register to zero before entering sleep.\nThe XMEM interface also provides a bus-keeper on the AD7:0 lines. The bus-keeper can be dis-\nabled and enabled in software as described in \u201cXMCRB \u2013 External Memo ry Control Register B\u201d\non page 38 . When enabled, the bus-keeper will keep th e previous value on the AD7:0 bus while\nthese lines are tri-stated by the XMEM interface.\n9.1.4 Timing\nExternal Memory devices have different timing requirements. To meet these requirements, the\nXMEM interface provides four different wait-states as shown in Table 9-3 on page 38 . It is impor-\ntant to consider the timing specification of the External Memory device before selecting the wait-\nstate. The most important parameters are the access time for the external memory compared tothe set-up requirement. The access time for the External Memory is defined to be the time from\nreceiving the chip selec t/address until the data of this address actually is driven on the bus. The\naccess time cannot exceed the time from the ALE pulse must be asserted low until data is stableduring a read sequence (see t\nLLRL+ tRLRH - tDVRH in Tables 31-11  through Tables 31-18  on pages\n379 - 382). The different wait-states are set up in software. As an additional feature, it is possible\nto divide the external memory s pace in two sectors with indivi dual wait-state settings. This\nmakes it possible to connect two different memory devices with different timing requirements to\nthe same XMEM interface. For XMEM interface timing details, please refer to Table 31-11 on\npage 379  to Table 31-18 on page 382  and Figure 31-9 on page 382  to Figure 31-12 on page 384\nin the \u201cExternal Data Memory Timing\u201d on page 379 .\nNote that the XMEM interface is asynchronous and that the waveforms in the following figures\nare related to the internal system clock. T he skew between the internal and external clock\n(XTAL1) is not guarantied (varies between devices temperature, and supply voltage). Conse-\nquently, the XMEM interface is not suited for synchronous operation.D[7:0]\nA[7:0]\nA[15:8]\nRD\nWRSRAM\nDQ\nGAD7:0\nALE\nA15:8\nRD\nWRAVR\n\n31\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-3. External Data Memory Cycles without Wait-state (SR Wn1=0 and SR Wn0=0)(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector). The ALE pulse in period T4  is only present if the next instruction \naccesses the RAM (internal or external).\nFigure 9-4. External Data Memory Cycles with SR Wn1 = 0 and SR Wn0 = 1(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector).\nThe ALE pulse in period T5 is only present if the next instruction accesses the RAM (internal \nor external).ALET1 T2 T3\nWrite\nReadWRT4\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)\nXXXXX XXXXXXXX\nALET1 T2 T3\nWrite\nReadWRT5\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4\n\n32\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-5. External Data Memory Cycles with SR Wn1 = 1 and SR Wn0 = 0(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or\nSRW00 (lower sector).\nThe ALE pulse in period T6 is only present if the next instruction accesses the RAM (internal\nor external).\nFigure 9-6. External Data Memory Cycles with SR Wn1 = 1 and SR Wn0 = 1(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector).\nThe ALE pulse in period T7 is only present if the next instruction accesses the RAM (internal \nor external).\n9.1.5 Using all Locations of External Memory Smaller than 64Kbytes\nSince the external memory is mapped after the internal memory as shown in Figure 9-1 on page\n28, the external memory is not addressed when addressing the first 8,704 bytes of data space. It\nmay appear that the first 8,704 bytes of the external memory are inaccessible (external memory\naddresses 0x0000 to 0x21FF). However, when connecting an external memory smaller than64Kbytes, for example 32Kbytes, these locations are easily accessed simply by addressing from\naddress 0x8000 to 0xA1FF. Since the External Me mory Address bit A15 is not connected to the\nexternal memory, addresses 0x 8000 to 0xA1FF will ap pear as addresses 0x 0000 to 0x21FF for\nthe external memory. Addressing above address 0xA1FF is not recommended, since this will\naddress an external memory location that is al ready accessed by another (lower) address. ToALET1 T2 T3\nWrite\nReadWRT6\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4 T5\nALET1 T2 T3\nWrite\nReadWRT7\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4 T5 T6\n\n33\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe Application software, the external 32Kbytes memory w ill appear as one linear 32Kbytes\naddress space from 0x2200 to 0xA1FF. This is illustrated in Figure 9-7 .\nFigure 9-7. Address Map with 32Kbytes External Memory\n9.1.6 Using all 64Kbytes Locations of External Memory\nSince the External Memory is mapped af ter the Internal Memory as shown in Figure 9-1 on page\n28, only 56Kbytes of External Memory is avail able by default (address  space 0x0000 to 0x21FF\nis reserved for internal memory). However, it is possible to take advantage of the entire External\nMemory by masking the higher address bits to zero. This can be done by using the XMMn bitsand control by software the most significant bits of the address. By setting Port C to output 0x00,and releasing the most si gnificant bits for normal Port Pin operation, the Memory Interface will\naddress 0x0000 - 0x2FFF. See the following code examples.\nCare must be exercised using this option as most of the memory is masked away.0x0000\n0x21FF \n0x2200 \n0x7FFF \n0x8000 \n0x90FF \n0x9100 0x0000\n0x7FFF Internal MemoryAVR Memory Map External 32K SRAM\nExternal \nMemory\n\n34\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\n; OFFSET is defined to 0x4000 to ensure\n; external memory access; Configure Port C (address high byte) to\n; output 0x00 when the pins are released\n; for normal Port Pin operation\nldir16, 0xFF\noutDDRC, r16\nldir16, 0x00\noutPORTC, r16\n; release PC7:6ldir16, (1<<XMM1)\nstsXMCRB, r16\n; write 0xAA to address 0x0001 of external; memory\nldir16, 0xaa\nsts0x0001+OFFSET, r16\n; re-enable PC7:6 for external memory\nldir16, (0<<XMM1)\nstsXMCRB, r16\n; store 0x55 to address (OFFSET + 1) of\n; external memory\nldir16, 0x55\nsts0x0001+OFFSET, r16\nC Code Example(1)\n#define OFFSET 0x4000\nvoid XRAM_example( void)\n{\nunsigned char *p = (unsigned char *) (OFFSET + 1);\nDDRC = 0xFF;\nPORTC = 0x00;\nXMCRB = (1<<XMM1);\n*p = 0xaa;\nXMCRB = 0x00;*p = 0x55;\n}\n\n35\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9.2 Register Description\n9.2.1 EEPROM registers\n9.2.1.1 EEARH and EEARL \u2013 The EEPROM Address Register\n\u0081 Bits 15:12 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 11:0 \u2013 EEAR8:0: EEPROM Address\nThe EEPROM Address Registers \u2013 EEARH and EEARL specify the EEPROM address in the\n4Kbytes EEPROM space. The EEPROM dat a bytes are addressed linearly between 0 and\n4096. The initial value of EEAR  is undefined. A proper valu e must be written before the\nEEPROM may be accessed.\n9.2.1.2 EEDR \u2013 The EEPROM Data Register\n\u0081 Bits 7:0 \u2013 EEDR7:0: EEPROM Data\nFor the EEPROM write operation, the EEDR Register contains the data to be written to the\nEEPROM in the address given by the EEAR Regi ster. For the EEPROM read operation, the\nEEDR contains the data read out from the EEPROM at the add ress given by EEAR.\n9.2.1.3 EECR \u2013 The EEPROM Control Register\n\u0081 Bits 7:6 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 5, 4 \u2013 EEPM1 and EEPM0: EEPROM Programming Mode Bits\nThe EEPROM Programming mode bit setting define s which programming acti on that will be trig-\ngered when writing EEPE. It is possible to program  data in one atomic operation (erase the old\nvalue and program the new value) or to split the Erase and Write operations in two different\noperations. The Programming times for the different modes are shown in Table 9-1 on page 36 .\nWhile EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be\nreset to 0b00 unless the EEPROM is busy programming.B i t 1 51 41 31 2 1 1 1 0 9 8\n0x22 (0x42) \u2013\u2013\u2013\u2013 E E A R 1 1 E E A R 1 0 E E A R 9 E E A R 8 E E A R H\n0x21 (0x41) EEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 EEARL\n7654 3 2 10\nRead/Wr i t e RRRR R / W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e0000X XXX\nXXXX X X XX\nB i t 765432100x20 (0x40) MSB LSB EEDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1F (0x3F) \u2013 \u2013 EEPM1 EEPM0 EERIE EEMPE EEPE EERE EECR\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 X X 0 0 X 0\n\n36\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 EERIE: EEPROM Ready Interrupt Enable\nWriting EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing\nEERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant inter-\nrupt when EEPE is cleared.\n\u0081 Bit 2 \u2013 EEMPE: EEPROM Master Programming Enable\nThe EEMPE bit determines whether setting EEPE to one causes the EEPROM to be written.\nWhen EEMPE is set, setting EEPE wit hin four clock cycles will writ e data to the EEPROM at the\nselected address If EEMPE is zero , setting EEPE will have no effect. When EEMPE has been\nwritten to one by software, ha rdware clears the bit to zero after four clock cycles. See the\ndescription of the EEPE bit fo r an EEPROM write procedure.\n\u0081 Bit 1 \u2013 EEPE: EEPROM Programming Enable\nThe EEPROM Write Enable Signal EEPE is the write strobe to the EEPROM. When address\nand data are correctly set up, the EEPE bit must be written to one to write the value into the\nEEPROM. The EEMPE bit must be written to one be fore a logical one is written to EEPE, other-\nwise no EEPROM write takes pl ace. The following pr ocedure should be followed when writing\nthe EEPROM (the order of steps  3 and 4 is not essential):\n1.Wait until EEPE becomes zero.\n2.Wait until SPMEN in SPMCSR becomes zero.\n3.Write new EEPROM address to EEAR (optional).\n4.Write new EEPROM data to EEDR (optional).\n5.Write a logical one to the EEMPE bit wh ile writing a zero to EEPE in EECR.\n6.Within four clock cycles after setting EEMPE, write a logical one to EEPE.\nThe EEPROM can not be programmed during a CPU write to the Flash memory. The software\nmust check that the Flash programming is co mpleted before initiating a new EEPROM write.\nStep 2 is only relevant if the software contai ns a Boot Loader allowing the CPU to program the\nFlash. If the Flash is never being updated by the CPU, step 2 can be omitted. See \u201cMemory Pro-\ngramming\u201d on page 335  for details about Boot programming.\nCaution:  An interrupt between step 5 and step 6 will  make the write cycle fail, since the\nEEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is\ninterrupting another EEPROM acce ss, the EEAR or EEDR Register  will be modified, causing the\ninterrupted EEPROM access to fail.  It is recommended to have the Global Interrupt Flag cleared\nduring all the steps to avoid these problems.\nWhen the write access time has elapsed, the EE PE bit is cleared by hardware. The user soft-\nware can poll this bit and wait for a zero before writing the next byte. When EEPE has been set,\nthe CPU is halted for two cycles before the next instruction is executed.Table 9-1. EEPROM Mode Bits\nEEPM1 EEPM0Programming \nTime Operation\n0 0 3.4ms Erase and Write in one operation (Atomic Operation)\n0 1 1.8ms Erase only\n1 0 1.8ms Write only\n1 1 \u2013 Reserved for future use\n\n37\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 EERE: EEPROM Read Enable\nThe EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct\naddress is set up in the EEAR Register, the EERE bit must be written to a logic one to trigger theEEPROM read. The EEPROM read access takes one  instruction, and th e requested data is\navailable immediately. When the EEPROM is read, the CPU is halted for four cycles before the\nnext instruction is executed.\nThe user should poll the EEPE bit before starting the read operation. If a write operation is in\nprogress, it is neither possi ble to read the EEPROM, nor to change the EEAR Register.\n9.3 General Purpose registers\n9.3.1 GPIOR2 \u2013 General Purpose I/O Register 2\n9.3.2 GPIOR1 \u2013 General Purpose I/O Register 1\n9.3.3 GPIOR0 \u2013 General Purpose I/O Register 0\n9.4 External Memory registers\n9.4.1 XMCRA \u2013 External Memory Control Register A\n\u0081 Bit 7 \u2013 SRE: External SRAM/XMEM Enable\nWriting SRE to one enables the External Memory  Interface.The pin functions AD7:0, A15:8,\nALE, WR, and RD  are activated as the alternate pin functions. The SRE bit overrides any pin\ndirection settings in the respective data direction registers. Writing SRE to zero, disables the\nExternal Memory Interface and the normal pin and data direction settings are used.\n\u0081 Bit 6:4 \u2013 SRL2:0: Wait-state Sector Limit\nIt is possible to configure different wait-states for different External Memory addresses. The\nexternal memory address space can be divided in two sectors that have separate wait-state bits.The SRL2, SRL1, and SRL0 bits select the split of the sectors, see Table 9-2 on page 38  andB i t 76543210\n0x2B (0x4B) MSB LSB GPIOR2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x2A (0x4A) MSB LSB GPIOR1\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1E (0x3E) MSB LSB GPIOR0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210\u201c(0x74)\u201d SRE SRL2 SRL1 SRL0 SRW11 SRW10 SRW01 SRW00 XMCRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n38\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-1 on page 28 . By default, the SRL2, SRL1, and SRL0 bits are set to zero and the entire\nexternal memory address space is treated as one sector. When the entire SRAM address space\nis configured as one sector, the wait-states are configured by the SR W11 and SR W10 bits.\n\u0081 Bit 3:2 \u2013 SRW11, SRW10: Wait-state Select Bits for Upper Sector\nThe SR W11 and SR W10 bits control the number of wait-states for the upper sector of the exter-\nnal memory address space, see Table 9-3 .\n\u0081 Bit 1:0 \u2013 SRW01, SRW00: Wait-state Select Bits for Lower Sector\nThe SR W01 and SR W00 bits control the number of wait-states for the lower sector of the exter-\nnal memory address space, see Table 9-3 .\nNote: 1. n = 0 or 1 (lower/upper sector).\nFor further details of the timing and wait-states of the External Memory Interface, see Figures \n9-3 through Figures 9-6  for how the setting of the SR W bits affects the timing.\n9.4.2 XMCRB \u2013 External Memory Control Register BTable 9-2. Sector limits with different settings of SRL2:0\nSRL2 SRL1 SRL0 Sector Limits\n00xLower sector = N/A\nUpper sector = 0x2200 - 0xFFFF\n010Lower sector = 0x2200 - 0x3FFF\nUpper sector = 0x4000 - 0xFFFF\n011Lower sector = 0x2200 - 0x5FFF\nUpper sector = 0x6000 - 0xFFFF\n100Lower sector = 0x2200 - 0x7FFF\nUpper sector = 0x8000 - 0xFFFF\n101Lower sector = 0x2200 - 0x9FFF\nUpper sector = 0xA000 - 0xFFFF\n110Lower sector = 0x2200 - 0xBFFF\nUpper sector = 0xC000 - 0xFFFF\n111Lower sector = 0x2200 - 0xDFFF\nUpper sector = 0xE000 - 0xFFFF\nTable 9-3. Wait States(1)\nSRWn1 SRWn0 Wait States\n0 0 No wait-states\n01 Wait one cycle during read/write strobe\n10 Wait two cycles during read/write strobe\n11Wait two cycles during read/write and wait one cycle before driving out new \naddress\nB i t 765 4 3 210\n(0x75) XMBK \u2013 \u2013 \u2013 \u2013 XMM2 XMM1 XMM0 XMCRB\nRead/Write R/ W RR R R R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n39\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7\u2013 XMBK: External Memory Bus-keeper Enable\nWriting XMBK to one enables the bus keeper on the AD7:0 lines. When the bus keeper is\nenabled, AD7:0 will keep the last driven value on the lines even if the XMEM  interface has tri-\nstated the lines. Writing XMBK to zero disables the bus keeper. XMBK is not qualified with SRE,\nso even if the XMEM in terface is disabled, the bus keepers are still activated as long as XMBK is\none.\n\u0081 Bit 6:3 \u2013 Res: Reserved Bits\nThese bits are reserved and will always read as zero. When writing to this address location,\nwrite these bits to zero for compatibility with future devices.\n\u0081 Bit 2:0 \u2013 XMM2, XMM1, XMM0: External Memory High Mask\nWhen the External Memory is enabled, all Port C pi ns are default used for the high address byte.\nIf the full 60Kbytes address space is not required to access the External Memory, some, or all,Port C pins can be released for normal  Port Pin function as described in Table 9-4 . As described\nin \u201cUsing all 64Kbytes Locations of External Memory\u201d on page 33 , it is possible to use the XMMn\nbits to access all 64Kbytes locations of the External Memory.\nTable 9-4. Port C Pins Released as Normal Port Pi ns when the External Memory is Enabled\nXMM2 XMM1 XMM0 # Bits for External Memory Address Released Port Pins\n0 0 0 8 (Full 56Kbytes space) None001 7 P C 7\n010 6 P C 7  -  P C 6\n011 5 P C 7  -  P C 5100 4 P C 7  -  P C 4\n101 3 P C 7  -  P C 3\n110 2 P C 7  -  P C 21 1 1 No Address high bits Full Port C\n\n40\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10. System Clock and Clock Options\nThis section describes the clock options for the AVR microcontroller.\n10.1 Overview\nFigure 10-1  presents the principal clock systems in the AVR and their distribution. All of the\nclocks need not be active at a given time. In order to reduce power consumption, the clocks tomodules not being used can be halted by using different sleep modes, as described in \u201cPower\nManagement and Sleep Modes\u201d on page 52 . The clock systems are detailed below.\nFigure 10-1. Clock Distribution\n10.2 Clock Systems and their Distribution\n10.2.1 CPU Clock \u2013 clkCPU\nThe CPU clock is routed to parts of the system concerned with operation of the AVR core.\nExamples of such modules are the General Pur pose Register File, the Status Register and the\ndata memory holding the Stack Pointer. Halting the CPU clock inhibits the core from performinggeneral operations and calculations.General I/O\nModulesAsynchronous\nTimer/CounterCPU Core RAM\nclkI/O\nclkASYAVR Clock\nControl UnitclkCPUFlash and\nEEPROM\nclkFLASH\nSource clockWatchdog  Timer\nWatchdog\nOscillatorReset  Logic\nClock\nMultiplexerWatchdog clock\nCalibrated RC\nOscillatorTimer/Counter\nOscillatorCrystal\nOscillatorLow-frequency\nCrystal OscillatorExternal ClockADC\nclkADC\nSystem Clock\nPrescaler\n\n41\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.2.2 I/O Clock \u2013 clkI/O\nThe I/O clock is used by the majority of the I/O modules, like Timer/Counters, SPI, and USART.\nThe I/O clock is also used by the External Inte rrupt module, but note that some external inter-\nrupts are detected by asynchronous logic, allowing such interrupts to be detected even if the I/O\nclock is halted. Also note that start condition detection in the USI module is carried out asynchro-\nnously when clkI/O is halted, T WI address recognition in all sleep modes.\n10.2.3 Flash Clock \u2013 clkFLASH\nThe Flash clock controls operation of the Flash in terface. The Flash clock is usually active simul-\ntaneously with the CPU clock.\n10.2.4 Asynchronous Timer Clock \u2013 clkASY\nThe Asynchronous Timer clock al lows the Asynchronous Timer/C ounter to be clocked directly\nfrom an external clock or an external 32kHz clock crystal. The dedicated clock domain allows\nusing this Timer/Counter as a real-time counter even when the device is in sleep mode.\n10.2.5 ADC Clock \u2013 clkADC\nThe ADC is provided with a dedicated clock domain. This allows halting the CPU and I/O clocks\nin order to reduce noise generated by digital circuitry. This gives more accurate ADC conversion\nresults.\n10.3 Clock Sources\nThe device has the following clock source options, selectable by Flash Fuse bits as shown\nbelow. The clock from the selected source is input to the AVR clock generator, and routed to the\nappropriate modules.\nNote: 1. For all fuses \u201c1\u201d means unprogrammed while \u201c0\u201d means programmed.Table 10-1. Device Clocking Options Select(1)\nDevice Clocking Option  CKSEL3:0\nLow Power Crystal Oscillator 1111 - 1000\nFull Swing Crystal Oscillator 0111 - 0110\nLow Frequency Crystal Oscillator 0101 - 0100\nInternal 128kHz RC Oscillator 0011\nCalibrated Internal RC Oscillator 0010\nExternal Clock 0000\nReserved 0001\n\n42\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.3.1 Default Clock Source\nThe device is shipped with inte rnal RC oscillator at 8.0MHz a nd with the fuse CKDIV8 pro-\ngrammed, resulting in 1.0MHz system clock. Th e startup time is set to maximum and time-out\nperiod enabled. (CKSEL = \"0010\", SU T = \"10\", CKDIV8 = \"0\"). Th e default setti ng ensures that\nall users can make their desired clock source se tting using any available programming interface.\n10.3.2 Clock Start-up Sequence\nAny clock source needs a sufficient VCC to start oscillating and a minimum number of oscillating\ncycles before it can be considered stable.\nTo ensure sufficient VCC, the device issues an internal reset with a time-out delay (tTOUT) after\nthe device reset is released by all other reset sources. \u201cOn-chip Debug System\u201d on page 55\ndescribes the start conditions for the internal reset. The delay (tTOUT) is timed from the Watchdog\nOscillator and the number of cycles in the delay is set by the SUTx and CKSELx fuse bits. The\nselectable delays are shown in Table 10-2 . The frequency of the Watchdog Oscillator is voltage\ndependent as shown in \u201cTypical Characteristics\u201d on page 385 .\nMain purpose of the delay is to keep the AVR in reset until it is supplied with minimum VCC. The\ndelay will not monitor t he actual voltage and it w ill be required to select a delay longer than the\nVcc rise time. If this is not possible, an intern al or external Brown-Out Detection circuit should be\nused. A BOD circuit will ensure sufficient VCC before it releases the reset, and the time-out delay\ncan be disabled. Disabling the time-out delay wi thout utilizing a Brown-Out Detection circuit is\nnot recommended.\nThe oscillator is required to oscillate for a minimu m number of cycles befo re the clock is consid-\nered stable. An inte rnal ripple counter monito rs the oscillator output cl ock, and keep s the internal\nreset active for a given number of clock cycl es. The reset is then released and the device will\nstart to execute. The recommend ed oscillator start-up time is  dependent on the clock type, and\nvaries from 6 cycles for an externally applied clock to 32K cycles for a low frequency crystal.\nThe start-up sequence for the clock includes both the time-out delay and the start-up time when\nthe device starts up from reset. When starting up from Power-save or Power-down mode, VCC is\nassumed to be at a sufficient level and only the start-up time is included.\n10.4 Low Power Crystal Oscillator\nPins XTAL1 and XTAL2 are input and output, respec tively, of an invertin g amplifier which can be\nconfigured for use as an On-c hip Oscillator, as shown in Figure 10-2 . Either a quartz crystal or a\nceramic resonator may be used.\nThis Crystal Oscillator is a low power oscillator, with reduced voltage swing on the XTAL2 out-\nput. It gives the lowest power consumption, but is not capable of driving other clock inputs, andmay be more susceptible to noise in noisy environments. In these cases, refer to the \u201cFull Swing\nCrystal Oscillator\u201d on page 44 .Table 10-2. Number of Watchdog Oscillator Cycles\nTyp Time-out (VCC = 5.0V) Typ Time-out (VCC = 3.0V) Number of Cycles\n0ms 0ms 0\n4.1ms 4.3ms 512\n65ms 69ms 8K (8,192)\n\n43\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nC1 and C2 should always be equal for both crystals and resonators. The optimal value of the\ncapacitors depends on the crystal or resonator in use, the amount of stray capacitance, and the\nelectromagnetic noise of the environment. Some initial guidelines for choosing capacitors for\nuse with crystals are given in Table 10-3 . For ceramic resonators, the capacitor values given by\nthe manufacturer should be used.\nFigure 10-2. Crystal Oscillator Connections\nThe Low Power Oscillator c an operate in three diff erent modes, each optimi zed for a specific fre-\nquency range. The operating mode is select ed by the fuses CKSEL3:1 as shown in Table 10-3 .\nNotes: 1. This is the recommended CKSEL settings for the different frequency ranges.\n2. This option should not be used with crystals, only with ceramic resonators.\n3. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8. It must be ensured \nthat the resulting divided clock meets th e frequency specification of the device.\n4. Maximum frequency when using ceramic oscillator is 10MHz.\nThe CKSEL0 Fuse together with the SUT1:0 Fuses select the start-up times as shown in Table\n10-4.Table 10-3. Low Power Crystal Osc illator Operating Modes(3)\n Frequency Range (MHz) CKSEL3:1(1)Recommended Range for Capacitors C1 and C2 (pF)\n0.4 - 0.9 100(2)\u2013\n0.9 - 3.0 101 12 - 22\n3.0 - 8.0 110 12 - 22\n8.0 - 16.0(4)111 12 - 22\nTable 10-4. Start-up Times for the Low Power Cr ystal Oscillator Clock Selection\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nCeramic resonator, fast \nrising power258 CK 14CK + 4.1ms(1)00 0\nCeramic resonator, slowly \nrising power258 CK 14CK + 65ms(1)00 1\nCeramic resonator, BOD \nenabled1K CK 14CK(2)01 0XTAL2\nXTAL1\nGNDC2\nC1\n\n44\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. These options should only be used when not operating close to the maximum frequency of the \ndevice, and only if frequency stability at start- up is not important for the application. These \noptions are not suitable for crystals.\n2. These options are intended for use with cerami c resonators and will ensure frequency stability \nat start-up. They can also be used with crystal s when not operating close to the maximum fre-\nquency of the device, and if frequency stability at  start-up is not important for the application.\n10.5 Full Swing Crystal Oscillator\nPins XTAL1 and XTAL2 are input and output, respec tively, of an invertin g amplifier which can be\nconfigured for use as an On-chip Oscillator, as shown in Figure 10-2 on page 43 . Either a quartz\ncrystal or a ceramic resonator may be used.\nThis Crystal Oscillator is a full s wing oscillator, wit h rail-to-rail swing on th e XTAL2 output. This is\nuseful for driving other clock inputs and in noisy environments. The current consumption ishigher than the \u201cLow Power Crystal Os cillator\u201d on page 42 . Note that the Full Swing Crystal\nOscillator will only operate for V\nCC = 2.7 - 5.5 volts.\nC1 and C2 should always be equal for both crystals and resonators. The optimal value of the\ncapacitors depends on the crystal or resonator in use, the amount of stray capacitance, and theelectromagnetic noise of the environment. Some initial guidelines for choosing capacitors for\nuse with crystals are given in Table 10-6 on page 45 . For ceramic resonato rs, the capacitor val-\nues given by the manufacturer should be used.\nThe operating mode is selected by the fuses CKSEL3:1 as shown in Table 10-5 .\nNote: 1. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8. It must be ensured \nthat the resulting divided clock meets th e frequency specification of the device.Ceramic resonator, fast \nrising power1K CK 14CK + 4.1ms(2)01 1\nCeramic resonator, slowly \nrising power1K CK 14CK + 65ms(2)10 0\nCrystal Oscillator, BOD \nenabled16K CK 14CK101\nCrystal Oscillator, fast \nrising power16K CK 14CK + 4.1ms110\nCrystal Oscillator, slowly \nrising power16K CK 14CK + 65ms111Table 10-4. Start-up Times for the Low Power Crysta l Oscillator Clock Se lection (Continued)\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nTable 10-5. Full Swing Crystal Osc illator operating modes(1)\nFrequency Range (MHz) CKSEL3:1 Recommended Range for Capacitors C1 and C2 (pF)\n0.4 - 16 011 12 - 22\n\n45\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. These options should only be used when not operating close to the maximum frequency of the \ndevice, and only if frequency stability at start- up is not important for the application. These \noptions are not suitable for crystals.\n2. These options are intended for use with cerami c resonators and will ensure frequency stability \nat start-up. They can also be used with crystal s when not operating close to the maximum fre-\nquency of the device, and if frequency stability at  start-up is not important for the application.\n10.6 Low Frequency Crystal Oscillator\nThe device can utilize a 32.768kHz watch crystal as clock source by a dedicated Low Frequency\nCrystal Oscillator.  The crystal should be connected as shown in Figure 10-2 on page 43 . When\nthis Oscillator is selected, start-up times are determined by  the SUT Fuses and CKSEL0 as\nshown in Table 10-8 on page 46 .\nThe Low-Frequency Crystal Oscillator provi des an internal load capacitance, see Table 10-7  at\neach XTAL/TOSC pin.Table 10-6. Start-up Times for the Full Swing Crystal Oscillator Clock Selection\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nCeramic resonator, fast \nrising power258 CK 14CK + 4.1ms(1)00 0\nCeramic resonator, slowly \nrising power258 CK 14CK + 65ms(1)00 1\nCeramic resonator, BOD \nenabled1K CK 14CK(2)01 0\nCeramic resonator, fast \nrising power1K CK 14CK + 4.1ms(2)01 1\nCeramic resonator, slowly \nrising power1K CK 14CK + 65ms(2)10 0\nCrystal Oscillator, BOD \nenabled16K CK 14CK 1 01\nCrystal Oscillator, fast \nrising power16K CK 14CK + 4.1ms 1 10\nCrystal Oscillator, slowly \nrising power16K CK 14CK + 65ms 1 11\nTable 10-7. Capacitance for Low Frequency Oscillator\nDevice 32kHz oscillator Cap (Xtal1/Tosc1) Cap (Xtal2/Tosc2)\nATmega640/1280/1281/2560/2561 System Osc. 18 pF 8pF\nTimer Osc. 6 pF 6pF\n\n46\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe capacitance (Ce + Ci) needed at each XTAL/TOSC pin can be calculated by using:\nwhere:\nCe - is optional external capacitors as described in Figure 10-2 on page 43 .\nCi - is is the pin capacitance in Table 10-7 on page 45 .\nCL - is the load capacitance for a 32.768kHz crystal specified by the crystal vendor.C\nS - is the total stray capacitance for one XTAL/TOSC pin.\nCrystals specifying load capacitance (CL)  higher than the ones given in the Table 10-7 on page\n45, require external capacitors applied as described in Figure 10-2 on page 43 .\nFigure 10-3. Crystal Oscillator Connections\nTo find suitable load capacitance for a 32.768kHz crysal, please consult the crystal datasheet.\nWhen this oscillator is selected, start-up ti mes are determined by the SUT Fuses and CKSEL0\nas shown in Table 10-8 .\nNote: 1. These options should only be used if frequen cy stability at start-up is not important for the \napplication.\n10.7 Calibrated Internal RC Oscillator\nBy default, the Internal RC Osc illator provides an a pproximate 8MHz clock. Though voltage and\ntemperature dependent, this clock can be very accurately calibrated by the user. See Table 31-1\non page 371  and \u201cInternal Oscillator Sp eed\u201d on page 404  for more details. The device is shipped\nwith the CKDIV8 Fuse programmed. See \u201cSystem Clock Presca ler\u201d on page 49  for more details.Table 10-8. Start-up Times for the Lo w Frequency Crystal Oscillator Clock Selection\nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nBOD enabled 1K CK 14CK(1)00 0\nFast rising power 1K CK 14CK + 4.1ms(1)00 1\nSlowly rising power 1K CK 14CK + 65ms(1)01 0\nReserved 0 11\nBOD enabled 32K CK 14CK 1 00\nFast rising power 32K CK 14CK + 4.1ms 1 01\nSlowly rising power 32K CK 14CK + 65ms 1 10\nReserved 1 11Ce Ci+ 2CL\u22c5 Cs\u2013 =\n\n47\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThis clock may be selected as  the system clock by programming the CKSEL Fuses as shown in\nTable 10-9 . If selected, it will operate with no external  components. During re set, hardware loads\nthe pre-programmed calibration value into the OSCCAL Register and thereby automatically  cal-\nibrates the RC Oscillator. The accuracy of this  calibration is shown as Factory calibration in\nTable 31-1 on page 371 .\nBy changing the OSCCAL register from S W, see \u201cOSCCAL \u2013 Oscillator Ca libration Register\u201d on\npage 50 , it is possible to get a higher calibration accuracy than by using the factory calibration.\nThe accuracy of this calibration is  shown as User calibration in Table 31-1 on page 371 .\nWhen this Oscillator is used as the chip clock, the Watchdog Oscillator will still be used for the\nWatchdog Timer and for the Reset Time-out. For more information on the pre-programmed cali-\nbration value, see the section \u201cCalibration Byte\u201d on page 338 .\nNotes: 1. The device is shipped with this option selected.\n2. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8.\nWhen this Oscillator is selected,  start-up times are determined by the SUT Fuses as shown in\nTable 10-10 .\nNote: 1. The device is shipped with this option selected.\n10.8 128 kHz Internal Oscillator\nThe 128kHz internal Oscillator is a low power Oscillator providing a clock of 128kHz. The fre-\nquency is nominal at 3V and 25 \u00b0C. This clock may be select as the system clock by\nprogramming the C KSEL Fuses to \u201c11\u201d as shown in Table 10-11 .\nNote: 1. Note that the 128kHz oscillator is a very low power clock source, and is not designed for high \naccuracy.Table 10-9. Internal Calibrated RC O scillator Operating Modes(1)(2)\nFrequency Range (MHz)  CKSEL3:0\n7.3 - 8.1 0010\nTable 10-10. Start-up times for the internal calib rated RC Oscillator clock selection\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset (VCC = 5.0V) SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4.1ms 01\nSlowly rising power 6CK 14CK + 65ms(1)10\nReserved 11\nTable 10-11. 128kHz Internal Osc illator Operating Modes(1)\nNominal Frequency  CKSEL3:0\n128kHz 0011\n\n48\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen this clock source is selected, start-up ti mes are determined by the SUT Fuses as shown in\nTable 10-12 .\n10.9 External Clock\nTo drive the device from an external clock source, XTAL1 should be driven as shown in Figure\n10-4. To run the device on an external clock, the CKSEL Fuses must be programmed to \u201c0000\u201d.\nFigure 10-4. External Clock Drive Configuration\nWhen this clock source is selected, start-up ti mes are determined by the SUT Fuses as shown in\nTable 10-15 on page 51 .\nWhen applying an external clock, it is required to avoid sudden changes in the applied clock fre-\nquency to ensure stable operation of the MCU. A variation in frequency of more than 2% fromone clock cycle to the next can lead to unpredict able behavior. If changes of more than 2% is\nrequired, ensure that the MCU is kept in Reset during the changes.Table 10-12. Start-up Times for the 128k Hz Internal Oscillator\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4ms 01\nSlowly rising power 6CK 14CK + 64ms 10\nReserved 11\nTable 10-13. Crystal Oscillator Clock Frequency\nNominal Frequency  CKSEL3:0\n0 - 16MHz 0000\nTable 10-14. Start-up Times for the External Clock Selection\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset (VCC = 5.0V) SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4.1ms 01\nSlowly rising power 6CK 14CK + 65ms 10\nReserved 11NC\nEXTERNAL\nCLOCK\nSIGNALXTAL2\nXTAL1\nGND\n\n49\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that the System Clock Prescaler can be used to implement run-time changes of the internal\nclock frequency while still ensuring stable operation. Refer to \u201cSystem Clock Prescaler\u201d  for\ndetails.\n10.10 Clock Output Buffer\nThe device can output the system clock on t he CLKO pin. To enable the output, the CKOUT\nFuse has to be programmed. This mode is suitable when the chip clock is used to drive other cir-\ncuits on the system. The clock also will be output during reset, and the normal operation of I/O\npin will be overridden when the fu se is programmed. An y clock source, includi ng the internal RC\nOscillator, can be selected when the clock is out put on CLKO. If the System Clock Prescaler is\nused, it is the divided system clock that is output.\n10.11 Timer/Counter Oscillator\nThe device can operate its Timer/Counter2 from an  external 32.768kHz watch crystal or a exter-\nnal clock source. See Figure 10-2 on page 43  for crystal connection.\nApplying an external clock source to TOSC1 r equires EXCLK in the ASSR Register written to\nlogic one. See \u201cAsynchronous Operation of Timer/Counter2\u201d on page 184  for further description\non selecting external clock as input instead of a 32kHz crystal.\n10.12 System Clock Prescaler\nThe ATmega640/1280/1281/2560/2561 has a system clock prescaler, and the system clock canbe divided by setting the \u201cCLKPR \u2013 Clock Prescale Register\u201d on page 50 . This feature can be\nused to decrease the system clock frequency and the power consumption when the requirement\nfor processing power is low. This  can be used with all clock sour ce options, and it will affect the\nclock frequency of the CPU and all synchronous peripherals. clk\nI/O, clkADC, clkCPU, and clkFLASH\nare divided by a factor as shown in Table 10-15 on page 51 .\nWhen switching between prescaler settings, the System Clock Prescaler ensures that no\nglitches occurs in the clock system. It also ensures that no intermediate frequency is higher thanneither the clock frequency corresponding to the previous setting, nor the clock frequency corre-\nsponding to the new setting.\nThe ripple counter that implements the prescaler runs at the frequency of the undivided clock,\nwhich may be faster than the CPU's clock frequency.  Hence, it is not possible to determine the\nstate of the prescaler - even if it were readable, and the exact time it takes to switch from one\nclock division to the other cann ot be exactly predicted. From th e time the CLKPS values are writ-\nten, it takes between T1 + T2 and T1 + 2 \u00d7 T2 before the new clock frequency is active. In thisinterval, 2 active clock edges are produced. Here, T1 is the previous clock period, and T2 is the\nperiod corresponding to the new prescaler setting.\nTo avoid unintentional changes of clock frequency, a special write procedure must be followed\nto change the CLKPS bits:\nWrite the Clock Prescaler Change Enable (CLKPCE) bit to one and  all other bits in CLKPR to\nzero.\nWithin four cycles, write th e desired value to CLKPS while  writing a zero to CLKPCE.\nInterrupts must be disabled when changing prescaler setting to make sure the write procedure is\nnot interrupted.\n\n50\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.13 Register Description\n10.13.1 OSCCAL \u2013 Oscillato r Calibration Register\n\u0081 Bits 7:0 \u2013 CAL7:0: Oscillator Calibration Value\nThe Oscillator Calibration Register is used to trim the Calibrated Internal RC Oscillator to\nremove process variations from the oscillator frequency. A pre-programmed calibration value is\nautomatically written to this register during chip reset, giving the Factory calibrated frequency as\nspecified in Table 31-1 on page 371 . The application software can write this register to change\nthe oscillator frequency. The os cillator can be calibrated to frequencies as specified in Table 31-\n1 on page 371 . Calibration outside that range is not guaranteed.\nNote that this o scillator is used to time EEPROM and Flash write accesses , and these write\ntimes will be affected accordingly. If the EEPROM or Flash are writ ten, do not calibrate to more\nthan 8.8 MHz. Other wise, the EEPROM or Flash write may fail.\nThe CAL7 bit determines the range of operation for the oscillator. Setting this bit to 0 gives the\nlowest frequency range, setting this bit to 1 gives the highest frequency range. The two fre-\nquency ranges are overlapping, in other words a setting of OSCCAL = 0x7F gives a higher\nfrequency than OSCCAL = 0x80.\nThe CAL6..0 bits are used to tune the frequency within the selected range. A setting of 0x00\ngives the lowest frequency in that range, and a setting of 0x7F gives the highest frequency in the\nrange.\n10.13.2 CLKPR \u2013 Clock Prescale Register\n\u0081 Bit 7 \u2013 CLKPCE: Clock Prescaler Change Enable\nThe CLKPCE bit must be written to logic one to enab le change of the CLKPS bits. The CLKPCE\nbit is only updated when the other bits in CL KPR are simultaneously wr itten to zero. CLKPCE is\ncleared by hardware four cycles af ter it is written or when CLKPS bits are written. Rewriting the\nCLKPCE bit within this time-out period does neither extend the time-out period, nor clear the\nCLKPCE bit.\n\u0081 Bits 3:0 \u2013 CLKPS3:0: Clock Prescaler Select Bits 3 - 0\nThese bits define the division factor between the selected clock source and the internal system\nclock. These bits can be written run-time to vary the clock frequency to suit the application\nrequirements. As the divider divides the master clock input to the MCU, the speed of all synchro-\nnous peripherals is reduced when a division fact or is used. The division factors are given in\nTable 10-15 on page 51 .\nThe CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is unprogrammed,\nthe CLKPS bits will be reset to \u201c0000\u201d. If CKDIV8 is programmed, CLKPS bits are reset to\u201c0011\u201d, giving a division factor of 8 at start up. This feature should be used if the selected clockB i t 76543210\n(0x66) CAL7 CAL6 CAL5 CAL4 CAL3 CAL2 CAL1 CAL0 OSCCAL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value Device Spec ific Calibration Value\nB i t 76543210\n(0x61) CLKPCE \u2013 \u2013 \u2013 CLKPS3 CLKPS2 CLKPS1 CLKPS0 CLKPR\nRead/Write R/ W RRR R / W R/W R/W R/W\nInitial Value 0 0 0 0 See Bit Description\n\n51\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nsource has a higher frequency than the maximum frequency of the device at the present operat-\ning conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8\nFuse setting. The Application software must ensure  that a sufficient division factor is chosen if\nthe selected clock source has a higher frequency than the maximum frequency of the device atthe present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.\nTable 10-15. Clock Prescaler Select\nCLKPS3 CLKPS2 CLKPS1 CLKPS0 Clock Division Factor\n0000 1\n0001 2\n0010 40011 8\n0100 1 6\n0101 3 20110 6 4\n0111 1 2 8\n1000 2 5 61001 R e s e r v e d\n1010 R e s e r v e d\n1011 R e s e r v e d1100 R e s e r v e d\n1101 R e s e r v e d\n1110 R e s e r v e d1111 R e s e r v e d\n\n52\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n11. Power Management and Sleep Modes\nSleep modes enable the application to shut down unused modules in the MCU, thereby saving\npower. The AVR provides various sleep modes allowing the user to tailor the power consump-\ntion to the application\u2019s requirements.\n11.1 Sleep Modes\nFigure 10-1 on page 40  presents the different clock systems in the\nATmega640/1280/1281/2560/2561, and their distribution. The figure is helpful in selecting an\nappropriate sleep mode. Table 11-1  shows the different sleep modes and their wake-up\nsources.\nNotes: 1. Only recommended with external crystal or resonator selected as clock source.\n2. If Timer/Counter2 is running in asynchronous mode.\n3. For INT7:4, only level interrupt.\nTo enter any of the sleep modes, the SE bit in \u201cSMCR \u2013 Sleep Mode Control Register\u201d on page\n56 must be written to logic one and a SLEEP instruction must be executed. The SM2, SM1, and\nSM0 bits in the SMCR Register select which sleep mode will be ac tivated by the SLEEP instruc-\ntion. See Table 11-2 on page 56  for a summary.\nIf an enabled interrupt occurs while the MCU is in a sleep mode, the MCU wakes up. The MCU\nis then halted for four cycles in addition to the st art-up time, executes the interrupt routine, and\nresumes execution from the instruction followi ng SLEEP. The contents of the Register File and\nSRAM are unaltered when the device wakes up from sleep. If a reset occurs during sleep mode,\nthe MCU wakes up and executes from the Reset Vector.\n11.2 Idle Mode\nWhen the SM2:0 bits are written to 000, the SLEEP instruction makes the MCU enter Idle mode,\nstopping the CPU but allowing the SPI, USART, Analog Comparator, ADC, 2-wire Serial Inter-\nface, Timer/Counters, Watchdog, and the interrupt system to continue operating. This sleep\nmode basically halts clkCPU and clkFLASH , while allowing the ot her clocks to run.Table 11-1. Active Clock Domains and Wake-up Sources in the Different Sleep Modes.\nActive Clock Domains Oscillators Wake-up Sources\nSleep Mode\nclkCPU\nclkFLASH\nclkIO\nclkADC\nclkASY\nMain Clock\nSource \nEnabled\nTimer Osc \nEnabled\nINT7:0 and \nPin Change\nTWI Address \nMatch\nTimer2\nSPM/\nEEPROM Ready\nADC\nWDT Interrupt\nOther I/O\nIdle X X X X X(2)XXXXXXX\nADCNRM X X X X(2)X(3)XX(2)XXX\nPower-down X(3)XX\nPower-save X X(2)X(3)XX X\nStandby(1)XX(3)XX\nExtended Standby X(2)XX(2)X(3)XX X\n\n53\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIdle mode enables the MCU to wake up from external triggered interrupts as well as internal\nones like the Timer Overflow and USART Transmit Complete interrupts. If wake-up from the\nAnalog Comparator interrupt is not required, the Analog Comparator can be powered down by\nsetting the ACD bit in the Analog Comparator Control and Status Regist er \u2013 ACSR. This will\nreduce power consumption in Idle mode. If t he ADC is enabled, a conversion starts automati-\ncally when this mode is entered.\n11.3 ADC Noise Reduction Mode\nWhen the SM2:0 bits are written to 001, th e SLEEP instruction makes the MCU enter ADC\nNoise Reduction mode, stopping the CPU but allowi ng the ADC, the external interrupts, 2-wire\nSerial Interface address match, Timer/Counter2 and the Watchdog to continue operating (if\nenabled). This sleep mode basically halts clkI /O, clkCPU, and clkFLASH, while allowing the\nother clocks to run.\nThis improves the noise environment for the AD C, enabling higher resolution measurements. If\nthe ADC is enabled, a conversion starts automatically when this mode is entered. Apart form theADC Conversion Complete interru pt, only an External Reset, a Watchdog System Reset, a\nWatchdog interrupt, a Brown-out Reset, a 2-wire serial interface interrupt, a Timer/Counter2\ninterrupt, an SPM/EEPROM ready interrupt, an external level interrupt on INT7:4 or a pinchange interrupt can wakeup the MCU from ADC Noise Reduction mode.\n11.4 Power-down Mode\nWhen the SM2:0 bits are written to 010, the SLEEP instruction makes the MCU enter Power-\ndown mode. In this mode,  the external Osc illator is stopped, while the external interrupts, the 2-\nwire Serial Interface, and the Watchdog continue operating (if enabled). Only an External Reset,\na Watchdog Reset, a Brown-out Reset, 2-wire Serial Interface address match, an external level\ninterrupt on INT7:4, an external interrupt on INT3:0, or a pin change interrupt can wake up theMCU. This sleep mode basically halts all gener ated clocks, allowing operation of asynchronous\nmodules only.\nNote that if a level triggered interrupt is used for wake-up from Power-down mode, the changed\nlevel must be held for some time to wake up the MCU. Refer to \u201cExternal Interrupts\u201d on page 112\nfor details.\nWhen waking up from Power-down mode, there is a delay from the wake-up condition occurs\nuntil the wake-up becomes effective. This allows the clock to restart and become stable afterhaving been stopped. The wake-up period is defined by the same  CKSEL Fuses that define the\nReset Time-out period, as described in \u201cClock Sources\u201d on page 41 .\n11.5 Power-save Mode\nWhen the SM2:0 bits are written to 011, the SLEEP instruction makes the MCU enter Power-\nsave mode. This mode is identical to Power-down, with one exception:\nIf Timer/Counter2 is e nabled, it will keep running during sleep. The device can wake up from\neither Timer Overflow or Output Compare event from Timer/Counter2 if the correspondingTimer/Counter2 interrupt enable bits are set in  TIMSK2, and the Global Interrupt Enable bit in\nSREG is set. If Timer/Counter2 is not running, Power-down mode is recommended instead of\nPower-save mode.\nThe Timer/Counter2 can be clocked both synchronously and asynchronously in Power-save\nmode. If the Time r/Counter2 is not using t he asynchronous clock, the Timer/Counter Oscillator is\n\n54\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nstopped during sleep. If the Timer/Counter2 is not using the synchronous clock, the clock source\nis stopped during sleep. Note that even if the synchronous clock is running in Power-save, this\nclock is only available for the Timer/Counter2.\n11.6 Standby Mode\nWhen the SM2:0 bits are 110 and an external crystal/resonator clock option is selected, the\nSLEEP instruction makes the MCU enter Standby mode. This mode is identical to Power-down\nwith the exception that the Oscillator is kept running. Fr om Standby mode, the device wakes up\nin six clock cycles.\n11.7 Extended Standby Mode\nWhen the SM2:0 bits are 111 and an external crystal/resonator clock option is selected, the\nSLEEP instruction makes the M CU enter Extended Standby mode . This mode is identical to\nPower-save mode with th e exception that the Oscillator is kept running. From  Extended Standby\nmode, the device wakes up in six clock cycles.\n11.8 Power Reduction Register\nThe Power Reduction Register (PRR), see \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nand \u201cPRR1 \u2013 Power Reduction Register 1\u201d on page 57 , provides a method for stopping the clock\nto individual peripherals to reduce power consumption.\nNote that when the clock for a peripheral is stopped, then:\n\u0081 The current state of the peripheral is frozen\n\u0081 The associated registers can not be read or written\u0081 Resources used by the peripherals (for example I/O pin, etc.) will remain occupied\nThe peripheral should in most cases be disabled before stopping the clock. Waking up a mod-\nule, which is done by cleaning the bit in PRR, puts the module in the same state as before\nshutdown. Module shutdown can be used in Idle mode or Active mode to significantly reduce the\noverall power consumption. See \u201cPower-down Supply Current\u201d on page 392  for examples. In all\nother sleep modes, the clock is already stopped.\n11.9 Minimizing Power Consumption\nThere are several issues to consider when trying to minimize the power consumption in an AVR\ncontrolled system. In general, sleep modes should be used as much as possible, and the sleep\nmode should be selected so that as few as possi ble of the device\u2019s functions are operating. All\nfunctions not needed should be disabled. In particular, the following modules may need special\nconsideration when trying to achieve th e lowest possible power consumption.\n11.9.1 Analog to Digital Converter\nIf enabled, the ADC will be enabled in all sleep  modes. To save power, the ADC should be dis-\nabled before entering any sleep mode. When the ADC is turned off and on again, the next\nconversion will be an extended conversion. Refer to \u201cADC \u2013 Analog to Digital Converter\u201d on\npage 275  for details on ADC operation.\n11.9.2 Analog Comparator\nWhen entering Idle mode, the Analog Comparator should be disabled if not used. When entering\nADC Noise Reduction mode, the Analog Comparator  should be disabled. In other sleep modes,\nthe Analog Comparator is automatically disabled. However, if the Analog Comparator is set up\n\n55\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nto use the Internal Voltage Reference as input, the Analog Comparator should be disabled in all\nsleep modes. Otherwise, the Internal Voltage Reference will be enabled, independent of sleep\nmode. Refer to \u201cAC \u2013 Analog Comparator\u201d on page 271  for details on how to configure the Ana-\nlog Comparator.\n11.9.3 Brown-out Detector\nIf the Brown-out Detector is not needed by the application, this module should be turned off. If\nthe Brown-out Detector is enabled by the BO DLEVEL Fuses, it will be enabled in all sleep\nmodes, and hence, always co nsume power. In the deeper sleep modes, this w ill contribute sig-\nnificantly to the total current consumption. Refer to \u201cBrown-out Detect ion\u201d on page 61  for details\non how to configure the Brown-out Detector.\n11.9.4 Internal Voltage Reference\nThe Internal Voltage Referenc e will be enabled when needed by the Brown-out De tection, the\nAnalog Comparator or the ADC. If these modules are disabled as described in the sections\nabove, the internal voltage re ference will be disabled and it will not be consuming power. When\nturned on again, the user must allow the reference to start up before the output is used. If the\nreference is kept on in sleep mode, the output can be used immediately. Refer to \u201cInternal Volt-\nage Reference\u201d on page 62  for details on the start-up time.\n11.9.5 Watchdog Timer\nIf the Watchdog Timer is not needed in the application, the module should be turned off. If the\nWatchdog Timer is enabled, it will be enabled in all sleep modes, and hence, always consume\npower. In the deeper slee p modes, this will contribute signific antly to the total current consump-\ntion. Refer to \u201cInterrupts\u201d on page 105  for details on how to configure the Watchdog Timer.\n11.9.6 Port Pins\nWhen entering a sleep mode, all port pins should be configured to use minimum power. The\nmost important is then to ensure that no pins drive resistive loads. In sleep modes where both\nthe I/O clock (clkI/O) and the ADC clock (clkADC) are stopped, the input buf fers of the device will\nbe disabled. This ensures that no power is consumed by the input logic when not needed. Insome cases, the input logic is needed for detec ting wake-up conditions, and it will then be\nenabled. Refer to the section \u201cDigital Input Enable and Sleep Modes\u201d on page 74  for details on\nwhich pins are enabled. If the input buffer is enabl ed and the input signal is left floating or have\nan analog signal level close to V\nCC/2, the input buffer will use excessive power.\nFor analog input pins, the digital input buffer should be disabled at all times. An analog signal\nlevel close to VCC/2 on an input pin can cause significant current even in active mode. Digital\ninput buffers can be disabled by writing to the Digital Input Disable Registers (DIDR2, DIDR1and DIDR0). Refer to \u201cDIDR2 \u2013 Digital Input Disable Register 2\u201d on page 295 , \u201cDIDR1 \u2013 Digital\nInput Disable Register 1\u201d on page 274  and \u201cDIDR0 \u2013 Digital Input Disable Register 0\u201d on page\n295 for details.\n11.9.7 On-chip Debug System\nIf the On-chip debug system is enabled by the OCDEN Fuse and the chip enters sleep mode,\nthe main clock source is enabled, and hence , always consumes power. In the deeper sleep\nmodes, this will contribute significantly  to the total cu rrent consumption.\n\n56\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThere are three alte rnative ways to disable the OCD system:\n\u0081 Disable the OCDEN Fuse\n\u0081 Disable the JTAGEN Fuse\u0081Write one to the JTD bit in MCUCR\n11.10 Register Description\n11.10.1 SMCR \u2013 Sleep Mode Control Register\nThe Sleep Mode Control Register contains control bits for power management.\n\u0081 Bits 3, 2, 1 \u2013 SM2:0: Sleep Mode Select Bits 2, 1, and 0\nThese bits select between the five available sleep modes as shown in Table 11-2 .\nNote: 1. Standby modes are only recommended for use with external crystals or resonators.\n\u0081 Bit 1 \u2013 SE: Sleep Enable\nThe SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP\ninstruction is executed. To avoid the MCU enteri ng the sleep mode unless it is the programmer\u2019s\npurpose, it is recommended to write the Sleep Enable (SE) bit to one just before the execution of\nthe SLEEP instruction and to clear it immediately af ter waking up.\n11.10.2 PRR0 \u2013 Power Reduction Register 0\n\u0081 Bit 7 - PRTWI: Power Reduction TWI\nWriting a logic one to this bit shuts down the T WI by stopping the clock to the module. When\nwaking up the T WI again, the T WI should be re initialized to ensure proper operation.B i t 76543210\n0x33 (0x53) \u2013\u2013\u2013\u2013 S M 2 S M 1 S M 0 S E S M C R\nRead/Wr i t e RRRR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 11-2. Sleep Mode Select\nSM2 SM1 SM0 Sleep Mode\n000 I d l e\n0 0 1 ADC Noise Reduction010 P o w e r - d o w n\n011 P o w e r - s a v e\n100 R e s e r v e d101 R e s e r v e d\n1 1 0 Standby\n(1)\n1 1 1 Extended Standby(1)\nB i t 7 6 543 2 1 0\n(0x64) PRTWI PRTIM2 PRTIM0 \u2013 PRTIM1 PRSPI PRUSART0 PRADC PRR0\nRead/Write R/ W R/W R/W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n57\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 - PRTIM2: Power Reduction Timer/Counter2\nWriting a logic one to this bit shuts down the Timer/Counter2 module in synchronous mode (AS2\nis 0). When the Timer/Counter2 is en abled, operation will continue  like before the shutdown.\n\u0081 Bit 5 - PRTIM0: Power Reduction Timer/Counter0\nWriting a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 4 - Res: Reserved bit\nThis bit is reserved bit and will always read as zero.\n\u0081 Bit 3 - PRTIM1: Power Reduction Timer/Counter1\nWriting a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 2 - PRSPI: Power Reduction Serial Peripheral Interface\nWriting a logic one to this bit shuts down the Seri al Peripheral Interface by stopping the clock to\nthe module. When waking up the SPI again, the SPI should be re initialized to ensure proper\noperation.\n\u0081 Bit 1 - PRUSART0: Power Reduction USART0\nWriting a logic one to this bit shuts down the U SART0 by stopping the clock to the module.\nWhen waking up the USART0 again, the USART0 should be re initialized to ensure proper\noperation.\n\u0081 Bit 0 - PRADC: Power Reduction ADC\nWriting a logic one to this bit shuts down the ADC. The ADC must be disabled before shut down.\nThe analog comparator cannot use the ADC input MUX when the ADC is shut down.\n11.10.3 PRR1 \u2013 Power Reduction Register 1\n\u0081 Bit 7:6 - Res: Reserved bits\nThese bits are reserved and will always read as zero.\n\u0081 Bit 5 - PRTIM5: Power Reduction Timer/Counter5\nWriting a logic one to this bit shuts down the Timer/Counter5 module. When the Timer/Counter5\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 4 - PRTIM4: Power Reduction Timer/Counter4\nWriting a logic one to this bit shuts down the Timer/Counter4 module. When the Timer/Counter4\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 3 - PRTIM3: Power Reduction Timer/Counter3\nWriting a logic one to this bit shuts down the Timer/Counter3 module. When the Timer/Counter3\nis enabled, operation will cont inue like before the shutdown.B i t 7 6 543 2 1 0\n(0x65) \u2013 \u2013 PRTIM5 PRTIM4 PRTIM3 PRUSART3 PRUSART2 PRUSART1 PRR1\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n58\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 - PRUSART3: Power Reduction USART3\nWriting a logic one to this bit shuts down the U SART3 by stopping the clock to the module.\nWhen waking up the USART3 again, the USART3 should be re initialized to ensure proper\noperation.\n\u0081 Bit 1 - PRUSART2: Power Reduction USART2\nWriting a logic one to this bit shuts down the U SART2 by stopping the clock to the module.\nWhen waking up the USART2 again, the USART2 should be re initialized to ensure proper\noperation.\n\u0081 Bit 0 - PRUSART1: Power Reduction USART1\nWriting a logic one to this bit shuts down the U SART1 by stopping the clock to the module.\nWhen waking up the USART1 again, the USART1 should be re initialized to ensure proper\noperation.\n\n59\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n12. System Control and Reset\n12.1 Resetting the AVR\nDuring reset, all I/O Registers are set to their initial values, and the program starts execution\nfrom the Reset Vector. The instruction placed at the Reset Vector must be a JMP \u2013 AbsoluteJump \u2013 instruction to the reset handling routine. If the program never enables an interrupt\nsource, the Interrupt Vectors are not used, and regular program code can be placed at these\nlocations. This is also the case if the Reset Vector is in the App lication section while the Interrupt\nVectors are in the Boot section or vice versa. The circuit diagram in Figure 12-1 on page 60\nshows the reset logic. \u201cSystem and Reset Characte ristics\u201d on page 372  defines the electrical\nparameters of the reset circuitry.\nThe I/O ports of the AVR are immediately reset to their initial state when a reset source goes\nactive. This does not require any clock source to be running.\nAfter all reset sources have gone inactive, a delay counter is invoked, stretching the internal\nreset. This allows the power to reach a stable level before normal operation starts. The time-out\nperiod of the delay counter is defined by the user through the SUT and CKSEL Fuses. The dif-\nferent selections for the delay period are presented in \u201cClock Sources\u201d on page 41 .\n12.2 Reset Sources\nThe ATmega640/1280/1281/2560/2561 has five sources of reset:\n\u0081Power-on Reset . The MCU is reset when the supply voltage is below the Power-on Reset \nthreshold (VPOT)\n\u0081External Reset . The MCU is reset when a low level is present on the RESET  pin for longer \nthan the minimum pulse length\n\u0081Watchdog Reset . The MCU is reset when the Watchdog Timer period expires and the \nWatchdog is enabled\n\u0081Brown-out Reset . The MCU is reset when  the supply voltage VCC is below the Brown-out \nReset threshold (VBOT) and the Brown-out Detector is enabled\n\u0081JTAG AVR Reset . The MCU is reset as long as there is a logic one in the Reset Register, \none of the scan chains of the JTAG system. Refer to the section \u201cIEEE 1149.1 (JTAG) \nBoundary-scan\u201d on page 302  for details\n\n60\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-1. Reset Logic\n12.2.1 Power-on Reset\nA Power-on Reset (POR) pulse is generated by an On-chip detection circuit. The detection level\nis defined in \u201cSystem and Reset Characteristics\u201d on page 372 . The POR is activated whenever\nVCC is below the detection level. The POR circuit can be used to trigger the start-up Reset, as\nwell as to detect a fa ilure in supply voltage.\nA Power-on Reset (POR) circuit ensures that the device is reset from Power-on. Reaching the\nPower-on Reset threshold voltage invokes the delay counter, which determines how long the\ndevice is kept in RESET after VCC rise. The RESET signal is acti vated again, without any delay,\nwhen VCC decreases below the detection level.\nFigure 12-2. MCU Start-up, RESET  Tied to VCCMCU Status\nRegister (MCU SR)\nBrown-out\nReset CircuitBODLEVEL [2..0]\nDelay Counters\nCKSEL[3:0]CK\nTIMEOUTWDRFBORF\nEXTRFPORFDATA BU S\nClock\nGeneratorSPIKE\nFILTERPull-up Resistor\nJTRF\nJTAG Reset\nRegister\nWatchdog\nOscillator\nSUT[1:0]Power-on Reset\nCircuit\nV\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTCC\n\n61\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-3. MCU Start-up, RESET  Extended Externally\n12.2.2 External Reset\nAn External Reset is generated by a low level on the RESET  pin. Reset pulses longer than the\nminimum pulse width (see \u201cSystem and Reset Characteristics\u201d on page 372 ) will generate a\nreset, even if the clock is not running. Shorter pulses are not guaranteed to generate a reset.\nWhen the applied signal reaches the Reset Threshold Voltage \u2013 VRST \u2013 on its positive edge, the\ndelay counter starts the MCU after the Time-out period \u2013 tTOUT \u2013 has expired.\nFigure 12-4. External Reset During Operation\n12.2.3 Brown-out Detection\nATmega640/1280/1281/2560/2561 has an On-chip Brown-out Detection (BOD) circuit for moni-\ntoring the VCC level during operation by comparing it to a fixed trigger level. The trigger level for\nthe BOD can be selected by the BODLEVEL Fu ses. The trigger level ha s a hysteresis to ensure\nspike free Brown-out Detection. The hysteresis on the detection level should be interpreted as\nVBOT+ = VBOT + VHYST/2 and VBOT- = VBOT - VHYST/2.\nWhen the BOD is enabled, and VCC decreases to a value below the trigger level (VBOT- in Figure\n12-5 on page 62 ), the Brown-out Reset is immediately activated. When VCC increases above the\ntrigger level (VBOT+ in Figure 12-5 on page 62 ), the delay counter starts the MCU after the Time-\nout period tTOUT has expired.\nThe BOD circuit will only detect a drop in VCC if the voltage stays below the trigger level for lon-\nger than tBOD given in \u201cSystem and Reset Characteristics\u201d on page 372 .RESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTVCC\nCC\n\n62\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-5. Brown-out Reset During Operation\n12.2.4 Watchdog Reset\nWhen the Watchdog times out, it will gene rate a short reset pulse of  one CK cycle duration. On\nthe falling edge of this pulse, the delay timer starts counting the Time-out period tTOUT. See\n\u201cWatchdog Timer\u201d on page 55.  for details on operation of the Watchdog Timer.\nFigure 12-6. Watchdog Reset During Operation\n12.3 Internal Voltage Reference\nATmega640/1280/1281/2560/2561 features an internal bandgap reference. This reference is\nused for Brown-out Detection, and it can be used as an input to the Analog Comparator or theADC.\n12.3.1 Voltage Reference Enable Signals and Start-up Time\nThe voltage reference has a start-up time that may influence the way it should be used. The\nstart-up time is given in \u201cSystem and Reset Characteristics\u201d on page 372 . To save power, the\nreference is not always turned on. The reference is on during the following situations:\n1.When the BOD is enabled (by prog ramming the BODLEVEL [2:0] Fuse).\n2.When the bandgap reference is connected to the Analog Comparator (by setting the \nACBG bit in ACSR).\n3.When the ADC is enabled.\nThus, when the BOD is not enabled, after setting the ACBG bit or enabling the ADC, the user\nmust always allow the reference to start up before the output from the Analog Comparator orVCC\nRESET\nTIME-OUT\nINTERNAL\nRESETVBOT -VBOT+\ntTOUT\nCKCC\n\n63\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nADC is used. To reduce power consumption in Power-down mode, the user can avoid the three\nconditions above to ensure that the reference is turned off before entering Power-down mode.\n12.4 Watchdog Timer\n12.4.1 Features\n\u0081Clocked from separate On-chip Oscillator\n\u00813 Operating modes\n\u2013 Interrupt\n\u2013 System Reset\n\u2013 Interrupt and System Reset\n\u0081Selectable Time-out pe riod from 16ms to 8s\n\u0081Possible Hardware fuse Watchdog al ways on (WDTON) for fail-safe mode\nFigure 12-7. Watchdog Timer\n12.4.2 Overview\nATmega640/1280/1281/2560/2561 has an Enhanced Watchdog Timer ( WDT). The WDT is a\ntimer counting cycles of a separate on-chip 128kHz oscillator. The WDT gives an interrupt or a\nsystem reset when the counter reaches a given time -out value. In normal  operation mode, it is\nrequired that the system uses the WDR - Watchdog Timer Reset - instruction to restart the coun-\nter before the time-out value is reached. If the system doesn't restart the counter, an interrupt orsystem reset will be issued.\nIn Interrupt mode, the WDT gives an interrupt when the timer expires. This interrupt can be used\nto wake the device from sleep-modes, and also as a general system timer. One example is to\nlimit the maximum time allowed for certain operations, giving an interrupt when the operation\nhas run longer than expected. In System Reset mode, the WDT gives a reset when the timer\nexpires. This is typically used to prevent sys tem hang-up in case of runaway code. The third\nmode, Interrupt and System Reset mode, combines  the other two modes by first giving an inter-\nrupt and then switch to System Reset mode. This mode will for instance allow a safe shutdown\nby saving critical parameters before a system reset.\nThe Watchdog always on ( WDTON) fuse, if programmed, will force the Watchdog Timer to Sys-\ntem Reset mode. With the fuse programmed the System Reset mode bit ( WDE) and Interrupt\nmode bit ( WDIE) are locked to 1 and 0 respectively. To further ensure program security, altera-128 kHz\nOSCILLATOR\nOSC/2K\nOSC/4K\nOSC/8K\nOSC/16K\nOSC/32KOSC/64K\nOSC/128K\nOSC/256K\nOSC/512K\nOSC/1024K\nWDP0\nWDP1WDP2WDP3WATCHDOG\nRESET\nWDE\nWDIF\nWDIEMCU RESET\nINTERRUPT\n\n64\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ntions to the Watchdog set-up must follow timed sequences. The sequence for clearing WDE and\nchanging time-out configuration is as follows:\n1. In the same operation, write a logic one to the Watchdog change enable bit ( WDCE) and\nWDE. A logic one must be written to WDE regardless of the previous value of the WDE\nbit.\n2.Within the next four clock cycles, write the WDE and Watchdog prescaler bits ( WDP) as\ndesired, but with the WDCE bit cleared. This must be done in one operation.\nThe following code example shows one assembly and one C function for turning off the Watch-\ndog Timer. The example assumes that interrupt s are controlled (for example by disabling\ninterrupts globally) so that no interrupts will occur during the execution of these functions.\n\n65\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. The example code assumes that the pa rt specific header file is included.\n2. If the Watchdog is accidentally enabled, for exampl e by a runaway pointer or brown-out condi-\ntion, the device will be reset and the Watchdog Timer will stay enabled. If the code is not set up \nto handle the Watchdog, this might lead to an eternal lo op of time-out resets . To avoid this sit-\nuation, the application software should always clear the Watchdog System Reset Flag \n(WDRF) and the WDE control bit in the initialisation routine, even if the Watchdog is not in use.\nThe following code example shows one assembly and one C function for changing the time-out\nvalue of the Watchdog Timer.Assembly Code Example(1)\nWDT_off:\n; Turn off global interruptcli\n; Reset Watchdog Timer\nwdr\n; Clear WDRF in MCUSR\nin    r16, MCUSR\nandi  r16, (0xff & (0<<WDRF))\nout   MCUSR, r16\n; Write logical one to WDCE and WDE; Keep old prescaler setting to prevent unintentional time-out\nldi r16, WDTCSR\nori   r16, (1<<WDCE) | (1<<WDE)\nsts WDTCSR, r16\n; Turn off WDT\nldi   r16, (0<<WDE)\nsts WDTCSR, r16\n; Turn on global interrupt\nseiret\nC Code Example(1)\nvoid WDT_off(void){\n__disable_interrupt();\n__watchdog_reset();\n/* Clear WDRF in MCUSR */MCUSR &= ~(1<<WDRF);\n/* Write logical one to WDCE and WDE */\n/* Keep old prescaler setting to prevent unintentional time-out \n*/\nWDTCSR |= (1<<WDCE) | (1<<WDE);\n/* Turn off WDT */WDTCSR = 0x00;\n__enable_interrupt();\n}\n\n66\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. The example code assumes that the part specific header file is included.\n2. The Watchdog Timer should be reset before any change of the WDP bits, since a change in \nthe WDP bits can result in a time-out when switching to a shorter time-out period.Assembly Code Example(1)\nWDT_Prescaler_Change:\n; Turn off global interruptcli\n; Reset Watchdog Timer\nwdr\n; Start timed sequence\nin    r16, WDTCSR\nori   r16, (1<<WDCE) | (1<<WDE)\nout   WDTCSR, r16\n; --  Got four cycles to set the new values from here -; Set new prescaler(time-out) value = 64K cycles (~0.5 s)\nldi   r16, (1<<WDE) | (1<<WDP2) | (1<<WDP0)\nout   WDTCSR, r16\n; --  Finished setting new values, used 2 cycles -\n; Turn on global interrupt\nseiret\nC Code Example(2)\nvoid WDT_Prescaler_Change(void){\n__disable_interrupt();\n__watchdog_reset();\n/* Start timed  equence */WDTCSR |= (1<<WDCE) | (1<<WDE);\n/* Set new prescaler(time-out) value = 64K cycles (~0.5 s) */\nWDTCSR  = (1<<WDE) | (1<<WDP2) | (1<<WDP0);__enable_interrupt();\n}\n\n67\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n12.5 Register Description\n12.5.1 MCUSR \u2013 MCU Status Register\nThe MCU Status Register provides information on which reset source caused an MCU reset.\n\u0081 Bit 4 \u2013 JTRF: JTAG Reset Flag\nThis bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by\nthe JTAG instruction AVR_RESET. This bit is rese t by a Power-on Reset, or by writing a logic\nzero to the flag.\n\u0081 Bit 3 \u2013 WDRF: Watchdog Reset Flag\nThis bit is set if a Watchdog Reset occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 2 \u2013 BORF: Brown-out Reset Flag\nThis bit is set if a Brown-out Reset occurs. The bi t is reset by a Power-on  Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 1 \u2013 EXTRF: External Reset Flag\nThis bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 0 \u2013 PORF: Power-on Reset Flag\nThis bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag.\nTo make use of the Reset Flags to identify a reset condition, the user should read and then\nReset the MCUSR as early as possible in the program. If the register is cleared before another\nreset occurs, the source of the reset can be found by examining the Reset Flags.\n12.5.2 WDTCSR \u2013 Watchdog Timer Control Register\n\u0081 Bit 7 - WDIF: Watchdog Interrupt Flag\nThis bit is set when a time-out occurs in the Watchdog Timer and the Watchdog Timer is config-\nured for interrupt. WDIF is cleared by hardware when executing the corresponding interrupt\nhandling vector. Alternatively, WDIF is cleared by writing a logic one to the flag. When the I-bit in\nSREG and WDIE are set, the Watchdog Time-out Interrupt is executed.B i t 76543210\n0x35 (0x55) \u2013 \u2013 \u2013 JTRF WDRF BORF EXTRF PORF MCUSR\nRead/Write R R R R/ W R/W R/W R/W R/W\nInitial Value 0 0 0 See Bit Description\nB i t 76543210(0x60) WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 WDTCSR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 X 0 0 0\n\n68\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 - WDIE: Watchdog Interrupt Enable\nWhen this bit is written to one and the I-bit in the Status Register is set, the Watchdog Interrupt is\nenabled. If WDE is cleared in combination with this setting, the Watchdog Timer is in Interrupt\nMode, and the corresponding interrupt is executed if time-out in the Watchdog Timer occurs.\nIf WDE is set, the Watchdog Timer is in Interrupt and Syst em Reset Mode. The first time-out in\nthe Watchdog Timer will set WDIF. Executing the corresponding interr upt vector will clear WDIE\nand WDIF automatically by hardware (the Watchdog goes to System Reset Mode). This is use-\nful for keeping the Watchdog Timer security while using the interrupt. To stay in Interrupt and\nSystem Reset Mode, WDIE must be set after each interrupt. This should however not be done\nwithin the interrupt service routine itself, as this might compromise the safety-function of the\nWatchdog System Reset mode. If the interrupt is not executed before the next time-out, a Sys-\ntem Reset will be applied.\nNote: 1. WDTON Fuse set to \u201c0\u201c means programmed and \u201c1\u201d means unprogrammed.\n\u0081 Bit 4 - WDCE: Watchdog Change Enable\nThis bit is used in timed sequences for changing WDE and prescaler bits. To clear the WDE bit,\nand/or change the prescaler bits, WDCE must be set.\nOnce written to one,  hardware will clear WDCE after four clock cycles.\n\u0081 Bit 3 - WDE: Watchdog System Reset Enable\nWDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is\nset. To clear WDE, WDRF must be cleared first. This feature ensures multiple resets during con-\nditions causing failure, and a safe start-up after the failure.\n\u0081 Bit 5, 2:0 - WDP3:0: Watchdog Timer Prescaler 3, 2, 1 and 0\nThe WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is run-\nning. The different prescaling values and thei r corresponding time-out periods are shown in\nTable 12-2 on page 69 .Table 12-1. Watchdog Timer Configuration\nWDTON(1)WDE WDIE Mode Action on Time-out\n1 0 0 Stopped None\n1 0 1 Interrupt Mode Interrupt1 1 0 System Reset Mode Reset\n111Interrupt and System \nReset ModeInterrupt, then go to \nSystem Reset Mode\n0 x x System Reset Mode Reset\n\n69\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n.\nTable 12-2. Watchdog Timer Prescale Select\nWDP3 WDP2 WDP1 WDP0Number of WDT Oscillator \nCyclesTypical Time-out at \nVCC = 5.0V\n0 0 0 0 2K (2048) cycles 16ms\n0 0 0 1 4K (4096) cycles 32ms\n0 0 1 0 8K (8192) cycles 64ms0 0 1 1 16K (16384) cycles 0.125s\n0 1 0 0 32K (32768) cycles 0.25s\n0 1 0 1 64K (65536) cycles 0.5s0 1 1 0 128K (131072) cycles 1.0s\n0 1 1 1 256K (262144) cycles 2.0s\n1 0 0 0 512K (524288) cycles 4.0s1 0 0 1 1024K (1048576) cycles 8.0s\n1010\nReserved1011\n1100\n1101\n11101111\n\n70\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13. I/O-Ports\n13.1 Introduction\nAll AVR ports have true Read-Modify- Write functionality when used as general digital I/O ports.\nThis means that the direction of one port pin can be changed without unintentionally changing\nthe direction of any other pin with the SBI and CBI instructions. The same applies when chang-\ning drive value (if configured as output) or enabling/disabling of pull-up resistors (if configured as\ninput). Each output buffer has symmetrical drive characteristics with both high sink and sourcecapability. The pin driver is stro ng enough to drive LED displays directly. All port pins have indi-\nvidually selectable pull-up resistors with a suppl y-voltage invariant resistance. All I/O pins have\nprotection diodes to both V\nCC and Ground as indicated in Figure 13-1 . Refer to \u201cElectrical Char-\nacteristics\u201d on page 367  for a complete list of parameters.\nFigure 13-1. I/O Pin Equivalent Schematic\nAll registers and bit references in this section are written in general form. A lower case \u201cx\u201d repre-\nsents the numbering letter for the port, and a lower case \u201cn\u201d represents the bit number. However,when using the register or bit defines in a progr am, the precise form must be used. For example,\nPORTB3 for bit no. 3 in Port B, here documented generally as PORTxn. The physical I/O Regis-\nters and bit locations are listed in \u201cTable 13-34 and Table 13-35 relates the alternate functions of\nPort L to the overriding signals shown in Figure 13-5 on page 76.\u201d on page 99 .\nThree I/O memory address locations are allocated for each port, one each for the Data Register\n\u2013 PORTx, Data Direction Register \u2013 DDRx, and the Port Input Pins \u2013 PINx. The Port Input PinsI/O location is read only, while the Data Register and the Data Direction Register are read/write.\nHowever, writing a logic one to a bit in the PINx Register, will result in a toggle in the correspond-\ning bit in the Data Register. In addition, the Pu ll-up Disable \u2013 PUD bit in MCUCR disables the\npull-up function for all pins in all ports when set.\nUsing the I/O port as General Digital I/O is described in \u201cPorts as General Digital I/O\u201d on page\n71. Most port pins are multiplexed with alternate functions for the peripheral features on the\ndevice. How each alternate function interferes with the port pin is described in \u201cAlternate Port\nFunctions\u201d on page 75 . Refer to the individual module sectio ns for a full description of the alter-\nnate functions.CpinLogicRpu\nSee Figure\n\"General Digital I/O\" for\nDetailsPxn\n\n71\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that enabling the alternate function of some of the port pins does not affect the use of the\nother pins in the port as general digital I/O.\n13.2 Ports as Gener al Digital I/O\nThe ports are bi-directional I/O ports  with optional internal pull-ups. Figure 13-2  shows a func-\ntional description of one I/O-port pin, here generically called Pxn.\nFigure 13-2. General Digital I/O(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O,\nSLEEP , and PUD are common to all ports.\n13.2.1 Configuring the Pin\nEach port pin consists of three register bits: DDxn, PORTxn, and PINxn. As shown in \u201cTable 13-\n34 and Table 13-35 relates the alternate function s of Port L to the ov erriding signals shown in\nFigure 13-5 on page 76.\u201d on page 99 , the DDxn bits are accessed at the DDRx I/O address, the\nPORTxn bits at the PORTx I/O address, and the PINxn bits at the PINx I/O address.\nThe DDxn bit in the DDRx Register selects the direct ion of this pin. If DDxn is written logic one,\nPxn is configured as an output pin. If DDxn is written logic zero, Pxn is configured as an input\npin.\nIf PORTxn is written logic one when the pin is c onfigured as an input pin, the pull-up resistor is\nactivated. To switch the pull-up resistor off, PORTxn has to be written logic zero or the pin has to\nbe configured as an output pin. The port pins are tri-stated when reset condition becomes active,even if no clocks are running.clkRPxRRxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWRx: WRITE PORTx\nRRx: READ PORTx REGISTER\nRPx: READ PORTx PINPUD: PULLUP DISABLE\nclkI/O: I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQD\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/OWPx01\nWRx\nWPx: WRITE PINx REGISTER\n\n72\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf PORTxn is written logic one when the pin is conf igured as an output pin, the port pin is driven\nhigh (one). If PORTxn is written logic zero when the pin is configured as an output pin, the port\npin is driven low (zero).\n13.2.2 Toggling the Pin\nWriting a logic one to PINxn toggles the value of PORTxn, independent on the value of DDRxn.\nNote that the SBI instruction can be used to toggle one single bit in a port.\n13.2.3 Switching Between Input and Output\nWhen switching between tri-state ({DDxn, PORTxn} = 0b00) and output high ({DDxn, PORTxn}\n= 0b11), an intermediate state with either pull-up enabled {DDxn, PORTxn} = 0b01) or output\nlow ({DDxn, PORTxn} = 0b10) must occur. Norma lly, the pull-up enabled state is fully accept-\nable, as a high-impedant enviro nment will not notice the differenc e between a strong high driver\nand a pull-up. If this is not the case, the PUD bit in the MCUCR Register can be set to disable all\npull-ups in all ports.\nSwitching between input with pull-up and output low generates the same problem. The user\nmust use either the tri-state ({DDxn, PORTxn} = 0b00) or the output high state ({DDxn, PORTxn}\n= 0b11) as an intermediate step.\nTable 13-1  summarizes the control signals for the pin value.\n13.2.4 Reading the Pin Value\nIndependent of the setting of Data Direction bit DDxn, the port pin can be read through the\nPINxn Register bit. As shown in Figure 13-2 on page 71 , the PINxn Register bit and the preced-\ning latch constitute a synchronizer. This is needed to avoid metastability if the physical pinchanges value near the edge of the internal clock, but it also introduces a delay. Figure 13-3 on\npage 73  shows a timing diagram of the synchroni zation when reading an externally applied pin\nvalue. The maximum and minimum propagation delays are denoted t\npd,max  and tpd,min\nrespectively.Table 13-1. Port Pin ConfigurationsDDxn\nPORTxn\nPUD\n(in MCUCR) I/O Pull-up Comment\n0 0 X Input No Tri-state (Hi-Z)0 1 0 Input Y es Pxn will source current if ext. pulled low\n0 1 1 Input No Tri-state (Hi-Z)\n1 0 X Output No Output Low (Sink)1 1 X Output No Output High (Source)\n\n73\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 13-3. Synchronization when Reading an Externally Applied Pin value\nConsider the clock period starting shortly after the first falling edge of the system cl ock. The latch\nis closed when the clock is low, and goes transpa rent when the clock is high, as indicated by the\nshaded region of the \u201cSYNC LATCH\u201d signal. The signal value is latched when the system clock\ngoes low. It is clocked into the PINxn Register  at the succeeding positive clock edge. As indi-\ncated by the two arrows tpd,max and tpd,min, a single signal tr ansition on the pin will be delayed\nbetween \u00bd and 1\u00bd system clock period depending upon the time of assertion.\nWhen reading back a software assigned pin value, a nop instruction must be inserted as indi-\ncated in Figure 13-4 . The out instruction sets the \u201cSYNC LATCH\u201d signal at the positive edge of\nthe clock. In this case, the delay tpd through  the synchronizer is one system clock period.\nFigure 13-4. Synchronization when Reading a Software Assigned Pin ValueXXX in r17, PINx\n0x00 0xFFINSTRUCTION S\nSYNC LATCH\nPINxn\nr17XXXSYSTEM CLK\ntpd, max\ntpd, min\nout PORTx, r16 nop in r17, PINx0xFF\n0x00 0xFFSYSTEM CLK\nr16\nINSTRUCTIONS\nSYNC LATCH\nPINxn\nr17\ntpd\n\n74\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code example shows how to set por t B pins 0 and 1 high, pins 2 and 3 low, and\ndefine the port pins from 4 to 7 as input with pull-ups assigned to port pins 6 and 7. The resulting\npin values are read back again, but as previously discussed, a nop instruction is included to be\nable to read back the value recently assigned to some of the pins.\nNote: 1. For the assembly program, two temporary registers are used to minimize the time from pull-\nups are set on pins 0, 1, 6, and 7, until the di rection bits are correctly  set, defining bit 2 and 3\nas low and redefining bits 0 and 1 as strong high drivers.\n13.2.5 Digital Input Enable and Sleep Modes\nAs shown in Figure 13-2 on page 71 , the digital input signal can be clamped to ground at the\ninput of the schmitt-trigger. Th e signal denoted SLEEP in the fi gure, is set by the MCU Sleep\nController in Power-down mode, Power-save mode, and Standby mode to avoid high power\nconsumption if some input signals are left floating, or have an analog signal level close to VCC/2.\nSLEEP is overridden for port pins enabled as ex ternal interrupt pins. If the external interrupt\nrequest is not e nabled, SLEEP is active also  for these pins. SL EEP is also overri dden by various\nother alternate functions as described in \u201cAlternate Port Functions\u201d on page 75 .\nIf a logic high level (\u201cone\u201d) is present on an asynchronous external interrupt pin configured as\n\u201cInterrupt on Rising Edge, Falling Edge, or Any Logic Change on Pin\u201d while the external interrupt\nis not enabled, the corresponding External Interrupt Flag will be set when resuming from theAssembly Code Example(1)\n...\n; Define pull-ups and set outputs high\n; Define directions for port pins\nldir16,(1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0)\nldir17,(1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0)\noutPORTB,r16\noutDDRB,r17\n; Insert nop for synchronization\nnop; Read port pins\ninr16,PINB\n...\nC Code Example\nunsigned char i;\n...\n/* Define pull-ups and set outputs high */\n/* Define directions for port pins */\nPORTB = (1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0);\nDDRB = (1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0);/* Insert nop for synchronization */\n__no_operation();\n/* Read port pins */\ni = PINB;\n...\n\n75\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nabove mentioned Sleep mode, as the clamping in these sleep mode produces the requested\nlogic change.\n13.2.6 Unconnected Pins\nIf some pins are unused, it is recommended to ens ure that these pins have a defined level. Even\nthough most of the digital inputs are disabled in  the deep sleep modes as described above, float-\ning inputs should be avoided to reduce current consumption in all other modes where the digitalinputs are enabled (Reset, Active mode and Idle mode).\nThe simplest method to ensure a defined level of an unused pin, is to enable the internal pull-up.\nIn this case, the pull-up will be  disabled during reset. If low po wer consumption during reset is\nimportant, it is recommended to use an external pull-up or pull-down. Connecting unused pins\ndirectly to V\nCC or GND is not recommended, since this ma y cause excessive curr ents if the pin is\naccidentally configured as an output.\n13.3 Alternate Port Functions\nMost port pins have alternate functions in addition to being general digital I/Os. Figure 13-5 on\npage 76  shows how the port pin control signals from the simplified Figure 13-2 on page 71  can\nbe overridden by alternate functions . The overriding signals may not be present in all port pins,\nbut the figure serves as a generic description applicable to all port pins in the AVR microcon-\ntroller family.\n\n76\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 13-5. Alternate Port Functions(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O,\nSLEEP , and PUD are common to all ports. All other signals are unique for each pin.clkRPxRRxWRxRDxWDxPUD\nSYNCHRONIZER\nWDx:     WRITE DDRx\nWRx:     WRITE PORTxRRx:     READ PORTx REGISTER\nRPx:     READ PORTx PINPUD:     PULLUP DISABLE\nclkI/O:     I/O CLOCKRDx:     READ DDRxD\nLQ\nQSET\nCLR01\n0101\nDIxn\nAIOxnDIEOExnPVOVxnPVOExnDDOVxnDDOExnPUOExn\nPUOVxn\nPUOExn: Pxn PULL-UP OVERRIDE ENABLE\nPUOVxn: Pxn PULL-UP OVERRIDE VALUE\nDDOExn: Pxn DATA DIRECTION OVERRIDE ENABLE\nDDOVxn: Pxn DATA DIRECTION OVERRIDE VALUE\nPVOExn: Pxn PORT VALUE OVERRIDE ENABLE\nPVOVxn: Pxn PORT VALUE OVERRIDE VALUE\nDIxn:     DIGITAL INPUT PIN n ON PORTx\nAIOxn:     ANALOG INPUT/OUTPUT PIN n ON PORTxRESETRESETQQ D\nCLR\nQQ D\nCLR\nQQD\nCLRPINxnPORTxnDDxn\nDATA BUS\n01DIEOVxn\nSLEEP\nDIEOExn: Pxn DIGITAL INPUT -ENABLE OVERRIDE ENABLE\nDIEOVxn: Pxn DIGITAL INPUT -ENABLE OVERRIDE VALUESLEEP: SLEEP CONTROLPxn\nI/O01\nPTOExn\nPTOExn: Pxn, PORT TOGGLE OVERRIDE ENABLEWPx: WRITE PINxWPx\n\n77\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 13-2  summarizes the function of the overriding signals. The pin and port indexes from Fig-\nure 13-5 on page 76  are not shown in the succeeding tables. The overriding signals are\ngenerated internally in the modules having the alternate function.\nThe following subsections shortly describe the alternate functions for each port, and relate the\noverriding signals to the alternate function. Refer to the alternate function description for further\ndetails.Table 13-2. Generic Description of Overriding  Signals for Alternate Functions\nSignal Name Full Name Description\nPUOEPull-up Override \nEnableIf this signal is set, the pull-up enable is controlled by the PUOV \nsignal. If this signal is cleared, the pull-up is enabled when \n{DDxn, PORTxn, PUD} = 0b010. \nPUOVPull-up Override \nValueIf PUOE is set, the pull-up is enabled/disabled when PUOV is \nset/cleared, regardless of the setting of the DDxn, PORTxn, \nand PUD Register bits.\nDDOEData Direction \nOverride EnableIf this signal is set, the Output Driver Enable is controlled by the \nDDOV signal. If this signal is cleared, the Output driver is \nenabled by the DDxn Register bit.\nDDOVData Direction \nOverride ValueIf DDOE is set, the Output Driver is enabled/disabled when \nDDOV is set/cleared, regardle ss of the setting of the DDxn \nRegister bit.\nPVOEPort Value \nOverride EnableIf this signal is set and the Output Driver is enabled, the port \nvalue is controlled by the PVOV si gnal. If PVOE is cleared, and \nthe Output Driver is enabled, the port Value is controlled by the \nPORTxn Register bit.\nPVOVPort Value \nOverride ValueIf PVOE is set, the port value is  set to PVOV, regardless of the \nsetting of the PORTxn Register bit.\nPTOEPort Toggle \nOverride EnableIf PTOE is set, the PORTxn Register bit is inverted.\nDIEOEDigital Input \nEnable Override \nEnableIf this bit is set, the Digital Input Enable is controlled by the \nDIEOV signal. If this signal is cleared, the Digital Input Enable is \ndetermined by MCU state (Normal mode, sleep mode).\nDIEOVDigital Input \nEnable Override \nValueIf DIEOE is set, the Digital Input is enabled/disabled when \nDIEOV is set/cleared, regardl ess of the MCU state (Normal \nmode, sleep mode).\nDI Digital InputThis is the Digital Input to alternate functions. In the figure, the \nsignal is connected to the output of the schmitt trigger but \nbefore the synchronizer. Unless the Digital Input is used as a \nclock source, the module with the alternate function will use its \nown synchronizer.\nAIOAnalog \nInput/OutputThis is the Analog I nput/output to/from alte rnate functions. The \nsignal is connected directly to the pad, and can be used bi-\ndirectionally.\n\n78\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.1 Alternate Functions of Port A\nThe Port A has an alternate function as the address low byte and data lines for the External\nMemory Interface.\nTable 13-4  and Table 13-5 on page 79  relates the alternate functions of Port A to the overriding\nsignals shown in Figure 13-5 on page 76 .\nNote: 1. ADA is short for ADdress Active and r epresents the time when address is output. See \u201cExter-\nnal Memory Interface\u201d on page 28  for details.Table 13-3. Port A Pins Alternate Functions\nPort Pin Alternate Function\nPA7 AD7 (External memory interface address and data bit 7)\nPA6 AD6 (External memory interface address and data bit 6)\nPA5 AD5 (External memory interface address and data bit 5)\nPA4 AD4 (External memory interface address and data bit 4)PA3 AD3 (External memory interface address and data bit 3)\nPA2 AD2 (External memory interface address and data bit 2)\nPA1 AD1 (External memory interface address and data bit 1)PA0 AD0 (External memory interface address and data bit 0)\nTable 13-4. Overriding Signals for Alternate Functions in PA7:PA4\nSignal\nName PA7/AD7 PA6/AD6 PA5/AD5 PA4/AD4\nPUOE SRE SRE SRE SRE\nPUOV~(WR | ADA(1)) \u0081 \nPORTA7 \u0081 PUD~(WR | ADA) \u0081 \nPORTA6 \u0081 PUD~(WR | ADA) \u0081 \nPORTA5 \u0081 PUD~(WR | ADA) \u0081 \nPORTA4 \u0081 PUD\nDDOE SRE SRE SRE SRE\nDDOV WR | ADA WR | ADA WR | ADA WR | ADA\nPVOE SRE SRE SRE SRE\nPVOVA7 \u0081 ADA | D7 \nOUTPUT \u0081 WRA6 \u0081 ADA | D6 \nOUTPUT \u0081 WRA5 \u0081 ADA | D5 \nOUTPUT \u0081 WRA4 \u0081 ADA | D4 \nOUTPUT \u0081 WR\nD I E O E 0000\nD I E O V 0000\nDI D7 INPUT D6 INPUT D5 INPUT D4 INPUT\nA I O \u2013\u2013\u2013\u2013\n\n79\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.2 Alternate Functions of Port B\nThe Port B pins with alternate functions are shown in Table 13-6 .\nThe alternate pin configuration is as follows:\n\u0081 OC0A/OC1C/PCINT7, Bit 7\nOC0A, Output Compare Match A output: The PB7 pin can serve as an external output for the\nTimer/Counter0 Output Compare. The pin has to be configured as an output (DDB7 set \u201cone\u201d) to\nserve this function. The OC0A pin is also the output pin for the P WM mode timer function.\nOC1C, Output Compare Match C output: The PB7 pi n can serve as an external output for the\nTimer/Counter1 Output Compare C. The pin has to be configured as an output (DDB7 set (one))\nto serve this function. The OC1C pin is also the output pin for the P WM mode timer function.Table 13-5. Overriding Signals for Alternate Functions in PA3:PA0\nSignal \nName PA3/AD3 PA2/AD2 PA1/AD1 PA0/AD0\nPUOE SRE SRE SRE SRE\nPUOV~(WR | ADA) \u0081 \nPORTA3 \u0081 PUD~(WR | ADA) \u0081 \nPORTA2 \u0081 PUD~(WR | ADA) \u0081 \nPORTA1 \u0081 PUD~(WR | ADA) \u0081 \nPORTA0 \u0081 PUD\nDDOE SRE SRE SRE SRE\nDDOV WR | ADA WR | ADA WR | ADA WR | ADA\nPVOE SRE SRE SRE SRE\nPVOVA3 \u0081 ADA | D3 \nOUTPUT \u0081 WRA2\u0081 ADA | D2 \nOUTPUT \u0081 WRA1 \u0081 ADA | D1 \nOUTPUT \u0081 WRA0 \u0081 ADA | D0 \nOUTPUT \u0081 WR\nD I E O E 0000\nD I E O V 0000\nD I D 3  I N P U TD 2  I N P U TD 1  I N P U TD 0  I N P U T\nA I O \u2013\u2013\u2013\u2013\nTable 13-6. Port B Pins Alternate Functions\nPort Pin Alternate Functions\nPB7OC0A/OC1C/PCINT7 (Output Compare and P WM Output A for Timer/Counter0, Output \nCompare and P WM Output C for Timer/Counter1 or Pin Change Interrupt 7)\nPB6OC1B/PCINT6 (Output Compare and P WM Output B for Timer/Counter1 or Pin Change \nInterrupt 6)\nPB5OC1A/PCINT5 (Output Compare and P WM Output A for Timer/Counter1 or Pin Change \nInterrupt 5)\nPB4OC2A/PCINT4 (Output Compare and P WM Output A for Timer/Counter2 or Pin Change \nInterrupt 4)\nPB3 MISO/PCINT3 (SPI Bus Master Input/Sla ve Output or Pin Change Interrupt 3)\nPB2 MOSI/PCINT2 (SPI Bus Ma ster Output/Slave Input or Pin Change Interrupt 2)\nPB1 SCK/PCINT1 (SPI Bus Serial Clock or Pin Change Interrupt 1)\nPB0 SS /PCINT0 (SPI Slave Select input or Pin Change Interrupt 0)\n\n80\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nPCINT7, Pin Change Interrupt source 7: The PB7 pin can serve as an external interrupt source.\n\u0081 OC1B/PCINT6, Bit 6\nOC1B, Output Compare Match B output: The PB6 pin can serve as an external output for the\nTimer/Counter1 Output Compare B. The pin has to be configured as an output (DDB6 set (one))\nto serve this function. The OC1B pin is also the output pin for the P WM mode timer function.\nPCINT6, Pin Change Interrupt source 6: The PB6 pin can serve as an external interrupt source.\n\u0081 OC1A/PCINT5, Bit 5\nOC1A, Output Compare Match A output: The PB5 pin can serve as an external output for the\nTimer/Counter1 Output Compare A. The pin has to be configured as an output (DDB5 set (one))to serve this function. The OC1A pin is also the output pin for the P WM mode timer function.\nPCINT5, Pin Change Interrupt source 5: The PB5 pin can serve as an external interrupt source.\n\u0081 OC2A/PCINT4, Bit 4\nOC2A, Output Compare Match output: The PB4 pin can serve as an external output for the\nTimer/Counter2 Output Compare. The pin has to be configured as an output (DDB4 set (one)) toserve this function. The OC2A pin is also the output pin for the P WM mode timer function.\nPCINT4, Pin Change Interrupt source 4: The PB4 pin can serve as an external interrupt source.\n\u0081 MISO/PCINT3 \u2013 Port B, Bit 3\nMISO: Master Data input, Slave Data output pin for SPI channel. When the SPI is enabled as a\nmaster, this pin is configured as an in put regardless of the setting of DDB3. When the SPI is\nenabled as a slave, the data direction of this pin is controlled by DDB3. When the pin is forced to\nbe an input, the pull- up can still be controlled by the PORTB3 bit.\nPCINT3, Pin Change Interrupt source 3: The PB3 pin can serve as an external interrupt source.\n\u0081 MOSI/PCINT2 \u2013 Port B, Bit 2\nMOSI: SPI Master Data output, Slave Data input for SPI channel. When the SPI is enabled as a\nslave, this pin is configured as an input regardless of the setting of DDB2. When the SPI is\nenabled as a master, the data direction of this pin is controlled by DDB2. When the pin is forced\nto be an input, the pull-up can st ill be controlled by the PORTB2 bit.\nPCINT2, Pin Change Interrupt source 2: The PB2 pin can serve as an external interrupt source.\n\u0081 SCK/PCINT1 \u2013 Port B, Bit 1\nSCK: Master Clock output, Slave Clock input pin for SPI channel. When the SPI is enabled as a\nslave, this pin is configured as an input regardless of the setting of DDB1. When the SPI0 is\nenabled as a master, the data direction of this pin is controlled by DDB1. When the pin is forced\nto be an input, the pull-up can st ill be controlled by the PORTB1 bit.\nPCINT1, Pin Change Interrupt source 1: The PB1 pin can serve as an external interrupt source.\n\u0081S S\n/PCINT0 \u2013 Port B, Bit 0\nSS: Slave Port Select input. When the SPI is enabled as a slave,  this pin is configured as an\ninput regardless of the setting of DDB0. As a slav e, the SPI is activated when this pin is driven\nlow. When the SPI is enabled as a master, the data direct ion of this pin is controlled by DDB0.\nWhen the pin is forced to be an input, the pu ll-up can still be controlled by the PORTB0 bit.\n\n81\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 13-7  and Table 13-8  relate the alternate functions of Port B to the overriding signals\nshown in Figure 13-5 on page 76 . SPI MSTR INPUT and SPI SL AVE OUTPUT constitute the\nMISO signal, while MOSI is divided in to SPI MSTR OUTPUT and SPI SLAVE INPUT.\nPCINT0, Pin Change Interrupt source 0: The PB0 pin can serve as an external interrupt source.\n Table 13-7. Overriding Signals for Alternate Functions in PB7:PB4\nSignal \nName PB7/OC0A/OC1C PB6/OC1B PB5/OC1A PB4/OC2A\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nPVOE OC0/OC1C ENABLE OC1B EN ABLE OC1A ENABLE OC2A ENABLE\nPVOV OC0/OC1C OC1B OC1A OC2A\nDIEOE PCINT7 \u0081 PCIE0 PCINT6 \u0081 PCIE0 PCINT5 \u0081 PCIE0 PCINT4 \u0081 PCIE0\nDIEOV 1 1 1 1\nDI PCINT7 INPUT PCINT6 INPUT PCINT5 INPUT PCINT4 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-8. Overriding Signals for Alternate Functions in PB3:PB0\nSignal \nName PB3/MISO PB2/MO SI PB1/SCK PB0/SS\nPUOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR\nPUOV PORTB3 \u0081 PUD PORTB2 \u0081 PUD PORTB1 \u0081 PUD PORTB0 \u0081 PUD\nDDOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR\nDDOV 0 0 0 0\nPVOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR 0\nPVOV SPI SLAVE OUTPUT SPI MSTR OUTPUT SCK OUTPUT 0\nDIEOE PCINT3 \u0081 PCIE0 PCI NT2 \u0081 PCIE0 PCINT1 \u0081 PCIE0 PCINT0 \u0081 PCIE0\nDIEOV 1 1 1 1\nDISPI MSTR INPUT\nPCINT3 INPUTSPI SLAVE INPUT\nPCINT2 INPUTSCK INPUT\nPCINT1 INPUTSPI SS\nPCINT0 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\n\n82\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.3 Alternate Functions of Port C\nThe Port C alternate function is as follows:\nTable 13-10  and Table 13-11 on page 83  relate the alternate functions of Port C to the overriding\nsignals shown in Figure 13-5 on page 76 .Table 13-9. Port C Pins Alternate Functions\nPort Pin Alternate Function\nPC7 A15 (External Memory interface address bit 15)\nPC6 A14 (External Memory interface address bit 14)\nPC5 A13 (External Memory interface address bit 13)PC4 A12 (External Memory interface address bit 12)\nPC3 A11 (External Memory interface address bit 11)\nPC2 A10 (External Memory interface address bit 10)PC1 A9 (External Memory interface address bit 9)\nPC0 A8 (External Memory interface address bit 8)\nTable 13-10. Overriding Signals for Alte rnate Functions in PC7:PC4\nSignal \nName PC7/A15 PC6/A14 PC5/A13 PC4/A12\nPUOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nPUOV 0 0 0 0\nDDOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nDDOV 1 1 1 1\nPVOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nPVOV A15 A14 A13 A12\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nDI \u2013 \u2013 \u2013 \u2013\nAIO \u2013 \u2013 \u2013 \u2013\n\n83\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.4 Alternate Functions of Port D\nThe Port D pins with alternate functions are shown in Table 13-12 .\nThe alternate pin configuration is as follows:\n\u0081 T0 \u2013 Port D, Bit 7\nT0, Timer/Counter0 counter source.\n\u0081 T1 \u2013 Port D, Bit 6\nT1, Timer/Counter1 counter source.\n\u0081 XCK1 \u2013 Port D, Bit 5\nXCK1, USART1 External clock. Th e Data Direction Register (DDD5) controls whether the clock\nis output (DDD5 set) or input (DDD5 cleared).  The XCK1 pin is active only when the USART1\noperates in Synchronous mode.\n\u0081 ICP1 \u2013 Port D, Bit 4\nICP1 \u2013 Input Capture Pin 1: The PD4 pin can ac t as an input capture pin for Timer/Counter1.Table 13-11. Overriding Signals for Alte rnate Functions in PC3:PC0\nSignal \nName PC3/A11 PC2/A10 PC1/A9 PC0/A8\nPUOE SRE \u0081 (XMM<5) SRE \u0081 (XMM< 6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nP U O V 0000\nDDOE SRE \u0081 (XMM<5) SRE \u0081 (XMM<6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nDDOV 1 1 1 1\nPVOE SRE \u0081 (XMM<5) SRE \u0081 (XMM< 6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nPVOV A11 A10 A9 A8\nD I E O E 0000\nD I E O V 0000\nD I \u2013\u2013\u2013\u2013\nA I O \u2013\u2013\u2013\u2013\nTable 13-12. Port D Pins Alternate Functions\nPort Pin Alternate Function\nPD7 T0 (Timer/Counter0 Clock Input)PD6 T1 (Timer/Counter1 Clock Input)\nPD5 XCK1 (USART1 External Clock Input/Output)\nPD4 ICP1 (Timer/Counter1 Input Capture Trigger)\nPD3 INT3/TXD1 (External Interrupt3 Input or USART1 Transmit Pin)\nPD2 INT2/RXD1 (External Interrupt2 Input or USART1 Receive Pin)\nPD1 INT1/SDA (External Interrupt1 Input or T WI Serial DAta)\nPD0 INT0/SCL (External Interrupt0 Input or T WI Serial CLock)\n\n84\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 INT3/TXD1 \u2013 Port D, Bit 3\nINT3, External Interrupt source 3: The PD3 pin c an serve as an external interrupt source to the\nMCU.\nTXD1, Transmit Data (Data output pin for the USART1). When the USART1 Transmitter is\nenabled, this pin is configured as an output regardless of the value of DDD3.\n\u0081 INT2/RXD1 \u2013 Port D, Bit 2\nINT2, External Interrupt source 2. The PD2 pin can serve as an External Interrupt source to the\nMCU.\nRXD1, Receive Data (Data input pin for the USART1). When the USART1 receiver is enabled\nthis pin is configured as an input regardless of the value of DDD2. When the USART forces this\npin to be an input, the pull-up can still be controlled by the PORTD2 bit.\n\u0081 INT1/SDA \u2013 Port D, Bit 1\nINT1, External Interrupt source 1. The PD1 pin c an serve as an external interrupt source to the\nMCU.\nSDA, 2-wire Serial Interface Data: When the T WEN bit in T WCR is set (one) to enable the 2-wire\nSerial Interface, pin PD1 is disconnected from t he port and becomes the Serial Data I/O pin for\nthe 2-wire Serial Interface. In this mode, ther e is a spike filter on the pin to suppress spikes\nshorter than 50ns on the input signal, and the pin is  driven by an open drain driver with slew-rate\nlimitation.\n\u0081I N T 0 / S C L  \u2013  P o r t  D ,  B i t  0\nINT0, External Interrupt source 0. The PD0 pin c an serve as an external interrupt source to the\nMCU.\nSCL, 2-wire Serial Interface Clock: When the T WEN bit in T WCR is set (one) to enable the 2-\nwire Serial Interface, pin PD0 is disconnect ed from the port and becomes the Serial Clock I/O\npin for the 2-wire Serial Interface. In this mode, there is a spike filter on the pin to suppress\nspikes shorter than 50ns on the input signal, and the pin is driven by an open drain driver with\nslew-rate limitation.\nTable 13-13 on page 85  and Table 13-14 on page 85  relates the alternate functions of Port D to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n85\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \nNote: 1. When enabled, the 2-wire Serial Interface enable s Slew-Rate controls on the output pins PD0 \nand PD1. This is not shown in this table. In addition, spike filters are connected between the \nAIO outputs shown in the port figure and the digital logic of the T WI module.Table 13-13. Overriding Signals for Alternate Functions PD7:PD4\nSignal Name PD7/T0 PD 6/T1 PD5/XCK1 PD4/ICP1\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 XCK1 OUTPUT ENABLE 0\nDDOV 0 0 1 0\nPVOE 0 0 XCK1 OUTPUT ENABLE 0\nPVOV 0 0 XCK1 OUTPUT 0\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nDI T0 INPUT T1 INPUT XCK1 INPUT ICP1 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-14. Overriding Signals for Alte rnate Functions in PD3:PD0(1)\nSignal Name PD3/INT3/T XD1 PD2/INT2/RXD1 PD1/INT1/SDA PD0/INT0/SCL\nPUOE TXEN1 RXEN1 T WEN T WEN\nPUOV 0 PORTD2 \u0081 PUD PORTD1 \u0081 PUD PORTD0 \u0081 PUD\nDDOE TXEN1 RXEN1 T WEN T WEN\nDDOV 1 0 SDA_OUT SCL_OUT\nPVOE TXEN1 0 T WEN T WEN\nPVOV TXD1 0 0 0\nDIEOE INT3 ENABLE INT2 EN ABLE INT1 ENABLE INT0 ENABLE\nDIEOV 1 1 1 1\nDI INT3 INPUT INT2 INPUT/RX D1 INT1 INPUT INT0 INPUT\nAIO \u2013 \u2013 SDA INPUT SCL INPUT\n\n86\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.5 Alternate Functions of Port E\nThe Port E pins with alternate functions are shown in Table 13-15 .\nNote: 1. Only for ATmega1281/2561. For ATmega640/ 1280/2560 these functions are placed on \nMISO/MOSI pins.\n\u0081 INT7/ICP3/CLKO \u2013 Port E, Bit 7\nINT7, External Interrupt source 7: The PE7 pin can serve as an external interrupt source.\nICP3, Input Capture Pin 3: The PE7 pin can act as an input capture pin for Timer/Counter3.\nCLKO - Divided System Clock: The divided system clock can be output on the PE7 pin. The\ndivided system clock will be output if the CK OUT Fuse is programmed, regardless of the\nPORTE7 and DDE7 settings. It will also be output during reset.\n\u0081 INT6/T3 \u2013 Port E, Bit 6\nINT6, External Interrupt source 6: The PE6 pin can serve as an external interrupt source.\nT3, Timer/Counter3 counter source.\n\u0081 INT5/OC3C \u2013 Port E, Bit 5\nINT5, External Interrupt source 5: The PE5 pin can serve as an External Interrupt source.\nOC3C, Output Compare Match C output: The PE5 pin can serve as an External output for the\nTimer/Counter3 Output Compare C. The pin has to be configured as an output (DDE5 set \u201cone\u201d)to serve this function. The OC3C pin is also the output pin for the P WM mode timer function.Table 13-15. Port E Pins Alternate Functions\nPort Pin Alternate Function\nPE7INT7/ICP3/CLK0\n(External Interrupt 7 Input, Timer/Counter3 Inpu t Capture Trigger or Divided System Clock)\nPE6INT6/ T3\n(External Interrupt 6 Input or Timer/Counter3 Clock Input)\nPE5INT5/OC3C\n(External Interrupt 5 Input or Output Compare and P WM Output C for Timer/Counter3)\nPE4INT4/OC3B\n(External Interrupt4 Input or Output Compare and P WM Output B for Timer/Counter3)\nPE3AIN1/OC3A\n(Analog Comparator Negative In put or Output Compare and P WM Output A for \nTimer/Counter3)\nPE2AIN0/XCK0\n(Analog Comparator Positive Input or USART0 external clock input/output)\nPE1PDO(1)/TXD0\n(Programming Data Output or USART0 Transmit Pin)\nPE0PDI(1)/RXD0/PCINT8\n(Programming Data Input, USART0 Receive Pin or Pin Change Interrupt 8)\n\n87\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 INT4/OC3B \u2013 Port E, Bit 4\nINT4, External Interrupt source 4: The PE4 pin can serve as an External Interrupt source.\nOC3B, Output Compare Match B output: The PE4 pin can serve as an External output for the\nTimer/Counter3 Output Compare B. The pin has to be configured as an output (DDE4 set (one))\nto serve this function. The OC3B pin is also the output pin for the P WM mode timer function.\n\u0081 AIN1/OC3A \u2013 Port E, Bit 3\nAIN1 \u2013 Analog Comparator Negative input. This pi n is directly connected to the negative input of\nthe Analog Comparator.\nOC3A, Output Compare Match A output: The PE3 pin can serve as an External output for the\nTimer/Counter3 Output Compare A. The pin has to be configured as an output (DDE3 set \u201cone\u201d)to serve this function. The OC3A pin is also the output pin for the P WM mode timer function.\n\u0081 AIN0/XCK0 \u2013 Port E, Bit 2\nAIN0 \u2013 Analog Comparator Positive input. This pin is directly connected to the positive input of\nthe Analog Comparator.\nXCK0, USART0 External clock. Th e Data Direction Register (DDE2) controls whether the clock\nis output (DDE2 set) or input (DDE2 cleared) . The XCK0 pin is active only when the USART0\noperates in Synchronous mode.\n\u0081 PDO/TXD0 \u2013 Port E, Bit 1\nPDO, SPI Serial Programming Data Output. Duri ng Serial Program Downloading, this pin is\nused as data output line for the ATmega1281/2561. For ATmega640/1280/2560 this function isplaced on MISO.\nTXD0, USART0 Transmit pin.\n\u0081 PDI/RXD0/PCINT8 \u2013 Port E, Bit 0\nPDI, SPI Serial Programming Data Input. During Serial Program Downloading, this pin is used\nas data input line for the ATmega1281/2561. Fo r ATmega640/1280/2560 this function is placed\non MOSI.\nRXD0, USART0 Receive Pin. Receive Da ta (Data input pin for the USART0). When the\nUSART0 receiver is enabled this pin is configur ed as an input regardless of the value of DDRE0.\nWhen the USART0 forces this pin to be an input, a logical one in  PORTE0 will turn on the inter-\nnal pull-up.\nPCINT8, Pin Change Interrupt source 8: The PE0 pin can serve as an external interrupt source.\nTable 13-16 on page 88  and Table 13-17 on page 88  relates the alternate functions of Port E to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n88\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \n \nNote: 1. PDO/PDI only available at PE1/PE0 for ATmega1281/2561.Table 13-16. Overriding Signals for Alternate Functions PE7:PE4\nSignal \nName PE7/INT7/ICP3 PE6/INT6/T3 PE5/INT5/OC3C PE4/INT4/OC3B\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nPVOE 0 0 OC3C ENABLE OC3B ENABLE\nPVOV 0 0 OC3C OC3B\nDIEOE INT7 ENABLE INT6 ENABL E INT5 ENABLE INT4 ENABLE\nDIEOV 1 1 1 1\nDIINT7 INPUT/ICP3 \nINPUTINT7 INPUT/T3 \nINPUTINT5 INPUT INT4 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-17. Overriding Signals for Alternate Functions in PE3:PE0\nSignal \nName PE3/AIN1/OC3A PE2/AIN0/XCK0PE1/PDO(1)/\nTXD0PE0/PDI(1)/\nRXD0/PCINT8\nPUOE 0 0 TXEN0 RXEN0\nPUOV 0 0 0 PORTE0 \u0081 PUD\nDDOE 0XCK0 OUTPUT \nENABLETXEN0 RXEN0\nDDOV 0 1 1 0\nPVOE OC3B ENABLEXCK0 OUTPUT \nENABLETXEN0 0\nPVOV OC3B XCK0 OUTPUT TXD0 0\nDIEOE 0 0 0 PCINT8 \u0081 PCIE1\nDIEOV 0 0 0 1\nDI 0 XCK0 INPUT \u2013 RXD0\nPE0 0 0 0 PCINT8 INPUT\nAIO AIN1 INPUT AIN0 INPUT \u2013 \u2013\n\n89\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.6 Alternate Functions of Port F\nThe Port F has an alternate function as analog input for the ADC as shown in Table 13-18 . If\nsome Port F pins are configured as outputs, it is essential that these do not switch when a con-version is in progress. This might corrupt the re sult of the conversion. If the JTAG interface is\nenabled, the pull-up resistors on pins PF7(TDI), PF5(TMS), an d PF4(TCK) will be activated even\nif a Reset occurs.\n\u0081 TDI, ADC7 \u2013 Port F, Bit 7\nADC7, Analog to Digital Converter, Channel 7.\nTDI, JTAG Test Data In: Serial input data to be shifted in to the Instruction Register or Data Reg-\nister (scan chains). When the JTAG interface is enabled, th is pin can not be used as an I/O pin.\n\u0081 TDO, ADC6 \u2013 Port F, Bit 6\nADC6, Analog to Digital Converter, Channel 6.\nTDO, JTAG Test Data Out: Serial output data from Instruction Register or Data Register. When\nthe JTAG interface is enabled, this pin can not be used as an I/O pin.\nThe TDO pin is tri-stated unless TAP states that shift out data are entered.\n\u0081 TMS, ADC5 \u2013 Port F, Bit 5\nADC5, Analog to Digital Converter, Channel 5.\nTMS, JTAG Test Mode Select: This pin is used fo r navigating through the TAP-controller state\nmachine. When the JTAG interface is enabled, this pin can not be used as an I/O pin.\n\u0081 TCK, ADC4 \u2013 Port F, Bit 4\nADC4, Analog to Digital Converter, Channel 4.\nTCK, JTAG Test Clock: JTAG oper ation is synchronous to TCK. When the JTAG interface is\nenabled, this pin can not be used as an I/O pin.\n\u0081 ADC3 \u2013 ADC0 \u2013 Port F, Bit 3:0\nAnalog to Digital Converter, Channel 3:0.Table 13-18. Port F Pins Alternate Functions\nPort Pin Alternate Function\nPF7 ADC7/TDI (ADC input channel 7 or JTAG Test Data Input)\nPF6 ADC6/TDO (ADC input channel 6 or JTAG Test Data Output)PF5 ADC5/TMS (ADC input channel 5 or JTAG Test Mode Select)\nPF4 ADC4/TCK (ADC input channel 4 or JTAG Test ClocK)\nPF3 ADC3 (ADC input channel 3)PF2 ADC2 (ADC input channel 2)\nPF1 ADC1 (ADC input channel 1)\nPF0 ADC0 (ADC input channel 0)\n\n90\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \n13.3.7 Alternate Functions of Port G\nThe Port G alternate pin configuration is as follows:Table 13-19. Overriding Signals for Alternate Functions in PF7:PF4\nSignal \nName PF7/ADC7/TDI PF6/ADC6/TDO PF5/ADC5/TMS PF4/ADC4/TCK\nPUOE JTAGEN JTAGEN JTAGEN JTAGEN\nPUOV 1 0 1 1\nDDOE JTAGEN JTAGEN JTAGEN JTAGEN\nDDOV 0SHIFT_IR + \nSHIFT_DR00\nPVOE 0 JTAGEN 0 0\nPVOV 0 TDO 0 0\nDIEOE JTAGEN JTAGEN JTAGEN JTAGEN\nDIEOV 0 0 0 0\nDI \u2013 \u2013 \u2013 \u2013\nAIO TDI/ADC7 INPUT ADC6 INPUT TMS/ADC5 INPUT TCK/ADC4 INPUT\nTable 13-20. Overriding Signals for Alternate Functions in PF3:PF0\nSignal Name PF3/ADC3 PF2/ADC2 PF1/ ADC1 PF0/ADC0\nP U O E 0000\nP U O V 0000\nD D O E 0000\nD D O V 0000\nP V O E 0000\nP V O V 0000\nD I E O E 0000\nD I E O V 0000\nD I \u2013\u2013\u2013\u2013\nAIO ADC3 INPUT ADC2 INPU TA D C 1  I N P U TA D C 0  I N P U T\nTable 13-21. Port G Pins Alternate Functions\nPort Pin Alternate Function\nPG5 OC0B (Output Compare and P WM Output B for Timer/Counter0)\nPG4 TOSC1 (RTC Oscillator Timer/Counter2)\nPG3 TOSC2 (RTC Oscillator Timer/Counter2)\nPG2 ALE (Address Latch Enable to external memory)PG1 RD\n (Read strobe to external memory)\nPG0 WR (Write strobe to external memory)\n\n91\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 OC0B \u2013 Port G, Bit 5\nOC0B, Output Compare match B output: The PG5 pin can serve as an external output for the\nTImer/Counter0 Output Compare. The pin has to be configured as an output (DDG5 set) toserve this function. The OC0B pin is also the output pin for the P WM mode timer function.\n\u0081 TOSC1 \u2013 Port G, Bit 4\nTOSC2, Timer Oscillator pin 1: When the AS2 bit in ASSR is se t (one) to enabl e asynchronous\nclocking of Timer/Counter2, pin PG4 is disconnected from the port, and becomes the input of the\ninverting Oscillator amplifier. In this mode, a Cr ystal Oscillator is connected to this pin, and the\npin can not be used as an I/O pin.\n\u0081 TOSC2 \u2013 Port G, Bit 3\nTOSC2, Timer Oscillator pin 2: When the AS2 bit in ASSR is se t (one) to enabl e asynchronous\nclocking of Timer/Counter2, pin PG3 is disconnected from the port, and becomes the inverting\noutput of the Oscillator amplifier. In this mode , a Crystal Oscillator is connected to this pin, and\nthe pin can not be used as an I/O pin.\n\u0081 ALE \u2013 Port G, Bit 2\nALE is the external data memory Address Latch Enable signal.\n\u0081R D\n \u2013 Port G, Bit 1\nRD is the external data memory read control strobe.\n\u0081W R  \u2013 Port G, Bit 0\nWR is the external data memory write control strobe.\nTable 13-22 on page 91  and Table 13-23 on page 92  relates the alternate functions of Port G to\nthe overriding signals shown in Figure 13-5 on page 76 .\nTable 13-22. Overriding Signals for Alternate Functions in PG5:PG4\nSignal Name \u2014 \u2014 PG5/ OC0B PG4/TOSC1\nPUOE \u2013 \u2013 \u2013 AS2\nP U O V \u2013\u2013\u2013 0\nDDOE \u2013 \u2013 \u2013 AS2\nDDOV \u2013 \u2013 \u2013 0\nPVOE \u2013 \u2013 OC0B Enable 0\nPVOV \u2013 \u2013 OC0B 0\nP T O E \u2013\u2013\u2013 \u2013\nDIEOE \u2013 \u2013 \u2013 AS2\nDIEOV \u2013 \u2013 \u2013 EXCLK\nD I \u2013\u2013\u2013 \u2013\nAIO \u2013 \u2013 \u2013 T/C2 OSC INPUT\n\n92\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.8 Alternate Functions of Port H\nThe Port H alternate pin configuration is as follows:\n\u0081 T4 \u2013 Port H, Bit 7\nT4, Timer/Counter4 counter source.\n\u0081 OC2B \u2013 Port H, Bit 6\nOC2B, Output Compare Match B output: The PH6 pin can serve as an external output for the\nTimer/Counter2 Output Compare B. The pin has to be configured as an output (DDH6 set) to\nserve this function. The OC2B pin is also the output pin for the P WM mode timer function.\n\u0081 OC4C \u2013 Port H, Bit 5\nOC4C, Output Compare Match C output: The PH5 pin can serve as an external output for the\nTimer/Counter4 Output Compare C. The pin has to be configured  as an output (DDH5 set) to\nserve this function. The OC4C pin is also the output pin for the P WM mode timer function.Table 13-23. Overriding Signals for Alternate Functions in PG3:PG0\nSignal Name PG3/TOSC2 PG2/ALE/A7 PG1/RD PG0/WR\nPUOE AS2 \u0081 EXCLK SRE SRE SRE\nP U O V 0 000\nDDOE AS2 \u0081 EXCLK SRE SRE SRE\nDDOV 0 1 1 1\nPVOE 0 SRE SRE SRE\nPVOV 0 ALE RD WR\nP T O E \u2013 \u2013\u2013\u2013\nDIEOE AS2 \u0081 EXCLK 000\nD I E O V 0 000\nD I \u2013 \u2013\u2013\u2013\nAIO T/C2 OSC OUTPUT \u2013 \u2013 \u2013\nTable 13-24. Port H Pins Alternate Functions\nPort Pin Alternate Function\nPH7 T4 (Timer/Counter4 Clock Input)\nPH6 OC2B (Output Compare and P WM Output B for Timer/Counter2)\nPH5 OC4C (Output Compare and P WM Output C for Timer/Counter4)\nPH4 OC4B (Output Compare and P WM Output B for Timer/Counter4)\nPH3 OC4A (Output Compare and P WM Output A for Timer/Counter4)\nPH2 XCK2 (USART2 External Clock)PH1 TXD2 (USART2 Transmit Pin)\nPH0 RXD2 (USART2 Receive Pin)\n\n93\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 OC4B \u2013 Port H, Bit 4\nOC4B, Output Compare Match B output: The PH4 pin can serve as an external output for the\nTimer/Counter2 Output Compare B. The pin has to be configured as an output (DDH4 set) toserve this function. The OC4B pin is also the output pin for the P WM mode timer function.\n\u0081 OC4A \u2013 Port H, Bit 3\nOC4C, Output Compare Match A output: The PH3 pi n can serve as an external output for the\nTimer/Counter4 Output Compare A. The pin has to be configured as an output (DDH3 set) to\nserve this function. The OC4A pin is also the output pin for the P WM mode timer function.\n\u0081 XCK2 \u2013 Port H, Bit 2\nXCK2, USART2 External Clock: The Data Direction Register (DDH2) controls whether the clock\nis output (DDH2 set) or input (DDH2 cleared).  The XC2K pin is active only when the USART2\noperates in synchronous mode.\n\u0081 TXD2 \u2013 Port H, Bit 1\nTXD2, USART2 Transmit Pin.\n\u0081 RXD2 \u2013 Port H, Bit 0\nRXD2, USART2 Receive pin: Receive Da ta (Data input pin for the USART2). When the\nUSART2 Receiver is enabled, this  pin is configured as an inpu t regardless of the value of DDH0.\nWhen the USART2 forces this pin to be an input,  a logical on in PORTH0  will turn on the internal\npull-up. \nTable 13-25. Overriding Signals for Alte rnate Functions in PH7:PH4\nSignal Name PH7/T4 PH6/OC2B PH5/OC4C PH4/OC4B\nP U O E 0 000\nP U O V 0 000\nDDOE 0 0 0 0\nD D O V 0 000\nPVOE 0 OC2B ENABLE OC4C ENABLE OC4B ENABLE\nPVOV 0 OC2B OC4C OC4BP T O E \u2013 \u2013\u2013\u2013\nD I E O E 0 000\nD I E O V 0 000\nDI T4 INPUT 0 0 0\nA I O \u2013 \u2013\u2013\u2013\n\n94\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.9 Alternate Functions of Port J\nThe Port J alternate pin configuration is as follows:\n\u0081 PCINT15:12 - Port J, Bit 6:3\nPCINT15:12, Pin Change Interrupt Source 15:12. Th e PJ6:3 pins can serve as External Interrupt\nSources.\n\u0081 XCK2/PCINT11 - Port J, Bit 2\nXCK2, USART 2 External Clock. The Data Directi on Register (DDJ2) controls whether the clock\nis output (DDJ2 set) or input (DDJ2 cleared). The XCK2 pin is active only when the USART2\noperates in synchronous mode.\nPCINT11, Pin Change Interrupt Source 11. The PJ2 pin can serve as External Interrupt\nSources.Table 13-26. Overriding Signals for Alte rnate Functions in PH3:PH0\nSignal Name PH3/OC4A PH 2/XCK2 PH1/TXD2 PH0/RXD2\nPUOE 0 0 TXEN2 RXEN2\nPUOV 0 0 0 PORTH0 \u0081 PUD\nDDOE 0XCK2 OUTPUT \nENABLETXEN2 RXEN2\nD D O V 0 110\nPVOE OC4A ENABLEXCK2 OUTPUT \nENABLETXEN2 0\nPVOV OC4A XCK2 TXD2 0\nP T O E \u2013 \u2013\u2013\u2013\nD I E O E 0 000\nD I E O V 0 000\nDI 0 XC2K INPUT 0 RXD2\nA I O \u2013 \u2013\u2013\u2013\nTable 13-27. Port J Pins Alternate Functions\nPort Pin Alternate Function\nPJ7 \u2013\nPJ6 PCINT15 (Pin Change Interrupt 15)\nPJ5 PCINT14 (Pin Change Interrupt 14)PJ4 PCINT13 (Pin Change Interrupt 13)\nPJ3 PCINT12 (Pin Change Interrupt 12)\nPJ2 XCK3/PCINT11 (USART3 External Clock or Pin Change Interrupt 11)PJ1 TXD3/PCINT10 (USART3 Transmit Pin or Pin Change Interrupt 10)\nPJ0 RXD3/PCINT9 (USART3 Receive Pin or Pin Change Interrupt 9)\n\n95\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 TXD3/PCINT10 - Port J, Bit 1\nTXD3, USART3 Transmit pin.\nPCINT10, Pin Change Interrupt Source 10. The PJ1 pin can serve as External Interrupt\nSources.\n\u0081 RXD3/PCINT9 - Port J, Bit 0\nRXD3, USART3 Receive pin. Receive Da ta (Data input pin for the USART3). When the\nUSART3 Receiver is enabled, this pin is config ured as an input regardless of the value of DDJ0.\nWhen the USART3 forces th is pin to be an input, a logical on e in PORTJ0 will tu rn on the inter-\nnal pull-up.\nPCINT9, Pin Change Interrupt Source 9. The PJ 0 pin can serve as External Interrupt Sources.\nTable 13-28 on page 96  and Table 13-29 on page 96  relates the alternate functions of Port J to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n96\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.10 Alternate Functions of Port K\nThe Port K alternate pin configuration is as follows:Table 13-28. Overriding Signals for Alternate Functions in PJ7:PJ4\nSignal Name PJ7 PJ6/ PCINT1 5 PJ5/ PCINT14 PJ4/ PCINT13\nP U O E 0000\nP U O V 0000\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nP V O E 0000P V O V 0000\nP T O E ----\nDIEOE 0 PCINT15\u00b7PCIE1 PCI NT14\u00b7PCIE1 PCINT13\u00b7PCIE1\nDIEOV 0 1 1 1\nDI 0 PCINT15 INPUT PCINT14 INPUT PCINT13 INPUT\nAIO - - - -\nTable 13-29. Overriding Signals for Alternate Functions in PJ3:PJ0\nSignal Name PJ3/PCINT12PJ2/XCK3/PCINT\n11PJ1/TXD3/PCINT\n10PJ0/RXD3/PCINT\n9\nPUOE 0 0 TXEN3 RXEN3P U O V 000P O R T J 0 \u00b7 P U D\nDDOE 0 XCK3 OUTPUT \nENABLETXEN3 RXEN3\nD D O V 0110\nPVOE 0 XCK3 OUTPUT \nENABLETXEN3 0\nPVOV 0 XCK3 TXD3 0\nP T O E ----\nDIEOE PCINT12\u00b7PCIE1 PCINT11\u00b7PCIE 1 PCINT10\u00b7PCIE1 P CINT9\u00b7PCIE1\nD I E O V 1111\nDI PCINT12 INPUT PCINT11 INPUT\nXCK3 INPUTPCINT10 INPUT PCINT9 INPUT \nRXD3\nA I O ----\nTable 13-30. Port K Pins Alternate Functions\nPort Pin Alternate Function\nPK7 ADC15/PCINT23 (ADC Input Channel 15 or Pin Change Interrupt 23)\nPK6 ADC14/PCINT22 (ADC Input Channel 14 or Pin Change Interrupt 22)PK5 ADC13/PCINT21 (ADC Input Channel 13 or Pin Change Interrupt 21)\n\n97\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 ADC15:8/PCINT23:16 \u2013 Port K, Bit 7:0\nADC15:8, Analog to Digital Converter, Channel 15 - 8.\nPCINT23:16, Pin Change Interrupt Source 23:16. The PK7:0 pins can serve as External Inter-\nrupt Sources.PK4 ADC12/PCINT20 (ADC Input Channel 12 or Pin Change Interrupt 20)\nPK3 ADC11/PCINT19 (ADC Input Channel 11 or Pin Change Interrupt 19)\nPK2 ADC10/PCINT18 (ADC Input Channel 10 or Pin Change Interrupt 18)\nPK1 ADC9/PCINT17 (ADC Input Channel 9 or Pin Change Interrupt 17)\nPK0 ADC8 /PCINT16 (ADC Input Channel 8 or Pin Change Interrupt 16)\nTable 13-31. Overriding Signals for Alternate Functions in PK7:PK4\nSignal NamePK7/ADC15/\nPCINT23PK6/ADC14/\nPCINT22PK5/ADC13/\nPCINT21PK4/ADC12/\nPCINT20\nP U O E 0000\nP U O V 0000\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nP V O E 0000\nP V O V 0000\nP T O E \u2013\u2013\u2013\u2013\nDIEOE PCINT23 \u0081 PCIE2 PCINT22 \u0081 PCIE 2 PCINT21 \u0081 PCIE2 PCINT20 \u0081 PCIE2\nDIEOV 1 1 1 1\nDI PCINT23 INPUT PCINT22 INPUT PCINT21 INPUT PCINT20 INPUT\nAIO ADC15 INPUT ADC14 INPUT ADC13 INPUT ADC12 INPUTTable 13-30. Port K Pins Alternate Functions (Continued)\nPort Pin Alternate Function\n\n98\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.11 Alternate Functions of Port L\nThe Port L alternate pin configuration is as follows:\n\u0081 OC5C \u2013 Port L, Bit 5\nOC5C, Output Compare Match C output: The PL5 pin can serve as an external output for the\nTimer/Counter5 Output Compare C. The pin has to  be configured as an output (DDL5 set) to\nserve this function. The OC5C pin is also the output pin for the P WM mode timer function.\n\u0081 OC5B \u2013 Port L, Bit 4\nOC5B, Output Compare Match B output: The PL4 pin can serve as an external output for the\nTimer/Counter 5 Output Compare B. The pin has to be configured as an output (DDL4 set) to\nserve this function. The OC5B pin is also the output pin for the P WM mode timer function.\n\u0081 OC5A \u2013 Port L, Bit 3\nOC5A, Output Compare Match A output: The PL3 pin can serve as an external output for the\nTimer/Counter 5 Output Compare A. The pin has to be configured as an output (DDL3 set) to\nserve this function. The OC5A pin is also the output pin for the P WM mode timer function.Table 13-32. Overriding Signals for Alternate Functions in PK3:PK0\nSignal NamePK3/ADC11/\nPCINT19PK2/ADC10/\nPCINT18PK1/ADC9/\nPCINT17PK0/ADC8/\nPCINT16\nP U O E 0000\nP U O V 0000\nD D O E 0000\nDDOV 0 0 0 0\nP V O E 0000\nP V O V 0000\nP T O E \u2013\u2013\u2013\u2013\nDIEOE PCINT19 \u0081 PCIE2 PCI NT18 \u0081 PCIE2 PCINT17 \u0081 PCIE2 PCINT16 \u0081 PCIE2\nDIEOV 1 1 1 1\nDI PCINT19 INPUT PCINT18 INPUT PCINT17 INPUT PCINT16 INPUT\nAIO ADC11 INPUT ADC10INPUT ADC9 INPUT ADC8 INPUT\nTable 13-33. Port L Pins Alternate Functions\nPort Pin Alternate Function\nPL7 \u2013PL6 \u2013\nPL5 OC5C (Output Compare and P WM Output C for Timer/Counter5)\nPL4 OC5B (Output Compare and P WM Output B for Timer/Counter5)\nPL3 OC5A (Output Compare and P WM Output A for Timer/Counter5)\nPL2 T5 (Timer/Counter5 Clock Input)\nPL1 ICP5 (Timer/Counter5 Input Capture Trigger)PL0 ICP4 (Timer/Counter4 Input Capture Trigger)\n\n99\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 T5 \u2013 Port L, Bit 2\nT5, Timer/Counter5 counter source.\n\u0081 ICP5 \u2013 Port L, Bit 1\nICP5, Input Capture Pin 5: The PL1 pin can serve as an Input Capture pin for Timer/Counter5.\n\u0081 ICP4 \u2013 Port L, Bit 0\nICP4, Input Capture Pin 4: The PL0 pin can serve as an Input Capture pin for Timer/Counter4.\nTable 13-34  and Table 13-35  relates the alternate functions of Port L to the overriding signals\nshown in Figure 13-5 on page 76 .\nTable 13-34. Overriding Signals for Alternate Functions in PL7:PL4\nSignal Name PL7 PL6 PL5/OC5C PL4/OC5B\nP U O E 0000\nP U O V 0000\nDDOE \u2013 \u2013 0 0\nDDOV \u2013 \u2013 0 0\nPVOE \u2013 \u2013 OC5C ENABLE OC5B ENABLE\nPVOV \u2013 \u2013 OC5C OC5B\nP T O E \u2013\u2013\u2013\u2013\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nD I 0000\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-35. Overriding Signals for Alternate Functions in PL3:PL0\nSignal Name PL 3/OC5A PL2/T5 PL 1/ICP5 PL0/ICP4\nP U O E 0000\nP U O V 0000\nD D O E 0000\nD D O V 0000\nPVOE OC5A ENABLE 0 0 0\nP V O V O C 5 A 000\nP T O E \u2013\u2013\u2013\u2013\nD I E O E 0000\nD I E O V 0000\nDI 0 T5 INPUT ICP5 INPUT ICP4 INPUT\nA I O \u2013\u2013\u2013\u2013\n\n100\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4 Register Descrip tion for I/O-Ports\n13.4.1 MCUCR \u2013 MCU Control Register\n\u0081 Bit 4 \u2013 PUD: Pull-up Disable\nWhen this bit is written to one, the I/O ports pull-up resistors are disabled even if the DDxn and\nPORTxn Registers are configured to enable the pull-up resistor ({DDxn, PORTxn} = 0b01). See\u201cConfiguring the Pin\u201d on page 71  for more details about this feature.\n13.4.2 PORTA \u2013 Port A Data Register\n13.4.3 DDRA \u2013 Port A Data Direction Register13.4.4 PINA \u2013 Port A Input Pins Address\n13.4.5 PORTB \u2013 Port B Data Register\n13.4.6 DDRB \u2013 Port B Data Direction Register13.4.7 PINB \u2013 Port B Input Pins AddressBit 7 6 5 4 3 2 1 0\n0x35 (0x55) JTD \u2013 \u2013P U D \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RRR / W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x02 (0x22)\nPORTA7 PORTA6 PORTA5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 PORTA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x01 (0x21) DDA7 DDA6 DDA5 DDA4 DDA3 DDA2 DDA1 DDA0 DDRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x00 (0x20) PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 PINA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210\n0x05 (0x25) PORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 PORTB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x04 (0x24) DDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 DDRB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x03 (0x23) PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 PINB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n101\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.8 PORTC \u2013 Port C Data Register\n13.4.9 DDRC \u2013 Port C Data Direction Register\n13.4.10 PINC\u2013 Port C Input Pins Address\n13.4.11 PORTD \u2013 Port D Data Register13.4.12 DDRD \u2013 Port D Data Direction Register\n13.4.13 PIND \u2013 Port D Input Pins Address\n13.4.14 PORTE \u2013 Port E Data Register13.4.15 DDRE \u2013 Port E Data Direction RegisterB i t 76543210\n0x08 (0x28) PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 PORTC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x07 (0x27) DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 DDRC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x06 (0x26) PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 PINC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x0B (0x2B)\nPORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 PORTD\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0A (0x2A) DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 DDRD\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x09 (0x29) PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 PIND\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x0E (0x2E)\nPORTE7 PORTE6 PORTE5 PORTE4 PORTE3 PORTE2 PORTE1 PORTE0 PORTE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0D (0x2D) DDE7 DDE6 DDE5 DDE4 DDE3 DDE2 DDE1 DDE0 DDRE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n102\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.16 PINE \u2013 Port E Input Pins Address\n13.4.17 PORTF \u2013 Port F Data Register\n13.4.18 DDRF \u2013 Port F Data Direction Register\n13.4.19 PINF \u2013 Port F Input Pins Address13.4.20 PORTG \u2013 Port G Data Register\n13.4.21 DDRG \u2013 Port G Data Direction Register\n13.4.22 PING \u2013 Port G Input Pins Address13.4.23 PORTH \u2013 Port H Data RegisterB i t 76543210\n0x0C (0x2C) PINE7 PINE6 PINE5 PINE4 PINE3 PINE2 PINE1 PINE0 PINE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x11 (0x31)\nPORTF7 PORTF6 PORTF5 PORTF4 PORTF3 PORTF2 PORTF1 PORTF0 PORTF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x10 (0x30) DDF7 DDF6 DDF5 DDF4 DDF3 DDF2 DDF1 DDF0 DDRF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0F (0x2F) PINF7 PINF6 PINF5 PINF4 PINF3 PINF2 PINF1 PINF0 PINF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x14 (0x34) \u2013\u2013\nPORTG5 PORTG4 PORTG3 PORTG2 PORTG1 PORTG0 PORTG\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x13 (0x33) \u2013 \u2013 DDG5 DDG4 DDG3 DDG2 DDG1 DDG0 DDRG\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x12 (0x32) \u2013 \u2013 PING5 PING4 PING3 PING2 PING1 PING0 PING\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x102)\nPORTH7 PORTH6 PORTH5 PORTH4 PORTH3 PORTH2 PORTH1 PORTH0 PORTH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n103\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.24 DDRH \u2013 Port H Data Direction Register\n13.4.25 PINH \u2013 Port H Input Pins Address\n13.4.26 PORTJ \u2013 Port J Data Register\n13.4.27 DDRJ \u2013 Port J Data Direction Register13.4.28 PINJ \u2013 Port J Input Pins Address\n13.4.29 PORTK \u2013 Port K Data Register\n13.4.30 DDRK \u2013 Port K Data Direction Register13.4.31 PINK \u2013 Port K Input Pins AddressB i t 76543210\n(0x101) DDH7 DDH6 DDH5 DDH4 DDH3 DDH2 DDH1 DDH0 DDRH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x100) PINH5 PINH5 PINH5 PINH4 PI NH3 PINGH PINH1 PINH0 PINH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x105)\nPORTJ7 PORTJ6 PORTJ5 PORTJ4 PORTJ3 PORTJ2 PORTJ1 PORTJ0 PORTJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x104) DDJ7 DDJ6 DDJ5 DDJ4 DDJ3 DDJ2 DDJ1 DDJ0 DDRJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x103) PINJ5 PINJ5 PINJ5 PINJ4 PINJ3 PINGJ PINJ1 PINJ0 PINJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x108)\nPORTK7 PORTK6 PORTK5 PORTK4 PORTK3 PORTK2 PORTK1 PORTK0 PORTK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x107) DDK7 DDK6 DDK5 DDK4 DDK3 DDK2 DDK1 DDK0 DDRK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x106) PINK5 PINK5 PINK5 PINK4 PI NK3 PINGK PINK1 PINK0 PINK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n104\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.32 PORTL \u2013 Port L Data Register\n13.4.33 DDRL \u2013 Port L Data Direction Register\n13.4.34 PINL \u2013 Port L Input Pins AddressB i t 76543210\n(0x10B) PORTL7 PORTL6 PORTL5 PORTL4 PORTL3 PORTL2 PORTL1 PORTL0 PORTL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x10A) DDL7 DDL6 DDL5 DDL4 DDL3 DDL2 DDL1 DDL0 DDRL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x109) PINL5 PINL5 PINL5 PINL4 PINL3 PINGL PINL1 PINL0 PINL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n105\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14. Interrupts\nThis section describes the specifics of the interrupt handling as performed in\nATmega640/1280/1281/2560/2561. For a general explanation of the AVR interrupt handling,\nrefer to \u201cReset and Interrupt Handling\u201d on page 18 .\n14.1 Interrupt Vectors in  ATmega640/1280/ 1281/2560/2561\nTable 14-1. Reset and Interrupt Vectors\nVector\nNo.Program\nAddress(2)Source Interrupt Definition\n1 $0000(1)RESETExternal Pin, Power-on Reset, Brown-out Reset, \nWatchdog Reset, and JTAG AVR Reset\n2 $0002 INT0 External Interrupt Request 03 $0004 INT1 External Interrupt Request 1\n4 $0006 INT2 External Interrupt Request 2\n5 $0008 INT3 External Interrupt Request 36 $000A INT4 External Interrupt Request 4\n7 $000C INT5 External Interrupt Request 5\n8 $000E INT6 External Interrupt Request 69 $0010 INT7 External Interrupt Request 7\n10 $0012 PCINT0 Pin Change Interrupt Request 0\n11 $0014 PCINT1 Pin Change Interrupt Request 112 $0016\n(3)PCINT2 Pin Change Interrupt Request 2\n13 $0018 WDT Watchdog Time-out Interrupt\n14 $001A TIMER2 COMPA Timer /Counter2 Compare Match A\n15 $001C TIMER2 COMPB Timer /Counter2 Compare Match B\n16 $001E TIMER2 OVF Timer/Counter2 Overflow\n17 $0020 TIMER1 CAPT Timer/Counter1 Capture Event18 $0022 TIMER1 COMPA Timer /Counter1 Compare Match A\n19 $0024 TIMER1 COMPB Timer /Counter1 Compare Match B\n20 $0026 TIMER1 COMPC Timer/Counter1 Compare Match C21 $0028 TIMER1 OVF Timer/Counter1 Overflow\n22 $002A TIMER0 COMPA Timer /Counter0 Compare Match A\n23 $002C TIMER0 COMPB Timer /Counter0 Compare match B\n24 $002E TIMER0 OVF Timer/Counter0 Overflow\n25 $0030 SPI, STC SPI Serial Transfer Complete\n26 $0032 USART0 RX USART0 Rx Complete\n27 $0034 USART0 UDRE USART0 Data Register Empty\n28 $0036 USART0 TX USART0 Tx Complete29 $0038 ANALOG COMP Analog Comparator\n\n106\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. When the BOOTRST Fuse is programmed, the device will jump to the Boot Loader address at \nreset, see \u201cMemory Programming\u201d on page 335 .\n2.When the IVSEL bit in MCUCR is set, Interrupt Ve ctors will be moved to the start of the Boot \nFlash Section. The address of each Interrupt Vector will then be the address in this table \nadded to the start address of the Boot Flash Section.\n3. Only available in ATmega640/1280/2560.30 $003A ADC ADC Conversion Complete\n31 $003C EE READY EEPROM Ready\n32 $003E TIMER3 CAPT Timer/Counter3 Capture Event\n33 $0040 TIMER3 COMPA Timer/Counter3 Compare Match A\n34 $0042 TIMER3 COMPB Timer/Counter3 Compare Match B35 $0044 TIMER3 COMPC Timer/Counter3 Compare Match C\n36 $0046 TIMER3 OVF Timer/Counter3 Overflow\n37 $0048 USART1 RX USART1 Rx Complete38 $004A USART1 UDRE USART1 Data Register Empty\n39 $004C USART1 TX USART1 Tx Complete\n40 $004E T WI 2-wire Serial Interface\n41 $0050 SPM READY Store Program Memory Ready\n42 $0052\n(3)TIMER4 CAPT Timer/Counter4 Capture Event\n43 $0054 TIMER4 COMPA Timer/Counter4 Compare Match A44 $0056 TIMER4 COMPB Timer/Counter4 Compare Match B\n45 $0058 TIMER4 COMPC Timer/Counter4 Compare Match C\n46 $005A TIMER4 OVF Timer/Counter4 Overflow47 $005C\n(3)TIMER5 CAPT Timer/Counter5 Capture Event\n48 $005E TIMER5 COMPA Timer/Counter5 Compare Match A\n49 $0060 TIMER5 COMPB Timer/Counter5 Compare Match B50 $0062 TIMER5 COMPC Timer/Counter5 Compare Match C\n51 $0064 TIMER5 OVF Timer/Counter5 Overflow\n52 $0066\n(3)USART2 RX USART2 Rx Complete\n53 $0068(3)USART2 UDRE USART2 Data Register Empty\n54 $006A(3)USART2 TX USART2 Tx Complete\n55 $006C(3)USART3 RX USART3 Rx Complete\n56 $006E(3))USART3 UDRE USART3 Data Register Empty\n57 $0070(3)USART3 TX USART3 Tx CompleteTable 14-1. Reset and Interrupt Vectors (Continued)\nVector\nNo.Program\nAddress(2)Source Interrupt Definition\n\n107\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.2 Reset and Interr upt Vector placement\nTable 14-2  shows Reset and Interrupt Vectors placement for the various combinations of\nBOOTRST and IVSEL settings. If the program never enables an in terrupt source, the Interrupt\nVectors are not used, and regular program code can be placed at these locations. This is alsothe case if the Reset Vector is in the Application section while the Interrupt Vectors are in the\nBoot section or vice versa.\nNote: 1. The Boot Reset Address is shown in Table 29-7 on page 328  through Table 29-15 on page \n332. For the BOOTRST Fuse \u201c1\u201d means unprogrammed while \u201c0\u201d means programmed.\nThe most typical and general program setup for the Reset and Interrupt Vector Addresses in\nATmega640/1280/1281/2560/2561 is:Table 14-2. Reset and Interrupt Vectors Placement(1)\nBOOTRST IVSEL Reset Address Interrupt Vectors Start Address\n1 0 0x0000 0x0002\n1 1 0x0000 Boot Reset Address + 0x0002\n0 0 Boot Reset Address 0x00020 1 Boot Reset Address Boot Reset Address + 0x0002\nAddress Labels Code Comments\n0x0000 jmp RESET ; Reset Handler0x0002 jmp INT0 ; IRQ0 Handler0x0004 jmp INT1 ; IRQ1 Handler0x0006 jmp INT2 ; IRQ2 Handler0x0008 jmp INT3 ; IRQ3 Handler0x000A jmp INT4 ; IRQ4 Handler0x000C jmp INT5 ; IRQ5 Handler0x000E jmp INT6 ; IRQ6 Handler0x0010 jmp INT7 ; IRQ7 Handler0x0012 jmp PCINT0 ; PCINT0 Handler0x0014 jmp PCINT1 ; PCINT1 Handler0x0016 jmp PCINT2 ; PCINT2 Handler0X0018 jmp WDT ; Watchdog Timeout Handler0x001A jmp TIM2_COMPA ; Timer2 CompareA Handler0x001C jmp TIM2_COMPB ; Timer2 CompareB Handler0x001E jmp TIM2_OVF ; Timer2 Overflow Handler0x0020 jmp TIM1_CAPT ; Timer1 Capture Handler0x0022 jmp TIM1_COMPA ; Timer1 CompareA Handler0x0024 jmp TIM1_COMPB ; Timer1 CompareB Handler0x0026 jmp TIM1_COMPC ; Timer1 CompareC Handler0x0028 jmp TIM1_OVF ; Timer1 Overflow Handler0x002A jmp TIM0_COMPA ; Timer0 CompareA Handler0x002C jmp TIM0_COMPB ; Timer0 CompareB Handler0x002E jmp TIM0_OVF ; Timer0 Overflow Handler0x0030 jmp SPI_STC ; SPI Transfer Complete Handler0x0032 jmp USART0_RXC ; USART0 RX Complete Handler0x0034 jmp USART0_UDRE ; USART0,UDR Empty Handler0x0036 jmp USART0_TXC ; USART0 TX Complete Handler0x0038 jmp ANA_COMP ; Analog Comparator Handler0x003A jmp ADC ; ADC Conversion Complete Handler0x003C jmp EE_RDY ; EEPROM Ready Handler0x003E jmp TIM3_CAPT ; Timer3 Capture Handler\n\n108\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the BOOTRST Fuse is unprogrammed, the Boot section size set to 8Kbytes and the\nIVSEL bit in the MCUCR Register is set before an y interrupts are enabled, the most typical and\ngeneral program setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n0x00000 RESET: ldi r16,high(RAMEND); Main program start\n0x00001 out SPH,r16 ; Set Stack Pointer to top of RAM0x00002 ldi r16,low(RAMEND)\n0x00003 out SPL,r16\n0x00004 sei ; Enable interrupts\n0x00005 <instr>  xxx\n;\n.org 0x1F0020x1F002 jmp EXT_INT0 ; IRQ0 Handler\n0x1F004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; \n0x1FO70 jmp USART3_TXC ; USART3 TX Complete Handler0x0040 jmp TIM3_COMPA ; Timer3 CompareA Handler\n0x0042 jmp TIM3_COMPB ; Timer3 CompareB Handler0x0044 jmp TIM3_COMPC ; Timer3 CompareC Handler0x0046 jmp TIM3_OVF ; Timer3 Overflow Handler0x0048 jmp USART1_RXC ; USART1 RX Complete Handler0x004A jmp USART1_UDRE ; USART1,UDR Empty Handler0x004C jmp USART1_TXC ; USART1 TX Complete Handler0x004E jmp TWI ; 2-wire Serial Handler0x0050 jmp SPM_RDY ; SPM Ready Handler0x0052 jmp TIM4_CAPT ; Timer4 Capture Handler0x0054 jmp TIM4_COMPA ; Timer4 CompareA Handler0x0056 jmp TIM4_COMPB ; Timer4 CompareB Handler0x0058 jmp TIM4_COMPC ; Timer4 CompareC Handler0x005A jmp TIM4_OVF ; Timer4 Overflow Handler0x005C jmp TIM5_CAPT ; Timer5 Capture Handler0x005E jmp TIM5_COMPA ; Timer5 CompareA Handler0x0060 jmp TIM5_COMPB ; Timer5 CompareB Handler0x0062 jmp TIM5_COMPC ; Timer5 CompareC Handler0x0064 jmp TIM5_OVF ; Timer5 Overflow Handler0x0066 jmp USART2_RXC ; USART2 RX Complete Handler0x0068 jmp USART2_UDRE ; USART2,UDR Empty Handler\n0x006A jmp USART2_TXC ; USART2 TX Complete Handler\n0x006C jmp USART3_RXC ; USART3 RX Complete Handler0x006E jmp USART3_UDRE ; USART3,UDR Empty Handler0x0070 jmp USART3_TXC ; USART3 TX Complete Handler;0x0072 RESET: ldi r16, high(RAMEND) ; Main program start0x0073 out SPH,r16 ; Set Stack Pointer to top of RAM0x0074 ldi r16, low(RAMEND)0x0075 out SPL,r160x0076 sei ; Enable interrupts0x0077 <instr> xxx\n... ... ... ...\n\n109\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the BOOTRST Fuse is programmed and the Boot section size set to 8Kbytes, the most\ntypical and general program setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n.org 0x0002\n0x00002 jmp EXT_INT0 ; IRQ0 Handler\n0x00004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; \n0x00070 jmp USART3_TXC ; USART3 TX Complete Handler;\n.org 0x1F000\n0x1F000 RESET: ldi r16,high(RAMEND); Main program start\n0x1F001 out SPH,r16 ; Set Stack Pointer to top of RAM\n0x1F002 ldi r16,low(RAMEND)\n0x1F003 out SPL,r16\n0x1F004 sei ; Enable interrupts\n0x1F005 <instr>  xxx\nWhen the BOOTRST Fuse is programmed, the Boot section size set to 8Kbytes and the IVSEL\nbit in the MCUCR Register is set before any interr upts are enabled, the mo st typical and general\nprogram setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n;\n.org 0x1F000\n0x1F000 jmp RESET ; Reset handler0x1F002 jmp EXT_INT0 ; IRQ0 Handler\n0x1F004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; 0x1F070 jmp USART3_TXC ; USART3 TX Complete Handler\n;\n0x1F072 RESET: ldi r16,high(RAMEND) ; Main program start\n0x1F073 out SPH,r16 ; Set Stack Pointer to top of RAM\n0x1F074 ldi r16,low(RAMEND)0x1F075 out SPL,r16\n0x1F076 sei ; Enable interrupts\n0x1FO77 <instr>  xxx\n14.3 Moving Interrupts Between A pplication and Boot Section\nThe MCU Control Register controls the placement of the Interrupt Vector table, see Code Exam-\nple below. For more details, see \u201cReset and Interrupt Handling\u201d on page 18 .\n\n110\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.4 Register Description\n14.4.1 MCUCR \u2013 MCU Control Register\n\u0081 Bit 1 \u2013 IVSEL: Interrupt Vector Select\nWhen the IVSEL bit is clea red (zero), the Interrupt Vectors ar e placed at the st art of the Flash\nmemory. When this bit is set (one), the Interrupt Vectors are moved to the beginning of the Boot\nLoader section of the Flash. The actual address of the start of the Boot Flash Section is deter-\nmined by the BOOTSZ Fuses. Refer to the section \u201cMemory Programming\u201d on page 335  for\ndetails. To avoid unintentional changes of Interrupt  Vector tables, a special write procedure must\nbe followed to change  the IVSEL bit (see \u201cMoving Interrupts Between Application and Boot Sec-\ntion\u201d on page 109 ):\n1.Write the Interrupt Vector Change Enable (IVCE) bit to one.\n2.Within four cycles, write the desired value to IVSEL while writing a zero to IVCE.Assembly Code Example\nMove_interrupts:\n; Get MCUCR\nin r16, MCUCR\nmov r17, r16\n; Enable change of Interrupt Vectors\nori r16, (1<<IVCE)\nout MCUCR, r16\n; Move interrupts to Boot Flash sectionori r16, (1<<IVSEL)\nout MCUCR, r17\nret\nC Code Example\nvoid Move_interrupts( void)\n{\nuchar temp;\n/* Get MCUCR */\ntemp = MCUCR;\n/* Enable change of Interrupt Vectors */\nMCUCR = temp|(1<<IVCE);\n/* Move interrupts to Boot Flash section */\nMCUCR = temp|(1<<IVSEL); \n}\nB i t 76543210\n0x35 (0x55) JTD \u2013 \u2013 PUD \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RR R / W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n111\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nInterrupts will automatically be di sabled while this sequence is executed. Interrupts are disabled\nin the cycle IVCE is set, and they remain disabl ed until after the instru ction following the write to\nIVSEL. If IVSEL is not written, interrupts remain disabled for four cycles. The I-bit in the Status\nRegister is unaffected by the automatic disabling.\nNote: If Interrupt Vectors are placed in the Boot Loader section and Boot Lock bit BLB02 is programmed, \ninterrupts are disabled while executing from the A pplication section. If Interrupt Vectors are placed \nin the Application section and Boot Lock bit BLB 12 is programed, interrupts are disabled while \nexecuting from the Boot Loader section. Refer to the section \u201cMemory Programmi ng\u201d on page 335  \nfor details on Boot Lock bits.\n\u0081 Bit 0 \u2013 IVCE: Interrupt Vector Change Enable\nThe IVCE bit must be written to  logic one to enable change of the IVSEL bit. IVCE is cleared by\nhardware four cyc les after it is written or when IVSEL is written. Sett ing the IVCE bit will disable\ninterrupts, as explained in the IVSEL description.\n\n112\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n15. External Interrupts\nThe External Interrupts are triggered by the INT7:0 pin or any of the PCINT23:0 pins. Observe\nthat, if enabled, the interrupts w ill trigger even if the INT7:0 or PCINT23:0 pins are configured as\noutputs. This feature provides a way of generating a software interrupt.\nThe Pin change interrupt PCI2 will trigger if any enabled PC INT23:16 pin toggles, Pin change\ninterrupt PCI1 if any enabled PCINT15:8 toggles and Pin change interrupts PCI0 will trigger if\nany enabled PCINT7:0 pin toggles. PCMSK2, PCMSK1 and PCMSK0 Re gisters control which\npins contribute to the pin change interrupts. Pin change interrupts on PCINT23 :0 are detected\nasynchronously. This implies that these interrupts can be used for waking the part also from\nsleep modes other than Idle mode.\nThe External Interrupts can be triggered by a falli ng or rising edge or a low level. This is set up\nas indicated in the specification for the External Interrupt Control Registers \u2013 EICRA (INT3:0)\nand EICRB (INT7:4). When the external interrupt is enabled and is configured as level triggered,\nthe interrupt will trigger as long as the pin is held  low. Note that recognition of falling or rising\nedge interrupts on INT7:4 requires the presence of an I/O clock, described in \u201cOverview\u201d on\npage 40 . Low level interrupts and the edge interrupt on INT3:0 are detected asynchronously.\nThis implies that these interrupts can be used for waking the part also from sleep modes other\nthan Idle mode. The I/O clock is halted in all sleep modes except Idle mode.\nNote that if a level triggered interrupt is used for wake-up from Power-down, the required level\nmust be held long enough for the MCU to complete the wake-up to trigger the level interrupt. If\nthe level disappears before the end of the Start-up Ti me, the MCU will still wake  up, but no inter-\nrupt will be generated. The start- up time is defined by the SU T and CKSEL Fuses as described\nin \u201cSystem Clock and Clock Options\u201d on page 40 .\n15.1 Pin Change Interrupt Timing\nAn example of timing of a pin change interrupt is shown in Figure 15-1 on page 113 .\n\n113\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 15-1. Normal pin change interrupt.\n15.2 Register Description\n15.2.1 EICRA \u2013 External Interrupt Control Register A\nThe External Interrupt Control Register A contains control bits for interrupt sense control.\n\u0081 Bits 7:0 \u2013 ISC31, ISC30 \u2013 ISC00, ISC00: External Interrupt 3 - 0 Sense Control Bits\nThe External Interrupts 3 - 0 are activated by the external pins INT3:0 if the SREG I-flag and the\ncorresponding interrupt mask in the EIMSK is set. The level and edges on the external pins thatactivate the interrupts are defined in Table 15-1 on page 114 . Edges on INT3:0 are registered\nasynchronously. Pulses on INT3:0 pins wider than the minimum pulse width given in Table 15-2\non page 114  will generate an interrupt. Shorter pulses  are not guaranteed to generate an inter-\nrupt. If low level interrupt is se lected, the low level must be held until the completion of the\ncurrently executing instru ction to generate an interrupt. If e nabled, a level trig gered inte rrupt will\ngenerate an interrupt request as long as the pin is held low. When changing the ISCn bit, an\ninterrupt can occur. Therefore, it is recommended to first disable INTn by clearing its Interrupt\nEnable bit in the EIMSK Register. Then, the ISCn bit can be changed. Finally, the INTn interrupt\nflag should be cleared by writing a logical one to its Interrupt Flag bit (INTFn) in the EIFR Regis-\nter before the interrupt is re-enabled.clk\nPCINT(n)\npin_lat\npin_sync\npcint_in_(n)\npcint_syn\npcint_setflag\nPCIFPCINT(0)\npin_syncpcint_synpin_lat\nD     Q\nLEpcint_setflag\nPCIF\nclk\nclk PCINT(0) in PCM SK(x)pcint_in_(0)\n0\nx\nB i t 76543210\n(0x69) I S C 3 1I S C 3 0I S C 2 1I S C 2 0I S C 1 1I S C 1 0I S C 0 1I S C 0 0 E I C R A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n114\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. n = 3, 2, 1or 0.\nWhen changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt \nEnable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.\n15.2.2 EICRB \u2013 External Interrupt Control Register B\n\u0081 Bits 7:0 \u2013 ISC71, ISC70 - ISC41, ISC40: External Interrupt 7 - 4 Sense Control Bits\nThe External Interrupts 7 - 4 are activated by the external pins INT7:4 if the SREG I-flag and the\ncorresponding interrupt mask in the EIMSK is set. The level and edges on the external pins thatactivate the interrupts are defined in Table 15-3 . The value on the INT7:4 pins are sampled\nbefore detecting edges. If edge or toggle interrupt is selected, pulses that last longer than one\nclock period will generate an interrupt. Shorter pulses are not guaranteed to generate an inter-rupt. Observe that CPU clock frequency can be lower than the XTAL frequency if the XTALdivider is enabled. If low level interrupt is se lected, the low level must be held until the comple-\ntion of the currently executing instruction to generate an interrupt. If enabled, a level triggered\ninterrupt will generate an interrupt request as long as the pin is held low.\nNote: 1. n = 7, 6, 5 or 4.\nWhen changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt \nEnable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.Table 15-1.  Interrupt Sense Control(1)\nISCn1 ISCn0 Description\n0 0 The low level of INTn generates an interrupt request\n0 1 Any edge of INTn generates asynchronously an interrupt request\n1 0 The falling edge of INTn generates asynchronously an interrupt request\n1 1 The rising edge of INTn generates asynchronously an interrupt request\nTable 15-2. Asynchronous External Interrupt Characteristics\nSymbol Parameter Condition Min Typ Max Units\ntINTMinimum pulse width for asynchronous \nexternal interrupt50 ns\nB i t 76543210\n(0x6A) ISC71 ISC70 ISC61 ISC60 ISC51 ISC50 ISC41 ISC40 EICRB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 15-3.  Interrupt Sense Control(1)\nISCn1 ISCn0 Description\n0 0 The low level of INTn generates an interrupt request\n0 1 Any logical change on INTn generates an interrupt request1 0 The falling edge between two samples of INTn generates an interrupt request\n1 1 The rising edge between two samples of INTn generates an interrupt request\n\n115\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n15.2.3 EIMSK \u2013 External Interrupt Mask Register\n\u0081 Bits 7:0 \u2013 INT7:0: External Interrupt Request 7 - 0 Enable\nWhen an INT7:0 bit is written to one and the I-bit in the Status Register (SREG) is set (one), the\ncorresponding external pin interrupt is enabled. The Interrupt Sense Control bits in the External\nInterrupt Control Registers \u2013 EICRA and EICRB \u2013 defines whether the external interrupt is acti-\nvated on rising or fal ling edge or level sensed. Activity on  any of these pins will trigger an\ninterrupt request even if the pin is enabled as an output. This provides a way of generating a\nsoftware interrupt.\n15.2.4 EIFR \u2013 External Interrupt Flag Register\n\u0081 Bits 7:0 \u2013 INTF7:0: External Interrupt Flags 7 - 0\nWhen an edge or logic change on the INT7:0 pin triggers an interrupt request, INTF7:0 becomes\nset (one). If the I-bit in SREG and the corresponding interrupt enable bit, INT7:0 in EIMSK, are\nset (one), the MCU will jump  to the interrupt vector . The flag is cleared wh en the interr upt routine\nis executed. Alternatively, the flag can be cleared by writing a logical one to it. These flags arealways cleared when INT7:0 are configured as level interrupt. Note that when entering sleep\nmode with the INT3:0 inte rrupts disabled, the input buffers on these pins will be disabled. This\nmay cause a logic change in internal si gnals which will set the INTF3:0 flags. See \u201cDigital Input\nEnable and Sleep Modes\u201d on page 74  for more information.\n15.2.5 PCICR \u2013 Pin Change Interrupt Control Register\n\u0081 Bit 2 \u2013 PCIE2: Pin Change Interrupt Enable 1\nWhen the PCIE2 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 2 is enabled. Any change on any enabled PCINT23:16 pin will cause an inter-\nrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI2Interrupt Vector. PCINT23:16 pins are enabled individually by the PCMSK2 Register.\n\u0081 Bit 1 \u2013 PCIE1: Pin Change Interrupt Enable 1\nWhen the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 1 is enabled. Any change on any enabled PCINT15:8 pin will cause an inter-\nrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1Interrupt Vector. PCINT15:8 pins are enabled individually by the PCMSK1 Register.B i t 76543210\n0x1D (0x3D) INT7 INT6 INT5 INT4 INT3 INT2 INT1 INT0 EIMSK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x1C (0x3C) INTF7 INTF6 INTF5 INTF4 INTF3 INTF2 INTF1 IINTF0 EIFR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210\n(0x68) \u2013 \u2013 \u2013 \u2013 \u2013 PCIE2 PCIE1 PCIE0 PCICR\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\n\n116\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 PCIE0: Pin Change Interrupt Enable 0\nWhen the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 0 is enabled. Any change on any enabled PCINT7 :0 pin will cause an interrupt.\nThe corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt\nVector. PCINT7:0 pins are enabled individually by the PCMSK0 Register.\n15.2.6 PCIFR \u2013 Pin Change Interrupt Flag Register\n\u0081 Bit 2 \u2013 PCIF2: Pin Change Interrupt Flag 1\nWhen a logic change on any PCINT23:16 pin triggers an interrupt request, PCIF2 becomes set\n(one). If the I-bit in SREG and the PCIE2 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n\u0081 Bit 1 \u2013 PCIF1: Pin Change Interrupt Flag 1\nWhen a logic change on any PCINT15:8 pin trigge rs an interrupt request, PCIF1 becomes set\n(one). If the I-bit in SREG and the PCIE1 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n\u0081 Bit 0 \u2013 PCIF0: Pin Change Interrupt Flag 0\nWhen a logic change on any PCINT7:0 pin triggers an interrupt request, PCIF0 becomes set\n(one). If the I-bit in SREG and the PCIE0 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n15.2.7 PCMSK2 \u2013 Pin Change Mask Register 2\n\u0081 Bit 7:0 \u2013 PCINT23:16: Pin Change Enable Mask 23:16\nEach PCINT23:16-bit selects whether pin change interrupt is enabled on the corresponding I/O\npin. If PCINT23:16 is set and the PCIE2 bit in PCICR is set, pin change interrupt is enabled on\nthe corresponding I/O pin. If PCINT23:16 is cleared, pin change interrupt on the corresponding\nI/O pin is disabled.\n15.2.8 PCMSK1 \u2013 Pin Change Mask Register 1B i t 76543210\n0x1B (0x3B) \u2013 \u2013 \u2013 \u2013 \u2013 PCIF2 PCIF1 PCIF0 PCIFR\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x6D)\nPCINT23 PCINT22 PCINT21 PCINT20 PCINT19 PCINT18 PCINT17 PCINT16 PCMSK2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x6C)\nPCINT15 PCINT14 PCINT13 PCINT12 PCINT11 PCINT10 PCINT9 PCINT8 PCMSK1\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n117\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7:0 \u2013 PCINT15:8: Pin Change Enable Mask 15:8\nEach PCINT15:8-bit selects whether pin change interrupt is enabled on the corresponding I/O\npin. If PCINT15:8 is set and the PCIE1 bit in EIMSK is set, pin change interrupt is enabled on the\ncorresponding I/O pin. If PCINT15:8 is cleared, pin change interrupt on the corresponding I/O\npin is disabled.\n15.2.9 PCMSK0 \u2013 Pin Change Mask Register 0\n\u0081 Bit 7:0 \u2013 PCINT7:0: Pin Change Enable Mask 7:0\nEach PCINT7:0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin.\nIf PCINT7:0 is set and the PCIE0 bit in PCICR is set, pin change interrupt is enabled on the cor-\nresponding I/O pin. If PCINT7:0 is cleared, pi n change interrupt on the corresponding I/O pin is\ndisabled.B i t 76543210\n(0x6B) PCINT7 PCINT6 PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 PCMSK0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n118\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16. 8-bit Timer/Counter0 with PWM\n16.1 Features\n\u0081Two Independent Output Compare Units\n\u0081Double Buffered Outp ut Compare Registers\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch Free, Phase Correct Pulse Width Modulator (PWM)\n\u0081Variable PWM Period\n\u0081Frequency Generator\n\u0081Three Independent Interrupt Sources (TOV0, OCF0A, and OCF0B)\n16.2 Overview\nTimer/Counter0 is a general purpose 8-bit Time r/Counter module, with two independent Output\nCompare Units, and with P WM support. It allows accurate program execution timing (event man-\nagement) and wave generation.\nA simplified block diagram of the 8-bit Timer/Counter is shown in Figure 16-1 . For the actual\nplacement of I/O pins, refer to \u201cTQFP-pinout ATmega640/1280/2560\u201d on page 2 . CPU accessi-\nble I/O Registers, including I/O bits and I/O pi ns, are shown in bold. The device-specific I/O\nRegister and bit locations are listed in the \u201cRegister Description\u201d on page 129 .\nFigure 16-1. 8-bit Timer/Counter Block Diagram \n16.2.1 Registers\nThe Timer/Counter (TCNT0) and Output Compare Registers (OCR0A and OCR0B) are 8-bit\nregisters. Interrupt request (abbreviated to Int.Req . in the figure) signals are all visible in the\nTimer Interrupt Flag Register (T IFR0). All interrupts are individually masked with the Timer Inter-\nrupt Mask Register (TIMSK0). TIFR0 and TIMSK0 are not shown in the figure.\nThe Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on\nthe T0 pin. The Clock Select logic block controls which clock source and edge the Timer/CounterClock Select\nTimer/Counter\nDATA BUSOCRnA\nOCRnB=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB=\nFixed\nTOP\nValueControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int.Req.)\nOCnA(Int.Req.)\nOCnB\n(Int.Req.)\nTCCRnA TCCRnBTnEdge\nDetector\n( From Prescaler )clkTn\n\n119\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nuses to increment (or decrement) its value. The Timer/Counter is inactive when no clock source\nis selected. The output from the Clock Select logic is referred to as the timer clock (clkT0).\nThe double buffered Output Compare Registers (OCR0A and OCR0B) are compared with the\nTimer/Counter value at all times. The result of the compare can be used by the Waveform Gen-\nerator to generate a P WM or variable frequency output on the Output Compare pins (OC0A and\nOC0B). See \u201cOutput Compare Unit\u201d on page 120.  for details. The Compare Match event will also\nset the Compare Flag (OCF0A or OCF0B) which can be used to generate an Output Compareinterrupt request.\n16.2.2 Definitions\nMany register and bit references in this section are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case 0. A lower case \u201cx\u201d replaces the Output Com-\npare Unit, in this case Compare Unit A or Compare Unit B. Howe ver, when using the register or\nbit defines in a program, the precise form must be used, that is, TCNT0 for accessing\nTimer/Counter0 counter value and so on.\nThe definitions in Table 16-1  are also used extensively throughout the document.\n16.3 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the Clock Select  logic which is controlled by the Clock Select (CS02:0) bits\nlocated in the Timer/Counter Control Register (TCCR0B). For details on clock sources and pres-\ncaler, see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169 .\n16.4 Counter Unit\nThe main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure\n16-2 shows a block diagram of the counter and its surroundings.\nFigure 16-2. Counter Unit Block DiagramTable 16-1. Definitions\nBOTTOM The counter reaches the BOTTOM when it becomes 0x00.\nMAX The counter reaches its MAXimum when it becomes 0xFF (decimal 255).TOP The counter reaches the TOP when it becomes equal to the highest value in the\ncount sequence. The TOP value can be assigned to be the fixed value 0xFF(MAX) or the value stored in the OCR0A Register. The assignment is depen-\ndent on the mode of operation.\nDATA BU S\nTCNTn Control LogiccountTOVn\n(Int.Req.)\nClock Select\ntopTnEdge\nDetector\n( From Prescaler )clkTn\nbottomdirectionclear\n\n120\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSignal description (internal signals):\ncount Increment or decrement TCNT0 by 1.\ndirection Select between increment and decrement.\nclear Clear TCNT0 (set all bits to zero).\nclkTn Timer/Counter clock, referred to as clkT0 in the following.\ntop Signalize that TCNT0 has  reached maximum value.\nbottom Signalize that TCNT0 has re ached minimum value (zero).\nDepending of the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock (clkT0). clkT0 can be generated from an external or internal clock source,\nselected by the Clock Select bits (CS02:0). When no clock source is selected (CS02:0 = 0) the\ntimer is stopped. However, the TCNT0 value can be accessed by the CPU, regardless of\nwhether clkT0 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the WGM01 and WGM00 bits located in\nthe Timer/Counter Control Register (TCCR0A) and the WGM02 bit located in the Timer/Counter\nControl Register B (TCCR0B). There are clos e connections between how the counter behaves\n(counts) and how waveforms are generated on the Output Compare outputs OC0A and OC0B.\nFor more details about advanced counting sequences and waveform generation, see \u201cModes of\nOperation\u201d on page 123 .\nThe Timer/Counter Overflow Flag (TOV0) is set according to the mode of operation selected by\nthe WGM02:0 bits. TOV0 can be used for generating a CPU interrupt.\n16.5 Output Compare Unit\nThe 8-bit comparator continuously compares TCNT0 with the Output Compare Registers\n(OCR0A and OCR0B). Whenever TCNT0 equals OCR0A or OCR0B, the comparator signals a\nmatch. A match will set the Output  Compare Flag (OCF0A or OCF0 B) at the next timer clock\ncycle. If the corresponding interrupt is enabled, the Output Compare Flag generates an OutputCompare interrupt. The Output Compare Flag is automatically cleared when the interrupt is exe-cuted. Alternatively, the flag can be cleared by software by writing a logical one to its I/O bit\nlocation. The Waveform Generator uses the match signal  to generate an output according to\noperating mode set by the WGM02:0 bits and Compare Output mode (COM0x1:0) bits. The\nmaximum and bottom signals are used by the Waveform Generator for handling the special\ncases of the extreme values in some modes of operation ( \u201cModes of Operation\u201d on page 123 ).\nFigure 16-3 on page 121  shows a block diagram of the Output Compare unit.\n\n121\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-3. Output Compare Unit, Block Diagram\nThe OCR0x Registers are double buffered when using any of the Pulse Width Modulation\n(PWM) modes. For the normal and Clear Timer on Compare (CTC) modes of operation, the dou-\nble buffering is disabled. The double buffering synchronizes the update of the OCR0x Compare\nRegisters to either top or bottom of the counting sequence. The synchronization prevents the\noccurrence of odd-length, non-symmetrical P WM pulses, thereby making the output glitch-free.\nThe OCR0x Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR0x Buffer Register, and if double buffering is dis-\nabled the CPU will access  the OCR0x directly.\n16.5.1 Force Output Compare\nIn non-P WM waveform generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Outp ut Compare (FOC0x) bit. Forcin g Compare Match will not set the\nOCF0x Flag or reload/clear the timer, but the OC0x pin will be updated as if a real Compare\nMatch had occurred (the COM0x1:0 bits settings de fine whether the OC0x pin is set, cleared or\ntoggled).\n16.5.2 Compare Match Bloc king by TCNT0 Write\nAll CPU write operations to the TCNT0 Register  will block any Compare Ma tch that occur in the\nnext timer clock cycle, even when the timer is stopped. This feature allows OCR0x to be initial-\nized to the same value as TCNT0 without triggering an interrupt when the Timer/Counter clock isenabled.\n16.5.3 Using the Output Compare Unit\nSince writing TCNT0 in any mo de of operation will block all Compare Matches for one timer\nclock cycle, there are risks involved when ch anging TCNT0 when using the Output Compare\nUnit, independently of whether the Timer/Counter is running or not. If the value written to TCNT0equals the OCR0x value, the Compare Match will be missed, resulting in incorrect waveformOCFn x (Int.Req.)= (8-bit Comparator )OCRnx\nOCnxDATA BU S\nTCNTn\nWGMn1:0Waveform Generatortop\nFOCn\nCOMnX1:0bottom\n\n122\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ngeneration. Similarly, do not write the TCNT0 value equal to BOTTOM when the counter is\ndown-counting.\nThe setup of the OC0x should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OC0x value is to use the Force Output Com-pare (FOC0x) strobe bits in Normal mode. The OC0x Registers keep their values even when\nchanging between Waveform Generation modes.\nBe aware that the COM0x1:0 bits are not doubl e buffered together with the compare value.\nChanging the COM0x1:0 bits will take effect immediately.\n16.6 Compare Match Output Unit\nThe Compare Output mode (COM0x1:0) bits have two functions. The Waveform Generator uses\nthe COM0x1:0 bits for defining the Output Compare (OC0x) state at the next Compare Match.Also, the COM0x1:0 bits control the OC0x pin output source. Figure 16-4  shows a simplified\nschematic of the logic affected by the COM0x1:0 bit setting. The I/O Registers, I/O bits, and I/O\npins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers(DDR and PORT) that are affected by the COM0x1:0 bits are shown. When referring to the\nOC0x state, the reference is for the internal OC0x  Register, not the OC0x pin. If a system reset\noccur, the OC0x Register is reset to \u201c0\u201d.\nFigure 16-4. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC0x) from the Waveform\nGenerator if either of the COM0x1:0 bits are set. However, the OC0x pin direction (input or out-put) is still controlled by the Da ta Direction Register (DDR) for th e port pin. The Data Direction\nRegister bit for the OC0x pin (DDR_OC0x) must be set as output before the OC0x value is visi-\nble on the pin. The port override  function is independent of the Waveform Generation mode.\nThe design of the Output Compare pin logic allows initialization of the OC0x state before the out-\nput is enabled. Note that some COM0x1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 129 .PORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCn\nclkI/O\n\n123\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.6.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COM0x1:0 bits differently in Normal, CTC, and P WM modes.\nFor all modes, setting the COM0x1:0 = 0 tells the Waveform Generator that no action on the\nOC0x Register is to be performed on the next Compare Match. For compare output actions in\nthe non-P WM modes refer to Table 16-2 on page 129 . For fast P WM mode, refer to Table 16-3\non page 129 , and for phase correct P WM refer to Table 16-4 on page 130 .\nA change of the COM0x1:0 bits state will have effe ct at the first Compare Match after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOC0x strobe bits.\n16.7 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode ( WGM02:0) and Compare Out-\nput mode (COM0x1:0) bits. The Compare Output mode bits do not affect the counting sequence,while the Waveform Generation mode bits do. The COM0x1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COM0x1:0 bits control whether the output should be set, cleared, or toggled at a CompareMatch. See \u201cCompare Match Output Unit\u201d on page 147.\nFor detailed timing information see \u201cTimer/Counter Timing Diagrams\u201d on page 127 .\n16.7.1 Normal Mode\nThe simplest mode of operation is the Normal mode ( WGM02:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 8-bit value (TOP = 0xFF) and then restarts from the bot-\ntom (0x00). In normal o peration the Timer/Counter Overflow Flag (TOV0) will be set in the same\ntimer clock cycle as the TCNT0 becomes zero. The TOV0 Flag in this case behaves like a ninth\nbit, except that it is only set, not cleared. However, combined with the timer overflow interrupt\nthat automatically clears the TOV0 Flag, the timer resolution can be increased by software.\nThere are no special cases to consider in the Normal mode, a new counter value can be writtenanytime.\nThe Output Compare Unit can be used to generate interrupts at some given time. Using the Out-\nput Compare to generate waveforms in Normal mode is not recommended, since this will\noccupy too much of the CPU time.\n16.7.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare or CTC mode ( WGM02:0 = 2), the OCR0A Register is used to\nmanipulate the counter resolution. In CTC mode the counter is cleared to zero when the counter\nvalue (TCNT0) matches the OCR0A. The OCR0A defines the top value for the counter, hence\nalso its resolution. This mode allows greater control of the Compare Match output frequency. Italso simplifies the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 16-5 on page 124 . The counter value\n(TCNT0) increases until a Compare Match occurs between TCNT0 and OCR0A, and then coun-ter (TCNT0) is cleared.\n\n124\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-5. CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter value reaches the TOP value by using the\nOCF0A Flag. If the interrupt is enabled, the interrupt handler routine can be used for updating\nthe TOP value. However, changing TOP to a va lue close to BOTTOM when the counter is run-\nning with none or a low prescaler value must be done with care since the CTC mode does nothave the double buffering feature. If the new value written to OCR0A is lower than the current\nvalue of TCNT0, the counter will miss the Compar e Match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starting at 0x00 before the Compare Match canoccur.\nFor generating a waveform output in CTC mode, the OC0A output can be set to toggle its logical\nlevel on each Compare Match by setting the Compare Output mode bits to toggle mode(COM0A1:0 = 1). The OC0A value will not be visible on the port pin unless the data direction for\nthe pin is set to output. The waveform ge nerated will have a ma ximum frequency of f\nOC0 =\nfclk_I/O /2 when OCR0A is set to zero (0x00). The waveform frequency is defined by the following\nequation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOV0 Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x00.\n16.7.3 Fast PWM Mode\nThe fast Pulse Width Modulation or fast P WM mode ( WGM02:0 = 3 or 7) provides a high fre-\nquency P WM waveform generation option. The fast P WM differs from the other P WM option by\nits single-slope operation. The counter counts from BOTTOM to TOP then restarts from BOT-\nTOM. TOP is defined as 0xFF when WGM2:0 = 3, and OCR0A when WGM2:0 = 7. In non-\ninverting Compare Output mode, the Output Compare (OC0x) is cleared on the Compare Match\nbetween TCNT0 and OCR0x, and set at BOTTOM. In inverting Compare Output mode, the out-\nput is set on Compare Match and cleared at BOTTOM. Due to the single-slope operation, theoperating frequency of the fast P WM mode can be twice as high as the phase correct P WM\nmode that use dual-slope operation. This high frequency makes the fast P WM mode well suited\nfor power regulation, rectification, and DAC app lications. High frequency a llows physically small\nsized external components (coils, capacitors), and therefore reduces total system cost.\nIn fast P WM mode, the counter is incremented until the counter value matches the TOP value.\nThe counter is then cleared at the following timer clock cycle. The timing diagram for the fastPWM mode is shown in Figure 16-6 . The TCNT0 value is in the timing diagram shown as a his-TCNTn\nOCn\n(Toggle)OCnx Interrupt Flag Set\n1 4 Period 2 3(COMnx1:0 = 1)\nfOCnxfclk_I/O\n2N1OCRnx+() \u22c5\u22c5------------------------------------------------- - =\n\n125\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ntogram for illustrating the single-slope operation. The diagram includes non-inverted and\ninverted P WM outputs. The small horizontal line marks on the TCNT0 slopes represent Com-\npare Matches between OCR0x and TCNT0.\nFigure 16-6. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each time the counter reaches TOP. If the inter-\nrupt is enabled, the interrupt handler routine can be used for updating the compare value.\nIn fast P WM mode, the compare unit allows generation of P WM waveforms on the OC0x pins.\nSetting the COM0x1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COM0x1:0 to three: Setting the COM0A1:0 bits to one allows\nthe OC0A pin to toggle on Compare Matches if the WGM02 bit is set. This option is not available\nfor the OC0B pin (see Table 16-3 on page 129 ). The actual OC0x value will only be visible on\nthe port pin if the data direction for the port pin is set as output. The P WM waveform is gener-\nated by setting (or clearing) the OC0x Register at the Compare Match between OCR0x and\nTCNT0, and clearing (or setting) the OC0x Regist er at the timer clock cycle the counter is\ncleared (changes from TOP to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Register represents special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCR0A is set equal to BOTTOM, the output will\nbe a narrow spike for each MAX+1 timer clock cycle. Setting the OCR0A equal to MAX will resultin a constantly high or low output (depending on the polarity of the output set by the COM0A1:0\nbits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OC0x to toggle its logical level on each Compare Match (COM0x1:0 = 1). The waveformgenerated will have a maximum frequency of f\nOC0 = fclk_I/O /2 when OCR0A is set to zero. This\nfeature is similar to the OC0A toggle in CTC mode, except the double buffer feature of the Out-\nput Compare unit is enabled in the fast P WM mode.TCNTnOCRnx Update and\nTOVn Interrupt Flag Set\n1 Period 2 3OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Interrupt Flag Set\n4 5 6 7\nfOCnxPWMfclk_I/O\nN256\u22c5------------------=\n\n126\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.7.4 Phase Correct PWM Mode\nThe phase correct P WM mode ( WGM02:0 = 1 or 5) provides a high resolution phase correct\nPWM waveform generation option. The phase correct P WM mode is based on a dual-slope\noperation. The counter counts repeatedly from BOTTOM to TOP and then from TOP to BOT-\nTOM. TOP is defined as 0xFF when WGM2:0 = 1, and OCR0A when WGM2:0 = 5. In non-\ninverting Compare Output mode, the Output Compare (OC0x) is cleared on the Compare Matchbetween TCNT0 and OCR0x while upcounting, and set on the Compare Match while down-\ncounting. In inverting Output Compare mode, the operation is inverted. The dual-slope operation\nhas lower maximum operation frequency than single slope operation. However, due to the sym-metric feature of the dual-slope P WM modes, these modes are preferred for motor control\napplications.\nIn phase correct P WM mode the counter is incremented until the counter value matches TOP.\nWhen the counter reaches TOP, it changes the count direction. The TCNT0 value will be equal\nto TOP for one timer clock cycle. The timing diagram for the phase correct P WM mode is shown\non Figure 16-7 . The TCNT0 value is in the timing diagram shown as a histogram for illustrating\nthe dual-slope operation. The diagram includes non-inverted and inverted P WM outputs. The\nsmall horizontal line marks on the TCNT0 slop es represent Compare Matches between OCR0x\nand TCNT0.\nFigure 16-7. Phase Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each time the counter reaches BOTTOM. The\nInterrupt Flag can be used to generate an interrupt each time the counter reaches the BOTTOM\nvalue.\nIn phase correct P WM mode, the compare unit allows generation of P WM waveforms on the\nOC0x pins. Setting the COM0x1:0 bits to two will produce a non-inverted P WM. An inverted\nPWM output can be generated by setting the COM0x1:0 to three: Setting the COM0A0 bits to\none allows the OC0A pin to toggle on Compare Matches if the WGM02 bit is set. This option is\nnot available for the OC0B pin (see Table 16-4 on page 130 ). The actual OC0x value will only be\nvisible on the port pin if the data direction for the port pin is set as output. The P WM waveform isTOVn Interrupt Flag SetOCnx Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Update\n\n127\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ngenerated by clearing (or setting) the OC0x Register at the Compare Match between OCR0x\nand TCNT0 when the counter increments, and setti ng (or clearing) the OC0x Register at Com-\npare Match between OCR0x and TCNT0 when the counter decrements. The P WM frequency for\nthe output when using phase correct P WM can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCR0A is set equal to BOTTOM, the\noutput will be continuously low an d if set equal to MAX the output  will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have th e opposite logic values.\nAt the very start of period 2 in Figure 16-7 on page 126  OCnx has a transition from high to low\neven though there is no Compare Match. The poin t of this transition is to guarantee symmetry\naround BOTTOM. There are two cases that give a transition without Compare Match.\n\u0081 OCR0A changes its value from MAX, like in Figure 16-7 on page 126 . When the OCR0A \nvalue is MAX the OCn pin value is the same as the result of a down-counting Compare Match. To ensure symmetry around BOTTOM the OCn value at MAX must correspond to the result of an up-counting Compare Match.\n\u0081 The timer starts counting from a value higher than the one in OCR0A, and for that reason \nmisses the Compare Match and hence the OCn change that would have happened on the way up.\n16.8 Timer/Counter Timing Diagrams\nThe Timer/Counter is a synchronous design and the timer clock (clkT0) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when Interrupt\nFlags are set. Figure 16-8  contains timing data for basic Timer/Counter operation. The figure\nshows the count sequence close to the MAX va lue in all modes other than phase correct P WM\nmode.\nFigure 16-8. Timer/Counter Timing Diagram, no Prescaling\nFigure 16-9 on page 128  shows the same timing data, but with the prescaler enabled.fOCnxPCPWMfclk_I/O\nN510\u22c5------------------=\nclkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\n\n128\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-9. Timer/Counter Timing Dia gram, with Prescaler (fclk_I/O /8)\nFigure 16-10  shows the setting of OCF0B in all modes and OCF0A in all modes except CTC\nmode and P WM mode, where OCR0A is TOP.\nFigure 16-10. Timer/Counter Timing Diagram, Setting of OCF0x, with Prescaler (fclk_I/O /8)\nFigure 16-11  shows the setting of OCF0A and the clearing of TCNT0 in CTC mode and fast\nPWM mode where OCR0A is TOP.\nFigure 16-11. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Pres-\ncaler (fclk_I/O /8)TOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n129\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9 Register Description\n16.9.1 TCCR0A \u2013 Timer/Counter Control Register A\n\u0081 Bits 7:6 \u2013 COM0A1:0: Compare Match Output A Mode\nThese bits control the Output Compare pin (OC0A) behavior. If one or both of the COM0A1:0\nbits are set, the OC0A output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction R egister (DDR) bit corresponding to the OC0A pin\nmust be set in order to enable the output driver.\nWhen OC0A is connected to the pin, the f unction of the COM0A1:0 bits depends on the\nWGM02:0 bit setting. Table 16-2  shows the COM0A1:0 bit functionality when the WGM02:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 16-3  shows the COM0A1:0 bit functionality when the WGM01:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 124  for more details.\nTable 16-4 on page 130  shows the COM0A1:0 bit functionality when the WGM02:0 bits are set\nto phase correct P WM mode.Bit 7 6 5 4 3 2 1 0\n0x24 (0x44) COM0A1 COM0A0 COM0B1 COM0B0 \u2013 \u2013 WGM01 WGM00 TCCR0A\nRead/Write R/ W R/W R/W R/W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 16-2. Compare Output Mode, non-P WM Mode\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n0 1 Toggle OC0A on Compare Match\n1 0 Clear OC0A on Compare Match1 1 Set OC0A on Compare Match\nTable 16-3. Compare Output Mode, Fast P WM Mode(1)\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n01WGM02 = 0: Normal Port Operation, OC0A Disconnected\nWGM02 = 1: Toggle OC0A on Compare Match\n10Clear OC0A on Compare Match, set OC0A at BOTTOM\n(non-inverting mode)\n11Set OC0A on Compare Match, clear OC0A at BOTTOM\n(inverting mode)\n\n130\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 126  for more details.\n\u0081 Bits 5:4 \u2013 COM0B1:0: Compare Match Output B Mode\nThese bits control the Output Compare pin (OC0B) behavior. If one or both of the COM0B1:0\nbits are set, the OC0B output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction R egister (DDR) bit corresponding to the OC0B pin\nmust be set in order to enable the output driver.\nWhen OC0B is connected to the pin, the function of the COM0B1:0 bits depends on the\nWGM02:0 bit setting. Table 16-5  shows the COM0B1:0 bit functionality when the WGM02:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 16-6  shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 124  for more details.Table 16-4. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n01WGM02 = 0: Normal Port Operation, OC0A Disconnected\nWGM02 = 1: Toggle OC0A on Compare Match\n10Clear OC0A on Compare Match when up-counting. Set OC0A on \nCompare Match when down-counting\n11Set OC0A on Compare Match when up-counting. Clear OC0A on \nCompare Match when down-counting\nTable 16-5. Compare Output Mode, non-P WM Mode\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected\n0 1 Toggle OC0B on Compare Match1 0 Clear OC0B on Compare Match\n1 1 Set OC0B on Compare Match\nTable 16-6. Compare Output Mode, Fast P WM Mode(1)\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected01 R e s e r v e d\n10Clear OC0B on Compare Match, set OC0B at BOTTOM\n(non-inverting mode)\n11Set OC0B on Compare Match, clear OC0B at BOTTOM\n(inverting mode)\n\n131\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 16-7  shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to phase cor-\nrect PWM mode.\nNote: 1. A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 126  for more details.\n\u0081 Bits 3, 2 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 1:0 \u2013 WGM01:0: Waveform Generation Mode\nCombined with the WGM02 bit found in the TCCR0B Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 16-8 . Modes of operation supported by the Timer/Counter\nunit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types ofPulse Width Modulation (P WM) modes (see \u201cModes of Operation\u201d on page 148 ).\nNote: 1. MAX        = 0xFF \n2. BOTTOM = 0x00Table 16-7. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected\n01 R e s e r v e d\n10Clear OC0B on Compare Match when up-counting. Set OC0B on \nCompare Match when down-counting\n11Set OC0B on Compare Match when up-counting. Clear OC0B on \nCompare Match when down-counting\nTable 16-8. Waveform Generation Mode Bit Description\nMode WGM2 WGM1 WGM0Timer/Counter \nMode of \nOperation TOPUpdate of\nOCRx atTOV Flag\nSet on(1)(2)\n0 0 0 0 Normal 0xFF Immediate MAX\n1 001PWM, Phase \nCorrect0xFF TOP BOTTOM\n2 010 C T C O C R A I m m e d i a t e M A X\n3 011 F a s t  P WM 0xFF TOP MAX\n4 100 R e s e r v e d \u2013 \u2013 \u2013\n5 101PWM, Phase \nCorrectOCRA TOP BOTTOM\n6 110 R e s e r v e d \u2013 \u2013 \u2013\n7 111 F a s t  P WM OCRA BOTTOM TOP\n\n132\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9.2 TCCR0B \u2013 Timer/Counter Control Register B\n\u0081 Bit 7 \u2013 FOC0A: Force Output Compare A\nThe FOC0A bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR0B is written when operating in P WM mode. When writing a logical one to the FOC0A bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC0A output is\nchanged according to its COM0A1:0 bits setting. Note that the FOC0A bit is implemented as a\nstrobe. Therefore it is the value present in the COM0A1:0 bits that determines the effect of theforced compare.\nA FOC0A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR0A as TOP.\nThe FOC0A bit is always read as zero.\n\u0081 Bit 6 \u2013 FOC0B: Force Output Compare B\nThe FOC0B bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR0B is written when operating in P WM mode. When writing a logical one to the FOC0B bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC0B output is\nchanged according to its COM0B1:0 bits setting. Note that the FOC0B bit is implemented as a\nstrobe. Therefore it is the value present in the COM0B1:0 bits that determines the effect of theforced compare.\nA FOC0B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR0B as TOP.\nThe FOC0B bit is always read as zero.\n\u0081 Bits 5:4 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 3 \u2013 WGM02: Waveform Generation Mode\nSee the description in the \u201cTCCR0A \u2013 Timer/Counter Control Register A\u201d on page 129 .\n\u0081 Bits 2:0 \u2013 CS02:0: Clock Select\nThe three Clock Select bits select the clock source to be used by the Timer/Counter, see Table\n16-9 on page 133 .Bit 7 6 5 4 3 2 1 0\n0x25 (0x45) FOC0A FOC0B \u2013 \u2013 WGM02 CS02 CS01 CS00 TCCR0B\nRead/Write WW RR R / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n133\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n16.9.3 TCNT0 \u2013 Timer/Counter Register\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter. Writing to the TCNT0 Register blocks (removes) the Compare\nMatch on the following timer clock. Modifying the counter (TCNT0) while the counter is running,introduces a risk of missing a Compare Match between TCNT0 and the OCR0x Registers.\n16.9.4 OCR0A \u2013 Output Compare Register A\nThe Output Compare Register A contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT0). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OC0A pin.\n16.9.5 OCR0B \u2013 Output Compare Register B\nThe Output Compare Register B contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT0). A match can be used to generate an Output Compare interrupt, or to\ngenerate a waveform output on the OC0B pin.Table 16-9. Clock Select Bit Description \nCS02 CS01 CS00 Description\n0 0 0 No clock source (Timer/Counter stopped)\n001 c l kI/O/(No prescaling)\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on T0 pin. Clock on falling edge1 1 1 External clock source on T0 pin. Clock on rising edge\nB i t 76543210\n0x26 (0x46) TCNT0[7:0] TCNT0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x27 (0x47) OCR0A[7:0] OCR0A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x28 (0x48) OCR0B[7:0] OCR0B\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n134\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9.6 TIMSK0 \u2013 Timer/Counter Interrupt Mask Register\n\u0081 Bits 7:3, 0 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 2 \u2013 OCIE0B: Timer/Counter Output Compare Match B Interrupt Enable\nWhen the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter Compare Match B interrupt is enab led. The corresponding interrupt is executed if\na Compare Match in Timer/Counter occurs, that is, when the OCF0B bit is set in the\nTimer/Counter Interrupt Flag Register \u2013 TIFR0.\n\u0081 Bit 1 \u2013 OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable\nWhen the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter0 Compare Match A interrupt is enabled. The corresponding interrupt is executed\nif a Compare Match in Timer/Counter0 occurs, that is, when the OCF0A bit is set in the\nTimer/Counter 0 Interrupt Flag Register \u2013 TIFR0.\n\u0081 Bit 0 \u2013 TOIE0: Timer/Counter0 Overflow Interrupt Enable\nWhen the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter0 occurs, that is, when the TOV0 bit is set in the Timer/Counter 0 Inter-\nrupt Flag Register \u2013 TIFR0.\n16.9.7 TIFR0 \u2013 Timer/Counter 0 Interrupt Flag Register\n\u0081 Bits 7:3, 0 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 2 \u2013 OCF0B: Timer/Counter 0 Output Compare B Match Flag\nThe OCF0B bit is set when a Compare Match occurs between the Timer/Counter and the data in\nOCR0B \u2013 Output Compare Register0 B. OCF0B is cleared by hardware when executing the cor-\nresponding interrupt handling vector. Alternatively, OCF0B is cleared by writing a logic one to\nthe flag. When the I-bit in SREG, OCIE0B (Timer/Counter Compare B Match Interrupt Enable),\nand OCF0B are set, the Timer/Counter Compare Match Interrupt is executed.\n\u0081 Bit 1 \u2013 OCF0A: Timer/Counter 0 Output Compare A Match Flag\nThe OCF0A bit is set when a Compare Match occurs between the Timer/Counter0 and the data\nin OCR0A \u2013 Output Compare Register0. OCF0A is cleared by hardware when executing the cor-\nresponding interrupt handling vector. Alternativel y, OCF0A is cleared by writing a logic one to\nthe flag. When the I-bit in SREG, OCIE0A (Timer/Counter0 Compare Match Interrupt Enable),\nand OCF0A are set, the Timer/Counter0 Compare Match Interrupt is executed.B i t 76543210\n(0x6E) \u2013 \u2013 \u2013 \u2013 \u2013 OCIE0B OCIE0A TOIE0 TIMSK0\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x15 (0x35) \u2013\u2013\u2013\u2013\u2013 O C F 0 B O C F 0 A\nTOV0 TIFR0\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\n\n135\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TOV0: Timer/Counter0 Overflow Flag\nThe bit TOV0 is set when an overflow occurs in  Timer/Counter0. TOV0 is cleared by hardware\nwhen executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by\nwriting a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt\nEnable), and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed.\nThe setting of this flag is dependent of the WGM02:0 bit setting. Refer to Table 16-8 , \u201cWaveform\nGeneration Mode Bit Description\u201d on page 131 .\n\n136\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17. 16-bit Timer/Counter (Timer/Counter 1, 3, 4, and 5)\n17.1 Features\n\u0081True 16-bit Design (that is, allows 16-bit PWM)\n\u0081Three independent Output Compare Units\n\u0081Double Buffered Outp ut Compare Registers\n\u0081One Input Capture Unit\n\u0081Input Capture Noise Canceler\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch-free, Phase Correct Pu lse Width Modulator (PWM)\n\u0081Variable PWM Period\n\u0081Frequency Generator\n\u0081External Event Counter\n\u0081Twenty independent interrupt sources (TOV1, OCF1A, OCF1B, OCF1C,  ICF1, TOV3, OCF3A, \nOCF3B, OCF3C, ICF3, TOV4, OCF4A, OCF4B, OCF4C, ICF4, TOV5, OCF5A, OCF5B, OCF5C and ICF5)\n17.2 Overview\nThe 16-bit Timer/Counter unit allows accurate program execution timing (event management),\nwave generation, and signal timing measurement.\nMost register and bit references in this sect ion are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, and a lower case \u201cx\u201d replaces the Output Compare unit\nchannel. However, when using the register or bit defines in a program, the precise form must beused, that is, TCNT1 for accessing Timer/Counter1 counter value and so on.\nA simplified block diagram of the 16-bit Timer/Counter is shown in Figure 17-1 on page 137 . For\nthe actual placement of I/O pins, see \u201cTQFP-pinout ATmega640/1280/2560\u201d on page 2  and\n\u201cPinout ATmega1281/2561\u201d on page 4 . CPU accessible I/O Registers,  including I/O bits and I/O\npins, are shown in bold. The device-specific I /O Register and bit locations are listed in the \u201cReg-\nister Description\u201d on page 158 .\nThe Power Reduction Timer/Counter1 bit, PRTIM1, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be written to zero to enable Timer/Counter1 module.\nThe Power Reduction Timer/Counter3 bit, PRTIM3, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter3 module.\nThe Power Reduction Timer/Counter4 bit, PRTIM4, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter4 module.\nThe Power Reduction Timer/Counter5 bit, PRTIM5, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter5 module.\nTimer/Counter4 and Timer/Counter5 only have full functionality in the ATmega640/1280/2560.\nInput capture and output compare are not available in the ATmega1281/2561.\n\n137\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-1. 16-bit Timer/Counter Block Diagram(1)\nNote: 1. Refer to Figure 1-1 on page 2 , Table 13-5 on page 79 , and Table 13-11 on page 83  for\nTimer/Counter1 and 3 and 3 pin placement and description.\n17.2.1 Registers\nThe Timer/Counter (TCNTn), Output Compare Registers (OCRnA/B/C), and Input Capture Reg-\nister (ICRn) are all 16-bit registers. Special procedures must be followed when accessing the 16-bit registers. These procedures are described in the section \u201cAccessing 16-bit Registers\u201d on\npage 138 . The Timer/Counter Control Registers (T CCRnA/B/C) are 8-bit registers and have no\nCPU access restrictions. Interrupt requests (short en as Int.Req.) signals are all visible in the\nTimer Interrupt Flag Register (T IFRn). All interrupts are individually masked with the Timer Inter-\nrupt Mask Register (TIMSKn). TIFRn and TIMSKn are not shown in the figure since these\nregisters are shared by other timer units.\nThe Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on\nthe Tn pin. The Clock Select logic block controls which clock source and edge the Timer/Counter\nuses to increment (or decrement) its value. The Timer/Counter is inactive when no clock sourceis selected. The output from the clock select logic is referred to as the timer clock (clk\nTn).\nThe double buffered Output Compare Registers (OCRnA/B/C) are compared with the\nTimer/Counter value at all time. The result of the compare can be used by the Waveform Gener-\nator to generate a P WM or variable frequency output on the Output Compare pin (OCnA/B/C).ICFn  (Int.Req.)TOVn\n(Int.Req.)\nClock Select\nTimer/CounterDATABUS\nICRn=\n==TCNTn\nWaveform\nGeneration\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB\nOCnC\nNoise\nCanceler\nICPn=\nFixed\nTOP\nValues\nEdge\nDetectorControl Logic\n= 0TOP BOTTOMCount\nClear\nDirection\nOCFnA\n(Int.Req.)\nOCFnB(Int.Req.)\nOCFnC\n(Int.Req.)\nTCCRnA TCCRnB TCCRnC( From Analog\nComparator Ouput )TnEdge\nDetector\n( From Prescaler )TCLK\nOCRnCOCRnBOCRnA\n\n138\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSee \u201cOutput Compare Units\u201d on page 145.  The compare match event will also set the Compare\nMatch Flag (OCFnA/B/C) which can be used to generate an Output Compare interrupt request.\nThe Input Capture Register can capture the Timer/ Counter value at a given external (edge trig-\ngered) event on either the Input Capture pin (ICPn) or on the Analog Comparator pins (see \u201cAC\n\u2013 Analog Comparator\u201d on page 271 ). The Input Capture unit incl udes a digital filtering unit\n(Noise Canceler) for reducing the chance of capturing noise spikes.\nThe TOP value, or maximum Timer/Counter value, can in some modes of operation be defined\nby either the OCRnA Register, the ICRn Register, or by a set of fixed values. When using\nOCRnA as TOP value in a P WM mode, the OCRnA Register can not be used for generating a\nPWM output. However, the TOP va lue will in this case be doub le buffered allowing the TOP\nvalue to be changed in run time. If a fixed TOP value is required, the ICRn Register can be used\nas an alternative, freeing the OCRnA to be used as P WM output.\n17.2.2 Definitions\nThe following definitions are used extensively throughout the document:\n17.3 Accessing 16-bit Registers\nThe TCNTn, OCRnA/B/C, and ICRn are 16-bit registers that can be accessed by the AVR CPU\nvia the 8-bit data bus. The 16-bit register must be byte accessed using two read or write opera-tions. Each 16-bit timer has a single 8-bit register for temporary storing of the high byte of the 16-\nbit access. The same Temporary Register is shared between all 16-bit registers within each 16-\nbit timer. Accessing the low byte triggers the 16-bit read or write operation. When the low byte of\na 16-bit register is written by the CPU, the high byte stored in the Temporary Register, and thelow byte written are both copied into the 16-bit register in the same clock cycle. When the low\nbyte of a 16-bit register is read by the CPU, the high byte of the 16-bit register is copied into the\nTemporary Register in the same clock cycle as the low byte is read.\nNot all 16-bit accesses uses the Temporary Regi ster for the high byte. Reading the OCRnA/B/C\n16-bit registers does not involve using the Temporary Register.\nTo do a 16-bit write, the high byte must be written before the low byte. For a 16-bit read, the low\nbyte must be read before the high byte.\nThe following code examples show how to access the 16-bit timer registers assuming that no\ninterrupts updates the temporary register. The same principle can be used directly for accessingthe OCRnA/B/C and ICRn Registers. Note that when using \u201cC\u201d, the compiler handles the 16-bit\naccess.Table 17-1. Definitions\nBOTTOM The counter reaches the BOTTOM  when it becomes 0x0000.\nMAX The counter reaches its MAX imum when it becomes 0xFFFF (decimal 65535).\nTOP The counter reaches the TOP when it becomes equal to the highest value in the\ncount sequence. The TOP value can be assigned to be one of the fixed values:\n0x00FF, 0x01FF, or 0x03FF, or to the value stored in the OCRnA or ICRn Reg-ister. The assignment is dependent of the mode of operation.\n\n139\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example returns the TCNTn value in the r17:r16 register pair.\nIt is important to notice that accessing 16-bit registers are atomic operations. If an interrupt\noccurs between the two instructions accessing the 16-bit register, and the interrupt codeupdates the temporary register by accessing the same or any other of the 16-bit Timer Regis-\nters, then the result of the a ccess outside the interrupt will be corrupted. Theref ore, when both\nthe main code and the interrupt code update the temporary register, the main code must disablethe interrupts during the 16-bit access.\nThe following code examples show how to do an atomic read of the TCNTn Register contents.\nReading any of the OCRnA/B/C or ICRn Registers can be done by using the same principle.Assembly Code Examples\n(1)\n...\n; Set TCNTn to 0x01FF\nldir17,0x01\nldir16,0xFF\noutTCNTnH,r17\noutTCNTnL,r16\n; Read TCNTn into r17:r16\ninr16,TCNTnL\ninr17,TCNTnH\n...\nC Code Examples(1)\nunsigned int  i;\n...\n/* Set TCNTn to 0x01FF */\nTCNTn = 0x1FF;/* Read TCNTn into i */\ni = TCNTn;\n...\n\n140\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example returns the TCNTn value in the r17:r16 register pair.Assembly Code Example(1)\nTIM16_ReadTCNTn:\n; Save global interrupt flag\ninr18,SREG\n; Disable interrupts\ncli\n; Read TCNTn into r17:r16inr16,TCNTnL\ninr17,TCNTnH\n; Restore global interrupt flagoutSREG,r18\nret\nC Code Example(1)\nunsigned  int TIM16_ReadTCNTn( void )\n{\nunsigned  char sreg;\nunsigned  int i;\n/* Save global interrupt flag */\nsreg = SREG;\n/* Disable interrupts */__disable_interrupt();\n/* Read TCNTn into i */\ni = TCNTn;/* Restore global interrupt flag */\nSREG = sreg;\nreturn i;\n}\n\n141\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code examples show how to do an atomic write of the TCNTn Register contents.\nWriting any of the OCRnA/B/C or ICRn Registers can be done by using the same principle.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example requires that the r17:r16 register pair contains the value to be writ-\nten to TCNTn.\n17.3.1 Reusing the Temporary High Byte Register\nIf writing to more than one 16-bit register where the high byte is the same for all registers written,\nthen the high byte only needs to be written once. However, note that the same rule of atomicoperation described previously also applies in this case.\n17.4 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the Clock Select logic which is controlled by the Clock Select  (CSn2:0) bits\nlocated in the Timer/Counter control Register B  (TCCRnB). For details on clock sources and\nprescaler, see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169 .Assembly Code Example(1)\nTIM16_WriteTCNTn:\n; Save global interrupt flag\ninr18,SREG\n; Disable interruptscli\n; Set TCNTn to r17:r16\noutTCNTnH,r17\noutTCNTnL,r16\n; Restore global interrupt flag\noutSREG,r18\nret\nC Code Example(1)\nvoid TIM16_WriteTCNTn( unsigned  int i )\n{\nunsigned  char sreg;\nunsigned  int i;\n/* Save global interrupt flag */sreg = SREG;\n/* Disable interrupts */\n__disable_interrupt();/* Set TCNTn to i */\nTCNTn = i;\n/* Restore global interrupt flag */SREG = sreg;\n}\n\n142\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.5 Counter Unit\nThe main part of the 16-bit Timer/Counter is th e programmable 16-bit bi-directional counter unit.\nFigure 17-2  shows a block diagram of the counter and its surroundings.\nFigure 17-2. Counter Unit Block Diagram\nSignal description (internal signals):\nCount Increment or decrement TCNTn by 1.\nDirection Select between increment and decrement.\nClear Clear TCNTn (set all bits to zero).\nclkTn Timer/Counter clock.\nTOP Signalize that TCNTn has  reached maximum value.\nBOTTOM Signalize that TCNTn has re ached minimum value (zero).\nThe 16-bit counter is mapped into two 8-bit I/O memory locations: Counter High  (TCNTnH) con-\ntaining the upper eight bits of the counter, and Counter Low  (TCNTnL) containing the lower eight\nbits. The TCNTnH Register can only be  indirectly accessed by the CPU. When the CPU does an\naccess to the TCNTnH I/O location, the CPU accesses the high byte temporary register (TEMP).\nThe temporary register is updated with the TCNTnH value when the TCNTnL is read, andTCNTnH is updated with the temporary register va lue when TCNTnL is written. This allows the\nCPU to read or write the entire  16-bit counter value within one clock cycle via the 8-bit data bus.\nIt is important to notice that there are special cases of writing to the TCNTn Register when thecounter is counting that will gi ve unpredictable results. The s pecial cases are described in the\nsections where they are of importance.\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock  (clk\nTn). The clkTn can be generated from an external or internal clock source,\nselected by the Clock Select  bits (CSn2:0). When no clock source is selected (CSn2:0 = 0) the\ntimer is stopped. However, the TCNTn value can be accessed by the CPU, independent of\nwhether clkTn is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the Waveform Generation mode  bits\n(WGMn3:0) located in the Timer/Counter Control Registers  A and B (TCCRnA and TCCRnB).\nThere are close connections between how the counter behaves (counts) and how waveforms\nare generated on the Output Compare outputs OCnx. For more details about advanced counting\nsequences and waveform generation, see \u201cModes of Operation\u201d on page 148 .\nThe Timer/Counter Overflow Flag (TOVn) is set according to the mode of operation selected by\nthe WGMn3:0 bits. TOVn can be used for generating a CPU interrupt.TEMP  (8-bit)DATA BU S (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nControl LogicCount\nClear\nDirectionTOVn\n(Int.Req.)\nClock Select\nTOP BOTTOMTnEdge\nDetector\n( From Prescaler )clkTn\n\n143\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.6 Input Capture Unit\nThe Timer/Counter incorporates an input capture un it that can capture external events and give\nthem a time-stamp indicating time of occurrence. The external signal indicating an event, or mul-\ntiple events, can be applied via the ICPn pin or al ternatively, for the Timer/Counter1 only, via the\nAnalog Comparator unit. The time-stamps can then be used to calculate frequency, duty-cycle,\nand other features of the signal applied. Alternatively the time-stamps can be used for creating a\nlog of the events.\nThe Input Capture unit is illustrated by the block diagram shown in Figure 17-3 . The elements of\nthe block diagram that are not directly a part of the input capture unit are gray shaded. The small\n\u201cn\u201d in register and bit names indicates the Timer/Counter number.\nFigure 17-3. Input Capture Unit Block Diagram\nNote: The Analog Comparator Output (ACO) ca n only trigger the Timer/Counter1 ICP \u2013 not \nTimer/Counter3, 4 or 5.\nWhen a change of the logic level (an event) occurs on the Input Capture Pin  (ICPn), alternatively\non the analog Comparator output  (ACO), and this change confirms to the setting of the edge\ndetector, a capture will be triggered. When a capture is triggered, the 16-bit value of the counter\n(TCNTn) is written to the Input Capture Register  (ICRn). The Input Capture Flag  (ICFn) is set at\nthe same system clock as the TCNTn value is c opied into ICRn Register. If enabled (TICIEn =\n1), the input capture flag generates an input capt ure interrupt. The ICFn flag is automatically\ncleared when the interrupt is executed. Alternativ ely the ICFn flag can be cleared by software by\nwriting a logical one to  its I/O bit location.\nReading the 16-bit value in the Input Capture Register  (ICRn) is done by first reading the low\nbyte (ICRnL) and then the high byte (ICRnH). When the low byte is read the high byte is copied\ninto the high byte Temporary Register (TEMP). When the CPU reads the ICRnH I/O location it\nwill access the TEMP Register.ICFn  (Int.Req.)Analog\nComparatorWRITE ICRn (16-bit Register)ICRnH (8-bit)\nNoise\nCanceler\nICPnEdge\nDetectorTEMP  (8-bit)DATA BU S (8-bit)\nICRnL (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nACIC* ICNC ICES ACO*\n\n144\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe ICRn Register can only be written when using a Waveform Generation mode that utilizes\nthe ICRn Register for defining the counter\u2019s TOP value. In these cases the Waveform Genera-\ntion mode  (WGMn3:0) bits must be set before the TOP value can be written to the ICRn\nRegister. When writing the ICRn Register the high byte  must be written to the ICRnH I/O location\nbefore the low byte is written to ICRnL.\nFor more information on how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 138 .\n17.6.1 Input Capture Trigger Source\nThe main trigger source for the input capture unit is the Input Capture Pin  (ICPn).\nTimer/Counter1 can alternatively use the analog comparator output as trigger source for the\ninput capture unit. The Analog Comparator is selected as trigger source by setting the analog\nComparator Input Capture  (ACIC) bit in the Analog Comparator Control and Status Register\n(ACSR). Be aware that changing trigger source can trigger a capture. The input capture flag\nmust therefore be cleared after the change.\nBoth the Input Capture Pin  (ICPn) and the Analog Comparator output  (ACO) inputs are sampled\nusing the same technique as for the Tn pin ( Figure 18-1 on page 169 ). The edge detector is also\nidentical. However, when the noise canceler is enabled, additional logic is inserted before the\nedge detector, which increases t he delay by four system clock cycles. Note that the input of the\nnoise canceler and edge detector is always enabled unless the Timer/Counter is set in a Wave-\nform Generation mode that uses ICRn to define TOP.\nAn input capture can be tri ggered by software by controllin g the port of the ICPn pin.\n17.6.2 Noise Canceler\nThe noise canceler improves noise immunity by  using a simple digital filtering scheme. The\nnoise canceler input is monitored over four samples, and all four must be equal for changing the\noutput that in turn is used by the edge detector.\nThe noise canceler is enabled by setting the Input Capture Noise Canceler  (ICNCn) bit in\nTimer/Counter Control Register B  (TCCRnB). When enabled the noise canceler introduces addi-\ntional four system clock cycles of delay from a change applied to the input, to the update of the\nICRn Register. The noise canceler uses the sy stem clock and is therefore not affected by the\nprescaler.\n17.6.3 Using the Input Capture Unit\nThe main challenge when using the Input Capture unit is to assign enough processor capacity\nfor handling the incoming events. The time between two events is critical. If the processor has\nnot read the captured value in th e ICRn Register before the nex t event occurs, the ICRn will be\noverwritten with a new value. In this case the result of the ca pture will be incorrect.\nWhen using the Input Capture interrupt, the ICRn Register should be read as early in the inter-\nrupt handler routine as possible. Even though the Input Capture interrupt has relatively high\npriority, the maximum interrupt response time is dependent on the maximum number of clockcycles it takes to handle any of the other interrupt requests.\nUsing the Input Capture unit in any mode of  operation when the TOP value (resolution) is\nactively changed during operation, is not recommended.\nMeasurement of an external signal\u2019s duty cycle requires that the trigger edge is changed after\neach capture. Changing the edge sensing must be done as early as possible after the ICRn\n\n145\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nRegister has been read. After a change of the edge, the Input Capture Flag (ICFn) must be\ncleared by software (writing a logical one to the I/O bit location). For measuring frequency only,\nthe clearing of the ICFn Flag is not required (if an interrupt handler is used).\n17.7 Output Compare Units\nThe 16-bit comparator continuously compares TCNTn with the Output Compare Register\n(OCRnx). If TCNT equals OCRnx the comparator signals a match. A match will set the Output\nCompare Flag  (OCFnx) at the next timer clock cycle. If enabled (OCIEnx = 1), the Output Com-\npare Flag generates an Output Compare interrupt. The OCFnx Flag is automatically clearedwhen the interrupt is executed. Alternatively the OCFnx Flag can be cleared by software by writ-\ning a logical one to its I/O bit location. The Waveform Generator uses the match signal to\ngenerate an output according to operating mode set by the Waveform Generation mode\n(WGMn3:0) bits and Compare Output mode  (COMnx1:0) bits. The TOP and BOTTOM signals\nare used by the Waveform Generator for handling the special cases of the extreme values in\nsome modes of operation. See \u201cModes of Operation\u201d on page 148.\nA special feature of Output Compare unit A allows it to define the Timer/Counter TOP value (that\nis, counter resolution). In addition to the counter resolution, the TOP value defines the period\ntime for waveforms generated by the Waveform Generator.\nFigure 17-4  shows a block diagram of the Output Compare unit. The small \u201cn\u201d in the register and\nbit names indicates the device number (n = n\n for Timer/Counter n), and the \u201cx\u201d indicates Output\nCompare unit (A/B/C). The elements of the block diagram that are not directly a part of the Out-put Compare unit are gray shaded.\nFigure 17-4. Output Compare Unit, Block Diagram\nOCFnx  (Int.Req.)= (16-bit Comparator )OCRnx  Buffer (16-bit Register)OCRnxH Buf. ( 8-bit)\nOCnxTEMP  (8-bit)DATA BU S (8-bit)\nOCRnxL Buf. ( 8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nCOMnx1:0 WGMn3:0OCRnx (16-bit Register)OCRnxH (8-bit) OCRnxL (8-bit)\nWaveform GeneratorTOP\nBOTTOM\n\n146\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe OCRnx Register is double buffered when using any of the twelve Pulse Width Modulation\n(PWM) modes. For the Normal and Clear Timer on Compare  (CTC) modes of operation, the\ndouble buffering is disabled. The double buffering synchronizes the update of the OCRnx Com-\npare Register to either TOP or BOTTOM of  the counting sequence. The synchronization\nprevents the occurrence of odd-length, non-symmetrical P WM pulses, thereby making the out-\nput glitch-free.\nThe OCRnx Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCRnx Buffer Register, and if double buffering is dis-\nabled the CPU will access the OCRnx directly. The content of the OCR1x (Buffer or Compare)\nRegister is only changed by a write operation (the Timer/Counter does not update this registerautomatically as the TCNT1 and ICR1 Register). Therefore OCR1x is not read via the high byte\ntemporary register (TEMP). However, it is a good practice to read the low byte first as when\naccessing other 16-bit registers. Writing the OCRnx Registers must be done via the TEMP Reg-\nister since the compare of all 16 bits is done continuously. The high byte (OCRnxH) has to be\nwritten first. When the high byte I/O location is written by the CPU, the TEMP Register will be\nupdated by the value written. Then when the low by te (OCRnxL) is written to the lower eight bits,\nthe high byte will be copied into the upper 8-bits  of either the OCRnx bu ffer or OCRnx Compare\nRegister in the same system clock cycle.\nFor more information of how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 138 .\n17.7.1 Force Output Compare\nIn non-P WM Waveform Generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Output Compare  (FOCnx) bit. Forcing compare match will not set the\nOCFnx Flag or reload/clear the timer, but the OCnx pin will be updated as if a real compare\nmatch had occurred (the COMn1:0 bits settings define whether the OCnx pin is set, cleared or\ntoggled).\n17.7.2 Compare Match Bloc king by TCNTn Write\nAll CPU writes to the TCNTn Register will block any compare match that o ccurs in the next timer\nclock cycle, even when the timer is stopped. This  feature allows OCRnx to  be initialized to the\nsame value as TCNTn without triggering an inte rrupt when the Timer/Counter clock is enabled.\n17.7.3 Using the Output Compare Unit\nSince writing TCNTn in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNTn when using any of the Output Compare\nchannels, independent of whether the Timer/Counter is running or not. If the value written to\nTCNTn equals the OCRnx value, the compare matc h will be missed, resulting in incorrect wave-\nform generation. Do not write the TCNTn equal to TOP in P WM modes with variable TOP\nvalues. The compare match for the TOP will be ignored and the counte r will continue to 0xFFFF.\nSimilarly, do not write the TCNTn value equal to BOTTOM when the counter is downcounting.\nThe setup of the OCnx should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OCnx value is to use the Force Output Com-\npare (FOCnx) strobe bits in Normal mode. The OCnx Register keeps its value even whenchanging between Waveform Generation modes.\nBe aware that the COMnx1:0 bits are not doubl e buffered together with the compare value.\nChanging the COMnx1:0 bits will take effect immediately.\n\n147\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.8 Compare Match Output Unit\nThe Compare Output mode (COMnx1:0) bits have two functions. The Waveform Generator uses\nthe COMnx1:0 bits for defining the Output Compare (OCnx) state at the next compare match.\nSecondly the COMnx1:0 bits control the OCnx pin output source. Figure 17-5  shows a simplified\nschematic of the logic affected by the COMnx1:0 bit setting. The I/O Registers, I/O bits, and I/O\npins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers\n(DDR and PORT) that are affected by the COMnx1:0 bits are shown. When referring to the\nOCnx state, the reference is for the internal OCnx  Register, not the OCnx pin. If a system reset\noccur, the OCnx Register is reset to \u201c0\u201d.\nFigure 17-5. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OCnx) from the Waveform\nGenerator if either of the COMnx1:0 bits are set. However, the OCnx pin direction (input or out-\nput) is still controlled by the Data Direction Register  (DDR) for the port pin. The Data Direction\nRegister bit for the OCnx pin (DDR_OCnx) must be set as output before the OCnx value is visi-\nble on the pin. The port override func tion is generally independent of the Waveform Generation\nmode, but there are some exceptions. Refer to Table 17-3 on page 159 , Table 17-4 on page 159\nand Table 17-5 on page 160  for details.\nThe design of the Output Compare pin logic allows initialization of the OCnx state before the out-\nput is enabled. Note that some COMnx1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 158.\nThe COMnx1:0 bits have no effect on the Input Capture unit.\n17.8.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COMnx1:0 bits differently in normal, CTC, and P WM modes.\nFor all modes, setting the COMnx1:0 = 0 tells the Waveform Generator that no action on the\nOCnx Register is to be performed on the next compare match. For compare output actions in thePORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCnx\nclkI/O\n\n148\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nnon-PWM modes refer to Table 17-3 on page 159 . For fast P WM mode refer to Table 17-4 on\npage 159 , and for phase correct and phase and frequency correct P WM refer to Table 17-5 on\npage 160 .\nA change of the COMnx1:0 bits st ate will have effect at the first compare matc h after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOCnx strobe bits.\n17.9 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode  (WGMn3:0) and Compare Out-\nput mode  (COMnx1:0) bits. The Compare Output mode bits do not affect the counting sequence,\nwhile the Waveform Generation mode bits do. The COMnx1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COMnx1:0 bits control whether the output should be set, cleared or toggle at a compare\nmatch. See \u201cCompare Match Output Unit\u201d on page 147.\nNote: 1. The CTCn and P WMn1:0 bit definition names are obsolete. Use the WGMn2:0 definitions. \nHowever, the functionality and location of these bits are compatible with previous versions of \nthe timer.\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 156 .Table 17-2. Waveform Generation Mode Bit Description(1)\nMode WGMn3WGMn2\n(CTCn)WGMn1\n(PWMn1)WGMn0\n(PWMn0)Timer/Counter\nMode of Operation TOPUpdate of \nOCRn x atTOVn Flag \nSet on\n0 0 0 0 0 Normal 0xFFFF Immediate MAX\n10 0 0 1 P WM, Phase Correct, 8-bit 0x00FF TOP BOTTOM\n20 0 1 0 P WM, Phase Correct, 9-bit 0x01FF TOP BOTTOM\n30 0 1 1 P WM, Phase Correct, 10-bit 0x03FF TOP BOTTOM\n4 0 1 0 0 CTC OCRnA Immediate MAX\n50 1 0 1 F a s t  P WM, 8-bit 0x00FF BOTTOM TOP\n60 1 1 0 F a s t  P WM, 9-bit 0x01FF BOTTOM TOP\n70 1 1 1 F a s t  P WM, 10-bit 0x03FF BOTTOM TOP\n81 0 0 0PWM, Phase and Frequency \nCorrectICRn BOTTOM BOTTOM\n91 0 0 1PWM,Phase and Frequency \nCorrectOCRnA BOTTOM BOTTOM\n1 0 1010P WM, Phase Correct ICRn TOP BOTTOM\n1 1 1011P WM, Phase Correct OCRnA TOP BOTTOM\n12 1 1 0 0 CTC ICRn Immediate MAX1 3 1101 ( R e s e r v e d ) \u2013 \u2013 \u2013\n1 4 1110 F a s t  P WMI C R n B O T T O M T O P\n1 5 1111 F a s t  P WM OCRnA BOTTOM TOP\n\n149\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.9.1 Normal Mode\nThe simplest mode of operation is the Normal mode  (WGMn3:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 16-bit value (MAX = 0xFFFF) and then restarts from the\nBOTTOM (0x0000). In normal operation the Timer/Counter Overflow Flag  (TOVn) will be set in\nthe same timer clock cycle as the TCNTn become s zero. The TOVn Flag in this case behaves\nlike a 17th bit, except that it is only set, not cleared. However, combined with the timer overflow\ninterrupt that automatically clears the TOVn Flag, the timer resolution can be increased by soft-\nware. There are no special cases to consider in the Normal mode, a new counter value can bewritten anytime.\nThe Input Capture unit is easy to use in Normal mode. However, observe that the maximum\ninterval between the external events must not exceed the resolution of the counter. If the intervalbetween events are too long, the timer overflow interrupt or the prescaler must be used to\nextend the resolution for the capture unit.\nThe Output Compare units can be used to generat e interrupts at some given time. Using the\nOutput Compare to gene rate waveforms in Norm al mode is not recommended, since this will\noccupy too much of the CPU time.\n17.9.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare  or CTC mode ( WGMn3:0 = 4 or 12), the OCRnA or ICRn Register\nare used to manipulate the counter resolution. In CTC mode the counter is cleared to zero when\nthe counter value (TCNTn) matches either the OCRnA ( WGMn3:0 = 4) or the ICRn ( WGMn3:0 =\n12). The OCRnA or ICRn define the top value for the counter, hence also its resolution. This\nmode allows greater control of the compare match output frequency. It also simplifies the opera-tion of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 17-6 . The counter value (TCNTn)\nincreases until a compare match occurs with either OCRnA or ICRn, and then counter (TCNTn)is cleared.\nFigure 17-6. CTC Mode, Timing Diagram\nAn interrupt can be generated at each time the counter value reaches the TOP value by either\nusing the OCFnA or ICFn Flag according to the register used to define the TOP value. If theinterrupt is enabled, the interrupt handler routine can be used for updating the TOP value. How-\never, changing the TOP to a value close to BOTTOM when the counter is running with none or a\nlow prescaler value must be done with care since the CTC mode does not have the double buff-ering feature. If the new value written to OCRnA or ICRn is lower than the current value ofTCNTn\nOCnA\n(Toggle)OCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 4 Period 2 3(COMnA1:0 = 1)\n\n150\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTCNTn, the counter will miss the co mpare match. The counter will then  have to count to its max-\nimum value (0xFFFF) and wrap around starting at 0x0000 before the compare match can occur.\nIn many cases this feature is not desirable. An al ternative will then be to use the fast P WM mode\nusing OCRnA for defining TOP ( WGMn3:0 = 15) since the OCRnA then will be doub le buffered.\nFor generating a waveform output in CTC mode, the OCnA output can be set to toggle its logical\nlevel on each compare match by setting the Compare Output mode bits to toggle mode\n(COMnA1:0 = 1). The OCnA value will not be visible on the port pin unless the data direction for\nthe pin is set to output (DDR_OCnA = 1). Th e waveform generated will have a maximum fre-\nquency of fOCnA = fclk_I/O /2 when OCRnA is set to zero (0x0000). The waveform frequency is\ndefined by the following equation:\nThe N variable represents the prescaler factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOVn Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x0000.\n17.9.3 Fast PWM Mode\nThe fast Pulse Width Modulation or fast P WM mode ( WGMn3:0 = 5, 6, 7, 14, or 15) provides a\nhigh frequency P WM waveform generation option. The fast P WM differs from the other P WM\noptions by its single-slope operation. The counter counts from BOTTOM to TOP then restarts\nfrom BOTTOM. In non-inverting Compare Output mode, the Output Compare (OCnx) is cleared\non the compare match between TCNTn and OCRnx, and set at BOTTOM. In inverting CompareOutput mode output is set on compare match and cleared at BOTTOM. Due to the single-slope\noperation, the operating frequency of the fast P WM mode can be twice as high as the phase cor-\nrect and phase and frequency correct P WM modes that use dual-slope operation. This high\nfrequency makes the fast P WM mode well suited for power regu lation, rectification, and DAC\napplications. High frequency allows physically sm all sized external com ponents (coils, capaci-\ntors), hence reduces total system cost.\nThe PWM resolution for fast P WM can be fixed to 8-bit, 9-bit, or 10-bit, or defined by either ICRn\nor OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA set to 0x0003), and the\nmaximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM resolution in bits can be\ncalculated by using the following equation:\nIn fast P WM mode the counter is incremented until the counter value matches either one of the\nfixed values 0x00FF, 0x01FF, or 0x03FF ( WGMn3:0 = 5, 6, or 7), the value in ICRn ( WGMn3:0 =\n14), or the value in OCRnA ( WGMn3:0 = 15). The counter is then cleared at the following timer\nclock cycle. The timing diagram for the fast P WM mode is shown in Figure 17-7 on page 151 .\nThe figure shows fast P WM mode when OCRnA or ICRn is used to define TOP. The TCNTn\nvalue is in the timing diagram shown as a hist ogram for illustrating the single-slope operation.\nThe diagram includes non-inverted and inverted P WM outputs. The small horizontal line marks\non the TCNTn slopes represent compare ma tches between OCRnx and TCNTn. The OCnx\nInterrupt Flag will be set when a compare match occurs.fOCnAfclk_I/O\n2N1OCRnA+() \u22c5\u22c5-------------------------------------------------- - =\nRFPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n151\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-7. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set each time the counter reaches TOP. In addition\nthe OCnA or ICFn Flag is set at the same time r clock cycle as TOVn is set when either OCRnA\nor ICRn is used for defining the TOP value. If one of the interrupts are enabled, the interrupt han-dler routine can be used for updating the TOP and compare values.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will never occur between the TCNTn and the OCRnx.\nNote that when using fixed TOP values the unused bits are masked to zero when any of the\nOCRnx Registers are written.\nThe procedure for updating ICRn differs from updating OCRnA when used for defining the TOP\nvalue. The ICRn Register is not double buffered. This means that if ICRn is changed to a low\nvalue when the counter is running with none or a low prescaler value, there is a risk that the newICRn value written is lower than the current va lue of TCNTn. The result will then be that the\ncounter will miss the compare matc h at the TOP value. The counter will then have to count to the\nMAX value (0xFFFF) and wrap around starting at 0x0000 before the compare match can occur.The OCRnA Register however, is double buffered. This feature allows the OCRnA I/O location\nto be written anytime. When the OCRnA I/O location is written the value written will be put into\nthe OCRnA Buffer Register. Th e OCRnA Compare Register will th en be updated with the value\nin the Buffer Register at the next timer clo ck cycle the TCNTn matches TOP. The update is done\nat the same timer clock cycle as the TCNT n is cleared and the TOVn Flag is set.\nUsing the ICRn Register for defining TOP work s well when using fixed TOP values. By using\nICRn, the OCRnA Register is free to be used for generating a P WM output on OCnA. However,\nif the base P WM frequency is actively changed (by ch anging the TOP value), using the OCRnA\nas TOP is clearly a better choice due to its double buffer feature.\nIn fast P WM mode, the compare units allow generation of P WM waveforms on the OCnx pins.\nSetting the COMnx1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COMnx1:0 to three (see Table  on page 159 ). The actual OCnx\nvalue will only be visible on the port pin if the data direction for the port pin is set as output\n(DDR_OCnx). The P WM waveform is generated by setting (or clearing) the OCnx Register at\nthe compare match between OCRnx and TCNTn, and clearing (or setting) the OCnx Register at\nthe timer clock cycle the counter is cleared (changes from TOP to BOTTOM).TCNTnOCRnx / TOP Update \nand TOVn Interrupt Flag Set and OCnA Interrupt Flag Set or ICFn Interrupt Flag Set (Interrupt on TOP)\n1 7 Period 2 3 4 56 8OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n152\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCRnx Register represents special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCRnx is set equal to BOTTOM (0x0000) the out-\nput will be a narrow spike for eac h TOP+1 timer clock cycle. Se tting the OCRnx equal to TOP\nwill result in a const ant high or low output (depending on the polarity of the output set by the\nCOMnx1:0 bits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OCnA to toggle its logical level on each compare match (COMnA1:0 = 1). This applies onlyif OCR1A is used to define the TOP value ( WGM13:0 = 15). The wave form generated will have\na maximum frequency of f\nOCnA = fclk_I/O /2 when OCRnA is set to zero (0x0000). This feature is\nsimilar to the OCnA toggle in CTC mode, except the double buffer feature of the Output Com-pare unit is enabled in the fast P WM mode.\n17.9.4 Phase Correct PWM Mode\nThe phase correct Pulse Width Modulation or phase correct P WM mode ( WGMn3:0 = 1, 2, 3,\n10, or 11) provides a high resolution phase correct P WM waveform generation option. The\nphase correct P WM mode is, like the phase and frequency correct P WM mode, based on a dual-\nslope operation. The counter counts repeatedly from BOTTOM (0x0000) to TOP and then from\nTOP to BOTTOM. In non-inverting Compare Output mode, the Output Compare (OCnx) is\ncleared on the compare match between TCNTn and OCRnx while upcounting, and set on thecompare match while downcounting. In inverting Output Compare mode, the operation is\ninverted. The dual-slope operation has lower maximum operation frequency than single slope\noperation. However, due to the symmetric feature of the dual-slope P WM modes, these modes\nare preferred for motor control applications.\nThe P WM resolution for the phase correct P WM mode can be fixed to 8-bit, 9-bit, or 10-bit, or\ndefined by either ICRn or OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA setto 0x0003), and the maximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM reso-\nlution in bits can be calculated by using the following equation:\nIn phase correct P WM mode the counter is incremented until the counter value matches either\none of the fixed values 0x00FF, 0x01FF, or 0x03FF ( WGMn3:0 = 1, 2, or 3), the value in ICRn\n(WGMn3:0 = 10), or the value in OCRnA ( WGMn3:0 = 11). The counter has then reached the\nTOP and changes the count direct ion. The TCNTn value will be equa l to TOP for one timer clock\ncycle. The timing diagram for the phase correct P WM mode is shown on Figure 17-8 on page\n153. The figure shows phase correct P WM mode when OCRnA or ICRn is used to define TOP.\nThe TCNTn value is in the timing diagram shown as a histogram for illustrating the dual-slope\noperation. The diagram includes non-inverted and inverted P WM outputs. The small horizontal\nline marks on the TCNTn slopes represent compare matches between OCRnx and TCNTn. TheOCnx Interrupt Flag will be set when a compare match occurs.fOCnxPWMfclk_I/O\nN1TOP+()\u22c5---------------------------------- - =\nRPCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n153\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-8. Phase Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set each time the counter reaches BOTTOM. When\neither OCRnA or ICRn is used for defining the TOP value, the OCnA or ICFn Flag is set accord-\ningly at the same timer clock cycle as the OCRnx Registers are updated with the double buffer\nvalue (at TOP). The Interrupt Flags can be used to  generate an interrupt each time the counter\nreaches the TOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will never occur between the TCNTn and the OCRnx.\nNote that when using fixed TOP values, the unus ed bits are masked to zero when any of the\nOCRnx Registers are written. As the third period shown in Figure 17-8  illustrates, changing the\nTOP actively while the Timer/Counter is running in the phase correct mode can result in an\nunsymmetrical output. The reason for this can be found in the time of update of the OCRnx Reg-\nister. Since the OCRnx update occurs at TOP, the P WM period starts and ends at TOP. This\nimplies that the length of the falling slope is determined by the previous TOP value, while thelength of the rising slope is determined by the new TOP value. When these two values differ the\ntwo slopes of the period will differ in length. The difference in length gives the unsymmetrical\nresult on the output.\nIt is recommended to use the phase and frequency correct mode instead of the phase correct\nmode when changing the TOP value while the Timer/Counter is running. When using a static\nTOP value there are practically no differences between the two modes of operation.\nIn phase correct P WM mode, the compare units allow generation of P WM waveforms on the\nOCnx pins. Setting the COMnx1:0 bits  to two will produce a non-inverted P WM and an inverted\nPWM output can be generated by setting the COMnx1:0 to three (see Table 17-5 on page 160 ).\nThe actual OCnx value will only be visible on the port pin if the data direction for the port pin is\nset as output (DDR_OCnx). The P WM waveform is generated by setting (or clearing) the OCnx\nRegister at the compare match between OCRnx and TCNTn when the counter increments, andclearing (or setting) the OCnx Register at compare match between OCRnx and TCNTn whenOCRnx/TOP Update and\nOCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 2 3 4TOVn Interrupt Flag Set\n(Interrupt on Bottom)\nTCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n154\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe counter decrements. The P WM frequency for the output when using phase correct P WM can\nbe calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCRnx Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCRnx is set equal to BOTTOM the\noutput will be continuously low and if set equal to TOP the output will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have the opposite logic values. If\nOCR1A is used to define the TOP value ( WGM13:0 = 11) and COM1A1:0 = 1, the OC1A output\nwill toggle with a 50% duty cycle.\n17.9.5 Phase and Frequency Correct PWM Mode\nThe phase and frequency correct Pulse Width Modulation, or phase and frequency correct P WM\nmode ( WGMn3:0 = 8 or 9) provides a high resolution phase and frequency correct P WM wave-\nform generation option. The phase and frequency correct P WM mode is, like the phase correct\nPWM mode, based on a dual-slope operation. The counter counts repeatedly from BOTTOM\n(0x0000) to TOP and then from TOP to BOTTOM. In non-inverting Compare Output mode, the\nOutput Compare (OCnx) is cleared on the compare match between TCNTn and OCRnx while\nupcounting, and set on the compare match while downcounting. In inverting Compare Outputmode, the operation is inverted. The dual-slope operation gives a lower maximum operation fre-\nquency compared to the single-slope operation. Howe ver, due to the symmetric feature of the\ndual-slope P WM modes, these modes are preferred for motor control applications.\nThe main difference between the phase correct, and the phase and frequency correct P WM\nmode is the time the OCRnx Register is updated by the OCRnx Buffer Register, see Figure 17-8\non page 153  and Figure 17-9 on page 155 .\nThe P WM resolution for the phase and frequency correct P WM mode can be defined by either\nICRn or OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA set to 0x0003), and\nthe maximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM resolution in bits can\nbe calculated using the following equation:\nIn phase and frequency correct P WM mode the counter is incremented until the counter value\nmatches either the value in ICRn ( WGMn3:0 = 8), or the value in OCRnA ( WGMn3:0 = 9). The\ncounter has then reac hed the TOP and ch anges the count di rection. The TCNTn value will be\nequal to TOP for one timer clock cycle. The timing diagram for the phase correct and frequency\ncorrect P WM mode is shown on Figure 17-9 on page 155 . The figure shows phase and fre-\nquency correct P WM mode when OCRnA or ICRn is used to define TOP. The TCNTn value is in\nthe timing diagram shown as a histogram for il lustrating the dual-slope operation. The diagram\nincludes non-inverted and inverted P WM outputs. The small horizontal line marks on the TCNTn\nslopes represent compare matches between OCRnx and TCNTn. The OCnx Interrupt Flag will\nbe set when a compare match occurs.fOCnxPCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\nRPFCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n155\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-9. Phase and Frequency Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set at the same timer clock cycle as the OCRnx\nRegisters are updated with the double buffer value (at BOTTOM). When either OCRnA or ICRn\nis used for defining the TOP value, the OCnA or ICFn Flag set when TCNTn has reached TOP.\nThe Interrupt Flags can then be used to generate an interrupt each time the counter reaches the\nTOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will neve r occur between the TCNTn and the OCRnx.\nAs Figure 17-9  shows the output generated is, in contrast to the phase correct mode, symmetri-\ncal in all periods. Since the OCRnx Registers are updated at BOTTOM, the length of the rising\nand the falling slopes will always be  equal. This gives symmetrical output pulses and is therefore\nfrequency correct.\nUsing the ICRn Register for defining TOP work s well when using fixed TOP values. By using\nICRn, the OCRnA Register is free to be used for generating a P WM output on OCnA. However,\nif the base P WM frequency is actively changed by changing the TOP value, using the OCRnA as\nTOP is clearly a better choice due to its double buffer feature.\nIn phase and frequency correct P WM mode, the compare units allow generation of P WM wave-\nforms on the OCnx pins. Setting the COMnx1:0  bits to two will produce a non-inverted P WM and\nan inverted P WM output can be generated by setting the COMnx1:0 to three (see Table 17-5 on\npage 160 ). The actual OCnx value will only be visible on the port pin if the data direction for the\nport pin is set as output (DDR_OCnx). The P WM waveform is generated by setting (or clearing)\nthe OCnx Register at the compare match between OCRnx and TCNTn when the counter incre-\nments, and clearing (or setting) the OCnx Register at compare match between OCRnx andTCNTn when the counter decrements. The P WM frequency for the output when using phase\nand frequency correct P WM can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).OCRnx/TOP Updateand\nTOVn Interrupt Flag Set\n(Interrupt on Bottom)OCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 2 3 4TCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\nfOCnxPFCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\n\n156\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe extreme values for the OCRnx Register represents special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCRnx is set equal to BOTTOM the\noutput will be continuously low and if set equal to TOP the output will be set to high for non-\ninverted P WM mode. For inverted P WM the output will have the opposite logic values. If OCR1A\nis used to define the TOP value ( WGM13:0 = 9) and COM1A1:0 = 1, the OC1A output will toggle\nwith a 50% duty cycle.\n17.10 Timer/Counte r Timing Diagrams\nThe Timer/Counter is a synchronous design and the timer clock (clkTn) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when Interrupt\nFlags are set, and when the OCRnx Register is updated with the OCRnx buffer value (only for\nmodes utilizing double buffering). Figure 17-10  shows a timing diagram for the setting of OCFnx. \nFigure 17-10. Timer/Counter Timing Diagram, Setting of OCFnx, no Prescaling\nFigure 17-11  shows the same timing data, but with the prescaler enabled.\nFigure 17-11. Timer/Counter Timing Diagram, Setting of OCFnx, with Prescaler (fclk_I/O /8)clkTn\n(clkI/O/1)\nOCFnxclkI/O\nOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2\nOCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\n\n157\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-12  shows the count sequence clos e to TOP in various modes. When using phase and\nfrequency correct P WM mode the OCRnx Register is updated at BOTTOM. The timing diagrams\nwill be the same, but TOP should be replaced by BOTTOM, TOP-1 by BOTTOM+1 and so on.\nThe same renaming applies for modes that set the TOVn Flag at BOTTOM.\nFigure 17-12. Timer/Counter Timing Diagram, no Prescaling\nFigure 17-13  shows the same timing data, but with the prescaler enabled.\nFigure 17-13. Timer/Counter Timing Dia gram, with Prescaler (fclk_I/O /8) TOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkTn\n(clkI/O/1)clkI/O\nTOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n158\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11 Register Description\n17.11.1 TCCR1A \u2013 Timer/Counter 1 Control Register A\n17.11.2 TCCR3A \u2013 Timer/Counter 3 Control Register A\n17.11.3 TCCR4A \u2013 Timer/Counter 4 Control Register A\n17.11.4 TCCR5A \u2013 Timer/Counter 5 Control Register A\n\u0081\nBit 7:6 \u2013 COMnA1:0: Compare Output Mode for Channel A\n\u0081Bit 5:4 \u2013 COMnB1:0: Compare Output Mode for Channel B\n\u0081Bit 3:2 \u2013 COMnC1:0: Compare Output Mode for Channel C\nThe COMnA1:0, COMnB1:0, and COMnC1:0 control the output compare pins (OCnA, OCnB,\nand OCnC respectively) behavior. If one or both of the COMnA1:0 bits are written to one, the\nOCnA output overrides the normal port functionality of the I/O pin it is connected to. If one or\nboth of the COMnB1:0 bits are written to one, the OCnB output overrides the normal port func-tionality of the I/O pin it is connected to. If one or both of the COMnC1:0 bits are written to one,\nthe OCnC output overrides the normal port functionality of the I/O pin it is connected to. How-\never, note that the Data Direction Register (DDR) bit corresponding to the OCnA, OCnB or\nOCnC pin must be set in order to enable the output driver.\nWhen the OCnA, OCnB or OCnC is connected to the pin, the function of the COMnx1:0 bits is\ndependent of the WGMn3:0 bits setting. Table 17-3 on page 159  shows the COMnx1:0 bit func-\ntionality when the WGMn3:0 bits are set to a normal or a CTC mode (non-P WM).B i t 765432 1 0\n(0x80) COM1A1 COM1A0 COM1B1 COM1B0 COM1C1 COM1C0 WGM11 WGM10 TCCR1A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0x90)\nCOM3A1 COM3A0 COM3B1 COM3B0 COM3C1 COM3C0 WGM31 WGM30 TCCR3A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0xA0)\nCOM4A1 COM4A0 COM4B1 COM4B0 COM4C1 COM4C0 WGM41 WGM40 TCCR4A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0x120)\nCOM5A1 COM5A0 COM5B1 COM5B0 COM5C1 COM5C0 WGM51 WGM50 TCCR5A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\n\n159\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1:0 \u2013 WGMn1:0: Waveform Generation Mode\nCombined with the WGMn3:2 bits found in the TCCRnB Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 17-2 on page 148 . Modes of operation supported by the\nTimer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode,and three types of Pulse Width Modulation (P WM) modes. For more information on the different\nmodes, see \u201cModes of Operation\u201d on page 148 .\nTable 17-4  shows the COMnx1:0 bit functionality when the WGMn3:0 bits are set to the fast\nPWM mode.\nNote: A special case occurs when  OCRnA/OCRnB/OCRnC equals TOP and \nCOMnA1/COMnB1/COMnC1 is set. In this case t he compare match is ignored, but the set or clear \nis done at BOTTOM. See \u201cFast P WM Mode\u201d on page 150.  for more details.Table 17-3. Compare Output Mode, non-P WM\nCOMnA1\nCOMnB1\nCOMnC1COMnA0\nCOMnB0\nCOMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected0 1 Toggle OCnA/OCnB/OCnC on compare match\n1 0 Clear OCnA/OCnB/OCnC on compare match (set output to low level)\n1 1 Set OCnA/OCnB/OCnC on compare match (set output to high level)\nTable 17-4. Compare Output Mode, Fast P WM\nCOMnA1\nCOMnB1COMnC1COMnA0\nCOMnB0COMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected\n01WGM13:0 = 14 or 15: Toggle OC1A on Compare Match, OC1B and OC1C \ndisconnected (normal port operation). For all other WGM1 settings, normal \nport operation, OC1A/OC1B/OC1C disconnected\n10Clear OCnA/OCnB/OCnC on compare match, set OCnA/OCnB/OCnC at \nBOTTOM (non-inverting mode)\n11Set OCnA/OCnB/OCnC on compare match, clear OCnA/OCnB/OCnC at \nBOTTOM (inverting mode)\n\n160\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 17-5  shows the COMnx1:0 bit functionality when the WGMn3:0 bits are set to the phase\ncorrect and frequency correct P WM mode.\nNote: A special case occurs when  OCRnA/OCRnB/OCRnC equals TOP and \nCOMnA1/COMnB1//COMnC1 is set. See \u201cPhase Correct P WM Mode\u201d on page 152.  for more \ndetails.\n17.11.5 TCCR1B \u2013 Timer/Counter 1 Control Register B\n17.11.6 TCCR3B \u2013 Timer/Counter 3 Control Register B\n17.11.7 TCCR4B \u2013 Timer/Counter 4 Control Register B\n17.11.8 TCCR5B \u2013 Timer/Counter 5 Control Register B\n\u0081 Bit 7 \u2013 ICNCn: Input Capture Noise Canceler\nSetting this bit (to one) activates the Input Capture Noise Canceler. When the Noise Canceler is\nactivated, the input from the Input Capture Pin (ICPn) is filtered. The filter function requires foursuccessive equal valued samples of the ICPn pin for changing its output. The input capture is\ntherefore delayed by four Oscillator cycles when the noise canceler is enabled.Table 17-5. Compare Output Mode, Phase Correct and Phase and Frequency Correct P WM\nCOMnA1\nCOMnB1\nCOMnC1COMnA0\nCOMnB0\nCOMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected\n01WGM13:0 =9 or 11: Toggle OC1A on Compare Match, OC1B and OC1C \ndisconnected (normal port operation). For all other WGM1 settings, normal \nport operation, OC1A/OC1B/OC1C disconnected\n10Clear OCnA/OCnB/OCnC on compare match when up-counting\nSet OCnA/OCnB/OCnC on compare match when downcounting\n11Set OCnA/OCnB/OCnC on compare match when up-counting\nClear OCnA/OCnB/OCnC on compare match when downcounting\nB i t 76543210\n(0x81) ICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 TCCR1B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nBit 7 6 5 4 3 2 1 0(0x91) ICNC3 ICES3 \u2013 WGM33 WGM32 CS32 CS31 CS30 TCCR3B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA1) ICNC4 ICES4 \u2013 WGM43 WGM42 CS42 CS41 CS40 TCCR4B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x121) ICNC5 ICES5 \u2013 WGM53 WGM52 CS52 CS51 CS50 TCCR5B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n161\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ICESn: Input Capture Edge Select\nThis bit selects which edge on the Input Capture Pin (ICPn) that is used to trigger a capture\nevent. When the ICESn bit is written to zero, a fa lling (negative) edge is  used as trigger, and\nwhen the ICESn bit is written to one, a risi ng (positive) edge w ill trigger the capture.\nWhen a capture is triggered according to the ICESn setting, the counter value is copied into the\nInput Capture Register (ICRn). The event will also set the Input Capture Flag (ICFn), and this\ncan be used to cause an Input Capture Interrupt, if this interrupt is enabled.\nWhen the ICRn is used as TOP value (see description of the WGMn3:0 bits located in the\nTCCRnA and the TCCRnB Register), the ICPn is disconnected and consequently the input cap-ture function is disabled.\n\u0081 Bit 5 \u2013 Reserved Bit\nThis bit is reserved for future use. For ensuring  compatibility with future de vices, this bit must be\nwritten to zero when TCCRnB is written.\n\u0081 Bit 4:3 \u2013 WGMn3:2: Waveform Generation Mode\nSee TCCRnA Register description.\n\u0081 Bit 2:0 \u2013 CSn2:0: Clock Select\nThe three clock select bits select the clock source to be used by the Timer/Counter, see Figure\n17-10 on page 156  and Figure 17-11 on page 156 .\nIf external pin modes are used for the Timer/Countern, transitions on the Tn pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n17.11.9 TCCR1C \u2013 Timer/Counter 1 Control Register CTable 17-6. Clock Select Bit Description\nCSn2 CSn1 CSn0 Description\n0 0 0 No clock source. (Timer/Counter stopped)001 c l k\nI/O/1 (No prescaling\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on Tn pin. Clock on falling edge1 1 1 External clock source on Tn pin. Clock on rising edge\nB i t 7654 3210\n(0x82) FOC1A FOC1B FOC1C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR1C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\n\n162\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.10 TCCR3C \u2013 Timer/Counter 3 Control Register C\n17.11.11 TCCR4C \u2013 Timer/Counter 4 Control Register C\n17.11.12 TCCR5C \u2013 Timer/Counter 5 Control Register C\n\u0081Bit 7 \u2013 FOCnA: Force Output Compare for Channel A\n\u0081Bit 6 \u2013 FOCnB: Force Output Compare for Channel B\n\u0081Bit 5 \u2013 FOCnC: Force Output Compare for Channel C\nThe FOCnA/FOCnB/FOCnC bits are only active when the WGMn3:0 bits specifies a non-P WM\nmode. When writing a logical one to the FOCnA/FOCnB/FOCnC bit, an immediate compare\nmatch is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed\naccording to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are imple-\nmented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine theeffect of the forced compare.\nA FOCnA/FOCnB/FOCnC strobe will no t generate any interrupt nor w ill it clear the timer in Clear\nTimer on Compare Match (CTC) mode using OCRnA as TOP.\nThe FOCnA/FOCnB/FOCnB bits are always read as zero.\n\u0081 Bit 4:0 \u2013 Reserved Bits\nThese bits are reserved for future  use. For ensuring compatibility with future devices, these bits\nmust be written to zero when TCCRnC is written.\n17.11.13 TCNT1H and TCNT1L \u2013 Timer/Counter 1\n17.11.14 TCNT3H and TCNT3L \u2013 Timer/Counter 3B i t 7654 3210\n(0x92) FOC3A FOC3B FOC3C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR3C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 7654 3210(0xA2) FOC4A FOC4B FOC4C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR4C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 7654 3210(0x122) FOC5A FOC5B FOC3C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR5C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x85) TCNT1[15:8] TCNT1H\n(0x84) TCNT1[7:0] TCNT1L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x95) TCNT3[15:8] TCNT3H\n(0x94) TCNT3[7:0] TCNT3L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n163\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.15 TCNT4H and TCNT4L \u2013Timer/Counter 4\n17.11.16 TCNT5H and TCNT5L \u2013Timer/Counter 5\nThe two Timer/Counter  I/O locations (TCNTnH and TCNTnL , combined TCNTn) give direct\naccess, both for read and for write operations, to the Timer/Counter unit 16-bit counter. Toensure that both the high and low bytes are read and written simultaneously when the CPU\naccesses these registers, the access is perfo rmed using an 8-bit temporary High Byte Register\n(TEMP). This temporary register is shared by all the other 16-bit registers. See \u201cAccessing 16-bit\nRegisters\u201d on page 138.\nModifying the counter (TCNTn) while the counte r is running introduces a risk of missing a com-\npare match between TCNTn and one of the OCRnx Registers.\nWriting to the TCNTn Register blocks (removes) the compare match on the following timer clock\nfor all compare units.\n17.11.17 OCR1AH and OCR1AL \u2013 Ou tput Compare Register 1 A\n17.11.18 OCR1BH and OCR1BL \u2013 Ou tput Compare Register 1 B\n17.11.19 OCR1CH and OCR1CL \u2013 Ou tput Compare Register 1 CB i t 76543210\n(0xA5) TCNT4[15:8] TCNT4H\n(0xA4) TCNT4[7:0] TCNT4L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x125) TCNT5[15:8] TCNT5H\n(0x124) TCNT5[7:0] TCNT5L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x89) OCR1A[15:8] OCR1AH\n(0x88) OCR1A[7:0] OCR1AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x8B) OCR1B[15:8] OCR1BH\n(0x8A) OCR1B[7:0] OCR1BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x8D) OCR1C[15:8] OCR1CH\n(0x8C) OCR1C[7:0] OCR1CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n164\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.20 OCR3AH and OCR3AL \u2013 Ou tput Compare Register 3 A\n17.11.21 OCR3BH and OCR3BL \u2013 Ou tput Compare Register 3 B\n17.11.22 OCR3CH and OCR3CL \u2013 Ou tput Compare Register 3 C\n17.11.23 OCR4AH and OCR4AL \u2013 Ou tput Compare Register 4 A\n17.11.24 OCR4BH and OCR4BL \u2013 Ou tput Compare Register 4 B\n17.11.25 OCR4CH and OCR4CL \u2013Output Compare Register 4 C\n17.11.26 OCR5AH and OCR5AL \u2013 Ou tput Compare Register 5 AB i t 76543210\n(0x99) OCR3A[15:8] OCR3AH\n(0x98) OCR3A[7:0] OCR3AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x9B) OCR3B[15:8] OCR3BH\n(0x9A) OCR3B[7:0] OCR3BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x9D) OCR3C[15:8] OCR3CH\n(0x9C) OCR3C[7:0] OCR3CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA9) OCR4A[15:8] OCR4AH\n(0xA8) OCR4A[7:0] OCR4AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xAA) OCR4B[15:8] OCR4BH\n(0xAB) OCR4B[7:0] OCR4BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xAD) OCR4C[15:8] OCR4CH\n(0xAC) OCR4C[7:0] OCR4CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x129) OCR5A[15:8] OCR5AH\n(0x128) OCR5A[7:0] OCR5AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n165\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.27 OCR5BH and OCR5BL \u2013 Ou tput Compare Register 5 B\n17.11.28 OCR5CH and OCR5CL \u2013Output Compare Register 5 C\nThe Output Compare Registers contain a 16-bit value that is continuously compared with the\ncounter value (TCNTn). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OCnx pin.\nThe Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are\nwritten simultaneously when the CP U writes to these registers, the access is performed using an\n8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other\n16-bit registers. See \u201cAccessing 16-bit Registers\u201d on page 138.\n17.11.29 ICR1H and ICR1L \u2013 Input Capture Register 1\n17.11.30 ICR3H and ICR3L \u2013 Input Capture Register 3\n17.11.31 ICR4H and ICR4L \u2013 Input Capture Register 4\n17.11.32 ICR5H and ICR5L \u2013 Input Capture Register 5B i t 76543210\n(0x12B) OCR5B[15:8] OCR5BH\n(0x12A) OCR5B[7:0] OCR5BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x12D) OCR5C[15:8] OCR5CH\n(0x12C) OCR5C[7:0] OCR5CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x87) ICR1[15:8] ICR1H\n(0x86) ICR1[7:0] ICR1L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x97) ICR3[15:8] ICR3H\n(0x96) ICR3[7:0] ICR3L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA7) ICR4[15:8] ICR4H\n(0xA6) ICR4[7:0] ICR4L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x127) ICR5[15:8] ICR5H\n(0x126) ICR5[7:0] ICR5L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n166\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Input Capture is updated with the counter (TCNTn) value each time an event occurs on the\nICPn pin (or optionally on the Analog Comparator output for Timer/Counter1). The Input Capture\ncan be used for defining the counter TOP value.\nThe Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read\nsimultaneously when the CPU accesses these regi sters, the access is performed using an 8-bit\ntemporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit\nregisters. See \u201cAccessing 16-bit Registers\u201d on page 138.\n17.11.33 TIMSK1 \u2013 Ti mer/Counter 1 Interrupt Mask Register\n17.11.34 TIMSK3 \u2013 Ti mer/Counter 3 Interrupt Mask Register\n17.11.35 TIMSK4 \u2013 Ti mer/Counter 4 Interrupt Mask Register\n17.11.36 TIMSK5 \u2013 Ti mer/Counter 5 Interrupt Mask Register\n\u0081 Bit 5 \u2013 ICIEn: Timer/Countern, Input Capture Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Input Capture interrupt is enabled. The corresponding Interrupt\nVector (see \u201cInterrupts\u201d on page 105 ) is executed when the ICFn Flag, located in TIFRn, is set.\n\u0081 Bit 3 \u2013 OCIEnC: Timer/Countern, Output Compare C Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare C Match interrupt is enabled. The corresponding\nInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnC Flag, located in\nTIFRn, is set.\n\u0081 Bit 2 \u2013 OCIEnB: Timer/Countern, Output Compare B Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare B Match interrupt is enabled. The corresponding\nInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnB Flag, located in\nTIFRn, is set.B i t 76543210\n(0x6F) \u2013 \u2013I C I E 1 \u2013 OCIE1C OCIE1B OCIE1A TOIE1 TIMSK1\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x71)\n\u2013 \u2013I C I E 3 \u2013 OCIE3C OCIE3B OCIE3A TOIE3 TIMSK3\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x72)\n\u2013 \u2013I C I E 4 \u2013 OCIE4C OCIE4B OCIE4A TOIE4 TIMSK4\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x73)\n\u2013 \u2013I C I E 5 \u2013 OCIE5C OCIE5B OCIE5A TOIE5 TIMSK5\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n167\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1 \u2013 OCIEnA: Timer/Countern, Output Compare A Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare A Match interrupt is enabled. The correspondingInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnA Flag, located in\nTIFRn, is set.\n\u0081 Bit 0 \u2013 TOIEn: Timer/Countern, Overflow Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Overflow interrupt is enabled. The corresponding Interrupt Vector(see \u201cInterrupts\u201d on page 105 ) is executed when the TOVn Flag, located in TIFRn, is set.\n17.11.37 TIFR1 \u2013 Timer/Counte r1 Interrupt Flag Register\n17.11.38 TIFR3 \u2013 Timer/Counte r3 Interrupt Flag Register\n17.11.39 TIFR4 \u2013 Timer/Counte r4 Interrupt Flag Register\n17.11.40 TIFR5 \u2013 Timer/Counte r5 Interrupt Flag Register\n\u0081 Bit 5 \u2013 ICFn: Timer/Count ern, Input Capture Flag\nThis flag is set when a capture event occurs on the ICPn pin. When the Input Capture Register\n(ICRn) is set by the WGMn3:0 to be used as the TOP value, the ICFn Flag is set when the coun-\nter reaches the TOP value.\nICFn is automatically cleared when the Input Capt ure Interrupt Vector is executed. Alternatively,\nICFn can be cleared by writing a logic one to its bit location.\n\u0081 Bit 3\u2013 OCFnC: Timer/Countern, Output Compare C Match Flag\nThis flag is set in the timer clock cycle af ter the counter (TCNTn) value matches the Output\nCompare Register C (OCRnC).\nNote that a Forced Output Compare (FOC nC) strobe will not set the OCFnC Flag.\nOCFnC is automatically cleared when the Output Compare Match C Interrupt Vector is exe-\ncuted. Alternatively, OCFnC can be cleared by writing a logic one to its bit location.B i t 76543210\n0x16 (0x36) \u2013 \u2013I C F 1 \u2013 OCF1C OCF1B OCF1A TOV1 TIFR1\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x18 (0x38)\n\u2013 \u2013I C F 3 \u2013 OCF3C OCF3B OCF3A TOV3 TIFR3\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x19 (0x39)\n\u2013 \u2013I C F 4 \u2013 OCF4C OCF4B OCF4A TOV4 TIFR4\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1A (0x3A)\n\u2013 \u2013I C F 5 \u2013 OCF5C OCF5B OCF5A TOV5 TIFR5\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n168\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 \u2013 OCFnB: Timer/Counter1, Output Compare B Match Flag\nThis flag is set in the timer clock cycle af ter the counter (TCNTn) value matches the Output\nCompare Register B (OCRnB).\nNote that a Forced Output Compare (FOC nB) strobe will not set the OCFnB Flag.\nOCFnB is automatically cleared when the Output  Compare Match B Interrupt Vector is exe-\ncuted. Alternatively, OCFnB can be cleared by writing a logic one to its bit location.\n\u0081 Bit 1 \u2013 OCF1A: Timer/Counter1, Output Compare A Match Flag\nThis flag is set in the timer clock cycle after the counter (TCNTn value matches the Output Com-\npare Register A (OCRnA).\nNote that a Forced Output Compare (FOC nA) strobe will not set the OCFnA Flag.\nOCFnA is automatically cleared when the Output  Compare Match A Interrupt Vector is exe-\ncuted. Alternatively, OCFnA can be cleared by writing a logic one to its bit location.\n\u0081 Bit 0 \u2013 TOVn: Timer/Countern, Overflow Flag\nThe setting of this flag is dependent of the WGMn3:0 bits setting. In Normal and CTC modes,\nthe TOVn Flag is set when the timer overflows. Refer to Table 17-2 on page 148  for the TOVn\nFlag behavior when using another WGMn3:0 bit setting.\nTOVn is automatically cleared when the Timer/C ountern Overflow Interrupt Vector is executed.\nAlternatively, TOVn can be cleared by writing a logic one to its bit location.\n\n169\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n18. Timer/Counter 0, 1, 3, 4, and 5 Prescaler\nTimer/Counter 0, 1, 3, 4, and 5 share the same prescaler module, but the Timer/Counters can\nhave different prescaler settings. The description below applies to all Timer/Counters. Tn is used\nas a general name, n = 0, 1, 3, 4, or 5.\n18.1 Internal Clock Source\nThe Timer/Counter can be clocked directly by the system clock (by setting the CSn2:0 = 1). This\nprovides the fastest operation, with a maximum Timer/Counter clock frequency equal to system\nclock frequency (fCLK_I/O ). Alternatively, one of four taps from the prescaler can be used as a\nclock source. The prescaled clock has a frequency of either fCLK_I/O /8, fCLK_I/O /64, fCLK_I/O /256, or\nfCLK_I/O /1024.\n18.2 Prescaler Reset\nThe prescaler is free running, that is, operates  independently of the Clock Select logic of the\nTimer/Counter, and it is shared by the Timer/Counter Tn. Since the prescaler is not affected by\nthe Timer/Counter\u2019s clock select, the state of the prescaler will ha ve implications  for situations\nwhere a prescaled clock is used. One example of prescaling artifacts occurs when the timer isenabled and clocked by the prescaler (6 > CSn2:0  > 1). The number of system clock cycles from\nwhen the timer is enabled to the first count occurs can be from 1 to N+1 system clock cycles,\nwhere N equals the prescaler divisor (8, 64, 256, or 1024).\nIt is possible to use the prescaler reset for synchronizing the Timer/Counter to program execu-\ntion. However, care must be taken if the other Timer/Counter that shares the same prescaler\nalso uses prescaling. A prescaler reset will affect the prescaler period for all Timer/Coun ters it is\nconnected to.\n18.3 External Clock Source\nAn external clock source applied to the Tn  pin can be used as Timer/Counter clock (clkTn). The\nTn pin is sampled once every system clock cycle by the pin synchronization logic. The synchro-nized (sampled) signal is then passed through the edge detector. Figure 18-1  shows a functional\nequivalent block diagram of the Tn synchronizati on and edge detector logic. The registers are\nclocked at the positive edge of the internal system clock (\nclkI/O). The latch is transparent in the\nhigh period of the internal system clock.\nThe edge detector generates one clkTn pulse for each positive (CSn2:0 = 7) or negative (CSn2:0\n= 6) edge it detects.\nFigure 18-1. Tn/T0 Pin Sampling\nTn_sync\n(To ClockSelect Logic)\nEdge Detector SynchronizationDQ DQ\nLEDQ Tn\nclkI/O\n\n170\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe synchronization and e dge detector logic introduces a de lay of 2.5 to 3.5 system clock cycles\nfrom an edge has been applied to the Tn pin to the counter is updated.\nEnabling and disabling of the clock input must be done when Tn has been stable for at least one\nsystem clock cycle, otherwise it is a risk that a false Timer/Counter clock pulse is generated.\nEach half period of the external clock applie d must be longer than one system clock cycle to\nensure correct sampling. The external clock must be guaranteed to have less than half the sys-\ntem clock frequency (fExtClk < fclk_I/O /2) given a 50/50% duty cycle. Since the edge detector uses\nsampling, the maximum frequency of an external clock it can detect is half the sampling fre-\nquency (Nyquist sampling theorem). However, due to variation of the system clock frequency\nand duty cycle caused by Oscillator source (crystal, resonator, and capacitors) tolerances, it isrecommended that maximum frequency of an external clock source is less than f\nclk_I/O /2.5.\nAn external clock source  can not be prescaled.\nFigure 18-2. Prescaler for synchronous Timer/Counters\n18.4 Register Description\n18.4.1 GTCCR \u2013 General Timer/Counter Control Register\n\u0081 Bit 7 \u2013 TSM: Timer/Counter Synchronization Mode\nWriting the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode, the\nvalue that is written to the PSRASY and PSRSYN C bits is kept, hence keeping the correspond-\ning prescaler reset signals asserted. This ensures that the corresponding Timer/Counters arehalted and can be configured to the same value without the risk of one of them advancing during\nconfiguration. When the TSM bit is writ ten to zero, the PSRASY and PSRSYNC bits are cleared\nby hardware, and the Timer/Counte rs start counting simultaneously.PSR10Clear\nTnTnclkI/O\nSynchronizationSynchronization\nTIMER/COUNTERn CLOCK SOURCE\nclkTnTIMER/COUNTERn CLOCK SOURCE\nclkTnCSn0\nCSn1\nCSn2CSn0\nCSn1\nCSn2\nBit 7 6 5 4 3 2 1 0\n0x23 (0x43) TSM \u2013 \u2013 \u2013 \u2013 \u2013 PSRASY PSRSYNC GTCCR\nRead/Write R/ W RRR R R R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n171\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 PSRSYNC: Prescaler Reset for Synchronous Timer/Counters\nWhen this bit is one, Timer/Counter0, Timer/C ounter1, Timer/Counter3, Timer/Counter4 and\nTimer/Counter5 prescaler will be Re set. This bit is normally cl eared immediatel y by hardware,\nexcept if the TSM bit is set. Note that Timer/Counter0, Timer/Counter1, Timer/Counter3,\nTimer/Counter4 and Timer/Counte r5 share the same prescaler and  a reset of this prescaler will\naffect all timers.\n\n172\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n19. Output Compare Modulator (OCM1C0A)\n19.1 Overview\nThe Output Compare Modulator (OCM) allows generation of waveforms modulated with a carrier\nfrequency. The modulator uses the outputs from the Output Compare Unit C of the 16-bitTimer/Counter1 and the Output Compare Unit of the 8-bit Timer/Counter0. For more details\nabout these Timer/Counters see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169  and \u201c8-\nbit Timer/Counter2 with P WM and Asynchronous Operation\u201d on page 174 .\nFigure 19-1. Output Compare Modulator, Block Diagram\nWhen the modulator is enabled, the two output compare channels are modulated together as\nshown in the block diagram (see Figure 19-1 ).\n19.2 Description\nThe Output Compare unit 1C and Output Compare unit 2 shares the PB7 port pin for output. The\noutputs of the Output Compare units (OC1C and OC0A) overrides the normal PORTB7 Register\nwhen one of them is enabled (that is, when COMnx1:0 is not equal to zero). When both OC1C\nand OC0A are enabled at the same time, the modulator is automatically enabled.\nThe functional equivalent schematic of the modulator is shown on Figure 19-2 . The schematic\nincludes part of the Timer/Counter units and the port B pin 7 output driver circuit.\nFigure 19-2. Output Compare Modulator, SchematicOC1C\nPin\nOC1C /\nOC0A / PB7Timer/Counter 1\nTimer/Counter 0 OC0A\nPORTB7 DDRB7DQ DQPinCOMA01\nCOMA00\nDATABUSOC1C /\nOC0A/ PB7COM1C1\nCOM1C0Modulator\n10\nOC1CDQ\nOC0ADQ( From Waveform Generator )\n( From Waveform Generator )01Vcc\n\n173\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the modulator is enabled the type of modulation (logical AND or OR) can be selected by\nthe PORTB7 Register. Note that the DDRB7 controls the direction of the port independent of the\nCOMnx1:0 bit setting.\n19.2.1 Timing example\nFigure 19-3 illustrates the modulator in ac tion. In this example the Ti mer/Counter1 is  set to oper-\nate in fast P WM mode (non-inverted) and Timer/Counter0 uses CTC waveform mode with toggle\nCompare Output mode (COMnx1:0 = 1).\nFigure 19-3. Output Compare Modulator, Timing Diagram\nIn this example, Timer/Counter2 provides the carrier, while the modulating signal is generated\nby the Output Compare unit C of the Timer/Counter1.\nThe resolution of the P WM signal (OC1C) is reduced by the modulation. The reduction factor is\nequal to the number of system clock cycles of one period of the carrier (OC0A). In this example\nthe resolution is reduced by a factor of two. The reason for the reduction is illustrated in Figure\n19-3 at the second and third period of the PB7 output when PORTB7 equals zero. The period 2\nhigh time is one cycle longer than the period 3 high time, but the result on the PB7 output is\nequal in both periods.1 2OC0A\n(CTC Mode)OC1C\n(FPWM Mode)\nPB7\n(PORTB7 = 0)\nPB7\n(PORTB7 = 1)\n(Period)3clkI/O\n\n174\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20. 8-bit Timer/Counter2 with PWM and Asynchronous Operation\nTimer/Counter2 is a general purpose, single channel, 8-bit Timer/Counter module. The main\nfeatures are:\n\u0081Single Channel Counter\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch-free, Phase Correct Pu lse Width Modulator (PWM)\n\u0081Frequency Generator\n\u008110-bit Clock Prescaler\n\u0081Overflow and Compare Ma tch Interrupt Sources (TOV2, OCF2A and OCF2B)\n\u0081Allows Clocking from External 32kHz Watch Crystal Independent of the I/O Clock\n20.1 Overview\nA simplified block diagram of the 8-bit Timer/Counter is shown in Figure 17-12.  For the actual\nplacement of I/O pins, see \u201cPin Configurations\u201d on page 2 . CPU accessible I/O Registers, includ-\ning I/O bits and I/O pins, are shown in bold. T he device-specific I/O Register and bit locations\nare listed in the \u201cRegister Description\u201d on page 187 .\nThe Power Reduction Timer/Counter2 bit, PRTIM2, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be written to zero to enable Timer/Counter2 module.\nFigure 20-1. 8-bit Timer/Counter Block Diagram\nTimer/Counter\nDATA BUSOCRnA\nOCRnB=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB=\nFixed\nTOP\nValueControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int.Req.)\nOCnA\n(Int.Req.)\nOCnB(Int.Req.)\nTCCRnA TCCRnBclkTn\nASSRnSynchronization UnitPrescalerT/C\nOscillator\nclkI/O\nclkASY\nasynchronous mode\n      select (ASn)Synchronized Status flagsTOSC1\nTOSC2\nStatus flagsclkI/O\n\n175\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.1.1 Registers\nThe Timer/Counter (TCNT2) and Output Compare Register (OCR2A and OCR2B) are 8-bit reg-\nisters. Interrupt request (abbreviated to Int.Req.) signals are all visible in the Timer Interrupt Flag\nRegister (TIFR2). All interrupts are individua lly masked with the Timer Interrupt Mask Register\n(TIMSK2). TIFR2 and TIMSK2 are not shown in the figure.\nThe Timer/Counter can be clocked internally, via the prescaler, or asynchronously clocked from\nthe TOSC1/2 pins, as detailed later in this section. The asynchronous operation is controlled by\nthe Asynchronous Status Regist er (ASSR). The Clock Select lo gic block controls which clock\nsource the Timer/Counter uses to increment (or de crement) its value. The Timer/Counter is inac-\ntive when no clock source is selected. The output from the Clock Select logic is referred to as the\ntimer clock (clkT2).\nThe double buffered Output Compare Register (OCR2A and OCR2B) are compared with the\nTimer/Counter value at all times. The result of the compare can be used by the Waveform Gen-\nerator to generate a P WM or variable frequency output on the Output Compare pins (OC2A and\nOC2B). See \u201cOutput Compare Unit\u201d on page 180  for details. The comp are match event will also\nset the Compare Flag (OCF2A or OCF2B) which can be used to generate an Output Compare\ninterrupt request.\n20.1.2 Definitions\nMany register and bit references in this document are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case  2. However, when using the register or bit\ndefines in a program, the precise form must be used, that is, TCNT2 for accessing\nTimer/Counter2 counter value and so on.\nThe definitions in Table 20-1  are also used extensively throughout the section.\n20.2 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal synchronous or an external asynchronous\nclock source. The clock source clkT2 is by default equal to the MCU clock, clkI/O. When the AS2\nbit in the ASSR Register is written to logic one, the clock source is taken from the Timer/Counter\nOscillator connecte d to TOSC1 and TOSC2. For details on asynchronous operation, see \u201cAsyn-\nchronous Operation of Timer/Counter2\u201d on page 184 . For details on clock sources and\nprescaler, see \u201cTimer/Counter Prescaler\u201d on page 186 .\n20.3 Counter Unit\nThe main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure\n20-2 on page 176  shows a block diagram of the counter and its surrounding environment.Table 20-1. Definitions\nBOTTOM The counter reaches the BOTTOM when it becomes zero (0x00)\nMAX The counter reaches its MAXimum when it becomes 0xFF (decimal 255)\nTOP The counter reaches the TOP when it becomes equal to the highest value in the count\nsequence. The TOP value can be assigned to be the fixed value 0xFF (MAX) or the\nvalue stored in the OCR2A Register. The assignment is dependent on the mode of\noperation\n\n176\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-2. Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment or decrement TCNT2 by 1.\ndirection Selects between increment and decrement.\nclear Clear TCNT2 (set all bits to zero).\nclkTn Timer/Counter clock, referred to as clkT2 in the following.\ntop Signalizes that TCNT2 has reached maximum value.\nbottom Signalizes that TCNT2 has reached minimum value (zero).\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock (clkT2). clkT2 can be generated from an external or internal clock source,\nselected by the Clock Select bits (CS22:0). When no clock source is selected (CS22:0 = 0) the\ntimer is stopped. However, the TCNT2 value can be accessed by the CPU, regardless of\nwhether clkT2 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the WGM21 and WGM20 bits located in\nthe Timer/Counter Control Register (TCCR2A) and the WGM22 located in the Timer/Counter\nControl Register B (TCCR2B). There are clos e connections between how the counter behaves\n(counts) and how waveforms are generated on the Output Compare outputs OC2A and OC2B.\nFor more details about advanced counting sequences and waveform generation, see \u201cModes of\nOperation\u201d on page 176 .\nThe Timer/Counter Overflow Flag (TOV2) is set according to the mode of operation selected by\nthe WGM22:0 bits. TOV2 can be used for generating a CPU interrupt.\n20.4 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode ( WGM22:0) and Compare Out-\nput mode (COM2x1:0) bits. The Compare Output mode bits do not affect the counting sequence,while the Waveform Generation mode bits do. The COM2x1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COM2x1:0 bits control whether the output should be set, cleared, or toggled at a comparematch. See \u201cCompare Match Output Unit\u201d on page 182.\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 183 .DATA BU S\nTCNTn Control LogiccountTOVn\n(Int.Req.)\ntop bottomdirectionclearTOSC1\nT/C\nOscillator\nTOSC2Prescaler\nclkI/OclkTn\n\n177\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.4.1 Normal Mode\nThe simplest mode of operation is the Normal mode ( WGM22:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 8-bit value (TOP = 0xFF) and then restarts from the bot-\ntom (0x00). In normal o peration the Timer/Counter Overflow Flag (TOV2) will be set in the same\ntimer clock cycle as the TCNT2 becomes zero. The TOV2 Flag in this case behaves like a ninth\nbit, except that it is only set, not cleared. However, combined with the timer overflow interrupt\nthat automatically clears the TOV2 Flag, the timer resolution can be increased by software.\nThere are no special cases to consider in the Normal mode, a new counter value can be writtenanytime.\nThe Output Compare unit can be used to generate interrupts at some given time. Using the Out-\nput Compare to generate waveforms in Normal mode is not recommended, since this willoccupy too much of the CPU time.\n20.4.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare or CTC mode ( WGM22:0 = 2), the OCR2A Register is used to\nmanipulate the counter resolution. In CTC mode the counter is cleared to zero when the counter\nvalue (TCNT2) matches the OCR2A. The OCR2A defines the top value for the counter, hencealso its resolution. This mode allows greater control of the compare match output frequency. It\nalso simplifies the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 20-3 . The counter value (TCNT2)\nincreases until a compare match occurs between TCNT2 and OCR2A, and then counter\n(TCNT2) is cleared.\nFigure 20-3. CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter value reaches the TOP value by using the\nOCF2A Flag. If the interrupt is enabled, the interrupt handler routine can be used for updatingthe TOP value. However, changing TOP to a va lue close to BOTTOM when the counter is run-\nning with none or a low prescaler value must be done with care since the CTC mode does not\nhave the double buffering feature. If the new value written to OCR2A is lower than the currentvalue of TCNT2, the counter will miss the compar e match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starting at 0x00 before the compare match can\noccur.\nFor generating a waveform output in CTC mode, the OC2A output can be set to toggle its logical\nlevel on each compare match by setting the Compare Output mode bits to toggle mode\n(COM2A1:0 = 1). The OC2A value will not be visible on the port pin unless the data direction forTCNTn\nOCnx\n(Toggle)OCnx Interrupt Flag Set\n1 4 Period 2 3(COMnx1:0 = 1)\n\n178\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe pin is set to output. The wavefo rm generated will have a maximum frequency of fOC2A =\nfclk_I/O /2 when OCR2A is set to zero (0x00). The waveform frequency is defined by the following\nequation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nAs for the Normal mode of operation, the TOV2  Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x00.\n20.4.3 Fast PWM Mode\nFigure 20-4. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches TOP. If the inter-\nrupt is enabled, the interrupt handler routine can be used for updating the compare value.\nIn fast P WM mode, the compare unit allows generation of P WM waveforms on the OC2x pin.\nSetting the COM2x1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COM2x1:0 to three. TOP is defined as 0xFF when WGM2:0 = 3,\nand OCR2A when WGM2:0 = 7 (see Table 20-3 on page 187 ). The actual OC2x value will only\nbe visible on the port pin if the data direction for the port pin is set as output. The P WM wave-\nform is generated by setting (or clearing) the OC2x Register at the compare match betweenOCR2x and TCNT2, and clearing (or setting) the OC2x Register  at the timer clock cycle the\ncounter is cleared (changes from TOP to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nThe extreme values for the OCR2A Register represent special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCR2A is set equal to BOTTOM, the output will\nbe a narrow spike for each MAX+1 timer clock cycle. Setting the OCR2A equal to MAX will resultfOCnxfclk_I/O\n2N1OCRnx+() \u22c5\u22c5------------------------------------------------- - =\nTCNTnOCRnx Update and\nTOVn Interrupt Flag Set\n1 Period 2 3OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Interrupt Flag Set\n4 5 6 7\nfOCnxPWMfclk_I/O\nN256\u22c5------------------=\n\n179\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nin a constantly high or low output (depending on the polarity of the output set by the COM2A1:0\nbits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OC2x to toggle its logical level on each compare match (COM2x1:0 = 1). The waveformgenerated will have a ma ximum frequency of f\noc2 = fclk_I/O /2 when OCR2A is set to zero. This fea-\nture is similar to the OC2A toggle in CTC mode, except the double buffer feature of the Output\nCompare unit is enabled in the fast P WM mode.\n20.4.4 Phase Correct PWM Mode\nThe phase correct P WM mode ( WGM22:0 = 1 or 5) provides a high resolution phase correct\nPWM waveform generation option. The phase correct P WM mode is based on a dual-slope\noperation. The counter counts repeatedly from BOTTOM to TOP and then from TOP to BOT-\nTOM. TOP is defined as 0xFF when WGM22:0 = 1, and OCR2A when MGM22:0 = 5. In non-\ninverting Compare Output mode, the Output Compare (OC2x) is cleared on the compare match\nbetween TCNT2 and OCR2x while upcounting, and set on the compare match while downcount-\ning. In inverting Output Compare mode, the operation is inverted. The dual-slope operation haslower maximum operation frequency than single slope operation. However, due to the symmet-\nric feature of the dual-slope P WM modes, these modes are preferred for motor control\napplications.\nIn phase correct P WM mode the counter is incremented until the counter value matches TOP.\nWhen the counter reaches TOP, it changes the count direction. The TCNT2 value will be equal\nto TOP for one timer clock cycle. The timing diagram for the phase correct P WM mode is shown\non Figure 20-5 . The TCNT2 value is in the timing diagram shown as a histogram for illustrating\nthe dual-slope operation. The diagram includes non-inverted and inverted P WM outputs. The\nsmall horizontal line marks on the TCNT2 sl opes represent compare matches between OCR2x\nand TCNT2.\nFigure 20-5. Phase Correct P WM Mode, Timing Diagram\nTOVn Interrupt Flag SetOCnx Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCnx\nOCnx (COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Update\n\n180\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches BOTTOM. The\nInterrupt Flag can be used to generate an interrupt each time the counter reaches the BOTTOM\nvalue.\nIn phase correct P WM mode, the compare unit allows generation of P WM waveforms on the\nOC2x pin. Setting the COM2x1:0 bits  to two will produce a non-inverted P WM. An inverted P WM\noutput can be generated by setting the COM2x1:0 to three. TOP is defined as 0xFF when\nWGM2:0 = 3, and OCR2A when MGM2:0 = 7 (see Table 20-4 on page 188 ). The actual OC2x\nvalue will only be visible on the port  pin if the data direction for the port pin is set as output. The\nPWM waveform is generated by clearing (or setting) the OC2x Register at the compare match\nbetween OCR2x and TCNT2 when the counter increments, and setting (or clearing) the OC2xRegister at compare match between OCR2x and TCNT2 when the counter decrements. The\nPWM frequency for the output when using phase correct P WM can be calculated by the follow-\ning equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nThe extreme values for the OCR2A Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCR2A is set equal to BOTTOM, the\noutput will be continuously low an d if set equal to MAX the output  will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have th e opposite logic values.\nAt the very start of period 2 in Figure 20-5 on page 179  OCnx has a transition from high to low\neven though there is no Compare Match. The poin t of this transition is to guarantee symmetry\naround BOTTOM. There are two cases that give a transition without Compare Match.\n\u0081 OCR2A changes its value from MAX, like in Figure 20-5 on page 179 . When the OCR2A \nvalue is MAX the OCn pin value is the same as the result of a down-counting compare match. To ensure symmetry around BOTTOM the OCn value at MAX must correspond to the result of an up-counting Compare Match.\n\u0081 The timer starts counting from a value higher than the one in OCR2A, and for that reason \nmisses the Compare Match and hence the OCn change that would have happened on the way up.\n20.5 Output Compare Unit\nThe 8-bit comparator continuously compares TCNT2 with the Output Compare Register\n(OCR2A and OCR2B). Whenever TCNT2 equals OCR2A or OCR2B, the comparator signals a\nmatch. A match will set the Output Compare Flag (OCF2A or OCF2B) at the next timer clock\ncycle. If the corresponding interrupt is enabled, the Output Compare Flag generates an Output\nCompare interrupt. The Output Compare Flag is automatically cleared when the interrupt is exe-cuted. Alternatively, the Output Compare Flag can be cleared by software by writing a logical\none to its I/O bit location. The Waveform Generator uses the match signal to generate an output\naccording to operating mode set by the WGM22:0 bits and Compare Output mode (COM2x1:0)\nbits. The max and bottom signals are used by the Waveform Generator for handling the special\ncases of the extreme values in some modes of operation (see \u201cModes of Operation\u201d on page\n176).\nFigure 20-6 on page 181  shows a block diagram of the Output Compare unit.fOCnxPCPWMfclk_I/O\nN510\u22c5------------------=\n\n181\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-6. Output Compare Unit, Block Diagram\nThe OCR2x Register is double buffered when using any of the Pulse Width Modulation (P WM)\nmodes. For the Normal and Clear Timer on Compare (CTC) modes of operation, the doublebuffering is disabled. The double buffering synchronizes the update of the OCR2x Compare\nRegister to either top or bottom of the counting sequence. The synchronization prevents the\noccurrence of odd-length, non-symmetrical P WM pulses, thereby making the output glitch-free.\nThe OCR2x Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR2x Buffer Register, and if double buffering is dis-\nabled the CPU will access  the OCR2x directly.\n20.5.1 Force Output Compare\nIn non-P WM waveform generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Outp ut Compare (FOC2x) bit. Forci ng compare match will not set the\nOCF2x Flag or reload/clear the timer, but the OC2x pin will be updated as if a real compare\nmatch had occurred (the COM2x1:0 bits settings de fine whether the OC2x pin is set, cleared or\ntoggled).\n20.5.2 Compare Match Bloc king by TCNT2 Write\nAll CPU write operations to the TCNT2 Register will block any compare matc h that occurs in the\nnext timer clock cycle, even when the timer is stopped. This feature allows OCR2x to be initial-\nized to the same value as TCNT2 without triggering an interrupt when the Timer/Counter clock isenabled.\n20.5.3 Using the Output Compare Unit\nSince writing TCNT2 in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNT2 when using the Output Compare channel,\nindependently of whether the Timer/Counter is running or not. If the value written to TCNT2equals the OCR2x value, the compare match will be missed, resulting in incorrect waveform\ngeneration. Similarly, do not write the TCNT2 value equal to BOTTOM when the counter is\ndowncounting.OCFn x (Int.Req.)= (8-bit Comparator )OCRnx\nOCnxDATA BU S\nTCNTn\nWGMn1:0Waveform Generatortop\nFOCn\nCOMnX1:0bottom\n\n182\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe setup of the OC2x should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OC2x value is to use the Force Output Com-\npare (FOC2x) strobe bit in Normal mode. The OC2x Register keeps its value even when\nchanging between Waveform Generation modes.\nBe aware that the COM2x1:0 bits are not doubl e buffered together with the compare value.\nChanging the COM2x1:0 bits will take effect immediately.\n20.6 Compare Match Output Unit\nThe Compare Output mode (COM2x1:0) bits have two functions. The Waveform Generator uses\nthe COM2x1:0 bits for defining the Output Compare (OC2x) state at the next compare match.\nAlso, the COM2x1:0 bits control the OC2x pin output source. Figure 20-7  shows a simplified\nschematic of the logic affected by the COM2x1:0 bit setting. The I/O Registers, I/O bits, and I/Opins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers\n(DDR and PORT) that are affected by the COM2x1:0 bits are shown. When referring to the\nOC2x state, the reference is for the internal OC2x Register, not the OC2x pin.\nFigure 20-7. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC2x) from the Waveform\nGenerator if either of the COM2x1:0 bits are set. However, the OC2x pin direction (input or out-\nput) is still controlled by the Da ta Direction Register (DDR) for th e port pin. The Data Direction\nRegister bit for the OC2x pin (DDR_OC2x) must be set as output before the OC2x value is visi-\nble on the pin. The port override  function is independent of the Waveform Generation mode.\nThe design of the Output Compare pin logic allows initialization of the OC2x state before the out-\nput is enabled. Note that some COM2x1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 187.PORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCnx\nclkI/O\n\n183\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.6.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COM2x1:0 bits differently in normal, CTC, and P WM modes.\nFor all modes, setting the COM2x1:0 = 0 tells the Waveform Generator that no action on the\nOC2x Register is to be performed on the next compare match. For compare output actions in the\nnon-PWM modes refer to Table 20-5 on page 188 . For fast P WM mode, refer to Table 20-6 on\npage 188 , and for phase correct P WM refer to Table 20-7 on page 189 .\nA change of the COM2x1:0 bits st ate will have effect at the first compare matc h after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOC2x strobe bits.\n20.7 Timer/Counter Timing Diagrams\nThe following figures show the Timer/Counter  in synchronous mode, and the timer clock (clkT2)\nis therefore shown as a clock enable  signal. In asynchronous mode, clkI/O should be replaced by\nthe Timer/Counter Oscillator clock. The figures include information on when Interrupt Flags areset. Figure 20-8  contains timing data for basic Timer/ Counter operation. The figure shows the\ncount sequence close to the MAX value in all modes other than phase correct P WM mode.\nFigure 20-8. Timer/Counter Timing Diagram, no Prescaling\nFigure 20-9  shows the same timing data, but with the prescaler enabled.\nFigure 20-9. Timer/Counter Timing Dia gram, with Prescaler (f\nclk_I/O /8)clkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\nTOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n184\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-10  shows the setting of OCF2A in all modes except CTC mode.\nFigure 20-10. Timer/Counter Timing Diagram, Setting of OCF2A, with Prescaler (fclk_I/O /8)\nFigure 20-11  shows the setting of OCF2A and the clearing of TCNT2 in CTC mode.\nFigure 20-11. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Pres-\ncaler (fclk_I/O /8)\n20.8 Asynchronous Operati on of Timer/Counter2\nWhen Timer/Counter2 operates asynchronously, some considerations must be taken.\n\u0081Warning: When switching between asynchronous and synchronous clocking of \nTimer/Counter2, the Timer Registers TCNT2, OCR2x, and TCCR2x might be corrupted. A safe procedure for switching clock source is:\n1. Disable the Timer/Counter2 interrupts by clearing OCIE2x and TOIE2.2. Select clock source by setting AS2 as appropriate.3.Write new values to TCNT2, OCR2x, and TCCR2x.\n4. To switch to asynchronous operation: Wait for TCN2UB, OCR2xUB, and TCR2xUB.\n5. Clear the Timer/Counter2 Interrupt Flags.6. Enable interrupts, if needed.OCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n185\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 The CPU main clock frequenc y must be more than four times the Oscillator frequency.\n\u0081When writing to one of the regi sters TCNT2, O CR2x, or TCCR2x, the va lue is transferred to \na temporary register, and latched after two positive edges on TOSC1. The user should not write a new value before the contents of the temporary register have been transferred to its destination. Each of the five mentioned registers have their individual temporary register, which means that, for example, writing to TCNT2 does not disturb an OCR2x write in progress. To detect that a transfer to the destination register has taken place, the Asynchronous Status  Register \u2013 ASSR has been implemented.\n\u0081When entering Power-save or ADC Noise Reduction mode after having written to TCNT2, \nOCR2x, or TCCR2x, the user must wait until the written register has been updated if Timer/Counter2 is used to wake up the device. Other wise, the MCU will enter sleep mode \nbefore the changes are effective. This is particularly important if any of the Output Compare2 interrupt is used to wake up the device, since the Output Compare function is disabled during writing to OCR2x or TCNT2. If the write cycle is not finished, and the MCU enters sleep mode befo re the corresponding OCR2xUB bit returns to zero, the device will \nnever receive a compare match interr upt, and the MCU will not wake up.\n\u0081 If Timer/Counter2 is used to wake the device up from Power-save or ADC Noise Reduction \nmode, precautions must be taken if the user wants to re-enter one of these modes: The interrupt logic needs one TOSC1 cycle to be reset. If the time between wake-up and re-entering sleep mode is less than one TOSC1 cycle, the interrupt will not occur, and the device will fail to wake up. If the user is in doubt whether the time be fore re-entering Power-\nsave or ADC Noise Reduction mode is suffic ient, the following algorithm can be used to \nensure that one TOSC1 cycle has elapsed:\n1.Write a value to TCCR2x, TCNT2, or OCR2x.\n2.Wait until the corresponding Update Busy Flag in ASSR returns to zero.\n3. Enter Power-save or ADC Noise Reduction mode.\n\u0081When the asynchronous ope ration is selected, the 32.768kH z Oscillator for Timer/Counter2 \nis always running, except in Power-down and Standby modes. After a Power-up Reset or wake-up from Power-down or Standby mode, the user should be aware of the fact that this Oscillator might take as long as  one second to stabilize. The us er is advised to wait for at \nleast one second before using Timer/Counter2 after power-up or wake-up from Power-down or Standby mode. The contents of all Timer/Counter2 Registers must be considered lost after a wake-up from Power-down or Standby mode due to unstable clock signal upon start-up, no matter whether the Oscillator is in use or a clock signal is applied to the TOSC1 pin.\n\u0081 Description of wake up from Power-save or  ADC Noise Reduction mode when the timer is \nclocked asynchronously: When the interrupt condition is met, the wake up process is started \non the following cycle of the timer clock, that is, the timer is always advanced by at least one before the processor can read the counter value. After wake-up, the MCU is halted for four cycles, it executes the interrupt routine, and resumes execution from the instruction \nfollowing SLEEP.\n\u0081 Reading of the TCNT2 Register shortly after wake-up from Power-save may give an \nincorrect result. Since TCNT2 is clocked on the asynchronous TOSC clock, reading TCNT2 must be done through a register synchronized to the internal I/O clock domain. Synchronization takes place for every rising TOSC1 edge. When waking up from Power-\nsave mode, and the I/O clock (clk\nI/O) again becomes active, TCNT2 will read as the previous \nvalue (before entering sleep) until the next rising TOSC1 edge. The phase of the TOSC clock after waking up from Power-save mode is essentially unpredictable, as it depends on the wake-up time. The recommended procedure for reading TCNT2 is thus as follows:\n1.Write any value to either of the registers OCR2x or TCCR2x.\n2.Wait for the corresponding Update Busy Flag to be cleared.\n3. Read TCNT2.\n\n186\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 During asynchronous operation, the synchronization of the Interrupt Flags for the \nasynchronous timer takes three p rocessor cycles plus one timer cycle. The timer is therefore \nadvanced by at least one before the processo r can read the timer value causing the setting \nof the Interrupt Flag. The Output Compare pi n is changed on the timer clock and is not \nsynchronized to the processor clock.\n20.9 Timer/Counter Prescaler\nFigure 20-12. Prescaler for Timer/Counter2\nThe clock source for Timer/Counter2 is named clkT2S. clkT2S is by default connected to the main\nsystem I/O clock clkIO. By setting the AS2 bit in ASSR, Timer/Counter2 is asynchronously\nclocked from the TOSC1 pin. This enables us e of Timer/Counter2 as a Real Time Counter\n(RTC). When AS2 is set, pins TOSC1 and TOSC2 are disconnected from Port C. A crystal can\nthen be connected between the TOSC1 and TOSC2 pins to serve as an independent clocksource for Timer/Counter2. The Oscillator is optimized for use with a 32.768kHz crystal. By set-\nting the EXCLK bit in the ASSR, a 32kHz  external clock can be applied. See \u201cASSR \u2013\nAsynchronous Status Register\u201d on page 192  for details.\nFor Timer/Counter2, the possible prescaled selections are: clk\nT2S/8, clkT2S/32, clkT2S/64,\nclkT2S/128, clkT2S/256, and clkT2S/1024. Additionally, clkT2S as well as 0 (stop) may be selected.\nSetting the PSRASY bit in GTCCR resets the prescale r. This allows the user to operate with a\npredictable prescaler.10-BIT T/C PRE SCALER\nTIMER/COUNTER2 CLOCK SOURCEclkI/O clkT2S\nTOSC1\nAS2\nCS20\nCS21\nCS22clkT2S/8\nclkT2S/64\nclkT2S/128\nclkT2S/1024\nclkT2S/256\nclkT2S/32\n0PSRASYClear\nclkT2\n\n187\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10 Register Description\n20.10.1 TCCR2A \u2013Timer/Counter Control Register A\n\u0081 Bits 7:6 \u2013 COM2A1:0: Compare Match Output A Mode\nThese bits control the Output Compare pin (OC2A) behavior. If one or both of the COM2A1:0\nbits are set, the OC2A output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction Re gister (DDR) bit corresponding to the OC2A pin\nmust be set in order to enable the output driver.\nWhen OC2A is connected to the pin, the function of the COM2A1:0 bits depends on the\nWGM22:0 bit setting. Table 20-2  shows the COM2A1:0 bit functionality when the WGM22:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 20-3  shows the COM2A1:0 bit functionality when the WGM21:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 178  for more details.\nTable 20-4 on page 188  shows the COM2A1:0 bi t functionality when the WGM22:0 bits are set\nto phase correct P WM mode.Bit 7 6 5 4 3 2 1 0\n(0xB0) COM2A1 COM2A0 COM2B1 COM2B0 \u2013 \u2013 WGM21 WGM20 TCCR2A\nRead/Write R/ W R/W R/W R/W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 20-2. Compare Output Mode, non-P WM Mode\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n0 1 Toggle OC2A on Compare Match\n1 0 Clear OC2A on Compare Match1 1 Set OC2A on Compare Match\nTable 20-3. Compare Output Mode, Fast P WM Mode(1)\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n01WGM22 = 0: Normal Port O peration, OC2A Disconnected\nWGM22 = 1: Toggle OC2A on Compare Match\n10Clear OC2A on Compare Match, set OC2A at BOTTOM\n(non-inverting mode)\n11Set OC2A on Compare Match, clear OC2A at BOTTOM\n(inverting mode)\n\n188\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 179  for more details.\n\u0081 Bits 5:4 \u2013 COM2B1:0: Compare Match Output B Mode\nThese bits control the Output Compare pin (OC2B) behavior. If one or both of the COM2B1:0\nbits are set, the OC2B output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction Re gister (DDR) bit corresponding to the OC2B pin\nmust be set in order to enable the output driver.\nWhen OC2B is connected to the pin, the function of the COM2B1:0 bits depends on the\nWGM22:0 bit setting. Table 20-5  shows the COM2B1:0 bit functionality when the WGM22:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 20-6  shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 178  for more details.Table 20-4. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n01WGM22 = 0: Normal Port O peration, OC2A Disconnected\nWGM22 = 1: Toggle OC2A on Compare Match\n10Clear OC2A on Compare Match when up-counting\nSet OC2A on Compare Match when down-counting\n11Set OC2A on Compare Match when up-counting\nClear OC2A on Compare Match when down-counting\nTable 20-5. Compare Output Mode, non-P WM Mode\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected0 1 Toggle OC2B on Compare Match\n1 0 Clear OC2B on Compare Match\n1 1 Set OC2B on Compare Match\nTable 20-6. Compare Output Mode, Fast P WM Mode(1)\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected\n01 R e s e r v e d\n10Clear OC2B on Compare Match, set OC2B at BOTTOM\n(non-inverting mode)\n11Set OC2B on Compare Match, clear OC2B at BOTTOM\n(inverting mode)\n\n189\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 20-7  shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to phase cor-\nrect PWM mode.\nNote: 1. A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 179  for more details.\n\u0081 Bits 3, 2 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 1:0 \u2013 WGM21:0: Waveform Generation Mode\nCombined with the WGM22 bit found in the TCCR2B Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 20-8 . Modes of operation supported by the Timer/Counter\nunit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types ofPulse Width Modulation (P WM) modes (see \u201cModes of Operation\u201d on page 176 ).\nNotes: 1. MAX  = 0xFF .\n2. BOTTOM = 0x00.Table 20-7. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected\n01 R e s e r v e d\n10Clear OC2B on Compare Match when up-counting\nSet OC2B on Compare Match when down-counting\n11Set OC2B on Compare Match when up-counting\nClear OC2B on Compare Match when down-counting\nTable 20-8. Waveform Generation Mode Bit Description\nMode WGM2 WGM1 WGM0Timer/Counter \nMode of \nOperation TOPUpdate of\nOCRx atTOV Flag\nSet on(1)(2)\n0 0 0 0 Normal 0xFF Immediate MAX\n1 001PWM, Phase \nCorrect0xFF TOP BOTTOM\n2 0 1 0 CTC OCRA Immediate MAX\n3 011 F a s t  P WM0 x F F B O T T O MM A X\n4 100 R e s e r v e d \u2013 \u2013 \u2013\n5 101PWM, Phase \nCorrectOCRA TOP BOTTOM\n6 110 R e s e r v e d \u2013 \u2013 \u2013\n7 111 F a s t  P WM OCRA BOTTOM TOP\n\n190\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10.2 TCCR2B \u2013 Timer/Counter Control Register B\n\u0081 Bit 7 \u2013 FOC2A: Force Output Compare A\nThe FOC2A bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR2B is written when operating in P WM mode. When writing a logical one to the FOC2A bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC2A output is\nchanged according to its COM2A1:0 bits setting. Note that the FOC2A bit is implemented as a\nstrobe. Therefore it is the value present in the COM2A1:0 bits that determines the effect of theforced compare.\nA FOC2A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR2A as TOP.\nThe FOC2A bit is always read as zero.\n\u0081 Bit 6 \u2013 FOC2B: Force Output Compare B\nThe FOC2B bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR2B is written when operating in P WM mode. When writing a logical one to the FOC2B bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC2B output is\nchanged according to its COM2B1:0 bits setting. Note that the FOC2B bit is implemented as a\nstrobe. Therefore it is the value present in the COM2B1:0 bits that determines the effect of theforced compare.\nA FOC2B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR2B as TOP.\nThe FOC2B bit is always read as zero.\n\u0081 Bits 5:4 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 3 \u2013 WGM22: Waveform Generation Mode\nSee the description in the \u201cTCCR2A \u2013Timer/Counter Control Register A\u201d on page 187 .\n\u0081 Bit 2:0 \u2013 CS22:0: Clock Select\nThe three Clock Select bits select the clock source to be used by the Timer/Counter, see Table\n20-9 on page 191 .Bit 7 6 5 4 3 2 1 0\n(0xB1) FOC2A FOC2B \u2013 \u2013 WGM22 CS22 CS21 CS20 TCCR2B\nRead/Write WW RR R / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n191\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n20.10.3 TCNT2 \u2013 Timer/Counter Register\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter. Writing to the TCNT2 Register blocks (removes) the Compare\nMatch on the following timer clock. Modifying the counter (TCNT2) while the counter is running,introduces a risk of missing a Compare Match between TCNT2 and the OCR2x Registers.\n20.10.4 OCR2A \u2013 Output Compare Register A\nThe Output Compare Register A contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT2). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OC2A pin.\n20.10.5 OCR2B \u2013 Output Compare Register B\nThe Output Compare Register B contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT2). A match can be used to generate an Output Compare interrupt, or to\ngenerate a waveform output on the OC2B pin.Table 20-9. Clock Select Bit Description\nCS22 CS21 CS20 Description\n0 0 0 No clock source (Timer/Counter stopped)001 c l k\nT2S/(No prescaling)\n010 c l kT2S/8 (From prescaler)\n011 c l kT2S/32 (From prescaler)\n100 c l kT2S/64 (From prescaler)\n101 c l kT2S/128 (From prescaler)\n110 c l kT2S/256 (From prescaler)\n111 c l kT2S/1024 (From prescaler)\nB i t 76543210\n(0xB2) TCNT2[7:0] TCNT2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xB3) OCR2A[7:0] OCR2A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xB4) OCR2B[7:0] OCR2B\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n192\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10.6 ASSR \u2013 Asynchronous Status Register\n\u0081 Bit 6 \u2013 EXCLK: Enable External Clock Input\nWhen EXCLK is written to one, and asynchronous clock is selected, the external clock input buf-\nfer is enabled and an external cl ock can be input on Timer Oscilla tor 1 (TOSC1) pin instead of a\n32kHz crystal. Writing to EXCLK should be done before asynchronous operation is selected.\nNote that the crystal Oscillator will only run when this bit is zero.\n\u0081 Bit 5 \u2013 AS2: Asynchronous Timer/Counter2\nWhen AS2 is written to zero, Timer/Counter2 is clocked from the I/O clock, clkI/O. When AS2 is\nwritten to one, Timer/Counter2 is clocked from a crystal Oscilla tor connected to the Timer Oscil-\nlator 1 (TOSC1) pin. When the value of AS2 is changed, the contents of TCNT2, OCR2A,\nOCR2B, TCCR2A and TCCR2B might be corrupted.\n\u0081 Bit 4 \u2013 TCN2UB: Timer/Counter2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set.\nWhen TCNT2 has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that TCNT2 is ready to be updated with a new value.\n\u0081 Bit 3 \u2013 OCR2AUB: Output Co mpare Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and OCR2A is written, this bit becomes set.\nWhen OCR2A has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that OCR2A is ready to be updated with a new value.\n\u0081 Bit 2 \u2013 OCR2BUB: Output Compare Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and OCR2B is written, this bit becomes set.\nWhen OCR2B has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that OCR2B is ready to be updated with a new value.\n\u0081 Bit 1 \u2013 TCR2AUB: Timer/Counter Control Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCCR2A is written, this bit becomes set.\nWhen TCCR2A has been updated from  the temporary storage regi ster, this bit is cleared by\nhardware. A logical zero in this bit indicates that TCCR2A is ready to be updated with a new\nvalue.\n\u0081 Bit 0 \u2013 TCR2BUB: Timer/Counter  Control Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCCR2B is written, this bit becomes set.\nWhen TCCR2B has been updated from  the temporary storage regi ster, this bit is cleared by\nhardware. A logical zero in this bit indicates that TCCR2B is ready to be updated with a new\nvalue.\nIf a write is performed to any of the five Timer/Counter2 Registers while its update busy flag is\nset, the updated value might get corrupted and cause an unintentional interrupt to occur.Bit 7 6 5 4 3 2 1 0\n(0xB6) \u2013 EXCLK AS2 TCN2UB OCR2AUB OCR2BUB TCR2AUB TCR2BUB ASSR\nRead/Write R R/ W R/W RR R R R\nInitial Value 0 0 0 0 0 0 0 0\n\n193\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe mechanisms for reading TCNT2, OCR2A,  OCR2B, TCCR2A and TCCR2B are different.\nWhen reading TCNT2, the actual timer value is read. When reading OCR2A, OCR2B, TCCR2A\nand TCCR2B the value in the temporary storage register is read.\n20.10.7 TIMSK2 \u2013 Timer/Counter2  Interrupt Mask Register\n\u0081 Bit 2 \u2013 OCIE2B: Timer/Counter2 Output Compare Match B Interrupt Enable\nWhen the OCIE2B bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Compare Match B interrupt is enabled. The corresponding interrupt is executed\nif a compare match in Timer/Counter2 occurs, that is, when the OCF2B bit is set in the\nTimer/Counter 2 Interrupt Flag Register \u2013 TIFR2.\n\u0081 Bit 1 \u2013 OCIE2A: Timer/Counter2 Output Compare Match A Interrupt Enable\nWhen the OCIE2A bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Compare Match A interrupt is enabled. The corresponding interrupt is executed\nif a compare match in Timer/Counter2 occurs, that is, when the OCF2A bit is set in the\nTimer/Counter 2 Interrupt Flag Register \u2013 TIFR2.\n\u0081 Bit 0 \u2013 TOIE2: Timer/Counter2 Overflow Interrupt Enable\nWhen the TOIE2 bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter2 occurs, that is, when  the TOV2 bit is set in the Timer/Counter2 Inter-\nrupt Flag Register \u2013 TIFR2.\n20.10.8 TIFR2 \u2013 Timer/Counter2 Interrupt Flag Register\n\u0081 Bit 2 \u2013 OCF2B: Output Compare Flag 2 B\nThe OCF2B bit is set (one) when a compare match occurs between the Timer/Counter2 and the\ndata in OCR2B \u2013 Output Compare Register2. OCF2B is cleared by hardware when executing\nthe corresponding interrupt handling vector. Alter natively, OCF2B is cleared by writing a logic\none to the flag. When the I-bit in SREG, OCIE2B (Timer/Counter2 Compare match Interrupt\nEnable), and OCF2B are set (one), the Timer/Counter2 Compare match Interrupt is executed.\n\u0081 Bit 1 \u2013 OCF2A: Output Compare Flag 2 A\nThe OCF2A bit is set (one) when a compare match occurs between the Timer/Counter2 and the\ndata in OCR2A \u2013 Output Compare Register2. OCF2A is cleared by hardware when executing\nthe corresponding interrupt handling vector. Alter natively, OCF2A is cleared by writing a logic\none to the flag. When the I-bit in SREG, OCIE2A (Timer/Counter2 Compare match Interrupt\nEnable), and OCF2A are set (one), the Timer/Counter2 Compare match Interrupt is executed.B i t 76543 2 1 0\n(0x70) \u2013 \u2013 \u2013 \u2013 \u2013 OCIE2B OCIE2A TOIE2 TIMSK2\nRead/Wr i t e RRRRR R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x17 (0x37) \u2013 \u2013 \u2013 \u2013 \u2013 OCF2B OCF2A TOV2 TIFR2\nRead/Wr i t e RRRRR R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n194\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TOV2: Timer/Counter2 Overflow Flag\nThe TOV2 bit is set (one) when an overflow occu rs in Timer/Counter2. TOV2 is cleared by hard-\nware when executing the corresponding interrupt handling vector. Alternatively, TOV2 is cleared\nby writing a logic one to the flag. When the SREG I-bit, TOIE2A (Timer/Counter2 Overflow Inter-\nrupt Enable), and TOV2 are set (one), the Timer/ Counter2 Overflow interrupt is executed. In\nPWM mode, this bit is set when Timer/Counter2 changes counting direction at 0x00.\n20.10.9 GTCCR \u2013 General Time r/Counter Control Register\n\u0081 Bit 1 \u2013 PSRASY: Prescaler Reset Timer/Counter2\nWhen this bit is one, the Time r/Counter2 prescaler will be rese t. This bit is normally cleared\nimmediately by hardware. If the bit is written wh en Timer/Counter2 is operating in asynchronous\nmode, the bit will remain one until the presca ler has been reset. The bit will not be cleared by\nhardware if the TSM bit is set. Refer to the description of the \u201cBit 7 \u2013 TSM: Timer/Counter Syn-\nchronization Mode\u201d on page 170  for a description of the Timer/Counter Synchronization mode.Bit 7 6 5 4 3 2 1 0\n0x23 (0x43) TSM \u2013 \u2013 \u2013 \u2013 \u2013 PSRASY PSRSYNC GTCCR\nRead/Write R/ W RRR R R R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n195\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21. SPI \u2013 Serial Peripheral Interface\nThe Serial Peripheral Interface (SPI) allows hi gh-speed synchronous data transfer between the\nATmega640/1280/1281/2560/2561 and peripheral devices or between several AVR devices.\nThe ATmega640/1280/1281/2560/2561 SPI includes the following features:\n\u0081Full-duplex, Three-wire Synchronous Data Transfer\n\u0081Master or Slave Operation\n\u0081LSB First or MSB First Data Transfer\n\u0081Seven Programmable Bit Rates\n\u0081End of Transmission Interrupt Flag\n\u0081Write Collision Flag Protection\n\u0081Wake-up from Idle Mode\n\u0081Double Speed (CK/2) Master SPI Mode\nUSART can also be used in Master SPI mode, see \u201cUSART in SPI Mode\u201d on page 232 .\nThe Power Reduction SPI bit, PRSPI, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56  on\npage 50 must be written to zero to enable SPI module.\nFigure 21-1. SPI Block Diagram(1)\nNote: 1. Refer to Figure 1-1 on page 2 , and Table 13-6 on page 79  for SPI pin placement.\nThe interconnection between Master and Slave CPUs with SPI is shown in Figure 21-2 on page\n196. The system consists of two shift Registers, and a Master clock generator. The SPI Master\ninitiates the communication cycle wh en pulling low the Slave Select SS  pin of the desired Slave.SPI2XSPI2XDIVIDER\n/2/4/8/16/32/64/12 8\n\n196\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nMaster and Slave prepare the data to be sent in their respective shift Registers, and the Master\ngenerates the required clock pulses on the SCK line to interchange data. Data is always shifted\nfrom Master to Slave on the Master Out \u2013 Slave In, MOSI, line, and from Slave to Master on the\nMaster In \u2013 Slave Out, MISO, line. After each data packet, the Master will synchronize the Slave\nby pulling high the Slave Select, SS , line.\nWhen configured as a Master, the SPI interface has no automatic control of the SS  line. This\nmust be handled by user software before communication can start. When this is do ne, writing a\nbyte to the SPI Data Register starts the SPI clock generator, and the hardware shifts the eight\nbits into the Slave. After shifting one byte , the SPI clock generator stops, setting the end of\nTransmission Flag (SPIF). If the SPI Interrupt Enable bit (SPIE) in the SPCR Register is set, aninterrupt is requested. The Master may continue to shift the next byte by writing it into SPDR, or\nsignal the end of packet by pulling high the Slave Select, SS\n line. The last incoming byte will be\nkept in the Buffer Register for later use.\nWhen configured as a Slave, the SPI interface will remain  sleeping with MISO tri-stated as long\nas the SS  pin is driven high. In this state, software may update the contents of the SPI Data\nRegister, SPDR, but the data will not be shifted out by incoming clock pulses on the SCK pinuntil the SS\n pin is driven low. As one byte has been completely shifted, the end of Transmission\nFlag, SPIF is set. If the SPI Interrupt Enable bit, SPIE, in the SPCR Register is set, an interrupt\nis requested. The Slave may continue to place new data to be sent into SPDR before readingthe incoming data. The last incoming byte will be kept in the Buffer Register for later use.\nFigure 21-2. SPI Master-slave Interconnection\nThe system is single buffered in the transmit di rection and double buffered in the receive direc-\ntion. This means that bytes to be transmitted cannot be written to the SPI Data Register before\nthe entire shift cycle is completed. When receiving data, however, a received character must be\nread from the SPI Data Register before the next character has been completely shifted in. Oth-erwise, the first byte is lost.\nIn SPI Slave mode, the control logic will sample  the incoming signal of the SCK pin. To ensure\ncorrect sampling of the clock signal, the minimum low and high periods should be:\nLow period: longer than 2 CPU clock cycles.\nHigh period: longer than 2 CPU clock cycles.SHIFT\nENABLE\n\n197\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the SPI is enabled, the data direction of the MOSI, MISO, SCK, and SS  pins is overridden\naccording to Table 21-1 . For more details on automatic port overrides, refer to \u201cAlternate Port\nFunctions\u201d on page 75 .\nNote: 1. See \u201cAlternate Functions of Port B\u201d on page 79  for a detailed description of how to define the \ndirection of the user defined SPI pins.\nThe following code examples show how to initialize the SPI as a Master and how to perform a\nsimple transmission. DDR_SPI in the examples mu st be replaced by the actual Data Direction\nRegister controlling the SPI pins. DD_MOSI, DD_MISO and DD_SCK must be replaced by the\nactual data direction bits for these pins. For example, if MOSI is placed on pin PB5, replace\nDD_MOSI with DDB5 and DDR_SPI with DDRB.Table 21-1. SPI Pin Overrides(1)\nPin Direction, Master SPI Direction, Slave SPI\nMOSI User Defined Input\nMISO Input User Defined\nSCK User Defined Input\nSS User Defined Input\n\n198\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nSPI_MasterInit:\n; Set MOSI and SCK output, all others inputldir17,(1<<DD_MOSI)|(1<<DD_SCK)\noutDDR_SPI,r17\n; Enable SPI, Master, set clock rate fck/16\nldir17,(1<<SPE)|(1<<MSTR)|(1<<SPR0)\noutSPCR,r17\nret\nSPI_MasterTransmit:\n; Start transmission of data (r16)\noutSPDR,r16\nWait_Transmit:\n; Wait for transmission complete\nsbisSPSR,SPIF\nrjmpWait_Transmit\nret\nC Code Example(1)\nvoid SPI_MasterInit( void)\n{\n/* Set MOSI and SCK output, all others input */\nDDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);\n/* Enable SPI, Master, set clock rate fck/16 */SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);\n}\nvoid SPI_MasterTransmit( char cData)\n{\n/* Start transmission */SPDR = cData;\n/* Wait for transmission complete */\nwhile(!(SPSR & (1<<SPIF)))\n;\n}\n\n199\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code examples show how to initialize the SPI as a Slave and how to perform a\nsimple reception.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nSPI_SlaveInit:\n; Set MISO output, all others input\nldir17,(1<<DD_MISO)\noutDDR_SPI,r17\n; Enable SPI\nldir17,(1<<SPE)\noutSPCR,r17\nret\nSPI_SlaveReceive:\n; Wait for reception complete\nsbisSPSR,SPIF\nrjmpSPI_SlaveReceive\n; Read received data and return\ninr16,SPDR\nret\nC Code Example(1)\nvoid SPI_SlaveInit( void)\n{\n/* Set MISO output, all others input */\nDDR_SPI = (1<<DD_MISO);\n/* Enable SPI */SPCR = (1<<SPE);\n}\nchar SPI_SlaveReceive( void)\n{\n/* Wait for reception complete */while(!(SPSR & (1<<SPIF)))\n;\n/* Return Data Register */return SPDR;\n}\n\n200\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.1 SS  Pin Functionality\n21.1.1 Slave Mode\nWhen the SPI is configured as a Slave, the Slave Select (SS ) pin is always input. When SS  is\nheld low, the SPI is activated, and MISO becomes  an output if configured so by the user. All\nother pins are inputs. When SS  is driven high, all pins are inputs, and the SPI is passive, which\nmeans that it will not receive incoming data. No te that the SPI logic will be reset once the SS  pin\nis driven high.\nThe SS  pin is useful for packet/byte synchroniza tion to keep the slave bit counter synchronous\nwith the master clock generator. When the SS  pin is driven high, the SPI slave will immediately\nreset the send and receive logic, and drop any partially received data in the Shift Register.\n21.1.2 Master Mode\nWhen the SPI is configured as a Master (MSTR in  SPCR is set), the user can determine the\ndirection of the SS  pin.\nIf SS  is configured as an output, the pin is a general output pin which does not affect the SPI\nsystem. Typically, the pin will be driving the SS  pin of the SPI Slave.\nIf SS  is configured as an input, it must be held high to ensure Master SPI operation. If the SS  pin\nis driven low by peripheral circuitry when the SPI is configured as a Master with the SS  pin\ndefined as an input, the SPI syst em interprets this as another master selecting the SPI as a\nslave and starting to send data to it. To avoid bus contention, the SPI system takes the followingactions:\n1. The MSTR bit in SPCR is cleared and the SPI system becomes a Slave. As a result of\nthe SPI becoming a Slave, the MOSI and SCK pins become inputs.\n2. The SPIF Flag in SPSR is set, and if the SPI interrupt is enabled, an d the I-bit in SREG is\nset, the interrupt routine will be executed.\nThus, when interrupt-driven SPI transmission is used in Master mode, and there exists a possi-\nbility that SS\n is driven low, the interrup t should always check that the MSTR bit is still set. If the\nMSTR bit has been cleared by a slave select, it must be set by the user to re-enable SPI Master\nmode.\n21.1.3 Data Modes\nThere are four combinations of SCK phase and polarity with respect to serial data, which are\ndetermined by control bits CPHA and CPOL. The SPI data transfer formats are shown in Figure\n21-3 on page 201  and Figure 21-4 on page 201 . Data bits are shifted out and latched in on\nopposite edges of the SCK signal, ensuring sufficient time for data signals to stabilize. This is\nclearly seen by summarizing Table 21-3 on page 202  and Table 21-4 on page 202  in Table 21-2 .\nTable 21-2. CPOL Functionality\nLeading Edge Trailing eDge SPI Mode\nCPOL=0, CPHA=0 Sample (Rising) Setup (Falling) 0\nCPOL=0, CPHA=1 Setup (Rising) Sample (Falling) 1\nCPOL=1, CPHA=0 Sample (Falling) Setup (Rising) 2\nCPOL=1, CPHA=1 Setup (Falling) Sample (Rising) 3\n\n201\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 21-3. SPI Transfer Format with CPHA = 0\nFigure 21-4. SPI Transfer Format with CPHA = 1Bit 1\nBit 6LSB\nMSBSCK (CPOL = 0)\nmode 0\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 2\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5MSB first (DORD = 0)\nLSB first (DORD = 1)\nSCK (CPOL = 0)\nmode 1\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 3\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5Bit 1\nBit 6LSB\nMSBMSB first (DORD = 0)\nLSB first (DORD = 1)\n\n202\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.2 Register Description\n21.2.1 SPCR \u2013 SPI Control Register\n\u0081 Bit 7 \u2013 SPIE: SPI  Interrupt Enable\nThis bit causes the SPI in terrupt to be executed if SPIF bit in the SPSR Register is set and the if\nthe Global Interrupt Enable bit in SREG is set.\n\u0081 Bit 6 \u2013 SPE: SPI Enable\nWhen the SPE bit is written to one, the SPI is enabled. This  bit must be set to enable any SPI\noperations.\n\u0081 Bit 5 \u2013 DORD: Data Order\nWhen the DORD bit is written to one, the LSB of the data word is transmitted first.\nWhen the DORD bit is written to zero, the MSB of the data word is transmitted first.\n\u0081 Bit 4 \u2013 MSTR: Master/Slave Select\nThis bit selects Master SPI mode when written to one, and Slave SPI mode when written logic\nzero. If SS  is configured as an input and is driven low while MSTR is set, MSTR will be cleared,\nand SPIF in SPSR will become set. The user will th en have to set MSTR to re-enable SPI Mas-\nter mode.\n\u0081 Bit 3 \u2013 CPOL: Clock Polarity\nWhen this bit is written to one, SCK is high when idle. When CPOL is written to zero, SCK is low\nwhen idle. Refer to Figure 21-3 on page 201  and Figure 21-4 on page 201  for an example. The\nCPOL functionality is summarized in Table 21-3 .\n\u0081 Bit 2 \u2013 CPHA: Clock Phase\nThe settings of the Clock Phase bit (CPHA) determine if data is sampled on the leading (first) or\ntrailing (last) edge of SCK. Refer to Figure 21-3 on page 201  and Figure 21-4 on page 201  for an\nexample. The CPOL functionality is summarized in Table 21-4 .B i t 76543210\n0x2C (0x4C) SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 SPCR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 21-3. CPOL Functionality\nCPOL Leading Edge Trailing Edge\n0 Rising Falling\n1 Falling Rising\nTable 21-4. CPHA Functionality\nCPHA Leading Edge Trailing Edge\n0 Sample Setup\n1 Setup Sample\n\n203\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bits 1, 0 \u2013 SPR1, SPR0: SPI Clock Rate Select 1 and 0\nThese two bits control the SCK rate of the dev ice configured as a Master. SPR1 and SPR0 have\nno effect on the Slave. The relationship between SCK and the Oscillator Clock frequency fosc is\nshown in Table 21-5 .\n21.2.2 SPSR \u2013 SPI Status Register\n\u0081 Bit 7 \u2013 SPIF: SPI Interrupt Flag\nWhen a serial transfer is complete, the SPIF Flag is set. An interrupt is generated if SPIE in\nSPCR is set and global interrupts are enabled. If SS  is an input and is dr iven low when the SPI is\nin Master mode, this will also set the SPIF Flag. SPIF is cleared by hardwa re when executing the\ncorresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the\nSPI Status Register with SPIF set, then accessing the SPI Data Register (SPDR).\n\u0081 Bit 6 \u2013 WCOL: Write COLlision Flag\nThe WCOL bit is set if the SPI Data Register (S PDR) is written during a data transfer. The\nWCOL bit (and the SPIF bit) are cleared by first reading the SPI Status Register with WCOL set,\nand then accessing the SPI Data Register.\n\u0081 Bit 5:1 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 0 \u2013 SPI2X: Double SPI Speed Bit\nWhen this bit is written logic one the SPI s peed (SCK Frequency) will be doubled when the SPI\nis in Master mode (see Table 21-5 ). This means that the mini mum SCK period will be two CPU\nclock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at fosc/4\nor lower.\nThe SPI interface on the ATmega640/1280/1281/2560/2561 is also used for program memory\nand EEPROM downloading or uploading. See \u201cSerial Downloading\u201d on page 349  for serial pro-\ngramming and verification.Table 21-5. Relationship Between SCK and  the Oscillator Frequency \nSPI2X SPR1 SPR0 SCK Frequency\n00 0 fosc/4\n00 1 fosc/16\n01 0 fosc/64\n01 1 fosc/128\n10 0 fosc/2\n10 1 fosc/8\n11 0 fosc/32\n11 1 fosc/64\nB i t 76543210\n0x2D (0x4D) S P I F W C O L \u2013\u2013\u2013\u2013\u2013 S P I 2 X S P S R\nRead/Wr i t e RRRRRRR R / W\nI n i t i a l  V a l u e00000000\n\n204\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.2.3 SPDR \u2013 SPI Data Register\nThe SPI Data Register is a read/write register used for data transfer between the Register File\nand the SPI Shift Register. Writing to the register initiates data transmission. Reading the regis-\nter causes the Shift Register Receive buffer to be read.B i t 76543210\n0x2E (0x4E) MSB LSB SPDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u eXXXXXXXX U n d e f i n e d\n\n205\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22. USART\n22.1 Features\n\u0081Full Duplex Operation (Independent Se rial Receive and Transmit Registers)\n\u0081Asynchronous or Synchronous Operation\n\u0081Master or Slave Clocked Synchronous Operation\n\u0081High Resolution Baud Rate Generator\n\u0081Supports Serial Frames with 5, 6, 7, 8, or 9 Data Bits and 1 or 2 Stop Bits\n\u0081Odd or Even Parity Generation and Parity Check Supported by Hardware\n\u0081Data OverRun Detection\n\u0081Framing Error Detection\n\u0081Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter\n\u0081Three Separate Interrupts on  TX Complete, TX Data Register Empty and RX Complete\n\u0081Multi-processor Communication Mode\n\u0081Double Speed Asynchronous Communication Mode\nOverview The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a\nhighly flexible serial communication device.\nThe ATmega640/1280/2560 has four USART\u2019s,  USART0, USART1, USART2, and USART3.\nThe functionality for all four USART\u2019s is de scribed below. USART0, USART1, USART2, and\nUSART3 have different I/O registers as shown in \u201cRegister Summary\u201d on page 411 .\nA simplified block diagram of the USART Transmitter is shown in Figure 22-1 on page 206 . CPU\naccessible I/O Registers and I/O pins are shown in bold.\nThe Power Reducion USART0 bit, PRUSART0, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART1 bit, PRUSART1, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART2 bit, PRUSART2, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART3 bit, PRUSART3, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\n\n206\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-1. USART Block Diagram(1)\nNote: 1. See Figure 1-1 on page 2 , Figure 1-3 on page 4 , Table 13-12 on page 83 , Table 13-15 on \npage 86 , Table 13-24 on page 92  and Table 13-27 on page 94  for USART pin placement.\nThe dashed boxes in the block diagram separate the three main parts of the USART (listed from\nthe top): Clock Generator, Transmitter and Receiver. Control Registers are shared by all units.The Clock Generation logic consis ts of synchronization logic fo r external clock input used by\nsynchronous slave operation, and the baud rate  generator. The XCKn (Transfer Clock) pin is\nonly used by synchronous transfer mode. The Transmi tter consists of a single write buffer, a\nserial Shift Register, Parity Generator and Cont rol logic for handling different serial frame for-\nmats. The write buffer allows a continuous transfer of data without any delay between frames.\nThe Receiver is the most complex part of the USART module due to its clock and data recoveryunits. The recovery units are used for asynchronous data reception. In addition to the recovery\nunits, the Receiver includes a Parity Checker, Control logic, a Shift Register and a two level\nreceive buffer (UDRn). The Receiver supports the same frame formats as the Transmitter, andcan detect Frame Error, Data OverRun and Parity Errors.\n22.2 Clock Generation\nThe Clock Generation logic generates the base clock for the Transmitter and Receiver. TheUSARTn supports four modes of clock opera tion: Normal asynchronous, Double Speed asyn-\nchronous, Master synchronous and Slave synchronous mode. The UMSELn bit in USART\nControl and Status Register C (UCSRnC) selects between asynchronous and synchronous\noperation. Double Speed (asynchronous mode only) is controlled by the U2Xn found in thePARITY\nGENERATORUBRR[H:L]\nUDR  (Transmit)\nUCSRA UCSRB UCSRCBAUD RATE GENERATOR\nTRANSMIT SHIFT REGISTER\nRECEIVE SHIFT REGISTER RxDTxDPIN\nCONTROL\nUDR (Receive)PIN\nCONTROLXCK\nDATA\nRECOVERYCLOCK\nRECOVERYPIN\nCONTROL\nTX\nCONTROL\nRX\nCONTROL\nPARITY\nCHECKERDATA BUSOSC\nSYNC LOGICClock Generator\nTransmitter\nReceiver\n\n207\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nUCSRnA Register. When using synchronous mode (UMSELn = 1), the Data Direction Register\nfor the XCKn pin (DDR_XCKn) controls whether the clock source is internal (Master mode) or\nexternal (Slave mode). The XCKn pin is only active when using synchronous mode.\nFigure 22-2  shows a block diagram of the clock generation logic.\nFigure 22-2. Clock Generation Logic, Block Diagram\nSignal description:\ntxclk Transmitter clock (Internal Signal).\nrxclk Receiver base clock (Internal Signal).\nxcki Input from XCK pin (internal Signal). Used for synchronous slave\noperation.\nxcko Clock output to XCK pin (Internal Signal). Used for synchronous master\noperation.\nfOSC XTAL pin frequency (System Clock).\n22.2.1 Internal Clock Generation \u2013 The Baud Rate Generator\nInternal clock generation is used for the as ynchronous and the synchronous master modes of\noperation. The description in this section refers to Figure 22-2 .\nThe USART Baud Rate Register (UBRRn) and the down-counter connected to it function as a\nprogrammable prescaler or baud rate generator. The down-counter, running at system clock(f\nosc), is loaded with the UBRRn value each time  the counter has counted down to zero or when\nthe UBRRLn Register is written. A clock is gene rated each time the counter reaches zero. This\nclock is the baud rate generator clock output (= fosc/(UBRRn+1)). The Transmitter divides the\nbaud rate generator clock output by 2, 8 or 16 depending on mode. The baud rate generator out-\nput is used directly by the Receiver\u2019s clock an d data recovery units. However, the recovery units\nuse a state machine that uses 2, 8 or 16 states depending on mode set by the state of theUMSELn, U2Xn and DDR_XCKn bits.\nTable 22-1 on page 208  contains equations for calculating th e baud rate (in bits per second) and\nfor calculating the UBRRn value for each mode of operation using an internally generated clocksource.Prescaling\nDown-Counter/2UBRR\n/4 /2fosc\nUBRR+1\nSync\nRegisterOSC\nXCK\nPintxclkU2X\nUMSELDDR_XCK0\n1\n01\nxcki\nxcko\nDDR_XCK\nrxclk\n0110Edge\nDetector\nUCPOL\n\n208\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. The baud rate is defined to be the transfer rate in bit per second (bps).\nBAUD Baud rate (in bits per second, bps).\nfOSC System Oscillator clock frequency.\nUBRRn Contents of the UBRRHn and UBRRLn Registers, (0-4095).\nSome examples of UBRRn values for some system clock frequencies are found in Table 22-9 on\npage 227 .\n22.2.2 Double Speed Operation (U2Xn)\nThe transfer rate can be doubled by setting the U2Xn bit in UCSRnA. Setting this bit only has\neffect for the asynchronous operation. Set this bit to zero when using synchronous operation.\nSetting this bit will reduce the divisor of the baud rate divider from 16 to 8, effectively doubling\nthe transfer rate for asynchronous communication. Note however that the Receiver will in thiscase only use half the number of samples (reduced from 16 to 8) for data sampling and clock\nrecovery, and therefore a more accurate baud rate setting and system clock are required when\nthis mode is used. For the Transmitter, there are no downsides.\n22.2.3 External Clock\nExternal clocking is used by the synchronous sl ave modes of operation. The description in this\nsection refers to Figure 22-2 on page 207  for details.\nExternal clock input from the XCKn pin is sample d by a synchronization register to minimize the\nchance of meta-stability. The output from the synchronization register must then pass through\nan edge detector before it can be used by the Transmitter and Receiver. This process intro-Table 22-1. Equations for Calculating Baud Rate Register Setting\nOperating ModeEquation for Calculating \nBaud Rate(1)Equation for Calculating \nUBRR Value\nAsynchronous Normal \nmode (U2Xn = 0)\nAsynchronous Double \nSpeed mode (U2Xn = \n1)\nSynchronous Master \nmodeBAUDfOSC\n16UBRR n1+ ()----------------------------------------- - = UBRR nfOSC\n16BAUD----------------------- -1\u2013 =\nBAUDfOSC\n8UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n8BAUD-------------------- 1\u2013 =\nBAUDfOSC\n2UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n2BAUD-------------------- 1\u2013 =\n\n209\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nduces a two CPU clock period delay and therefore the maximum external XCKn clock frequency\nis limited by the following equation:\nNote that fosc depends on the stability of the system clock source. It is therefore recommended to\nadd some margin to avoid possible loss of data due to frequency variations.\n22.2.4 Synchronous Clock Operation\nWhen synchronous mode is  used (UMSELn = 1), the XCKn pin will be used as either clock input\n(Slave) or clock output (Master). The dependency between the clock edges and data sampling\nor data change is the same. The basic principle is  that data input (on RxDn) is sampled at the\nopposite XCKn clock edge of the edge the data output (TxDn) is changed.\nFigure 22-3. Synchronous Mode XCKn Timing.\nThe UCPOLn bit UCRSC selects which XCKn cloc k edge is used for data sampling and which is\nused for data change. As Figure 22-3  shows, when UCPOLn is zero  the data will be changed at\nrising XCKn edge and sampled at falling XCKn edge. If UCPOLn is set, the data will be changed\nat falling XCKn edge and samp led at rising XCKn edge.\n22.3 Frame Formats\nA serial frame is defined to be one character of da ta bits with synchronizat ion bits (start and stop\nbits), and optionally a parity bi t for error checking. The USART accepts all 30 combinations of\nthe following as valid frame formats:\n\u0081 1 start bit\n\u0081 5, 6, 7, 8, or 9 data bits\u0081 no, even or odd parity bit\u0081 1 or 2 stop bitsA frame starts with the start bit followed by the least significant data bit. Then the next data bits,\nup to a total of nine, are succeeding, ending with t he most significant bit. If enabled, the parity bit\nis inserted after the data bits, before the stop bits. When a complete frame is transmitted, it can\nbe directly followed by a new frame, or the communication line can be set to an idle (high) state.\nFigure 22-4 on page 210  illustrates the possible combinations of the frame formats. Bits inside\nbrackets are optional.fXCKfOSC\n4-----------<\nRxD / TxDXCK\nRxD / TxDXCK UCPOL = 0UCPOL = 1\nSample\nSample\n\n210\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-4. Frame Formats\nSt Start bit, always low.\n(n) Data bits (0 to 8).\nP Parity bit. Can be odd or even.\nSp Stop bit, always high.\nIDLE No transfers on the communication line (RxDn or TxDn). An IDLE line\nmust be high.\nThe frame format used by th e USART is set by the UCSZn2:0, UPMn1:0 and USBSn bits in\nUCSRnB and UCSRnC. The Receiver  and Transmitter use the same setting. Note that changing\nthe setting of any of these bits will corrupt a ll ongoing communication for both the Receiver and\nTransmitter.\nThe USART Character SiZe (UCSZn2:0) bits select  the number of data bits in the frame. The\nUSART Parity mode (UPMn1:0) bits enable and set the type of parity bit. The selection between\none or two stop bits is done by the USART Stop Bit Select (USBSn) bit. The Re ceiver ignores\nthe second stop bit. An FE (F rame Error) will theref ore only be detected in the cases where the\nfirst stop bit is zero.\n22.3.1 Parity Bit Calculation\nThe parity bit is calculated by do ing an exclusive-or of all the data bits. If odd parity is used, the\nresult of the exclusive or is inverted. The parity bit is located between the last data bit and firststop bit of a serial frame. The relation betwee n the parity bit and data bits is as follows:\nP\neven Parity bit using even parity.\nPodd Parity bit using odd parity.\ndn Data bit n of the character.\n22.4 USART Initialization\nThe USART has to be initialized before any communication can take place. The initialization pro-\ncess normally consists of setting the baud rate, setting frame format and enabling the\nTransmitter or the Receiver depending on the usage. For interrupt driven USART operation, the\nGlobal Interrupt Flag should be cleared (and interrupts globally disabled) when doing the\ninitialization.\nBefore doing a re-initialization with changed baud rate or frame format, be sure that there are no\nongoing transmissions during the period the registers are changed. The TXCn Flag can be usedto check that the Transmitter has completed all transfers, and the RXC Flag can be used to1 0 2 3 4 [5] [6] [7] [8] [P] St Sp1 [Sp2] (St / IDLE) (IDLE)FRAME\nPevendn1\u2013\u2026 d3d2d1d00\nPodd\u2295\u2295\u2295\u2295\u2295\u2295\ndn1\u2013\u2026 d3d2d1d01 \u2295\u2295\u2295\u2295\u2295\u2295=\n=\n\n211\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ncheck that there are no unread data in the receive buffer. Note that the TXCn Flag must be\ncleared before each transmission (before UDRn is  written) if it is used for this purpose.\nThe following simple USART initialization code examples show one assembly and one C func-\ntion that are equal in functionality. The exampl es assume asynchronous  operation using polling\n(no interrupts enabled) and a fixed frame format. The baud rate is given as a function parameter.\nFor the assembly code, the baud rate parameter is assumed to be stored in the r17:r16\nRegisters.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nMore advanced initialization routines can be made that include frame format as parameters, dis-\nable interrupts and so on. However, many appl ications use a fixed setting of the baud and\ncontrol registers, and for these types of applicati ons the initialization code can be placed directly\nin the main routine, or be combined with initialization code for other I/O modules.Assembly Code Example(1)\nUSART_Init:\n; Set baud rate\nstsUBRRnH, r17\nstsUBRRnL, r16\nldir16, (1<<U2Xn)\nstsUCRnA, r16\n; Enable receiver and transmitter\nldir16, (1<<RXENn)|(1<<TXENn)\nstsUCSRnB,r16\n; Set frame format: 8data, 1stop bit\nldir16, (2<<UMSELn)|(3<<UCSZn0)\nstsUCSRnC,r16\nret\nC Code Example(1)\n#define FOSC 1843200// Clock Speed\n#define BAUD 9600#define (MYUBRR FOSC/16/BAUD-1)void main( void ){...USART_Init ( MYUBRR );...} // mainvoid USART_Init( unsigned int ubrr){/* Set baud rate */UBRRH = (unsigned char)(ubrr>>8);UBRRL = (unsigned char)ubrr;/* Enable receiver and transmitter */UCSRB = (1<<RXEN)|(1<<TXEN);/* Set frame format: 8data, 2stop bit */UCSRC = (1<<USBS)|(3<<UCSZ0);} // USART_Init\n\n212\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.5 Data Transmission \u2013 The USART Transmitter\nThe USART Transmitter is enabled by setting the Transmit Enable  (TXEN) bit in the UCSRnB\nRegister. When the Transmitter is enabled, the normal port operation of the TxDn pin is overrid-\nden by the USART and given the function as t he Transmitter\u2019s serial output. The baud rate,\nmode of operation and frame format must be set up once before doing any transmissions. If syn-\nchronous operation is used, the clock on the XCKn pi n will be overridden and used as\ntransmission clock.\n22.5.1 Sending Frames with 5 to 8 Data Bit\nA data transmission is initiated by loading the transmit buffer with the data to be transmitted. The\nCPU can load the transmit buffer by writing to the UDRn I/O location. The buffered data in the\ntransmit buffer will be moved to the Shift Register wh en the Shift Register is ready to send a new\nframe. The Shift Register is loaded with new data if it is in idle state (no ongoing transmission) orimmediately after the last stop bit of the previous frame is transmitted. When the Shift Register is\nloaded with new data, it will transf er one complete frame at the ra te given by the Baud Register,\nU2Xn bit or by XCKn depending on mode of operation.\nThe following code examples show a simple USART transmit function based on polling of the\nData Register Empty  (UDREn) Flag. When using frames with less than eight bits, the most sig-\nnificant bits written to the UDRn  are ignored. The USART has to be initialized before the function\ncan be used. For the assembly code, the data to be sent is assumed to be stored in Register\nR16.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe function simply waits for the transmit buffer to be em pty by checking the UDREn Flag,\nbefore loading it wit h new data to be transmitted. If the Da ta Register Empty in terrupt is utilized,\nthe interrupt routine writes the data into the buffer.Assembly Code Example(1)\nUSART_Transmit:\n; Wait for empty transmit buffer\nldsr17, UCSRnA\nsbrs r17, UDREn\nrjmpUSART_Transmit\n; Put data (r16) into buffer, sends the data\nstsUDRn,r16\nret\nC Code Example(1)\nvoid USART_Transmit( unsigned char  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRnA & (1<<UDREn)) )\n;\n/* Put data into buffer, sends the data  */\nUDRn = data;\n}\n\n213\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.5.2 Sending Frames with 9 Data Bit\nIf 9-bit characters are used (UCSZn = 7), the ninth bit must be written to the TXB8 bit in\nUCSRnB before the low byte of the character is  written to UDRn. The following code examples\nshow a transmit function that handles 9-bit characters. For the assembly code, the data to be\nsent is assumed to be stored in registers R17:R16.\nNotes: 1. These transmit functions are written to be general functions. They can be optimized if the con-\ntents of the UCSRnB is static. For example, only the TXB8 bit of the UCSRnB Register is used \nafter initialization.\n2.See \u201cAbout Code Examples\u201d on page 11.\nThe ninth bit can be used for indicating an address frame when using multi processor communi-\ncation mode or for other protocol handling as for example synchronization.\n22.5.3 Transmitter Flags and Interrupts\nThe USART Transmitter has two flags that indi cate its state: USART Data Register Empty\n(UDREn) and Transmit Complete (TXCn). Both flags can be used for generating interrupts.\nThe Data Register Empty (UDREn) Flag indicates whether the transmit buffer is ready to receive\nnew data. This bit is set when the transmit buffer is empty, and cleared when the transmit buffer\ncontains data to be transmitted that has not yet be en moved into the Shift Register. For compat-\nibility with future devices, alwa ys write this bit to zero when  writing the UCSRnA Register.Assembly Code Example(1)(2)\nUSART_Transmit:\n; Wait for empty transmit buffer\nsbisUCSRnA,UDREn\nrjmpUSART_Transmit\n; Copy 9th bit from r17 to TXB8\ncbiUCSRnB,TXB8\nsbrcr17,0\nsbiUCSRnB,TXB8\n; Put LSB data (r16) into buffer, sends the data\nstsUDRn,r16\nret\nC Code Example(1)(2)\nvoid USART_Transmit( unsigned int  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRnA & (1<<UDREn))) )\n;\n/* Copy 9th bit to TXB8 */\nUCSRnB &= ~(1<<TXB8);\nif ( data & 0x0100 )\nUCSRnB |= (1<<TXB8);\n/* Put data into buffer, sends the data  */\nUDRn = data;\n}\n\n214\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the Data Register Empty Interrupt Enable ( UDRIEn) bit in UCSRnB is written to one, the\nUSART Data Register Empty Inte rrupt will be executed as long as UDREn is set (provided that\nglobal interrupts are enabled). UD REn is cleared by writing UDRn. When interrupt-driven data\ntransmission is used, the Data Register Empty interrupt routine must either write new data toUDRn in order to clear UDREn or disable the Data Register Empty interrupt, otherwise a new\ninterrupt will occur once the in terrupt routin e terminates.\nThe Transmit Complete (TXCn) Flag bit is set one when the entire frame in the Transmit Shift\nRegister has been shifted out and there are no new data currently present in the transmit buffer.\nThe TXCn Flag bit is automatically cleared when a transmit complete interrupt is executed, or it\ncan be cleared by writing a one to its bit location . The TXCn Flag is usef ul in half-duplex commu-\nnication interfaces (like the RS-485 standard) , where a transmitting application must enter\nreceive mode and free the communication bus immediately after completing the transmission.\nWhen the Transmit Compete Interrupt Enable (TXCIEn) bit in UCSRnB is set, the USART\nTransmit Complete Interrupt will  be executed when the TXCn Flag becomes set (provided that\nglobal interrupts are enabled). When the transmit complete interrupt is used, the interrupt han-\ndling routine does not have to clear the TXCn Fl ag, this is done automatically when the interrupt\nis executed.\n22.5.4 Parity Generator\nThe Parity Generator calculates the parity bit for the serial frame data. When parity bit is enabled\n(UPMn1 = 1), the transmitter control logic inserts the parity bit between the last data bit and the\nfirst stop bit of the frame that is sent.\n22.5.5 Disabling the Transmitter\nThe disabling of the Tran smitter (setting the TXEN to zero ) will not become effective until ongo-\ning and pending transmissions are completed, that is, when the Transmit Shift Register and\nTransmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter\nwill no longer override the TxDn pin.\n22.6 Data Reception \u2013 The USART Receiver\nThe USART Receiver is enabled by writi ng the Receive Enable (RXENn) bit in the\nUCSRnB Register to one. When the Receiver is enabled, the normal pin operation of the RxDn\npin is overridden by the USART and given the func tion as the Receiver\u2019s serial input. The baud\nrate, mode of operation and frame format must be set up once before any serial reception canbe done. If synchronous operation is used, the cloc k on the XCKn pin will be used as transfer\nclock.\n22.6.1 Receiving Frames with 5 to 8 Data Bits\nThe Receiver starts data reception when it detects a valid start bit. Each bit that follows the start\nbit will be sampled at the baud rate or XCKn cl ock, and shifted into the Receive Shift Register\nuntil the first stop bit of  a frame is received. A second stop  bit will be ignored by the Receiver.\nWhen the first stop bit is received, that is, a complete serial frame is present in the Receive Shift\nRegister, the contents of the Shift Register will be moved into the rece ive buffer. The receive\nbuffer can then be read by reading the UDRn I/O location.\nThe following code example shows a simple US ART receive function based on polling of the\nReceive Complete (RXCn) Flag. When using frames with less than eight bits the most significant\nbits of the data read from the UDRn will be masked to zero. Th e USART has to be initialized\nbefore the function can be used.\n\n215\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe function simply waits for data to be present in the receive buffer by checking the RXCn Flag,\nbefore reading the buffer and returning the value.\n22.6.2 Receiving Frames with 9 Data Bits\nIf 9-bit characters are used (UCSZn=7) the ninth bit must be read from the RXB8n bit in\nUCSRnB before  reading the low bits from the UDRn. This rule applies to the FEn, DORn and\nUPEn Status Flags as well. Read status fr om UCSRnA, then data from UDRn. Reading the\nUDRn I/O location will change the state of the re ceive buffer FIFO and consequently the TXB8n,\nFEn, DORn and UPEn bits, which a ll are stored in the FIFO, will change.\nThe following code example shows a simple USART receive function that handles both nine bit\ncharacters and the status bits.Assembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nldsr17, UCSRnA\nsbrsr17, RXCn\nrjmpUSART_Receive\n; Get and return received data from buffer\nldsr16, UDRn\nret\nC Code Example(1)\nunsigned char  USART_Receive( void )\n{\n/* Wait for data to be received  */\nwhile ( !(UCSRnA & (1<<RXCn)) )\n;\n/* Get and return received data from buffer  */\nreturn UDRn;\n}\n\n216\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe receive function example reads all the I/O R egisters into the Register File before any com-\nputation is done. This gives an optimal receive buffer utilization since the bu ffer location read will\nbe free to accept new data as early as possible.\n22.6.3 Receive Compete Flag and Interrupt\nThe USART Receiver has one flag that indicates the Receiver state.\nThe Receive Complete (RXCn) Flag indicates if there are unread data present in the receive buf-\nfer. This flag is one when unread data exist in the receive buffer, and zero when the receiveAssembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nldsr17, UCSRnA\nsbrsr17, RXCn\nrjmpUSART_Receive\n; Get status and 9th bit, then data from buffer\nldsr18, UCSRnA\nldsr17, UCSRnB\nldsr16, UDRn\n; If error, return -1\nandir18,(1<<FEn)|(1<<DORn)|(1<<UPEn)\nbreqUSART_ReceiveNoError\nldir17, HIGH(-1)\nldir16, LOW(-1)\nUSART_ReceiveNoError:\n; Filter the 9th bit, then return\nlsrr17\nandir17, 0x01\nret\nC Code Example(1)\nunsigned int  USART_Receive( void )\n{\nunsigned char  status, resh, resl;\n/* Wait for data to be received  */\nwhile ( !(UCSRnA & (1<<RXCn)) )\n;\n/* Get status and 9th bit, then data  */\n/* from buffer  */\nstatus = UCSRnA;resh = UCSRnB;resl = UDRn;/* If error, return -1  */\nif ( status & (1<<FEn)|(1<<DORn)|(1<<UPEn) )\nreturn -1;\n/* Filter the 9th bit, then return  */\nresh = (resh >> 1) & 0x01;return ((resh << 8) | resl);\n}\n\n217\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nbuffer is empty (that is, does not contain any un read data). If the Receiver is disabled (RXENn =\n0), the receive bu ffer will be flushed and consequently  the RXCn bit will become zero.\nWhen the Receive Complete Interrupt Enable (RXCIEn) in UCSRnB is set, the USART Receive\nComplete interrupt will be executed as long as the RXCn Flag is se t (provided that  global inter-\nrupts are enabled). When interrupt-driven data reception is used, the receive complete routine\nmust read the received data from UDRn in order to clear the RXCn Flag, otherwise a new inter-\nrupt will occur once the inte rrupt routine terminates.\n22.6.4 Receiver Error Flags\nThe USART Receiver has three Error Flags: Frame Error (FEn), Data OverRun (DORn) and\nParity Error (UPEn). All can be accessed by reading UCSRnA. Common for the Error Flags is\nthat they are located in the receive buffer together with the frame for which they indicate the\nerror status. Due to the buffering of the Error Flags, the UCSRnA must be read before thereceive buffer (UDRn), since reading the UDRn I/O location change s the buffer read location.\nAnother equality for the Error Flags is that they can not be altered by software doing a write to\nthe flag location. However, all flags must be set to zero when the UCSRnA is written for upwardcompatibility of future USART impl ementations. None of the Error Flags can genera te interrupts.\nThe Frame Error (FEn) Flag indicates the state of the first stop bit of the next readable frame\nstored in the receive buffer. The FEn Flag is zero when the stop bit was correctly read (as one),and the FEn Flag will be one when the stop bit was incorrect (zero). This flag can be used for\ndetecting out-of-sync conditions, detecting break conditions and protocol handling. The FEn\nFlag is not affected by the setting of the U SBSn bit in UCSRnC since the Receiver ignores all,\nexcept for the first, stop bits. For compatibility with future devices, always set this bit to zero\nwhen writing to UCSRnA.\nThe Data OverRun (DORn) Flag indicates data loss due to a receiver buffer full condition. A\nData OverRun occurs when the receive buffer is full (two characters), it is a new character wait-\ning in the Receive Shift Register, and a new start bit is detected. If the DORn Flag is set there\nwas one or more serial frame lost between the frame last read from UDRn, and the next frameread from UDRn. For compatibility wi th future devices, always write this bit to zero when writing\nto UCSRnA. The DORn Flag is cleared when t he frame received was successfully moved from\nthe Shift Register to the receive buffer.\nThe Parity Error (UPEn) Flag indicates that the next frame in the receive buffer had a Parity\nError when received. If Parity Check is not enabled the UPEn bit will always be read zero. For\ncompatibility with future devices, always set this  bit to zero when writing to UCSRnA. For more\ndetails see \u201cParity Bit Calculation\u201d on page 210  and \u201cParity Checker\u201d on page 217 .\n22.6.5 Parity Checker\nThe Parity Checker is active when the high USART Parity mode (UPMn1) bit is set. Type of Par-\nity Check to be performed (odd or even) is selected by the UPMn0 bit. When enabled, the Parity\nChecker calculates the parity of the data bits in incoming frames and compares the result with\nthe parity bit from the serial frame. The result of the check is stored in the receive buffer togetherwith the received data and stop bits. The Parity Error (UPEn) Flag can then be read by software\nto check if the frame had a Parity Error.\nThe UPEn bit is set if the next character that can be read from the receive buffer had a Parity\nError when received and the Parity Checking was enabled at that point (UPMn1 = 1). This bit is\nvalid until the receive buffer (UDRn) is read.\n\n218\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.6.6 Disabling the Receiver\nIn contrast to the Transmitter, disabling of the Receiver will be immediate. Data from ongoing\nreceptions will ther efore be lost. When disabled (that is, the RXENn is set to zero) the Receiver\nwill no longer override th e normal function of the RxDn port pi n. The Receiver buffer FIFO will be\nflushed when the Receiver is disabled. Remaining data in th e buffer will be lost.\n22.6.7 Flushing the Receive Buffer\nThe receiver buffer FIFO will be flushed when th e Receiver is disabled, that is, the buffer will be\nemptied of its contents. Unread data will be lost. If the buffer has to be flushed during normaloperation, due to for in stance an error conditi on, read the UDRn I/O location until the RXCn Flag\nis cleared. The following code example shows how to flush the receive buffer.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n22.7 Asynchronous Data Reception\nThe USART includes a clock recovery and a data  recovery unit for handling asynchronous data\nreception. The clock recovery logic is used fo r synchronizing the internally generated baud rate\nclock to the incoming asynchronous serial frames at the RxDn pin. The data recovery logic sam-ples and low pass filters each incoming bit, ther eby improving the noise immunity of the\nReceiver. The asynchronous reception operational range depends on the accuracy of the inter-\nnal baud rate clock, the rate of the incoming frames, and the frame size in number of bits.\n22.7.1 Asynchronous Clock Recovery\nThe clock recovery logic synchronizes internal clock to the incoming serial frames. Figure 22-5\non page 219  illustrates the sampling process of the start bit of an incoming frame. The sample\nrate is 16 times the baud rate for Normal mode, and eight times the baud rate for Double Speed\nmode. The horizontal arrows illustrate the sy nchronization variation due to the sampling pro-\ncess. Note the larger time variation when using the Double Speed mode (U2Xn = 1) of\noperation. Samples denoted zero are samples done when the RxDn line is idle (that is, no com-\nmunication activity).Assembly Code Example\n(1)\nUSART_Flush:\nsbisUCSRnA, RXCn\nretinr16, UDRn\nrjmpUSART_Flush\nC Code Example(1)\nvoid USART_Flush( void )\n{\nunsigned char  dummy;\nwhile ( UCSRnA & (1<<RXCn) ) dummy = UDRn;\n}\n\n219\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-5. Start Bit Sampling\nWhen the clock recovery logic detects a high (idle) to low (start) transition on the RxDn line, the\nstart bit detection sequence is initiated. Let sample 1 denote the first zero-sample as shown inthe figure. The clock recovery logic then uses samples 8, 9, and 10 for Normal mode, and sam-\nples 4, 5, and 6 for Double Speed mode (indicated with sample numbers inside boxes on the\nfigure), to decide if a valid start bit is received. If two or more of these three samples have logicalhigh levels (the majority wins), the start bit is rejected as a noise spike and the Receiver starts\nlooking for the next high to low-transition. If however, a valid start bit is detected, the clock recov-\nery logic is synchronized and the data recove ry can begin. The sy nchronization process is\nrepeated for each start bit.\n22.7.2 Asynchronous Data Recovery\nWhen the receiver clock is synchronized to the start bit, the data recovery can begin. The data\nrecovery unit uses a state machine that has  16 states for each bit in Normal mode and eight\nstates for each bit in Double Speed mode. Figure 22-6  shows the sampling of the data bits and\nthe parity bit. Each of the samples is given a number that is equal to the state of the recovery\nunit.\nFigure 22-6. Sampling of Data and Parity Bit\nThe decision of the logic level of the received bit is taken by doing a majori ty voting of the logic\nvalue to the three samples in the center of the received bit. The center samples are emphasized\non the figure by having the sample number inside boxes. The majority voting process is done as\nfollows: If two or all three samples have high levels, the received bit is registered to be a logic 1.If two or all three samples have low levels, the received bit is registered to be a logic 0. Thismajority voting process acts as a low pass filter for the incoming signal on the RxDn pin. The\nrecovery process is then repeated until a complete frame is received. Including the first stop bit.\nNote that the Receiver only uses the first stop bit of a frame.\nFigure 22-7 on page 220  shows the sampling of the stop bit and the earliest possible beginning\nof the start bit of the next frame.1234567 8 9 10 11 12 13 14 15 16 12START IDLE\n0 0BIT 0\n3\n123 4 5 678 12 0RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n1234567 8 9 10 11 12 13 14 15 16 1BIT n\n123 4 5 678 1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n\n220\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-7. Stop Bit Sampling and Ne xt Start Bit Sampling\nThe same majority voting is done to the stop bit as done for the other bits in the frame. If the stop\nbit is registered to have a logic 0 va lue, the Frame Error (FEn) Flag will be set.\nA new high to low transition indicating the start bit of a new frame can come right after the last of\nthe bits used for majority voting. For Normal Speed mode, the first low level sample can be at\npoint marked (A) in Figure 22-7 . For Double Speed mode the first low level must be delayed to\n(B). (C) marks a stop bit of full length. The ear ly start bit detection influences the operational\nrange of the Receiver.\n22.7.3 Asynchronous Operational Range\nThe operational range of the Receiver is dependent on the mismatch between the received bit\nrate and the internally generated baud rate. If the Transmitter is sending frames at too fast or tooslow bit rates, or the internally generated baud rate of the Receiver does not have a similar (see\nTable 22-2 on page 221 ) base frequency, the Receiver will not be able to synchronize the\nframes to the start bit.\nThe following equations can be used to calculate the ratio of the incoming data rate and internal\nreceiver baud rate.\nD Sum of character size and parity size (D = 5 to 10 bit).\nS Samples per bit. S = 16 for Normal Speed mode and S = 8 for Double Speed\nmode.\nS\nF First sample number used for majority voting. SF = 8 for normal speed and SF = 4\nfor Double Speed mode.\nSM Middle sample number used for majority voting. SM = 9 for normal speed and\nSM= 5 for Double Speed mode.\nRslow is the ratio of the slowest incoming data rate that can be accepted in relation to the\nreceiver baud rate. Rfast is the ratio of the fastest incoming data rate that can be\naccepted in relation to the receiver baud rate.1234567 8 9 10 0/1 0/1 0/1STOP 1\n123 4 5 6 0/1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)(A) (B) (C)\nRslowD1+() S\nS1\u2013 DS\u22c5SF++------------------------------------------ - =RfastD2+() S\nD1+() SSM+-----------------------------------=\n\n221\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 22-2  and Table 22-3  list the maximum receiver baud rate error that can be tolerated. Note\nthat Normal Speed mode has higher toleration of baud rate variations.\nThe recommendations of the maximum receiver baud rate error was made under the assump-\ntion that the Receiver and Transmitter equally divides the maximum total error.\nThere are two possible sources fo r the receivers baud rate erro r. The Receiver\u2019s system clock\n(XTAL) will always have some minor instabilit y over the supply voltage range and the tempera-\nture range. When using a crystal to generate the system clock, this is rarely a problem, but for a\nresonator the system clock may differ more than 2% depending of the resonators tolerance. Thesecond source for the error is more controllable. The baud rate generator can not always do an\nexact division of the system frequency to get the b aud rate wanted. In this case an UBRR value\nthat gives an acceptable low error can be used if possible.\n22.8 Multi-processor Communication Mode\nSetting the Multi-processor Communication m ode (MPCMn) bit in UCSRnA enables a filtering\nfunction of incoming frames received by the USART Receiver. Frames that do not contain\naddress information will be ignored and not put in to the receive buffer. This effectively reduces\nthe number of incoming frames that has to be handled by the CPU, in a system with multiple\nMCUs that communicate via the same serial bu s. The Transmitter is unaffected by the MPCMn\nsetting, but has to be used diffe rently when it is a part of a system utilizing the Multi-processor\nCommunication mode.\nIf the Receiver is set up to receive frames that contain 5 to 8 data bits, then the first stop bit indi-\ncates if the frame contains data or address information. If the Receiver is set up for frames withTable 22-2. Recommended Maximum Receiver Baud Rate Error for Normal Speed Mode \n(U2Xn = 0)\nD\n# (Data+Parity Bit) Rslow (%) Rfast (%) Max Total Error (%)Recommended Max \nReceiver Error (%)\n5 93.20 106.67 +6.67/-6.8 \u00b13.0\n6 94.12 105.79 +5.79/-5.88 \u00b12.5\n7 94.81 105.11 +5.11/-5.19 \u00b12.0\n8 95.36 104.58 +4.58/-4.54 \u00b12.09 95.81 104.14 +4.14/-4.19 \u00b11.5\n10 96.17 103.78 +3.78/-3.83 \u00b11.5\nTable 22-3. Recommended Maximum Receiver Baud Rate Error for Double Speed Mode \n(U2Xn = 1)\nD\n# (Data+Parity Bit) Rslow (%) Rfast (%) Max Total Error (%)Recommended Max \nReceiver Error (%)\n5 94.12 105.66 +5.66/-5.88 \u00b12.56 94.92 104.92 +4.92/-5.08 \u00b12.0\n7 95.52 104.35 +4.35/-4.48 \u00b11.5\n8 96.00 103.90 +3.90/-4.00 \u00b11.59 96.39 103.53 +3.53/-3.61 \u00b11.5\n10 96.70 103.23 +3.23/-3.30 \u00b11.0\n\n222\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nnine data bits, then the ninth bit (RXB8n) is  used for identifying address and data frames. When\nthe frame type bit (the first stop or the ninth bit) is one, the frame contains an address. When the\nframe type bit is zero the frame is a data frame.\nThe Multi-processor Communication mode enables several slave MCUs to receive data from a\nmaster MCU. This is done by first decoding an address frame to find out which MCU has been\naddressed. If a particular slave MCU has been  addressed, it will rece ive the following data\nframes as normal, while the other slave MCUs will ignore the received frames until anotheraddress frame is received.\n22.8.1 Using MPCMn\nFor an MCU to act as a master MCU, it can us e a 9-bit character frame format (UCSZn = 7). The\nninth bit (TXB8n) must be set when an address frame (TXB8n = 1) or cleared when a data frame\n(TXB = 0) is being transmitted. The slave MCUs must in this case be set to use a 9-bit characterframe format.\nThe following procedure should be used to exchange data in Multi-processor Communication\nmode:\n1. All Slave MCUs are in Multi-processor Communication mode (MPCMn in UCSRnA is\nset).\n2. The Master MCU sends an address frame, and all slaves receive and read this frame. In \nthe Slave MCUs, the RXCn Flag in UCSRnA will be set as normal.\n3. Each Slave MCU reads the UDRn Register and determines if it has been selected. If so, \nit clears the MPCMn bit in UCSRnA, otherwise it waits for the next address byte and keeps the MPCMn setting.\n4. The addressed MCU will receive all data frames until a new address frame is received. \nThe other Slave MCUs, which still have the MP CMn bit set, will ignore the data frames.\n5.When the last data frame is received by the addressed MCU, the addressed MCU sets \nthe MPCMn bit and waits for a new address frame from master. The process then repeats from 2.\nUsing any of the 5-bit to 8-bit character frame formats is possible, but impractical since the\nReceiver must change between using n and n+1 character frame formats. This makes full-\nduplex operation difficult since the Transmitter a nd Receiver uses the same character size set-\nting. If 5-bit to 8-bit character frames are used, the Transmitter must be set to use two stop bit(USBSn = 1) since the first stop bit is  used for indicating the frame type.\nDo not use Read-Modify- Write instructions (SBI and CBI) to set or clear the MPCMn bit. The\nMPCMn bit shares the same I/O location as the TXCn Flag and this might accidentally becleared when using SBI or CBI instructions.\n22.9 Register Description\nThe following section describes the USART\u2019s registers.\n22.9.1 UDRn \u2013 USART I/O Data Register n\nB i t 76543210\nRXB[7:0] UDRn (Read)\nTXB[7:0] UDRn (Write)\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n223\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe USART Transmit Data Buffer Register and USART Receive Data Buffer Registers share the\nsame I/O address re ferred to as USART Data Register or  UDRn. The Transmit Data Buffer Reg-\nister (TXB) will be the destination for data wri tten to the UDRn Register  location. Reading the\nUDRn Register location will retu rn the contents of the Receiv e Data Buffer Register (RXB).\nFor 5-bit, 6-bit, or 7-bit characters the upper  unused bits will be ignored by the Transmitter and\nset to zero by the Receiver.\nThe transmit buffer can only be written when the UDREn Flag in the UCSRnA Register is set.\nData written to UDRn wh en the UDREn Flag is not set, will be  ignored by the USART Transmit-\nter. When data is written to the transmit buffer, and the Transmitter is enabled, the Transmitter\nwill load the data into the Transmit Shift Regist er when the Shift Register is empty. Then the\ndata will be serially transmitted on the TxDn pin.\nThe receive buffer consists of a two level FIFO . The FIFO will change its state whenever the\nreceive buffer is accessed. Due to this behavior of the receive buffer, do not use Read-Modify-Write instructions (SBI and CBI) on this location. Be careful when using bit test instructions\n(SBIC and SBIS), since these also will change the state of the FIFO.\n22.9.2 UCSRnA \u2013 USART Contro l and Status Register A\n\u0081 Bit 7 \u2013 RXCn: USART Receive Complete\nThis flag bit is set when there are unread data in the receive buffer and cleared when the receive\nbuffer is empty (that is, does not contain any unread data). If the Receiver is disabled, the\nreceive buffer will be flushed and conse quently the RXCn bit will be come zero. The RXCn Flag\ncan be used to generate a Receive Complete interrupt (see description of the RXCIEn bit).\n\u0081 Bit 6 \u2013 TXCn: USART Transmit Complete\nThis flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and\nthere are no new data currently present in the transmit buffer (UDRn). The TXCn Flag bit is auto-matically cleared when a transmit complete interrupt is executed, or it can be cleared by writing\na one to its bit location. The TXCn Flag can generate a Transmit Complete interrupt (see\ndescription of the TXCIEn bit).\n\u0081 Bit 5 \u2013 UDREn: USART Data Register Empty\nThe UDREn Flag indicates if the transmit buff er (UDRn) is ready to receive new data. If UDREn\nis one, the buffer is empty, and therefore ready to be written. The UDREn Flag can generate a\nData Register Empty interrupt (see description of the UDRIEn bit).\nUDREn is set after a reset to indicate that the Transmitter is ready.\n\u0081 Bit 4 \u2013 FEn: Frame Error\nThis bit is set if the next character in the receive buffer had a Frame Error when received, that is,\nwhen the first stop bit of the next character in the receive buffer is zero. This bit is valid until the\nreceive buffer (UDRn) is read. The FEn bit is zero when the stop bit of received data is one.\nAlways set this bit to ze ro when writing to UCSRnA.B i t 76543210\nRXCn TXCn UDREn FEn DORn UPEn U2Xn MPCMn UCSRnA\nRead/Write R R/ W RRRR R / W R/W\nI n i t i a l  V a l u e00100000\n\n224\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 DORn: Data OverRun\nThis bit is set if a Data OverRun condition is detected. A Data OverRun occurs when the receive\nbuffer is full (two characters), it is a new char acter waiting in the Receive Shift Register, and a\nnew start bit is detected. This bi t is valid until the receive buffer  (UDRn) is read . Always set this\nbit to zero when writing to UCSRnA.\n\u0081 Bit 2 \u2013 UPEn: USART Parity Error\nThis bit is set if the next character in the receive buffer had a Parity Error when received and the\nParity Checking was enabled at that point (UPMn1 = 1). This bit is valid until the receive buffer(UDRn) is read. Always set this bit to zero when writing to UCSRnA.\n\u0081 Bit 1 \u2013 U2Xn: Double the USART Transmission Speed\nThis bit only has effect for the asynchronous operation. Write this bit to zero when using syn-\nchronous operation.\nWriting this bit to one will reduce the divisor of th e baud rate divider from 16 to 8 effectively dou-\nbling the transfer rate for asynchronous communication.\n\u0081 Bit 0 \u2013 MPCMn: Multi-processor Communication Mode\nThis bit enables the Multi-processor Communication mode. When the MPCMn bit is written to\none, all the incoming frames received by the USART Receiver that do not contain address infor-\nmation will be ignored. The Transmitter is unaffe cted by the MPCMn setting. For more detailed\ninformation see \u201cMulti-processor Communication Mode\u201d on page 221 .\n22.9.3 UCSRnB \u2013 USART Control and Status Register n B\n\u0081 Bit 7 \u2013 RXCIEn: RX Comp lete Interrupt Enable n\nWriting this bit to one enables interrupt on the RXCn Flag. A USART Rece ive Complete interrupt\nwill be generated only if the RXCIEn bit is written to one, the Global Interrupt Flag in SREG iswritten to one and the RXCn bit in UCSRnA is set.\n\u0081 Bit 6 \u2013 TXCIEn: TX Complete Interrupt Enable n\nWriting this bit to one enables interrupt on the TXCn Flag. A USART Transmit Complete interrupt\nwill be generated only if the TXCIEn bit is written to one, the Global Interrupt Flag in SREG is\nwritten to one and the TXCn bit in UCSRnA is set.\n\u0081 Bit 5 \u2013 UDRIEn: USART Data Register Empty Interrupt Enable n\nWriting this bit to one enables interrupt on the UDREn Flag. A Data Register  Empty interrupt will\nbe generated only if the UDRIEn bit is written to one, the Global Interrupt Flag in SREG is writtento one and the UDREn bit in UCSRnA is set.\n\u0081 Bit 4 \u2013 RXENn: Receiver Enable n\nWriting this bit to one enables the USART Receiv er. The Receiver will override normal port oper-\nation for the RxDn pin when enabled. Disab ling the Receiver will fl ush the receive buffer\ninvalidating the FEn, DORn, and UPEn Flags.B i t 7654 321 0\nRXCIEn TXCIEn UDRIEn RXENn TXENn UCSZn2 RXB8n TXB8n UCSRnB\nRead/Write R/ W R/W R/W R/W R/W R/W RR / W\nInitial Value 0 0 0 0 0 0 0 0\n\n225\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 TXENn: Transmitter Enable n\nWriting this bit to on e enables the USART Transmitter. Th e Transmitter will override normal port\noperation for the TxDn pin when enabled. The di sabling of the Transmitter (writing TXENn to\nzero) will not become effective until ongoing and pending transmissions are completed, that is,\nwhen the Transmit Shift Register and Transmit Buffer Register do not contain data to be trans-\nmitted. When disabled, the Transmitter will no  longer override the TxDn port.\n\u0081 Bit 2 \u2013 UCSZn2: Character Size n\nThe UCSZn2 bits combined with the UCSZn1:0 bit in UCSRnC sets the number of data bits\n(Character SiZe) in a frame the Receiver and Transmitter use.\n\u0081 Bit 1 \u2013 RXB8n: Receive Data Bit 8 n\nRXB8n is the ninth data bit of the received char acter when operating with serial frames with nine\ndata bits. Must be read before reading the low bits from UDRn.\n\u0081 Bit 0 \u2013 TXB8n: Transmit Data Bit 8 n\nTXB8n is the ninth data bit in the character to be transmitted when operating with serial frames\nwith nine data bits. Must be written before writing the low bits to UDRn.\n22.9.4 UCSRnC \u2013 USART Control and Status Register n C\n\u0081 Bits 7:6 \u2013 UMSELn1:0 USART Mode Select\nThese bits select the mode of operation of the USARTn as shown in Table 22-4 .\nNote: 1. See \u201cUSART in SPI Mode\u201d on page 232  for full description of the Master SPI Mode (MSPIM) \noperation.\n\u0081 Bits 5:4 \u2013 UPMn1:0: Parity Mode\nThese bits enable and set type of parity generation and check. If enabled, the Transmitter will\nautomatically generate and send the parity of th e transmitted data bits within each frame. TheBit 7 6 5 4 3 2 1 0\nUMSELn1 UMSELn0 UPMn1 UPMn0 USBSn UCSZn1 UCSZn0 UCPOLn UCSRnC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 1 1 0\nTable 22-4. UMSELn Bits Settings\nUMSELn1 UMSELn0 Mode\n0 0 Asynchronous USART\n0 1 Synchronous USART1 0 (Reserved)\n1 1 Master SPI (MSPIM)\n(1)\n\n226\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nReceiver will generate a parity va lue for the incoming data and co mpare it to th e UPMn setting.\nIf a mismatch is detected, the UPEn Flag in UCSRnA will be set.\n\u0081 Bit 3 \u2013 USBSn: Stop Bit Select\nThis bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores\nthis setting.\n\u0081 Bit 2:1 \u2013 UCSZn1:0: Character Size\nThe UCSZn1:0 bits combined with the UCSZn2 bit in UCSRnB sets the number of data bits\n(Character SiZe) in a frame the Receiver and Transmitter use.\n\u0081 Bit 0 \u2013 UCPOLn: Clock Polarity\nThis bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is\nused. The UCPOLn bit sets the relationship between data output change and data input sample,\nand the synchronous clock (XCKn).Table 22-5. UPMn Bits Settings\nUPMn1 UPMn0 Parity Mode\n00 D i s a b l e d\n01 R e s e r v e d\n1 0 Enabled, Even Parity\n1 1 Enabled, Odd Parity\nTable 22-6. USBS Bit Settings\nUSBSn Stop Bit(s)\n01 - b i t12 - b i t\nTable 22-7. UCSZn Bits Settings\nUCSZn2 UCSZn1 UCSZn0 Character Size\n000 5 - b i t\n001 6 - b i t010 7 - b i t\n011 8 - b i t\n1 0 0 Reserved1 0 1 Reserved\n1 1 0 Reserved\n111 9 - b i t\nTable 22-8. UCPOLn Bit Settings\nUCPOLnTransmitted Data Ch anged (Output of \nTxDn Pin)Received Data Sampled (Input on RxDn \nPin)\n0 Rising XCKn Edge Falling XCKn Edge\n1 Falling XCKn Edge Rising XCKn Edge\n\n227\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.9.5 UBRRnL and UBRRnH \u2013 USART Baud Rate Registers\n\u0081 Bit 15:12 \u2013 Reserved Bits\nThese bits are reserved for future use. For compatibility with future devices, these bit must be\nwritten to zero when UBRRH is written.\n\u0081 Bit 11:0 \u2013 UBRR11:0: USART Baud Rate Register\nThis is a 12-bit register which contains the USART baud rate. The UBRRH contains the four\nmost significant bits, and the UBRRL contains th e eight least significant bits of the USART baud\nrate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if th e baud rate is\nchanged. Writing UBRRL will trigger an immediate update of the baud rate prescaler.\n22.10 Examples of Ba ud Rate Setting\nFor standard crystal and resonator frequencies, the most commonly used baud rates for asyn-\nchronous operation can be generated by using the UBRR settings in Table 22-9  to Table 22-12\non page 231 . UBRR values which yield an actual baud rate differing less than 0.5% from the tar-\nget baud rate, are bold in the table. Higher error ratings are acceptable, but the Receiver will\nhave less noise resistance when the error ratings are high, especially for large serial frames (see\n\u201cAsynchronous Operational Range\u201d on page 220 ). The error values are calculated using the fol-\nlowing equation:B i t 1 51 41 31 21 11 0 9 8\n\u2013 \u2013 \u2013 \u2013 UBRR[11:8] UBRRHn\nUBRR[7:0] UBRRLn\n76543210\nRead/Wr i t e RRRR R / W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n00000000\nError[%]BaudRateClosest Match\nBaudRate-------------------------------------------------------- 1\u2013\u239d\u23a0\u239b\u239e100%\u2022 =\nTable 22-9. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 1.0000MHz fosc = 1.8432MHz fosc = 2.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 25 0.2% 51 0.2% 47 0.0% 95 0.0% 51 0.2% 103 0.2%\n4800 12 0.2% 25 0.2% 23 0.0% 47 0.0% 25 0.2% 51 0.2%9600 6 -7.0% 12 0.2% 11 0.0% 23 0.0% 12 0.2% 25 0.2%\n14.4K 3 8.5% 8 -3.5% 7 0.0% 15 0.0% 8 -3.5% 16 2.1%\n19.2K 2 8.5% 6 -7.0% 5 0.0% 11 0.0% 6 -7.0% 12 0.2%28.8K 1 8.5% 3 8.5% 3 0.0% 7 0.0% 3 8.5% 8 -3.5%\n38.4K 1 -18.6% 2 8.5% 2 0.0% 5 0.0% 2 8.5% 6 -7.0%\n\n228\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%57.6K 0 8.5% 1 8.5% 1 0.0% 3 0.0% 1 8.5% 3 8.5%\n76.8K \u2013 \u2013 1 -18.6% 1 -25.0% 2 0.0% 1 -18.6% 2 8.5%\n115.2K \u2013 \u2013 0 8.5% 0 0.0% 1 0.0% 0 8.5% 1 8.5%\n230.4K \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 0 0.0% \u2013 \u2013 \u2013 \u2013\n2 5 0 K \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u20130 0 . 0 %\nMax.(1)62.5Kbps 125Kbps 115.2Kbps 2 30.4Kbps 125Kbps 250KbpsTable 22-9. Examples of UBRRn Settings for Common ly Used Oscillator Frequencies (Continued)\nBaud \nRate \n(bps)fosc = 1.0000MHz fosc = 1.8432MHz fosc = 2.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n\n229\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-10. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 3.6864MHz fosc = 4.0000MHz fosc = 7.3728MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 95 0.0% 191 0.0% 103 0.2% 207 0.2% 191 0.0% 383 0.0%\n4800 47 0.0% 95 0.0% 51 0.2% 103 0.2% 95 0.0% 191 0.0%\n9600 23 0.0% 47 0.0% 25 0.2% 51 0.2% 47 0.0% 95 0.0%\n14.4K 15 0.0% 31 0.0% 16 2.1% 34 -0.8% 31 0.0% 63 0.0%\n1 9 . 2 K1 10 . 0 %2 30 . 0 %1 20 . 2 %2 50 . 2 %2 30 . 0 %4 70 . 0 %28.8K 7 0.0% 15 0.0% 8 -3.5% 16 2.1% 15 0.0% 31 0.0%\n38.4K 5 0.0% 11 0.0% 6 -7.0% 12 0.2% 11 0.0% 23 0.0%\n57.6K 3 0.0% 7 0.0% 3 8.5% 8 -3.5% 7 0.0% 15 0.0%76.8K 2 0.0% 5 0.0% 2 8.5% 6 -7.0% 5 0.0% 11 0.0%\n115.2K 1 0.0% 3 0.0% 1 8.5% 3 8.5% 3 0.0% 7 0.0%\n230.4K 0 0.0% 1 0.0% 0 8.5% 1 8.5% 1 0.0% 3 0.0%\n250K 0 -7.8% 1 -7.8% 0 0.0% 1 0.0% 1 -7.8% 3 -7.8%\n0.5M \u2013 \u2013 0 -7.8% \u2013 \u2013 0 0.0% 0 -7.8% 1 -7.8%\n1 M \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u20130 - 7 . 8 %\nMax.\n(1)230.4Kbps 460.8Kbps 250Kbps 0. 5Mbps 460.8Kbps 921.6Kbps\n\n230\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-11. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 8.0000MHz fosc = 11.0592 MHz fosc = 14.7456MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 207 0.2% 416 -0.1% 287 0.0% 575 0.0% 383 0.0% 767 0.0%\n4800 103 0.2% 207 0.2% 143 0.0% 287 0.0% 191 0.0% 383 0.0%\n9600 51 0.2% 103 0.2% 71 0.0% 143 0.0% 95 0.0% 191 0.0%\n14.4K 34 -0.8% 68 0.6% 47 0.0% 95 0.0% 63 0.0% 127 0.0%\n1 9 . 2 K2 50 . 2 %5 10 . 2 %3 50 . 0 %7 10 . 0 %4 70 . 0 %9 50 . 0 %28.8K 16 2.1% 34 -0.8% 23 0.0% 47 0.0% 31 0.0% 63 0.0%\n3 8 . 4 K1 20 . 2 %2 50 . 2 %1 70 . 0 %3 50 . 0 %2 30 . 0 %4 70 . 0 %\n57.6K 8 -3.5% 16 2.1% 11 0.0% 23 0.0% 15 0.0% 31 0.0%76.8K 6 -7.0% 12 0.2% 8 0.0% 17 0.0% 11 0.0% 23 0.0%\n115.2K 3 8.5% 8 -3.5% 5 0.0% 11 0.0% 7 0.0% 15 0.0%\n230.4K 1 8.5% 3 8.5% 2 0.0% 5 0.0% 3 0.0% 7 0.0%\n250K 1 0.0% 3 0.0% 2 -7.8% 5 -7.8% 3 -7.8% 6 5.3%\n0.5M 0 0.0% 1 0.0% \u2013 \u2013 2 -7.8% 1 -7.8% 3 -7.8%\n1 M \u2013\u20130 0 . 0 % \u2013\u2013\u2013\u20130 - 7 . 8 % 1 - 7 . 8 %\nMax.\n(1)0.5Mbps 1Mbps 691.2Kbps 1.3824Mbps 921.6Kbps 1.8432Mbps\n\n231\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-12. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 16.0000MHz fosc = 18.4320MHz fosc = 20.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 416 -0.1% 832 0.0% 479 0.0% 959 0.0% 520 0.0% 1041 0.0%\n4800 207 0.2% 416 -0.1% 239 0.0% 479 0.0% 259 0.2% 520 0.0%\n9600 103 0.2% 207 0.2% 119 0.0% 239 0.0% 129 0.2% 259 0.2%\n14.4K 68 0.6% 138 -0.1% 79 0.0% 159 0.0% 86 -0.2% 173 -0.2%\n19.2K 51 0.2% 103 0.2% 59 0.0% 119 0.0% 64 0.2% 129 0.2%28.8K 34 -0.8% 68 0.6% 39 0.0% 79 0.0% 42 0.9% 86 -0.2%\n3 8 . 4 K2 50 . 2 %5 10 . 2 %2 90 . 0 %5 90 . 0 %3 2 - 1 . 4 % 6 40 . 2 %\n57.6K 16 2.1% 34 -0.8% 19 0.0% 39 0.0% 21 -1.4% 42 0.9%7 6 . 8 K1 20 . 2 %2 50 . 2 %1 40 . 0 %2 90 . 0 %1 51 . 7 %3 2 - 1 . 4 %\n115.2K 8 -3.5% 16 2.1% 9 0.0% 19 0.0% 10 -1.4% 21 -1.4%\n230.4K 3 8.5% 8 -3.5% 4 0.0% 9 0.0% 4 8.5% 10 -1.4%\n250K 3 0.0% 7 0.0% 4 -7.8% 8 2.4% 4 0.0% 9 0.0%\n0.5M 1 0.0% 3 0.0% \u2013 \u2013 4 -7.8% \u2013 \u2013 4 0.0%\n1 M 0 0 . 0 % 1 0 . 0 % \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\nMax.\n(1)1Mbps 2Mbps 1.152Mbps 2.304Mbps 1.25Mbps 2.5Mbps\n\n232\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23. USART in SPI Mode\nThe Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) can be\nset to a master SPI compliant mode of operation. The Master SPI Mode (MSPIM) has the follow-\ning features:\n\u0081Full Duplex, Three-wire Synchronous Data Transfer\n\u0081Master Operation\n\u0081Supports all four SPI Modes of Operation (Mode 0, 1, 2, and 3)\n\u0081LSB First or MSB First Data Tran sfer (Configurable Data Order)\n\u0081Queued Operation (Double Buffered)\n\u0081High Resolution Baud Rate Generator\n\u0081High Speed Operatio n (fXCKmax = fCK/2)\n\u0081Flexible Interrupt Generation\n23.1 Overview\nSetting both UMSELn1:0 bits to one enables the USART in MSPIM logic. In this mode of opera-\ntion the SPI master control logic takes direct control over the USART resources. These\nresources include the transmitter and receiver shift register and buffers, and the baud rate gen-\nerator. The parity generator and checker, the data and clock recovery logic, and the RX and TXcontrol logic is disabled. The USART RX and TX control logic is replaced by a common SPI\ntransfer control logic. However, the pin control l ogic and interrupt generation logic is identical in\nboth modes of operation.\nThe I/O register locations are the same in both modes. However, some of the functionality of the\ncontrol registers changes when using MSPIM.\n23.2 USART MSPIM vs. SPI\nThe AVR USART in MSPIM mode is fully compatible with the AVR SPI regarding:\n\u0081 Master mode timing diagram\n\u0081 The UCPOLn bit functionality is identical to the SPI CPOL bit\u0081 The UCPHAn bit functionality is identical to the SPI CPHA bit\u0081 The UDORDn bit functionality is identical to the SPI DORD bit\nHowever, since the USART in MSPIM mode reuses the USART resources, the use of the\nUSART in MSPIM mode is somewhat different compared to the SPI. In addition to differences of\nthe control register bits, and that only master  operation is supported by the USART in MSPIM\nmode, the following features differ between the two modules:\n\u0081 The USART in MSPIM mode includes (double) buffering of the transmitter. The SPI has no \nbuffer\n\u0081 The USART in MSPIM mode receiver includes an additional buffer level\u0081 The SPI WCOL (Write Collision) bit is not incl uded in USART in MSPIM mode\n\u0081 The SPI double speed mode (SPI2X) bit is not included. However, the same effect is \nachieved by setting UBRRn accordingly\n\u0081 Interrupt timing is not compatible\u0081 Pin control differs due to the master only operation of the USART in MSPIM mode\n\n233\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA comparison of the USART in MSPIM mode and the SPI pins is shown in Table 23-4 on page\n240.\n23.2.1 Clock Generation\nThe Clock Generation logic generates the base clock for the Transmitter and Receiver. For\nUSART MSPIM mode of operation only internal cl ock generation (that is, master operation) is\nsupported. The Data Direction Register for the XCKn pin (DDR_XCKn) must therefore be set toone (that is, as output) for the USART in MSPIM to operate correctly. Preferably the DDR_XCKn\nshould be set up before the USART in MSPIM is enabled (that is, TXENn and RXENn bit set to\none).\nThe internal clock generation used in MSPIM mode is identical to the USART synchronous mas-\nter mode. The baud rate or UBRRn setting can therefore be calculated using the same\nequations, see Table 23-1 .\nNote: 1. The baud rate is defined to be the transfer rate in bit per second (bps).\nBAUD Baud rate (in bits per second, bps).\nfOSC System Oscillator clock frequency.\nUBRRn Contents of the UBRRnH and UBRRnL Registers, (0-4095).\n23.3 SPI Data Modes and Timing\nThere are four combinations of XCKn (SCK) phase and polarity with respect to serial data, which\nare determined by control bits UCPHAn and UCPOLn. The data transfer timing diagrams areshown in Figure 23-1 on page 234 . Data bits are shifted out and latched in on opposite edges of\nthe XCKn signal, ensuring sufficient time for data signals to stabilize. The UCPOLn and\nUCPHAn functionality is summarized in Table 23-2 . Note that changing the setting of any of\nthese bits will corrupt all ongoing communication for both the Receiver and Transmitter.Table 23-1. Equations for Calculating Baud Rate Register Setting\nOperating ModeEquation for Calculating Baud \nRate(1)Equation for Calculating \nUBRRn Value\nSynchronous Master \nmodeBAUDfOSC\n2UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n2BAUD-------------------- 1\u2013 =\nTable 23-2. UCPOLn and UCPHAn Functionality-\nUCPOLn UCPHAn SPI Mode Lead ing Edge Trailing Edge\n0 0 0 Sample (Rising) Setup (Falling)\n0 1 1 Setup (Rising) Sample (Falling)1 0 2 Sample (Falling) Setup (Rising)\n1 1 3 Setup (Falling) Sample (Rising)\n\n234\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 23-1. UCPHAn and UCPOLn data transfer timing diagrams.\n23.4 Frame Formats\nA serial frame for the MSPIM is defined to be one character of 8 data bits. The USART in MSPIM\nmode has two valid frame formats:\n\u0081 8-bit data with MSB first\n\u0081 8-bit data with LSB firstA frame starts with the least or most significant data bit. Then the next data bits, up to a total of\neight, are succeeding, ending with the most or least significant bit accordingly. When a complete\nframe is transmitted, a new frame can directly follow it, or the communication line can be set to\nan idle (high) state.\nThe UDORDn bit in UCSRnC sets the frame form at used by the USART in MSPIM mode. The\nReceiver and Transmitter use the same setting. Note that changing the setting of any of these\nbits will corrupt all ongoin g communication for both th e Receiver and Transmitter.\n16-bit data transfer can be achieved by writing two data bytes to UDRn. A UART transmit com-\nplete interrupt will then signal that the 16-bit value ha s been shifted out.\n23.4.1 USART MSPIM Initialization\nThe USART in MSPIM mode has to be initialized before any communication can take place. The\ninitialization process normally consists of setting the baud rate, setting master mode of operation\n(by setting DDR_XCKn to one), setting frame format and enabling the Transmitter and theReceiver. Only the transmitter can operate independently. For interrupt driven USART opera-\ntion, the Global Interrupt Flag should be clear ed (and thus interrupts globally disabled) when\ndoing the initialization.\nNote: To ensure immediate initialization of the XCKn output the baud-rate register (UBRRn) must be \nzero at the time the transmitter is enabled. Contrary to the normal mode USART operation the \nUBRRn must then be written to the desired value after the transmitter is enabled, but before the \nfirst transmission is started. Setting UBRRn to ze ro before enabling the transmitter is not neces-\nsary if the initialization is done immediatel y after a reset since UBRRn is reset to zero.\nBefore doing a re-initialization with changed baud rate, data mode, or frame format, be sure that\nthere is no ongoing transmissions during the per iod the registers are changed. The TXCn Flag\ncan be used to check that the Transmitter has completed all transfers, and the RXCn Flag can\nbe used to check that there are no unread data in the receive buffer. Note that the TXCn Flag\nmust be cleared bef ore each transmission (before UDRn is wri tten) if it is used  for this purpose.XCK\nData setup (TXD)\nData sample (RXD)\nXCK\nData setup (TXD)\nData sample (RXD)XCK\nData setup (TXD)\nData sample (RXD)\nXCK\nData setup (TXD)\nData sample (RXD)UCPOL=0 UCPOL=1\nUCPHA=0UCPHA=1\n\n235\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following simple USART initialization code examples show one assembly and one C func-\ntion that are equal in functionality. The examples assume polling (no interrupts enabled). The\nbaud rate is given as a function parameter. For the assembly code, the baud rate parameter is\nassumed to be stored in the r17:r16 registers.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nUSART_Init:\nclr r18\nout UBRRnH,r18\nout UBRRnL,r18\n; Setting the XCKn port pin as output, enables master mode.\nsbi XCKn_DDR, XCKn\n; Set MSPI mode of operation and SPI data mode 0.ldi r18, (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn)\nout UCSRnC,r18\n; Enable receiver and transmitter.ldi r18, (1<<RXENn)|(1<<TXENn)\nout UCSRnB,r18\n; Set baud rate. \n; IMPORTANT: The Baud Rate must be set after the transmitter is enabled!\nout UBRRnH, r17\nout UBRRnL, r18\nret\nC Code Example(1)\nvoid USART_Init( unsigned int  baud )\n{\nUBRRn = 0;/* Setting the XCKn port pin as output, enables master mode. */\nXCKn_DDR |= (1<<XCKn);\n/* Set MSPI mode of operation and SPI data mode 0. */UCSRnC = (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn);\n/* Enable receiver and transmitter. */\nUCSRnB = (1<<RXENn)|(1<<TXENn);/* Set baud rate. */\n/* IMPORTANT: The Baud Rate must be set after the transmitter is enabled \n*/\nUBRRn = baud;\n}\n\n236\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23.5 Data Transfer\nUsing the USART in MSPI mode requires the Transmitter to be enabled, that is, the TXENn bit in\nthe UCSRnB register is set to one. When the Transmitter is enabled, the normal port operation\nof the TxDn pin is overridden and given the func tion as the Transmitter's serial output. Enabling\nthe receiver is optional and is done by setting the RXENn bit in the UCSRnB register to one.\nWhen the receiver is enabled, the normal pin operation of the RxDn pin is overridden and given\nthe function as the Receiver's se rial input. The XCKn will in both cases be used as the transfer\nclock.\nAfter initialization the USART is re ady for doing data transfers. A data transfer is initiated by writ-\ning to the UDRn I/O location. This is the ca se for both sending and receiving data since the\ntransmitter controls the transfer clock. The data written to UDRn is moved from the transmit buf-\nfer to the shift register when the shift register is ready to send a new frame.\nNote: To keep the input buffer in sync with the number  of data bytes transmitted, the UDRn register must \nbe read once for each byte transmitted. The input buffer operation is identical to normal USART \nmode, that is, if an overflow occurs the character last received will be lost, not the first data in the \nbuffer. This means that if four bytes are transferr ed, byte 1 first, then byte 2, 3, and 4, and the \nUDRn is not read before all transfers are completed, then byte 3 to be received will be lost, and not \nbyte 1.\nThe following code examples show a simple U SART in MSPIM mode transfer function based on\npolling of the Data Register Empty (UDREn) Flag and the Receive Complete (RXCn) Flag. The\nUSART has to be initialized before the function can be used. For the assembly code, the data to\nbe sent is assumed to be stor ed in Register R16 and the data  received will be available in the\nsame register (R16) after the function returns.\nThe function simply waits for the transmit buffer to be em pty by checking the UDREn Flag,\nbefore loading it with new data to be transmitted. The function then waits for data to be presentin the receive buffer by checking the RXCn Flag, before reading the buffer and returning the\nvalue.\n\n237\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n23.5.1 Transmitter and Receiver Flags and Interrupts\nThe RXCn, TXCn, and UDREn flag s and corresponding interrupt s in USART in MSPIM mode\nare identical in function to the normal USART operation. However, the receiver error status flags(FE, DOR, and PE) are not in use and is always read as zero.\n23.5.2 Disabling the Transmitter or Receiver\nThe disabling of the transmitter or receiver in  USART in MSPIM mode is identical in function to\nthe normal USART operation.\n23.6 USART MSPIM R egister Description\nThe following section describes the registers used for SPI operation using the USART.\n23.6.1 UDRn \u2013 USART MSPI M I/O Data Register\nThe function and bit description of the USART data register (UDRn) in MSPI mode is identical to\nnormal USART operation. See \u201cUDRn \u2013 USART I/O Data Register n\u201d on page 222.Assembly Code Example(1)\nUSART_MSPIM_Transfer:\n; Wait for empty transmit buffer\nsbis UCSRnA, UDREn\nrjmp USART_MSPIM_Transfer\n; Put data (r16) into buffer, sends the data\nout UDRn,r16\n; Wait for data to be received\nUSART_MSPIM_Wait_RXCn:\nsbis UCSRnA, RXCn\nrjmp USART_MSPIM_Wait_RXCn\n; Get and return received data from buffer\nin r16, UDRn\nret\nC Code Example(1)\nunsigned char  USART_Receive( void )\n{\n/* Wait for empty transmit buffer */\nwhile ( !( UCSRnA & (1<<UDREn)) );\n/* Put data into buffer, sends the data */\nUDRn = data;\n/* Wait for data to be received */while ( !(UCSRnA & (1<<RXCn)) );\n/* Get and return received data from buffer */\nreturn UDRn;\n}\n\n238\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23.6.2 UCSRnA \u2013 USART MSPIM Control and Status Register n A\n\u0081\n\u0081 Bit 7 - RXCn: USART Receive Complete\nThis flag bit is set when there are unread data in the receive buffer and cleared when the receive\nbuffer is empty (that is, does not contain any unread data). If the Receiver is disabled, thereceive buffer will be flushed and conse quently the RXCn bit will be come zero. The RXCn Flag\ncan be used to generate a Receive Complete interrupt (see description of the RXCIEn bit).\n\u0081 Bit 6 - TXCn: USART Transmit Complete\nThis flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and\nthere are no new data currently present in the transmit buffer (UDRn). The TXCn Flag bit is auto-matically cleared when a transmit complete interrupt is executed, or it can be cleared by writing\na one to its bit location. The TXCn Flag can generate a Transmit Complete interrupt (see\ndescription of the TXCIEn bit).\n\u0081 Bit 5 - UDREn: USART Data Register Empty\nThe UDREn Flag indicates if the transmit buff er (UDRn) is ready to receive new data. If UDREn\nis one, the buffer is empty, and therefore ready to be written. The UDREn Flag can generate a\nData Register Empty interrupt (see description of the UDRIE bit). UDREn is set after a reset to\nindicate that the Tr ansmitter is ready.\n\u0081 Bit 4:0 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnA is written.\n23.6.3 UCSRnB \u2013 USART MSPIM Control and Status Register n B\n\u0081 Bit 7 - RXCIEn: RX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the RXCn Flag. A USART Rece ive Complete interrupt\nwill be generated only if the RXCIEn bit is written to one, the Global Interrupt Flag in SREG is\nwritten to one and the RXCn bit in UCSRnA is set.\n\u0081 Bit 6 - TXCIEn: TX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the TXCn Flag. A USART Transmit Complete interrupt\nwill be generated only if the TXCIEn bit is written to one, the Global Interrupt Flag in SREG iswritten to one and the TXCn bit in UCSRnA is set.Bit 7 6 5 4 3 2 1 0\nRXCn TXCn UDREn - - - - - UCSRnA\nRead/Write R/ W R/W R/W RR R R R\nInitial Value 0 0 0 0 0 1 1 0\nB i t 7 6543 2 1 0\nRXCIEn TXCIEn UDRIE RXENn TXENn - - - UCSRnB\nRead/Write R/ W R/W R/W R/W R/W RRR\nInitial Value 0 0 0 0 0 1 1 0\n\n239\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 5 - UDRIE: USART Data Re gister Empty Interrupt Enable\nWriting this bit to one enables interrupt on the UDREn Flag. A Data Register  Empty interrupt will\nbe generated only if  the UDRIE bit is written to one, the Glob al Interrupt Flag in SREG is written\nto one and the UDREn bit in UCSRnA is set.\n\u0081 Bit 4 - RXENn: Receiver Enable\nWriting this bit to one enables the USART Rece iver in MSPIM mode. The Receiver will override\nnormal port oper ation for the RxDn pin when enabled . Disabling the Receiver will flush the\nreceive buffer. Only enabling the receiver in MSPI mode (that is, setting RXENn=1 and\nTXENn=0) has no meaning since it is the transmit ter that controls the transfer clock and since\nonly master mode is supported.\n\u0081 Bit 3 - TXENn: Transmitter Enable\nWriting this bit to on e enables the USART Transmitter. Th e Transmitter will override normal port\noperation for the TxDn pin when enabled. The di sabling of the Transmitter (writing TXENn to\nzero) will not become effective until ongoing and pending transmissions are completed, that is,\nwhen the Transmit Shift Register and Transmit Buffer Register do not contain data to be trans-mitted. When disabled, the Transmitter will no  longer override the TxDn port.\n\u0081 Bit 2:0 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnB is written.\n23.6.4 UCSRnC \u2013 USART MSPIM Control and Status Register n C\n\u0081 Bit 7:6 - UMSELn1:0: USART Mode Select\nThese bits select the mode of operation of the USART as shown in Table 23-3 . See \u201cUCSRnC \u2013\nUSART Control and Status Register n C\u201d on page 225  for full description of the normal USART\noperation. The MSPIM is enabled when both UMSELn bits are set to one. The UDORDn,UCPHAn, and UCPOLn can be set in the same write operation where the MSPIM is enabled.\n\u0081 Bit 5:3 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnC is written.B i t 7 6 543 2 1 0\nUMSELn1 UMSELn0 - - - UDORDn UCPHAn UCPOLn UCSRnC\nRead/Write R/ W R/W RRR R / W R/W R/W\nInitial Value 0 0 0 0 0 1 1 0\nTable 23-3. UMSELn Bits Settings\nUMSELn1  UMSELn0 Mode\n0  0 Asynchronous USART\n0 1  Synchronous USART\n1 0 (Reserved)1 1 Master SPI (MSPIM)\n\n240\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 - UDORDn: Data Order\nWhen set to one the LSB of the data word is transmitted first. When set to zero the MSB of the\ndata word is transmitted first. Refer to \u201cSPI Data Modes and Timing\u201d on page 233  for details.\n\u0081 Bit 1 - UCPHAn: Clock Phase\nThe UCPHAn bit setting determine if data is sampled on the leasing edge (first) or tailing (last)\nedge of XCKn. Refer to \u201cSPI Data Modes and Timing\u201d on page 233  for details.\n\u0081 Bit 0 - UCPOLn: Clock Polarity\nThe UCPOLn bit sets the polarity of the XC Kn clock. The combination of the UCPOLn and\nUCPHAn bit settings determine the timing of the data transfer. Refer to \u201cSPI Data Modes and\nTiming\u201d on page 233  for details.\n23.6.5 UBRRnL and UBRRnH \u2013 USART MSPIM Baud Rate Registers\nThe function and bit description of the baud rate registers in MSPI mode is identical to normal\nUSART operation. See \u201cUBRRnL and UBRRnH \u2013 USART Baud Rate Registers\u201d on page 227.\nTable 23-4. Comparison of USART in MSPIM mode and SPI pins.\nUSART_MSPIM  SPI  Comment\nTxDn  MOSI  Master Out only\nRxDn  MISO  Master In only\nXCKn  SCK  (Functionally identical)\n(N/A)  SS  Not supported by USART in MSPIM\n\n241\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24. 2-wire Serial Interface\n24.1 Features\n\u0081Simple yet Powerful and Flexible Communication Interface, only two Bus Lines needed\n\u0081Both Master and Sla ve Operation Supported\n\u0081Device can Operate as Transmitter or Receiver\n\u00817-bit Address Space Allows up to 128 Different Slave Addresses\n\u0081Multi-master Arbitration Support\n\u0081Up to 400kHz Data Transfer Speed\n\u0081Slew-rate Limited Output Drivers\n\u0081Noise Suppression  Circuitry Rejects Spikes on Bus Lines\n\u0081Fully Programmable Slave Address with General Call Support\n\u0081Address Recognition Causes Wake-up  When AVR is in Sleep Mode\n24.2 2-wire Serial In terface Bus Definition\nThe 2-wire Serial Interface (T WI) is ideally suited for typica l microcontroller applications. The\nTWI protocol allows the systems designer to inte rconnect up to 128 different devices using only\ntwo bi-directional bus lines, one for clock (SCL) and one for data (SDA). The only external hard-\nware needed to implement the bus is a single pull-up resistor for each of the T WI bus lines. All\ndevices connected to the bus have individual addresses, and mechanisms for resolving bus\ncontention are inherent in the T WI protocol.\nFigure 24-1. TWI Bus Interconnection\n24.2.1 TWI Terminology\nThe following definitions are frequently encountered in this section.Device 1 Device 2 Device 3 Device n\nSDA\nSCL........ R1 R2VCC\nTable 24-1. TWI Terminology\nTerm Description\nMasterThe device that initiates and terminates a transmission. The Master also generates the \nSCL clock\nSlave The device addressed by a Master\nTransmitter The device placing data on the bus\nReceiver The device reading data from the bus\n\n242\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Power Reduction T WI bit, PRT WI bit in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be written to zero to enable the 2-wire Serial Interface.\n24.2.2 Electrical Interconnection\nAs depicted in Figure 24-1 on page 241 , both bus lines are connected to the positive supply volt-\nage through pull-up resistors. The bus drivers of all T WI-compliant devices are open-drain or\nopen-collector. This implements a wired-AND function which is essential to the operation of theinterface. A low level on a T WI bus line is generated when one or more T WI devices output a\nzero. A high level is output when all T WI devices trim-state their outputs, allowing the pull-up\nresistors to pull the line high. Note that all AVR devices connected to the T WI bus must be pow-\nered in order to allow any bus operation.\nThe number of devices that can be connected to the bus is only limited by the bus capacitance\nlimit of 400pF and the 7-bit slave address space. A detailed specification of the electrical charac-\nteristics of the T WI is given in \u201cSPI Timing Characteristics\u201d on page 375 . Two different sets of\nspecifications are presented ther e, one relevant for bus speeds below 100kHz, and one valid for\nbus speeds up to 400kHz.\n24.3 Data Transfer and Frame Format\n24.3.1 Transferring Bits\nEach data bit transferred on the T WI bus is accompanied by a pulse on the clock line. The level\nof the data line must be stable when the clock line is  high. The only exception to this rule is for\ngenerating start and stop conditions.\nFigure 24-2. Data Validity\n24.3.2 START and STOP Conditions\nThe Master initiates and terminates a data transmi ssion. The transmission is initiated when the\nMaster issues a START condition on the bus, and it is terminated when the Master issues a\nSTOP condition. Between a START and a STOP condition, the bus is considered busy, and noother master should try to seize control of the bus. A special case occurs when a new START\ncondition is issued between a START and STOP condition. This  is referred to as a REPEATED\nSTART condition, and is used when the Master wis hes to initiate a new transfer without relin-\nquishing control of  the bus. After a REPEATED START, the bus is considered busy until the next\nSTOP. This is identical to the START behavior, and therefore START is used to describe both\nSTART and REPEATED START for the remainder of this datasheet, unless otherwise noted. Asdepicted below, START and STOP conditions are signalled by changing the level of the SDA\nline when the SCL line is high.SDA\nSCL\nData Stable Data Stable\nData Change\n\n243\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-3. START, REPEATED START and STOP conditions\n24.3.3 Address Packet Format\nAll address packets transmitted on the T WI bus are 9 bits long, consisting of 7 address bits, one\nREAD/ WRITE control bit and an acknowledge bit. If the READ/ WRITE bit is set, a read opera-\ntion is to be performed, otherwise a write operation should be performed. When a Slave\nrecognizes that it is being a ddressed, it should acknowledge by  pulling SDA low in the ninth SCL\n(ACK) cycle. If the addressed Slave is busy, or  for some other reason can not service the Mas-\nter\u2019s request, the SDA line should be left high in the ACK clock cycle. The Master can then\ntransmit a STOP condition, or a REPEATED START condition to initiate a new transmission. An\naddress packet consisting of a slave address and a READ or a WRITE bit is called SLA+R or\nSLA+W, respectively.\nThe MSB of the address byte is transmitted first. Slave addresses can freely be allocated by the\ndesigner, but the address 0000 000 is reserved for a general call.\nWhen a general call is issued, all slaves should  respond by pulling the SDA line low in the ACK\ncycle. A general call is used when a Master wi shes to transmit the same message to several\nslaves in the system. When the general call address followed by a Write bit is transmitted on the\nbus, all slaves set up to ackn owledge the general call will pull th e SDA line low in the ack cycle.\nThe following data packets will then  be received by all the slaves  that acknowle dged the general\ncall. Note that transmitting the general call add ress followed by a Read bit is meaningless, as\nthis would cause contention if several slaves started transmitting different data.\nAll addresses of the format 1111 xxx should be reserved for future purposes.\nFigure 24-4. Address Packet FormatSDA\nSCL\nSTART STOP REPEATED START STOP START\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\n\n244\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.3.4 Data Packet Format\nAll data packets transmitted on the T WI bus are nine bits long, consisting of one data byte and\nan acknowledge bit. During a data transfer, the Master generates the clock and the START andSTOP conditions, while the Receiver is res ponsible for acknowledging the reception. An\nAcknowledge (ACK) is signalled by the Receiver pulling the SDA line low during the ninth SCL\ncycle. If the Receiver leaves the SD A line high, a NACK is signalled. When the Receiver has\nreceived the last byte, or for some reason cannot receive any more bytes, it should inform the\nTransmitter by sending a NACK after the final byte. The MSB of the data byte is transmitted first. \nFigure 24-5. Data Packet Format\n24.3.5 Combining Address and Data  Packets into a Transmission\nA transmission basically consists of a START condition, a SLA+R/ W, one or more data packets\nand a STOP condition. An empty message, consisting of a START followed by a STOP condi-tion, is illegal. Note that the Wired-ANDing of the SCL line can be used to implement\nhandshaking between the Master and the Slave. The Slave can extend the SCL low period by\npulling the SCL line low. This is useful if the cloc k speed set up by the Master is too fast for the\nSlave, or the Slave needs extra time for proces sing between the data transmissions. The Slave\nextending the SCL low period will not affect t he SCL high period, which is determined by the\nMaster. As a consequence, the Slave can reduce the T WI data transfer speed by prolonging the\nSCL duty cycle.\nFigure 24-6  shows a typical data transmission. Note that several data bytes can be transmitted\nbetween the SLA+R/ W and the STOP condition, depending on the software protocol imple-\nmented by the application software.\nFigure 24-6. Typical Data Transmission12 789Data MSB Data LSB ACK\nAggregate\nSDA\nSDA from\nTransmitter\nSDA from\nReceiver\nSCL from\nMaster\nSLA+R/W Data ByteSTOP , REPEATED\nSTART or Next\nData Byte\n12 789\nData ByteData MSB Data LSB ACK\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\nSLA+R/W STOP\n\n245\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.4 Multi-master Bus Systems, Arbitration and Synchronization\nThe TWI protocol allows bus systems with severa l masters. Special concerns have been taken\nin order to ensure that transmis sions will proceed as normal, even if two or more masters initiate\na transmission at the same time. Two problems arise in multi-master systems:\n\u0081 An algorithm must be implemented allowing only one of the masters to complete the \ntransmission. All other masters should cease tr ansmission when they discover that they \nhave lost the selection process. This selection process is called arbitration. When a \ncontending master discovers that it has lost the arbitration process, it should immediately \nswitch to Slave mode to check whether it is being addressed by the winning master. The fact that multiple masters have started transmission at the same time should not be detectable to the slaves, that is, the data being transferred on the bus must not be corrupted.\n\u0081 Different masters may use different SCL frequencies. A scheme must be devised to \nsynchronize the serial clocks from all masters, in order to let the transmission proceed in a lockstep fashion. This will fac ilitate the arbitration process.\nThe wired-ANDing of the bus lines is used to solv e both these problems. The serial clocks from\nall masters will be wired-ANDed, yielding a co mbined clock with a high period equal to the one\nfrom the Master with the shortest high period. The low period of the combined clock is equal tothe low period of the Master with the longest low period. Note that all masters listen to the SCL\nline, effectively starting to count their SCL high and low time-out periods when the combined\nSCL line goes high or low, respectively.\nFigure 24-7. SCL Synchronization Betw een Multiple Masters\nArbitration is carried out by all masters cont inuously monitoring the SDA line after outputting\ndata. If the value read from the SDA line does not match the value the Master had output, it has\nlost the arbitration. Note that a Master can only lose arbitration when it outputs a high SDA value\nwhile another Master outputs a low value. The losing Master should immediately go to Slave\nmode, checking if it is being addressed by the winning Master. The SDA line should be left high,\nbut losing masters are allowed to generate a clock signal until the end of the current data or\naddress packet. Arbitration will cont inue until only one Master re mains, and this may take many\nbits. If several masters are trying to address th e same Slave, arbitratio n will continue into the\ndata packet.TAlowTAhigh\nSCL from\nMaster A\nSCL from\nMaster B\nSCL Bus\nLine\nTBlowTBhigh\nMasters Start\nCounting Low PeriodMasters Start\nCounting High Period\n\n246\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-8. Arbitration Between Two Masters\nNote that arbitration is not allowed between:\n\u0081 A REPEATED START cond ition and a data bit\n\u0081 A STOP condition and a data bit\u0081 A REPEATED START and a STOP conditionIt is the user software\u2019s responsibility to ensur e that these illegal arbitration conditions never\noccur. This implies that  in multi-master systems, all data transfers must use the same composi-\ntion of SLA+R/ W and data packets. In other words: All transmissions must contain the same\nnumber of data packets, otherwise the result of the arbitration is undefined.\n24.5 Overview of the TWI Module\nThe TWI module is comprised of several submodules, as shown in Figure 24-9 on page 247 . All\nregisters drawn in a thick line are accessible through the AVR data bus.SDA from\nMaster A\nSDA from\nMaster B\nSDA Line\nSynchronized\nSCL LineSTARTMaster A Loses\nArbitration, SDAA   SDA\n\n247\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-9. Overview of the T WI Module\n24.5.1 SCL and SDA Pins\nThese pins interface the AVR T WI with the rest of the MCU system. The output drivers contain a\nslew-rate limiter in order to conform to the T WI specification. The input stages contain a spike\nsuppression unit removing spikes shorter than 50ns. Note that the internal pull-ups in the AVR\npads can be enabled by setting the PORT bits corresponding to the SCL and SDA pins, as\nexplained in the I/O Port section. The internal pull-ups can in some systems eliminate the needfor external ones.\n24.5.2 Bit Rate Generator Unit\nThis unit controls the period of SCL when oper ating in a Master mode. The SCL period is con-\ntrolled by settings in the T WI Bit Rate Register (T WBR) and the Prescaler bits in the T WI Status\nRegister (T WSR). Slave operation does not depend on Bit Rate or Prescaler settings, but the\nCPU clock frequency in the Slave must be at l east 16 times higher than the SCL frequency. Note\nthat slaves may prolong the SCL low period, thereby reducing the average T WI bus clock\nperiod.\nTWI UnitAddress Register\n(TWAR)Address Match Unit\nAddress ComparatorControl Unit\nControl Register\n(TWCR)Status Register\n(TWSR)\nState Machine and\nStatus controlSCL\nSlew-rate\nControlSpike\nFilterSDA\nSlew-rate\nControlSpike\nFilter\nBit Rate Generator\nBit Rate Register\n(TWBR)PrescalerBus Interface Unit\nSTART / STOP\nControl\nArbitration detection AckSpike Suppression\nAddress/Data Shift\nRegister (TWDR)\n\n248\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe SCL frequency is generated according to the following equation:\n\u0081TWBR = Value of the T WI Bit Rate Register\n\u0081TWPS = Value of the prescaler bits in the T WI Status Register\nNote: Pull-up resistor values should be selected according to the SCL frequency and the capacitive bus\nline load. See \u201c2-wire Serial Interface Characteristics\u201d on page 373  for value of pull-up resistor.\n24.5.3 Bus Interface Unit\nThis unit contains the Data and Address Shift Register (T WDR), a START/STOP Controller and\nArbitration detection hardware. The T WDR contains the address or data bytes to be transmitted,\nor the address or data bytes received. In addition to the 8-bit T WDR, the Bus Interface Unit also\ncontains a register containing the (N)ACK bit to be transmitted or receiv ed. This (N)ACK Regis-\nter is not directly accessible by the application software. However, when re ceiving, it can be set\nor cleared by manipulating the T WI Control Register (T WCR). When in Transmitter mode, the\nvalue of the received (N)ACK bit can be determined by the value in the T WSR.\nThe START/STOP Controller is responsible for gene ration and detection of START, REPEATED\nSTART, and STOP conditions. The START/STOP controller is able to detect START and STOP\nconditions even when the AVR MCU is in one of  the sleep modes, enabling the MCU to wake up\nif addressed by a Master.\nIf the T WI has initiated a transmission as Master, the Arbitration Detection hardware continu-\nously monitors the transmission trying to determine if arbitration is in process. If the T WI has lost\nan arbitration, the Control Unit is informed. Correct action can then be taken and appropriatestatus codes generated.\n24.5.4 Address Match Unit\nThe Address Match unit checks if received address bytes match the seven-bit address in the\nTWI Address Register (T WAR). If the T WI General Call Recognition Enable (T WGCE) bit in the\nTWAR is written to one, all incoming address bi ts will also be compared against the General Call\naddress. Upon an address match, the Control Unit is informed, allowing correct action to betaken. The T WI may or may not acknowledge its address, depending on settings in the T WCR.\nThe Address Match unit is able to compare addresses even when the AVR MCU is in sleep\nmode, enabling the MCU to wake up if addressed by a Master. If another interrupt (for example,INT0) occurs during T WI Power-down address match and wakes up the CPU, the T WI aborts\noperation and return to it\u2019s idle state. If this cause any problems, ensure that T WI Address Match\nis the only enabled interrupt when entering Power-down.\n24.5.5 Control Unit\nThe Control unit monitors the T WI bus and generates responses corresponding to settings in the\nTWI Control Register (T WCR). When an event requiring the attention of the application occurs\non the T WI bus, the T WI Interrupt Flag (T WINT) is asserted. In the next clock cycle, the T WI Sta-\ntus Register (T WSR) is updated with a status code identifying the event. The T WSR only\ncontains relevant status information when the T WI Interrupt Flag is asserted. At all other times,\nthe TW\nSR contains a special status code indicating t hat no relevant status information is avail-\nable. As long as the T WINT Flag is set, the SCL line is held  low. This allows the application\nsoftware to complete its tasks before allowing the T WI transmission to continue.SCL frequencyCPU Clock frequency\n16 2(T WBR) 4TWPS\u22c5 +-----------------------------------------------------------=\n\n249\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe TWINT Flag is set in th e following situations:\n\u0081 After the T WI has transmitted a START/REPEATED START condition\n\u0081 After the T WI has transmitted SLA+R/ W\n\u0081 After the T WI has transmitted an address byte\n\u0081 After the T WI has lost arbitration\n\u0081 After the T WI has been addressed by own slave address or general call\n\u0081 After the T WI has received a data byte\n\u0081 After a STOP or REPEATED START has been received while still add ressed as a Slave\n\u0081When a bus error has occurr ed due to an illegal START or STOP condition\n24.6 Using the TWI\nThe AVR T WI is byte-oriented and interrupt based. Interrupts are issued after all bus events, like\nreception of a byte or transmission of a START condition. Because the T WI is interrupt-based,\nthe application software is free to carry on other operations during a T WI byte transfer. Note that\nthe TWI Interrupt Enable (T WIE) bit in T WCR together with the Global Interrupt Enable bit in\nSREG allow the application to decide whether or not assertion of the T WINT Flag should gener-\nate an interrupt request. If the T WIE bit is cleared, the application must poll the T WINT Flag in\norder to detect actions on the T WI bus.\nWhen the T WINT Flag is asserted, the T WI has finished an operation and awaits application\nresponse. In this case, the T WI Status Register (T WSR) contains a value indicating the current\nstate of the T WI bus. The application software can then decide how the T WI should behave in\nthe next T WI bus cycle by manipulating the T WCR and T WDR Registers.\nFigure 24-10  is a simple example of how the application can interface to the T WI hardware. In\nthis example, a Master wishes to transmit a single data byte to a Slave. This description is quite\nabstract, a more detailed explanation follows later in this section. A simple code example imple-\nmenting the desired behavior is also presented.\nFigure 24-10. Interfacing the Application to the T WI in a Typical Transmission\nSTART SLA+W A Data A STOP1. Application\nwrites to TWCR to\ninitiate\ntransmission of\nSTART\n2. TWINT set.\nStatus code indicates\nSTART condition sent4. TWINT set.\nStatus code indicates\nSLA+W sent, ACK\nreceived6. TWINT set.\nStatus code indicates\ndata sent, ACK received3. Check TWSR to see if START was \nsent. Application loads SLA+W into \nTWDR, and loads appropriate control \nsignals into TWCR, makin sure that \nTWINT is written to one, \nand TWSTA is written to zero.5. Check TWSR to see if SLA+W was\nsent and ACK received.\nApplication loads data into TWDR, and\nloads appropriate control signals into\nTWCR, making sure that TWINT is\nwritten to one7. Check TWSR to see if data was sent\nand ACK received.\nApplication loads appropriate control\nsignals to send STOP into TWCR,\nmaking sure that TWINT is written to one\nTWI bus\nIndicates\nTWINT setApplication\nAction TWI\nHardware\nAction\n\n250\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1. The first step in a T WI transmission is to transmit a START condition. This is done by \nwriting a specific value into T WCR, instructing the T WI hardware to transmit a START \ncondition. Which value to write is described later on. However, it is important that the \nTWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI will \nnot start any operation as long as the T WINT bit in T WCR is set. Immediately after the \napplication has cleared T WINT, the T WI will initiate transmission of the START condition.\n2.When the START condition has been transmitted, the T WINT Flag in T WCR is set, and \nTWSR is updated with a status code indicating that the START condition has success-\nfully been sent.\n3. The application software should now examine the value of T WSR, to make sure that the \nSTART condition was successfully transmitted. If T WSR indicates otherwise, the applica-\ntion software might take some special action,  like calling an error routine. Assuming that \nthe status code is as expected, the application must load SLA+ W into TWDR. Remember \nthat TWDR is used both for address and data. After T WDR has been loaded with the \ndesired SLA+ W, a specific value must be written to T WCR, instructing the T WI hardware \nto transmit the SLA+ W present in T WDR. Which value to write is described later on. \nHowever, it is important that the T WINT bit is set in the value written. Writing a one to \nTWINT clears the flag. The T WI will not start any operation as long as the T WINT bit in \nTWCR is set. Immediately after the application has cleared T WINT, the T WI will initiate \ntransmission of the address packet.\n4.When the address packet has been transmitted, the T WINT Flag in T WCR is set, and \nTWSR is updated with a status code indicating that the address packet has successfully \nbeen sent. The status code will also reflect whether a Slave acknowledged the packet or not.\n5. The application software should now examine the value of T WSR, to make sure that the \naddress packet was successfully transmitted, and that the value of the ACK bit was as expected. If T WSR indicates otherwise, the application software might take some special \naction, like calling an error routine. Assuming that the status code is as expected, the \napplication must load a data packet into T WDR. Subsequently, a specific value must be \nwritten to T WCR, instructing the T WI hardware to transmit the data packet present in \nTWDR. Which value to write is described later on. However, it is important that the \nTWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI will \nnot start any operation as long as the T WINT bit in T WCR is set. Immediately after the \napplication has cleared T WINT, the T WI will initiate transmissi on of the data packet.\n6.When the data packet has been transmitted, the T WINT Flag in T WCR is set, and T WSR \nis updated with a status code indicating that the data packet has successfully been sent. The status code will also re flect whether a Slave ackno wledged the packet or not.\n7. The application software should now examine the value of T WSR, to make sure that the \ndata packet was successfully transmitted, and that the value of the ACK bit was as expected. If T WSR indicates otherwise, the application software might take some special \naction, like calling an error routine. Assuming that the status code is as expected, the \napplication must write a specific value to T WCR, instructing the T WI hardware to transmit \na STOP condition. Which value to write is described late r on. However, it is important that \nthe TWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI \nwill not start any operation as long as the T WINT bit in T WCR is set. Immediately after \nthe application has cleared T WINT, the T WI will initiate transmission of the STOP condi-\ntion. Note that T WINT is NOT set after a STOP condition has been sent.\n\n251\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nEven though this example is simple, it shows the principles involved in all T WI transmissions.\nThese can be summarized as follows:\n\u0081When the T WI has finished an operation and expects application response, the T WINT Flag \nis set. The SCL line is pulled low until T WINT is cleared.\n\u0081When the T WINT Flag is set, the user must update all T WI Registers with the value relevant \nfor the next T WI bus cycle. As an example, T WDR must be loaded with the value to be \ntransmitted in the next bus cycle.\n\u0081 After all T WI Register updates and other pending application software tasks have been \ncompleted, T WCR is written. When writing T WCR, the T WINT bit should be set. Writing a \none to T WINT clears the flag. The T WI will then commence executin g whatever operation \nwas specified by the T WCR setting.\nIn the following an assembly and C implementation  of the example is given. Note that the code\nbelow assumes that several definitions have been made, for example by using include-files.\nAssembly Code Example C Example Comments\n1ldir16, (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN)\noutTWCR, r16TWCR = (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN) Send START condition\n2wait1:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait1while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the START condition \nhas been transmitted\n3inr16,TWSR\nandir16, 0xF8\ncpir16, START\nbrneERRORif ((TWSR & 0xF8) != START)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from START go to \nERROR\nldir16, SLA_W\noutTWDR, r16 \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = SLA_W;\nTWCR = (1<<TWINT) | (1<<TWEN);Load SLA_ W into T WDR Register. \nClear T WINT bit in T WCR to start \ntransmission of address\n4wait2:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait2while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the SLA+ W has been \ntransmitted, and ACK/NACK has \nbeen received.\n5inr16,TWSR\nandir16, 0xF8\ncpir16, MT_SLA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_SLA_ACK)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from MT_SLA_ACK \ngo to ERROR\nldir16, DATA\noutTWDR, r16       \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = DATA;\nTWCR = (1<<TWINT) | (1<<TWEN);Load DATA into T WDR Register. \nClear T WINT bit in T WCR to start \ntransmission of data\n\n252\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.7 Transmission Modes\nThe TWI can operate in one of four major modes. These are named Master Transmitter (MT),\nMaster Receiver (MR), Slave Transmitter (ST)  and Slave Receiver (SR). Several of these\nmodes can be used in the same application. As an example, the T WI can use MT mode to write\ndata into a T WI EEPROM, MR mode to read  the data back from the EEPROM. If other masters\nare present in the system, some of these might transmit data to the T WI, and then SR mode\nwould be used. It is the application softw are that decides which modes are legal.\nThe following sections describe each of these modes. Possible status codes are described\nalong with figures detailing data transmission in  each of the modes. These figures contain the\nfollowing abbreviations:\nS: START condition\nRs: REPEATED START condition\nR: Read bit (high level at SDA)\nW: Write bit (low level at SDA)\nA: Acknowledge bit (low level at SDA)\nA:Not acknowledge bit (high level at SDA)\nData: 8-bit data byte\nP: STOP condition\nSLA: Slave Address\nIn Figure 24-12 on page 255  to Figure 24-18 on page 264 , circles are used to indicate that the\nTWINT Flag is set. The numbers in the circles show the status code held in T WSR, with the\nprescaler bits masked to zero. At these points, ac tions must be taken by the application to con-\ntinue or complete the T WI transfer. The T WI transfer is suspended until the T WINT Flag is\ncleared by software.\nWhen the T WINT Flag is set, the status code in T WSR is used to determine the appropriate soft-\nware action. For each status code, the required software action and details of the following serial\ntransfer are given in Table 24-2 on page 254  to Table 24-5 on page 263 . Note that the prescaler\nbits are masked to zero in these tables.6wait3:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait3while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the DATA has been \ntransmitted, and ACK/NACK has \nbeen received.\n7inr16,TWSR\nandir16, 0xF8\ncpir16, MT_DATA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_DATA_ACK)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from \nMT_DATA_ACK go to ERROR\nldir16, (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO)\noutTWCR, r16 TWCR = (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO); Transmit STOP conditionAssembly Code Example C Example Comments\n\n253\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.7.1 Master Transmitter Mode\nIn the Master Transmitter mode, a number of data bytes are transmitted to a Slave Receiver\n(see Figure 24-11 ). In order to enter a Master mode, a START condition must be transmitted.\nThe format of the following address packet determines whether Master Transmitter or Master\nReceiver mode is to be entered. If SLA+ W is transmitted, MT mode is entered, if SLA+R is trans-\nmitted, MR mode is entered. All the status codes mentioned in this section assume that theprescaler bits are zero or are masked to zero.\nFigure 24-11. Data Transfer in Master Transmitter Mode\nA START condition is sent by writing the following value to T WCR:\nTWEN must be set to enable the 2-wire Serial Interface, T WSTA must be written to one to trans-\nmit a START condition and T WINT must be written to one to clear the T WINT Flag. The T WI will\nthen test the 2-wire Serial Bus and generate a START condition as soon as the bus becomes\nfree. After a START condition has been transmitted, the T WINT Flag is set by hardware, and the\nstatus code in T WSR will be 0x08 (see Table 24-2 on page 254 ). In order to enter MT mode,\nSLA+W must be transmitted. This  is done by writing SLA+ W to TWDR. Thereafter the T WINT bit\nshould be cleared (by writing it to one) to continue the transfer. This is accomplished by writing\nthe following value to T WCR:\nWhen SLA+ W have been transmitted and an acknowledgement bit has been received, T WINT is\nset again and a number of status codes in T WSR are possible. Possible status codes in Master\nmode are 0x18, 0x20, or 0x38. The appropriate action to be taken for each of these status codesis detailed in Table 24-2 on page 254 .\nWhen SLA+ W has been successfully transmitted, a data packet should be transmitted. This is\ndone by writing the data byte to T WDR. TWDR must only be written when T WINT is high. If not,\nthe access will be discarded, and the Write Collision bit (T WWC) will be set in the T WCR Regis-\nter. After updating T WDR, the T WINT bit should be cleared (by writing it to one) to continue the\ntransfer. This is acco mplished by writing the following value to T WCR:TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 XDevice 1\nMASTER\nTRANSMITTERDevice 2\nSLAVE\nRECEIVERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n254\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThis scheme is repeated until the last byte has been sent and the transfer is ended by generat-\ning a STOP condition or a repeated START condition. A STOP condition is generated by writing\nthe following value to T WCR:\nA REPEATED START condition is generated by writing the following value to T WCR:\nAfter a repeated START condition (state 0x10) th e 2-wire Serial Interface can access the same\nSlave again, or a new Slave without transmitting a STOP condition. Repeated START enables\nthe Master to switch between Slaves, Master Transmitter mode and Master Receiver mode with-out losing control of the bus.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTable 24-2. Status codes for Master Transmitter Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDR To TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+W 0 0 1 X SLA+W will be transmitted;\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+W or \nLoad SLA+R0\n00\n01\n1X\nXSLA+W will be transmitted;\nACK or NOT ACK will be receivedSLA+R will be transmitted;\nLogic will switch to Master Receiver mode\n0x18 SLA+W has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmitted\nSTOP condition will be transmitted andTWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x20 SLA+W has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x28 Data byte has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmitted\nSTOP condition will be transmitted andTWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x30 Data byte has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x38 Arbitration lost in SLA+W or data\nbytesNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nX2-wire Serial Bus will be released and not addressed \nSlave mode enteredA START condition will be transmitted when the bus be-\ncomes free\n\n255\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-12. Formats and States in the Master Transmitter Mode \n24.7.2 Master Receiver Mode\nIn the Master Receiver mode, a number of data bytes are received from a Slave Transmitter\n(see Figure 24-13 on page 256 ). In order to enter a Master mode, a START condition must be\ntransmitted. The format of the following address packet determines whether Master Transmitter\nor Master Receiver mode is to be entered. If SLA+ W is transmitted, MT mode is entered, if\nSLA+R is transmitted, MR mode is entered. All the status codes mentioned in this section\nassume that the prescaler bits are zero or are masked to zero.S SLA W A DATA A P\n$08 $18 $28\nR SLA W\n$10\nAP\n$20\nP\n$30\nA or A\n$38A\nOther master\ncontinues A or A\n$38Other master\ncontinuesR\nA\n$68Other master\ncontinues\n$78 $B0To corresponding\nstates in slave modeMT\nMRSuccessfull\ntransmissionto a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nNot acknowledge\nreceived after a databyte\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. Theprescaler bits are zero or masked to zeroS\n\n256\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-13. Data Transfer in Ma ster Receiver Mode\nA START condition is sent by writing the following value to T WCR:\nTWEN must be written to one to enable the 2-wire Serial Interface, T WSTA must be written to\none to transmit a START condition and T WINT must be set to clear the T WINT Flag. The T WI\nwill then test the 2-wire Serial Bus and generate a START condition as soon as the busbecomes free. After a START condition has been transmitted, the T WINT Flag is set by hard-\nware, and the status code in T WSR will be 0x08 (see Table 24-2 on page 254 ). In order to enter\nMR mode, SLA+R must be transmitted. This is done by writing SLA+R to T WDR. Thereafter the\nTWINT bit should be cleared (by writing it to one) to continue the transfer. This is accomplished\nby writing the following value to T WCR:\nWhen SLA+R have been transmitted and an acknowledgement bit has been received, T WINT is\nset again and a number of status codes in T WSR are possible. Possible status codes in Master\nmode are 0x38, 0x40, or 0x48. The appropriate action to be taken for each of these status codes\nis detailed in Table 24-3 on page 257 . Received data can be read from the T WDR Register\nwhen the T WINT Flag is set high by hardware. This scheme is repeated until the last byte has\nbeen received. After the last byte has been received, the MR should inform the ST by sending a\nNACK after the last received data byte. The transfer is ended by generating a STOP condition ora repeated START condition. A STOP condition is generated by writing the following value toTWCR:\nA REPEATED START condition is generated by writing the following value to T WCR:\nAfter a repeated START condition (state 0x10) th e 2-wire Serial Interface can access the same\nSlave again, or a new Slave without transmitting a STOP condition. Repeated START enables\nthe Master to switch between Slaves, Master Transmitter mode and Master Receiver mode with-\nout losing control over the bus.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 XDevice 1\nMASTER\nRECEIVERDevice 2\nSLAVE\nTRANSMITTERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n257\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-3. Status codes for Master Receiver Mode\nStatus Code\n(TWSR)\nPrescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+R 0 0 1 X SLA+R will be transmitted\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+R or \nLoad SLA+W0\n00\n01\n1X\nXSLA+R will be transmitted\nACK or NOT ACK will be received\nSLA+W will be transmitted\nLogic will switch to Master Transmitter mode\n0x38 Arbitration lost in SLA+R or NOT\nACK bitNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nX2-wire Serial Bus will be released and not addressed \nSlave mode will be entered\nA START condition will be transmitted when the busbecomes free\n0x40 SLA+R has been transmitted;\nACK has been receivedNo TWDR action or\nNo TWDR action0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x48 SLA+R has been transmitted;\nNOT ACK has been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will \nbe reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x50 Data byte has been received;\nACK has been returnedRead data byte or\nRead data byte0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x58 Data byte has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n\n258\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-14. Formats and States in the Master Receiver Mode\n24.7.3 Slave Receiver Mode\nIn the Slave Receiver mode, a number of data bytes are received from a Master Transmitter\n(see Figure 24-15 ). All the status codes mentioned in this section assume that the prescaler bits\nare zero or are masked to zero.\nFigure 24-15. Data transfer in Slave Receiver mode\nTo initiate the Slave Receiver mode, T WAR and T WCR must be initialized as follows:S SLA R A DATA A\n$08 $40 $50\nSLA R\n$10\nAP\n$48\nA or A\n$38Other master\ncontinues\n$38Other master\ncontinuesW\nA\n$68Other master\ncontinues\n$78 $B0To corresponding\nstates in slave modeMR\nMTSuccessfull\nreceptionfrom a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP DATA A\n$58\nARS\nTWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave AddressDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nTRANSMITTERDevice 1\nSLAVE\nRECEIVER\n\n259\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe upper seven bits are the address to which the 2-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the T WI will respond to the general call address (0x00),\notherwise it will ignore the general call address.\nTWEN must be written to one to enable the T WI. The T WEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. T WSTA\nand TWSTO must be written to zero.\nWhen TWAR and T WCR have been initialized, the T WI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If the\ndirection bit is \u201c0\u201d (write), the T WI will operate in SR mode, otherw ise ST mode is entered. After\nits own slave address and the write bit have been received, the T WINT Flag is set and a valid\nstatus code can be read from T WSR. The status code is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 24-4 on\npage 260 . The Slave Receiver mode may also be en tered if arbitration is lost while the T WI is in\nthe Master mode (see states 0x68 and 0x78).\nIf the T WEA bit is reset during a transfer, the T WI will return a \u201cNot Acknowledge\u201d (\u201c1\u201d) to SDA\nafter the next received data byte. This can be used to indicate that the Slave is not able toreceive any more bytes. While TWEA is zero, the T WI does not acknowledge its own slave\naddress. However, the 2-wire Se rial Bus is still monitored and address recognit ion may resume\nat any time by setting T WEA. This implies that the T WEA bit may be used to temporarily isolate\nthe TWI from the 2-wire Serial Bus.\nIn all sleep modes other than Idle  mode, the clock system to the T WI is turned off. If the T WEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the 2-wire Serial Bus clock as a clock sour ce. The part will then wake up from sleep and\nthe TWI will hold the SCL clock low duri ng the wake up and until the T WINT Flag is cleared (by\nwriting it to one). Further data reception will be carried out as normal, with the AVR clocks run-ning as normal. Observe that if the AVR is set up with a long start-up time, the SCL line may be\nheld low for a long time, blocking other data transmissions.\nNote that the 2-wire Serial Interface Data Register \u2013 T WDR does not reflect the last byte present\non the bus when waking up from these Sleep modes.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 X\n\n260\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-4. Status Codes for Slave Receiver Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus and\n2-wire Serial Interface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x60 Own SLA+W has been received;\nACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x68 Arbitration lost in SLA+R/W as\nMaster; own SLA+W has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x70 General call address has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x78 Arbitration lost in SLA+R/W as\nMaster; General call address has\nbeen received; ACK has been \nreturnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x80 Previously addressed with own\nSLA+W; data has been received;\nACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x88 Previously addressed with own\nSLA+W; data has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;no recognition of own SLA or GCA;\na START condition will be transmitted when the bus \nbecomes freeSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0x90 Previously addressed with \ngeneral call; data has been re-\nceived; ACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x98 Previously addressed with \ngeneral call; data has been \nreceived; NOT ACK has been \nreturnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0xA0 A STOP condition or repeated\nSTART condition has been \nreceived while still addressed as\nSlaveNo action 0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus \nbecomes free\n\n261\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-16. Formats and States in the Slave Receiver Mode\n24.7.4 Slave Transmitter Mode\nIn the Slave Transmitter mode, a number of data bytes are transmitted to a Master Receiver\n(see Figure 24-17 ). All the status codes mentioned in this section assume that the prescaler bits\nare zero or are masked to zero.\nFigure 24-17. Data Transfer in Slave Transmitter ModeS SLA W A DATA A\n$60 $80\n$88\nA\n$68Reception of the own\nslave address and one ormore data bytes.  All areacknowledged\nLast data byte received\nis not acknowledged\nArbitration lost as master\nand addressed as slave\nReception of the general call\naddress and one or more databytes\nLast data byte received is\nnot acknowledged\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA A\n$80 $A0\nP or S A\nA DATA A\n$70 $90\n$98\nA\n$78P or S DATA A\n$90 $A0\nP or S AGeneral Call\nArbitration lost as master and\naddressed as slave by general call\nDATA A\nDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nRECEIVERDevice 1\nSLAVE\nTRANSMITTER\n\n262\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTo initiate the Slave Transmitter mode, T WAR and T WCR must be initialized as follows:\nThe upper seven bits are the address to which the 2-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the T WI will respond to the general call address (0x00),\notherwise it will ignore the general call address.\nTWEN must be written to one to enable the T WI. The T WEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. T WSTA\nand TWSTO must be written to zero.\nWhen TWAR and T WCR have been initialized, the T WI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If the\ndirection bit is \u201c1\u201d (read), the T WI will operate in ST mode, otherw ise SR mode is entered. After\nits own slave address and the write bit have been received, the T WINT Flag is set and a valid\nstatus code can be read from T WSR. The status code is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 24-5 on\npage 263 . The Slave Transmitter mode may also be entered if arbitration is lost while the T WI is\nin the Master mode (see state 0xB0).\nIf the T WEA bit is written to zero during a transfer, the T WI will transmit the last  byte of the trans-\nfer. State 0xC0 or state 0xC8 will be entere d, depending on whether the Master Receiver\ntransmits a NACK or ACK after the final byte. The T WI is switched to the not addressed Slave\nmode, and will ignore the Mast er if it continues th e transfer. Thus the Ma ster Receiver receives\nall \u201c1\u201d as serial data. State 0xC8 is entered if the Master demands additional data bytes (by\ntransmitting ACK), even though the Slave has transmitted the last byte (T WEA zero and expect-\ning NACK from the Master).\nWhile TWEA is zero, the T WI does not respond to its own slave address. However, the 2-wire\nSerial Bus is still monitored an d address recognition may resume  at any time by setting T WEA.\nThis implies that the T WEA bit may be used to temporarily isolate the T WI from the 2-wire Serial\nBus.\nIn all sleep modes other than Idle  mode, the clock system to the T WI is turned off. If the T WEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the 2-wire Serial Bus clock as a clock sour ce. The part will then wake up from sleep and\nthe TWI will hold the SCL clock will low duri ng the wake up and until the T WINT Flag is cleared\n(by writing it to one). Further data tr ansmission will be carried out as normal, with the AVR clocks\nrunning as normal. Observe that if the AVR is set up with a long start-up time, the SCL line maybe held low for a long time, blocking other data transmissions.\nNote that the 2-wire Serial Interface Data Register \u2013 T WDR does not reflect the last byte present\non the bus when waking up from these sleep modes.TWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave Address\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 X\n\n263\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-5. Status Codes for Slave Transmitter Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus and\n2-wire Serial Interface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xA8 Own SLA+R has been received;\nACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-\nceived\n0xB0 Arbitration lost in SLA+R/W as\nMaster; own SLA+R has been \nreceived; ACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-ceived\n0xB8 Data byte in TWDR has been \ntransmitted; ACK has been receivedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe receivedData byte will be transmitted and ACK should be re-\nceived\n0xC0 Data byte in TWDR has been \ntransmitted; NOT ACK has been \nreceivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus becomes free\n0xC8 Last data byte in TWDR has been\ntransmitted (TWEA = \u201c0\u201d); ACKhas been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCASwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201dSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;\na START condition will be transmitted when the bus becomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus \nbecomes free\n\n264\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-18. Formats and States in the Slave Transmitter Mode\n24.7.5 Miscellaneous States\nThere are two status codes that do not correspond to a defined T WI state, see Table 24-6 .\nStatus 0xF8 indicates that no relevant  information is available because the T WINT Flag is not\nset. This occurs between other states, and when the T WI is not involved in a serial transfer.\nStatus 0x00 indicates that a bus error has occu rred during a 2-wire Serial Bus transfer. A bus\nerror occurs when a START or STOP condition occurs at an illegal position in the format frame.\nExamples of such illegal positions are during the serial transfer of an address byte, a data byte,\nor an acknowledge bit. When a bus error occurs, T WINT is set. To recover from a bus error, the\nTWSTO Flag must set and T WINT must be cleared by writing a logic one to it. This causes the\nTWI to enter the not addressed Slave mode and to clear the T WSTO Flag (no other bits in\nTWCR are affected). The SDA and SCL lines are released, and no STOP condition is\ntransmitted.\n24.7.6 Combining Several TWI Modes\nIn some cases, several T WI modes must be combined in order to complete the desired action.\nConsider for example reading data from a serial  EEPROM. Typically, such a transfer involves\nthe following steps:\n1. The transfer must be initiated.\n2. The EEPROM must be instructed what location should be read.\n3. The reading must be performed.4. The transfer must be finished.S SLA R A DATA A\n$A8 $B8\nA\n$B0Reception of the own\nslave address and one ormore data bytes\nLast data byte transmitted.\nSwitched to not addressedslave (TWEA = '0')Arbitration lost as master\nand addressed as slave\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA\n$C0\nDATA AA\n$C8P or S All 1'sA\nTable 24-6. Miscellaneous States\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xF8 No relevant state information\navailable; TWINT = \u201c0\u201dNo TWDR action No TWCR action Wait or proceed current transfer\n0x00 Bus error due to an illegal\nSTART or STOP conditionNo TWDR action 0 1 1 X Only the internal hardware is affected, no STOP condi-\ntion is sent on the bus. In all cases, the bus is released \nand TWSTO is cleared.\n\n265\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that data is transmitted both from Master to Slave and vice versa. The Master must instruct\nthe Slave what location it wants to read, r equiring the use of the MT mode. Subsequently, data\nmust be read from the Slave, implying the use of  the MR mode. Thus, the transfer direction must\nbe changed. The Master must keep control of the bus during all these steps, and the stepsshould be carried out as an atomical operation. If th is principle is violated in a multimaster sys-\ntem, another Master can alter the data pointer in the EEPROM between steps 2 and 3, and the\nMaster will read the wrong data lo cation. Such a change in transfe r direction is accomplished by\ntransmitting a REPEATED START between the trans mission of the address byte and reception\nof the data. After a REPEATED START, the Master keeps ownership of the bus. The following\nfigure shows the flow in this transfer.\nFigure 24-19. Combining Several T WI Modes to Access a Serial EEPROM\n24.8 Multi-master Syst ems and Arbitration\nIf multiple masters are connected to the same bus, transmissions may be initiated simultane-\nously by one or more of them. The T WI standard ensures that such situations are handled in\nsuch a way that one of the mast ers will be allowed to proceed wit h the transfer, and that no data\nwill be lost in the process. An example of an ar bitration situation is depicted below, where two\nmasters are trying to transmit data to a Slave Receiver.\nFigure 24-20. An Arbitration Example\nSeveral different scenarios may arise during arbitration, as described below:\n\u0081 Two or more masters are performing identical communication with the same Slave. In this \ncase, neither the Slave nor any of the ma sters will know about the bus contention.\n\u0081 Two or more masters are accessing the same Slave with different data or direction bit. In this \ncase, arbitration will occur, either in the READ/ WRITE bit or in the data bits. The masters \ntrying to output a one on SDA while another Master outputs a zero will lose the arbitration. \nLosing masters will switch to no t addressed Slave mode or wa it until the bus is free and \ntransmit a new START condition, depending on application software action.Master Transmitter Master Receiver\nS = START Rs = REPEATED START P = STOP\nTransmitted from master to slave Transmitted from slave to masterS SLA+W A ADDRESS ARs SLA+R A DATA AP\nDevice 1\nMASTER\nTRANSMITTERDevice 2\nMASTER\nTRANSMITTERDevice 3\nSLAVE\nRECEIVERDevice n\nSDA\nSCL........ R1 R2VCC\n\n266\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Two or more masters are accessing different slav es. In this case, arbitration will occur in the \nSLA bits. Masters trying to ou tput a one on SDA while anot her Master outputs a zero will \nlose the arbitration. Masters lo sing arbitration in SLA will switch  to Slave mode to check if \nthey are being addressed by the winning Master. If addressed, they will switch to SR or ST \nmode, depending on the value of the READ/ WRITE bit. If they are not being addressed, they \nwill switch to not addressed Slav e mode or wait until the bu s is free and transmit a new \nSTART condition, depending on application software action.\nThis is summarized in Figure 24-21 . Possible status values are given in circles.\nFigure 24-21. Possible Status Codes Caused by Arbitration\n24.9 Register Description\n24.9.1 TWBR \u2013 TWI Bit Rate Register\n\u0081 Bits 7:0 \u2013 TWI Bit Rate Register\nTWBR selects the division factor for the bit rate generator. The bit rate generator is a frequency\ndivider which generates the SCL clock frequency in the Master modes. See \u201cBit Rate Generator\nUnit\u201d on page 247  for calculating bit rates.\n24.9.2 TWCR \u2013 TWI Control Register\nThe TWCR is used to control the operation of the T WI. It is used to enable the T WI, to initiate a\nMaster access by applying a START condition to the bus, to generate a Receiver acknowledge,to generate a stop condition, and to control halting of the bus while the data to be written to the\nbus are written to the T WDR. It also indicates a write collisio n if data is at tempted written to\nTWDR while the register  is inaccessible.Own\nAddress / General Call\nreceivedArbitration lost in SLA\nTWI bus will be released and not addressed slave mode will be enteredA START condition will be transmitted when the bus becomes free NoArbitration lost in Data\nDirectionYe s\nWrite Data byte will be received and NOT ACK will be returned\nData byte will be received and ACK will be returned\nLast data byte will be transmitted and NOT ACK should be receivedData byte will be transmitted and ACK should be received Read\nB068/7838SLA START Data STOP\nB i t 76543210\n(0xB8) TWBR7 TWBR6 TWBR5 TWBR4 TWBR3 TWBR2 TWBR1 TWBR0 TWBR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xBC) TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE TWCR\nRead/Write R/W R/W R/W R/W R R/W R R/WInitial Value 0 0 0 0 0 0 0 0\n\n267\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7 \u2013 TWINT: TWI Interrupt Flag\nThis bit is set by hardware when the T WI has finished its current job and expects application\nsoftware response. If the I-bit in SREG and T WIE in T WCR are set, the MCU will jump to the\nTWI Interrupt Vector. While the T WINT Flag is set, the SCL low period is stretched. The T WINT\nFlag must be cleared by software by writing a logic one to it. Note that this flag is not automati-\ncally cleared by hardware when executing the interr upt routine. Also note that clearing this flag\nstarts the operation of the T WI, so all accesses to the T WI Address Register (T WAR), T WI Sta-\ntus Register (T WSR), and T WI Data Register (T WDR) must be complete before clearing this\nflag.\n\u0081 Bit 6 \u2013 TWEA: TWI Enable Acknowledge Bit\nThe TWEA bit controls the generation of the acknowledge pulse. If the T WEA bit is written to\none, the ACK pulse is generated on the T WI bus if the following  conditions are met:\n1. The device\u2019s own slave address has been received.\n2. A general call has been received, while the T WGCE bit in the T WAR is set.\n3. A data byte has been received in Master Receiver or Slave Receiver mode.By writing the T WEA bit to zero, the device can be virtually disconnected from the 2-wire Serial\nBus temporarily. Address recognition can then be resumed by writing the T WEA bit to one\nagain.\n\u0081 Bit 5 \u2013 TWSTA: TWI START Condition Bit\nThe application writes the T WSTA bit to one when it desires to become a Master on the 2-wire\nSerial Bus. The T WI hardware checks if the bus is available, and generates a START condition\non the bus if it is free. However, if the bus is not free, the T WI waits until a STOP condition is\ndetected, and then generates a new START condition to claim the bus Master status. T WSTA\nmust be cleared by software when the START condition has been transmitted.\n\u0081 Bit 4 \u2013 TWSTO: TWI STOP Condition Bit\nWriting the T WSTO bit to one in Master mode will g enerate a STOP cond ition on the 2-wire\nSerial Bus. When the STOP condition is executed on the bus, the T WSTO bit is cleared auto-\nmatically. In Slave mode, setting the T WSTO bit can be used to recover from an error condition.\nThis will not generate a STOP  condition, but the T WI returns to a well-defined unaddressed\nSlave mode and releases the SCL and SDA lines to a high impedance state.\n\u0081 Bit 3 \u2013 TWWC: TWI Write Collision Flag\nThe TWW\nC bit is set when attempting to write to the T WI Data Register \u2013 T WDR when T WINT is\nlow. This flag is cl eared by writing the T WDR Register when T WINT is high.\n\u0081 Bit 2 \u2013 TWEN: TWI Enable Bit\nThe TWEN bit enables T WI operation and activates the T WI interface. When TWEN is written to\none, the T WI takes control over the I/O pins connected to the SCL and SDA pins, enabling the\nslew-rate limiters and spike filters. If  this bit is written to zero, the T WI is switched off and all T WI\ntransmissions are terminated, regardless of any ongoing operation.\n\u0081 Bit 1 \u2013 Res: Reserved Bit\nThis bit is a reserved bit an d will always read as zero.\n\n268\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TWIE: TWI Interrupt Enable\nWhen this bit is written to one, and the I-bit in SREG is set, the T WI interrupt request will be acti-\nvated for as long as the T WINT Flag is high.\n24.9.3 TWSR \u2013 TWI Status Register\n\u0081 Bits 7:3 \u2013 TWS: TWI Status\nThese five bits reflect the status of the T WI logic and the 2-wire Serial Bus. The different status\ncodes are described later in this section. Note that the value read from T WSR contains both the\n5-bit status value and the 2-bit prescaler value. The application designer should mask the pres-\ncaler bits to zero when checking the Status bits. This makes status checking independent ofprescaler setting. This approach is used in this datasheet, unless otherwise noted.\n\u0081 Bit 2 \u2013 Res: Reserved Bit\nThis bit is reserved and will always read as zero.\n\u0081 Bits 1:0 \u2013 TWPS: TWI Prescaler Bits\nThese bits can be read and written, and control the bit rate prescaler.\nTo calculate bit rates, see \u201cBit Rate Generator Unit\u201d on page 247 . The value of T WPS1:0 is used\nin the equation.\n24.9.4 TWDR \u2013 TWI Data Register\nIn Transmit mode, T WDR contains the next byte to be transmitted. In Receive mode, the T WDR\ncontains the last byte receiv ed. It is writable while the T WI is not in the process of shifting a byte.\nThis occurs when the T WI Interrupt Flag (T WINT) is set by hardware. Note that the Data Regis-\nter cannot be initialized by the user before the first interrupt occurs. The data in T WDR remains\nstable as long as T WINT is set. While data is shifted out, data on the bus is simultaneously\nshifted in. T WDR always contains the last byte present on the bus, except after a wake up from\na sleep mode by the T WI interrupt. In this case, the contents of T WDR is undefined. In the case\nof a lost bus arbitration, no data is lost in the transition from Master to Slave. Handling of the\nACK bit is controlled automatically by the T WI logic, the CPU cannot access the ACK bit directly.B i t 76543210\n(0xB9) TWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 TWSR\nR e a d / W r i t e RRRRRR R / W R / WInitial Value 1 1 1 1 1 0 0 0\nTable 24-7. TWI Bit Rate Prescaler\nTWPS1 TWPS0 Prescaler Value\n001014\n101 6\n116 4\nB i t 76543210\n(0xBB) TWD7 TWD6 TWD5 TWD4 TWD3 TWD2 TWD1 TWD0 TWDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 1 1 1 1 1 1 1 1\n\n269\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bits 7:0 \u2013 TWD: TWI Data Register\nThese eight bits constitute the next data byte to be transmitted, or the latest data byte received\non the 2-wire Serial Bus.\n24.9.5 TWAR \u2013 TWI (Slave) Address Register\nThe TWAR should be loaded with the 7-bit Slave address (in the seven most significant bits of\nTWAR) to which the T WI will respond when programmed as a Slave Transmitter or Receiver,\nand not needed in the Master modes. In multimaster systems, T WAR must be set in masters\nwhich can be addressed as Slaves by other Masters.\nThe LSB of T WAR is used to enable recognition of the general call address (0x00). There is an\nassociated address comparator that looks for the slave address (or general call address if\nenabled) in the received serial address. If a match is found, an interrupt request is generated.\n\u0081 Bits 7:1 \u2013 TWA: TWI (Slave) Address Register\nThese seven bits constitute the slave address of the T WI unit.\n\u0081 Bit 0 \u2013 TWGCE: TWI General Call Recognition Enable Bit\nIf set, this bit enables the recognition of a General Call given over the 2-wire Serial Bus.\n24.9.6 TWAMR \u2013 TWI (Slave) Address Mask Register\n\u0081 Bits 7:1 \u2013 TWAM: TWI Address Mask\nThe TWAMR can be loaded with a 7-bit Slave A ddress mask. Each of the bits in T WAMR can\nmask (disable) the corresponding address bit in the T WI Address Register (T WAR). If the mask\nbit is set to one then the address match l ogic ignores the compare between the incoming\naddress bit and the corresponding bit in T WAR. Figure 24-22  shows the address match logic in\ndetail.\nFigure 24-22. TWI Address Match Logic, Block DiagramB i t 76543210\n(0xBA) TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE TWAR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 1 1 1 1 1 1 1 0\nB i t 76543210(0xBD)\nTWAM[6:0] \u2013 TWAMR\nRead/Write R/W R/W R/W R/W R/W R/W R/W RInitial Value 0 0 0 0 0 0 0 0\nAddress\nMatch\nAddress Bit Comparator 0\nAddress Bit Comparator 6..1TWAR0\nTWAMR0Address\nBit 0\n\n270\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 Res: Reserved Bit\nThis bit is reserved and will always read as zero.\n\n271\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25. AC \u2013 Analog Comparator\nThe Analog Comparator compares the input values on the positive pin AIN0 and negative pin\nAIN1. When the voltage on the positive pin AIN0 is higher than the voltage on the negative pin\nAIN1, the Analog Comparator output, ACO, is set. The comparator\u2019s output can be set to triggerthe Timer/Counter1 Input Capture function. In addition, the comparator can trigger a separate\ninterrupt, exclusive to the Analog Comparator. Th e user can select Interrupt triggering on com-\nparator output rise, fall or toggle. A block diagram of the comparator and its surrounding logic isshown in Figure 25-1 .\nThe Power Reduction ADC bit, PRADC, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be disabled by writing a logical zero to be able to use the ADC input MUX.\nFigure 25-1. Analog Comparator Block Diagram\n(2)\nNote: 1. See Table 25-1 .\n2. Refer to Figure 1-1 on page 2  and Table 13-5 on page 79  for Analog Comparator pin \nplacement.\n25.1 Analog Comparator  Multiplexed Input\nIt is possible to select any of the ADC15:0 pins  to replace the negative input to the Analog Com-\nparator. The ADC multiplexer is used to select this input, and consequently, the ADC must be\nswitched off to utilize this feature. If the Analog Comparator Multiplexer Enable bit (ACME in\nADCSRB) is set and the ADC is switched off (A DEN in ADCSRA is zero), MUX5 and MUX2:0 in\nADMUX select the input pin to replace the negati ve input to the Analog Comparator, as shown in\nTable 25-1 . If ACME is cleared or ADEN is set, AIN1  is applied to the negative input to the Ana-\nlog Comparator.ACBGBANDGAP\nREFERENCE\nADC MULTIPLEXER\nOUTPUTACME\nADEN\n(1)\nTable 25-1. Analog Comparator Mulitiplexed Input\nACME ADEN MUX5 MUX2:0 Analog Comparator Negative Input\n0 x x xxx AIN1\n1 1 x xxx AIN11 0 0 000 ADC0\n1 0 0 001 ADC1\n1 0 0 010 ADC21 0 0 011 ADC3\n\n272\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25.2 Register Description\n25.2.1 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 6 \u2013 ACME: Analog Comparator Multiplexer Enable\nWhen this bit is written logic one and the ADC is  switched off (ADEN in ADCSRA is zero), the\nADC multiplexer selects the negative input to the Analog Comparator. When this bit is written\nlogic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detailed\ndescription of this bit, see \u201cAnalog Comparator Multiplexed Input\u201d on page 271 .\n25.2.2 ACSR \u2013 Analog Comparator Control and Status Register\n\u0081 Bit 7 \u2013 ACD: Analog Comparator Disable\nWhen this bit is written logic one , the power to the Analog Comparator is switched off. This bit\ncan be set at any time to tu rn off the Analog Com parator. This will reduce power consumption in\nActive and Idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be\ndisabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is\nchanged.1 0 0 100 ADC4\n1 0 0 101 ADC5\n1 0 0 110 ADC6\n1 0 0 111 ADC7\n1 0 1 000 ADC8\n1 0 1 001 ADC91 0 1 010 ADC10\n1 0 1 011 ADC11\n1 0 1 100 ADC121 0 1 101 ADC13\n1 0 1 110 ADC14\n1 0 1 111 ADC15Table 25-1. Analog Comparator Mulitiplexed Input (Continued)\nACME ADEN MUX5 MUX2:0 Analog Comparator Negative Input\nB i t 76543210\n(0x7B) \u2013 ACME \u2013 \u2013 MUX5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x30 (0x50) ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 ACSR\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00 N / A 00000\n\n273\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ACBG: Analog Comparator Bandgap Select\nWhen this bit is set, a fixed bandgap reference volt age replaces the positive input to the Analog\nComparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Compar-\nator. When the bandgap reference is used as input to the Analog Comparator, it will take a\ncertain time for the voltage to stabilize. If not stabilized, the first conversion may give a wrong\nvalue. See \u201cInternal Voltage Reference\u201d on page 62.\n\u0081 Bit 5 \u2013 ACO: Analog Comparator Output\nThe output of the Analog Comparator is synchronized and then directly connected to ACO. The\nsynchronization introduces a delay of 1 - 2 clock cycles.\n\u0081 Bit 4 \u2013 ACI: Analog Comparator Interrupt Flag\nThis bit is set by hardware when a comparator output event triggers the interrupt mode defined\nby ACIS1 and ACIS0. The Analog Comparator interr upt routine is executed if the ACIE bit is set\nand the I-bit in SREG is set. ACI is cleared by  hardware when executing the corresponding inter-\nrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.\n\u0081 Bit 3 \u2013 ACIE: Analog Comparator Interrupt Enable\nWhen the ACIE bit is written logic one and the I-bit in the Status Register is set, the Analog Com-\nparator interrupt is activated. When written logic zero, the interrupt is disabled.\n\u0081 Bit 2 \u2013 ACIC: Analog Comparator Input Capture Enable\nWhen written logic one, this bit enables the input capture function in Timer/Counter1 to be trig-\ngered by the Analog Comparator. The comparator output is in this case directly connected to the\ninput capture front-end logic, making the compar ator utilize the noise canceler and edge select\nfeatures of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection\nbetween the Analog Comparator and the input capture function exists. To make the comparator\ntrigger the Timer/Counter1 Input Capture interrupt, the ICIE1 bit in the Timer Interrupt Mask\nRegister (TIMSK1) must be set.\n\u0081 Bits 1, 0 \u2013 ACIS1, ACIS0: Analog Comparator Interrupt Mode Select\nThese bits determine which comparator events that trigger the Analog Comparator interrupt. The\ndifferent settings are shown in Table 25-2 .\nWhen changing the ACIS1/ACIS0 bits, the Analog Comparator Interrupt must be disabled by\nclearing its Interrupt Enable bit in the ACSR Register. Otherwise an interrupt can occur when thebits are changed.Table 25-2. ACIS1/ACIS0 Settings\nACIS1 ACIS0 Interrupt Mode\n0 0 Comparator Interrupt on Output Toggle\n01 R e s e r v e d1 0 Comparator Interrupt on Falling Output Edge\n1 1 Comparator Interrupt on Rising Output Edge\n\n274\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25.2.3 DIDR1 \u2013 Digital In put Disable Register 1\n\u0081 Bit 1, 0 \u2013 AIN1D, AIN0D: AI N1, AIN0 Digita l Input Disable\nWhen this bit is written logic one, the digital input buffer on the AIN1/0 pin is disabled. The corre-\nsponding PIN Register bit will always re ad as zero when this bit is set. When an analog signal is\napplied to the AIN1/0 pin and the digital input from this pin is not needed, this bit should be writ-\nten logic one to reduce power consumption in the digital input buffer.B i t 76543210\n(0x7F) \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 AIN1D AIN0D DIDR1\nRead/Wr i t e RRRRRR R / W R/W\nI n i t i a l  V a l u e 00000000\n\n275\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26. ADC \u2013 Analog to Digital Converter\n26.1 Features\n\u008110-bit Resolution\n\u00811 LSB Integral Non-linearity\n\u0081\u00b12 LSB Absolute Accuracy\n\u008113\u00b5s - 260\u00b5s Conversion Time\n\u0081Up to 76.9kSPS (Up to 15kSP S at Maximum Resolution)\n\u008116 Multiplexed Single Ended Input Channels\n\u008114 Differential input channels\n\u00814 Differential Input Ch annels with Optional Gain of 10\u00d7 and 200\u00d7\n\u0081Optional Left Adjustment for ADC Result Readout\n\u00810V - VCC ADC Input Voltage Range\n\u00812.7V - VCC Differential ADC Voltage Range\n\u0081Selectable 2.56V or 1.1V ADC Reference Voltage\n\u0081Free Running or Single Conversion Mode\n\u0081Interrupt on ADC Conversion Complete\n\u0081Sleep Mode No ise Canceler\nThe ATmega640/1280/1281/2560/2561 features a 10-bit successive approximation ADC. The\nADC is connected to an 8/16-channel Analog Mult iplexer which allows eight/sixteen single-\nended voltage inputs constructed from the pins of Port F and Port K. The single-ended voltage\ninputs refer to 0V (GND).\nThe device also supports 16/32 differential voltage input combinations. Four of the differential\ninputs (ADC1 & ADC0, ADC3 & ADC2, ADC9 & ADC8 and ADC11 & ADC10) are equipped with\na programmable gain stage, providing amplificati on steps of 0 dB (1\u00d7), 20 dB (10\u00d7) or 46 dB\n(200\u00d7) on the differential input voltage before the ADC conversion. The 16 channels are split intwo sections of 8 channels where in each section seven differential analog input channels share\na common negative terminal (A DC1/ADC9), while any other ADC input in that section can be\nselected as the positive input terminal. If 1\u00d7  or 10\u00d7 gain is used, 8 bit resolution can be\nexpected. If 200\u00d7 gain is used, 7 bit resolution can be expected.\nThe ADC contains a Sample and Hold circuit whic h ensures that the input voltage to the ADC is\nheld at a constant level during conversion. A block diagram of the ADC is shown in Figure 26-1\non page 276 .\nThe ADC has a separate analog supply voltage pi n, AVCC. AVCC must not differ more than\n\u00b10.3V from V\nCC. See the paragraph \u201cADC Noise Canceler\u201d on page 283  on how to connect this\npin.\nInternal reference voltages of nominally 1.1V, 2.56V or AVCC are provided On-chip. The voltage\nreference may be externally decoupled at the AREF pin by a capacitor for better noise\nperformance.\nThe Power Reduction ADC bit, PRADC, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be disabled by writing a logical zero to enable the ADC.\n\n276\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-1. Analog to Digital Converter Block Schematic\n26.2 Operation\nThe ADC converts an analog input voltage to a 10-bit digital value through successive approxi-\nmation. The minimum value represents GND and the maximum value represents the voltage on\nthe AREF pin minus 1 LSB. Optionally, AVCC or an internal 1.1V or 2.56V reference voltage\nmay be connected to the AREF pin by writing to  the REFSn bits in the ADMUX Register. The\ninternal voltage reference may thus be decoupled by an external capacitor at the AREF pin to\nimprove noise immunity.\nThe analog input channel is selected by writing to the MUX bits in ADMUX and ADCSRB. Any of\nthe ADC input pins, as well as GND and a fixed bandgap voltage reference, can be selected as\nsingle ended inputs to the ADC. A selection of ADC input pins can be selected as positive and\nnegative inputs to the differential amplifier.ADC CONVERSION\nCOMPLETE IRQ\n8-BIT DATABUS\n15 0 ADIE\nADFR ADSC ADENADIFADIF\nMUX[4:0]ADPS[2:0]\nSAMPLE & HOLD\nCOMPARATORINTERNAL\nREFERENCE\n(1.1V/2.56V)AVCCREFS[1:0]ADLAR\nCHANNEL SELECTIONADC[9:0]\nADC\nMULTIPLEXER\nOUTPUTGAIN\nAMPLIFIE RAREF\nBANDGAP (1.1V)\nREFERENCE\nGNDCONVERSION LOGICADC CTRL & STATUS\nREGISTER B (ADCSRB)ADC CTRL & STATUS\nREGISTER A (ADCSRA)\nPRESCALERADC MULTIPLEXER\nSELECT (ADMUX)\nMUX DECODER\nDIFF / GAIN SELECTADC DATA REGISTER\n(ADCH/ADCL)\nADC[2:0]TRIGGER\nSELECT\nSTARTINTERRUPT\nFLAGS\nADTS[2:0]\n+-\nADC[15:0]+- 10-bit DACMUX[5]\nADC[10:8]\n\n277\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf differential channels are selected, the voltage difference between the selected input channel\npair then becomes the analog input to the ADC. If single ended channels are used, the amplifier\nis bypassed altogether.\nThe ADC is enabled by setting the ADC Enable bit, ADEN in ADCSRA. Voltage reference and\ninput channel selections will not go into effect  until ADEN is set. The ADC does not consume\npower when ADEN is cleared, so it is recommended to switch off the ADC before entering power\nsaving sleep modes.\nThe ADC generates a 10-bit result which is pr esented in the ADC Data Registers, ADCH and\nADCL. By default, the result is presented right adjusted, but can optionally be presented left\nadjusted by setting the ADLAR bit in ADMUX.\nIf the result is left adjusted and no more than 8-bit precision is required, it is sufficient to read\nADCH. Otherwise, ADCL must be read first, then ADCH, to ensure that the content of the Data\nRegisters belongs to the same conversion. Once ADCL is read, ADC access to Data Registersis blocked. This means that if ADCL has been read, and a conversion completes before ADCH is\nread, neither register is updated and the result from the conversion is lost. When ADCH is read,\nADC access to the ADCH and AD CL Registers is re-enabled.\nThe ADC has its own interrupt which can be triggered when a conversion completes. When ADC\naccess to the Data Registers is prohibited between reading of ADCH and ADCL, the interrupt\nwill trigger even if the result is lost.\n26.3 Starting a Conversion\nA single conversion is started by writing a l ogical one to the ADC Start Conversion bit, ADSC.\nThis bit stays high as long as the conversi on is in progress and will be cleared by hardware\nwhen the conversion is completed. If a different  data channel is selected while a conversion is in\nprogress, the ADC will finish the current conv ersion before performing  the channel change.\nAlternatively, a conversion can be triggered automatically by various sources. Auto Triggering is\nenabled by setting the ADC Auto Trigger Enable bi t, ADATE in ADCSRA. The trigger source is\nselected by setting the ADC Trigger Select bits, ADTS in ADCSRB (see description of the ADTS\nbits for a list of the trigger sources). When a positive edge occurs on the selected trigger signal,\nthe ADC prescaler is reset and a conversion is st arted. This provides a method of starting con-\nversions at fixed intervals. If the trigger signal still is set when the conversion completes, a new\nconversion will not be star ted. If another positive edge occurs  on the trigger si gnal during con-\nversion, the edge will be ignored. Note that an Interrupt Flag will be set even if the specific\ninterrupt is disabled or the Global Interrupt Enable bit in SREG is cleared. A conversion can thusbe triggered without causing an interrupt. However, the Interrupt Flag must be cleared in order to\ntrigger a new conversion at the next interrupt event.\n\n278\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-2. ADC Auto Trigger Logic\nUsing the ADC Interrupt Flag as a trigger source makes the ADC start a new conversion as soon\nas the ongoing conversion has finished. The ADC then operates in Free Running mode, con-stantly sampling and updating the ADC Data Register. The first conversion must be started by\nwriting a logical one to the ADSC bit in ADCS RA. In this mode the ADC will perform successive\nconversions independently of whether the A DC Interrupt Flag, ADIF is cleared or not.\nIf Auto Triggering is enabled, single conversi ons can be started by writing ADSC in ADCSRA to\none. ADSC can also be used to determine if a conversion is in progress. The ADSC bit will be\nread as one during a conversion, independently of how the conversion was started.\n26.4 Prescaling and Conversion Timing\nFigure 26-3. ADC Prescaler\nBy default, the successive approximation circ uitry requires an input clock frequency between\n50kHz and 200kHz. If a lower resolution than 10 bits is needed, the input clock frequency to the\nADC can be as high as 1000kHz to get a higher sample rate.\nThe ADC module contains a prescaler, which generates an acceptable ADC clock frequency\nfrom any CPU frequency above 100kHz. The prescaling is set by the ADPS bits in ADCSRA.ADSCADIF\nSOURCE 1\nSOURCE nADTS[2:0]\nCONVER SION\nLOGICPRESCALER\nSTART CLKADC\n.\n.\n..\nEDGE\nDETECTORADATE\n7-BIT ADC PRE SCALER\nADC CLOCK SOURCECK\nADPS0\nADPS1\nADPS2CK/128\nCK/2CK/4CK/8\nCK/16CK/32CK/64ResetADEN\nSTART\n\n279\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe prescaler starts counting from the moment the ADC is switched on by setting the ADEN bit\nin ADCSRA. The prescaler keeps running for as lo ng as the ADEN bit is set, and is continuously\nreset when ADEN is low.\nWhen initiating a single ended conversion by setti ng the ADSC bit in ADCSRA, the conversion\nstarts at the following rising edge of the ADC clock cycle.\nA normal conversion takes 13 ADC clock cycles. The first conversion after the ADC is switched\non (ADEN in ADCSRA is set) takes 25 ADC clock cycles in order to initialize the analog circuitry.\nWhen the bandgap reference voltage is used as input to the ADC, it will take a certain time for\nthe voltage to stabilize. If not stabilized, the first value read after the first conversion may be\nwrong.\nThe actual sample-and-hold takes place 1.5 ADC clock cycles after the start of a normal conver-\nsion and 13.5 ADC clock cycles afte r the start of an first conversion. When a conversion is\ncomplete, the result is written to the ADC Data Re gisters, and ADIF is set. In Single Conversion\nmode, ADSC is cleared simultaneously. The software may then set ADSC again, and a new\nconversion will be init iated on the first rising ADC clock edge.\nWhen Auto Triggering is used, the prescaler is reset when the trigger event occurs. This assures\na fixed delay from the trigger event to the start of conversion. In this mode, the sample-and-hold\ntakes place two ADC clock cycles after the rising edge on the trigger source signal. Three addi-\ntional CPU clock cycles are used for synchronization logic.\nIn Free Running mode, a new conversion will be  started immediately after the conversion com-\npletes, while ADSC remains high. For a summary of conversion times, see Table 26-1 on page\n281.\nFigure 26-4. ADC Timing Diagram, First Conver sion (Single Conversion Mode)\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nSample & HoldADIF\nADCHADCLCycle Number\nADEN1 21 2 13 14 15 16 17 18 19 20 21 22 23 24 25 1 2First ConversionNext\nConversion\n3\nMUX and REF S\nUpdateMUX and REF S\nUpdateConversion\nComplete\n\n280\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-5. ADC Timing Diagram, Single Conversion\nFigure 26-6. ADC Timing Diagram, Auto Triggered Conversion\nFigure 26-7. ADC Timing Diagram, Free Running Conversion1 2 3 4 5 6 7 8 9 10 11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nADIFADCHADCLCycle Number 12One Conversion Next Conversion\n3\nSample & Hold\nMUX and REF S\nUpdateConversion\nCompleteMUX and REF S\nUpdate\n1 2 3 4 5 6 7 8 9 10 11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nTrigger\nSource\nADIF\nADCHADCLCycle Number 12One Conversion Next Conversion\nConversion\nCompletePrescaler ResetADATE\nPrescalerReset Sample &\nHold\nMUX and REF S \nUpdate\n11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nADIFADCHADCLCycle Number12One Conversion Next Conversion\n34\nConversion\nCompleteSample & Hold\nMUX and REF S\nUpdate\n\n281\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.4.1 Differential Channels\nWhen using differential channels, certain aspe cts of the conversion need to be taken into\nconsideration.\nDifferential conversions are synchronized to the internal clock CKADC2 equal to half the ADC\nclock. This synchronization is done automatically by the ADC interface in such a way that the\nsample-and-hold occurs at  a specific phase of CKADC2. A conversion initiated by the user (that is,\nall single conversions, and the first free running conversion) when CKADC2 is low will take the\nsame amount of time as a single ended conversion (13 ADC clock cycles from the next pres-caled clock cycle). A conversion initiated by the user when CK\nADC2 is high will take 14 ADC clock\ncycles due to the synchronization mechanism. In Free Running mode, a new conversion is initi-\nated immediately after the previous conversion completes, and since CKADC2 is high at this time,\nall automatically started (that is, all but the first) Free Running conversions will take 14 ADC\nclock cycles.\nIf differential channels are used and conversions ar e started by Auto Triggering, the ADC must\nbe switched off between conversions. When Auto Triggering is used, the ADC prescaler is reset\nbefore the conversion is started. Since the stage is dependent of a stable ADC clock prior to the\nconversion, this conversion w ill not be valid. By disabling a nd then re-enabling the ADC between\neach conversion (writing ADEN in ADCSRA to \u201c0\u201d then to \u201c1\u201d), only extended conversions are\nperformed. The result from the extended conversions will be valid. See \u201cPrescaling and Conver-\nsion Timing\u201d on page 278  for timing details.Table 26-1. ADC Conversion Time\nConditionSample & Hold (Cycles from \nStart of Conversion) Conversion Time (Cycles)\nFirst conversion 13.5 25\nNormal conversions, single ended 1.5 13\nAuto Triggered conversions 2 13.5\nNormal conversions, differential 1.5/2.5 13/14\n\n282\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.5 Changing Channel or  Reference Selection\nThe MUXn and REFS1:0 bits in the ADMUX Register are single buffered through a temporary\nregister to which the CPU has random access. This ensures that the channels and reference\nselection only takes place at a safe point dur ing the conversion. The channel and reference\nselection is continuously updated until a conversion is started. Once the conversion starts, the\nchannel and reference selection is locked to ensure a sufficient sampling time for the ADC. Con-\ntinuous updating resumes in the last ADC clock cycle before the conversion completes (ADIF inADCSRA is set). Note that the conversion star ts on the following rising  ADC clock edge after\nADSC is written. The user is thus advised not to write new channel or reference selection values\nto ADMUX until one ADC clock cycle after ADSC is written.\nIf Auto Triggering is used, the exact time of t he triggering event can be indeterministic. Special\ncare must be taken when updating the ADMUX Register, in order to control which conversion\nwill be affected by the new settings.\nIf both ADATE and ADEN is written to one, an interrupt event can occur at any time. If the\nADMUX Register is changed in this period, the user cannot tell if the next conversion is based\non the old or the new settings. ADMUX can be safely updated in the following ways:\n1.When ADATE or ADEN is cleared.\n2. During conversion, minimum one ADC clock cycle after the trigger event.3. After a conversion, before the Interrupt Flag used as trigger source is cleared.\nWhen updating ADMUX in one of these conditions, t he new settings will affect the next ADC\nconversion.\nSpecial care should be taken when changing differential channels. Once a differential channel\nhas been selected, the  stage may take as much as 125\u00b5s to stabilize to the new value. Thus\nconversions should not be started within the first 125\u00b5s after selecting a new differential chan-\nnel. Alternatively, conversion results obt ained within this period should be discarded.\nThe same settling time should be observed for th e first differential conversion after changing\nADC reference (by changing the REFS1:0 bits in ADMUX).\n26.5.1 ADC Input Channels\nWhen changing channel selections, the user should observe the following guidelines to ensure\nthat the correct channel is selected:\nIn Single Conversion mode, always select the channel before starting the conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the conversion to complete before changing the channel selection.\nIn Free Running mode, always select the channel before starting the first conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the first conversion to complete, and then change the channel\nselection. Since the next conver sion has already started automati cally, the next result will reflect\nthe previous channel selection.  Subsequent conversions will refl ect the new channel selection.\nWhen switching to a differential gain channel, the first conversion result may have a poor accu-\nracy due to the required settling time for the automatic offset cancellation circuitry. The usershould preferably disregard the first conversion result.\n\n283\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.5.2 ADC Voltage Reference\nThe reference voltage for the ADC (VREF) indicates the conversion range for the ADC. Single\nended channels that exceed VREF will result in code s close to 0x3FF. VREF can be selected as\neither AVCC, internal 1.1V reference, internal 2.56V reference or external AREF pin.\nAVCC is connected to the ADC through a passive switch. The internal 1.1V reference is gener-\nated from the internal bandgap reference (VBG) through an internal amplifier. In either case, theexternal AREF pin is directly connected to the ADC, and the reference voltage can be made\nmore immune to noise by connecting a capacitor between the AREF pin and ground. V\nREF can\nalso be measured at the AREF pin with a high impedant voltmeter. Note that VREF is a high\nimpedant source, and only a capacitive load shoul d be connected in a system. The Internal\n2.56V reference is generated from the 1.1V reference.\nIf the user has a fixed voltage source connected to the AREF pin, the user may not use the other\nreference voltage options in the ap plication, as they will be shorte d to the external voltage. If no\nexternal voltage is applied to the AREF pin, the user may switch between AVCC, 1.1V and\n2.56V as reference selection. The first ADC c onversion result after switching reference voltage\nsource may be inaccurate, and the user is advised to discard this result.\nIf differential channels are used, the selected reference should not be closer to AVCC than\nindicated in \u201cADC Characteristics \u2013 Preliminary Data\u201d on page 377 .\n26.6 ADC Noise Canceler\nThe ADC features a noise canceler that enables conversion during sleep mode to reduce noise\ninduced from the CPU core and other I/O peripherals. The noise canceler can be used with ADC\nNoise Reduction and Idle mode. To make use of this feature, the following procedure should beused:\n1. Make sure that the ADC is enabled and is not busy converting. Single Conversion \nmode must be selected and the ADC conversion complete interrupt must be enabled.\n2. Enter ADC Noise Reduction mode (or Id le mode). The ADC will start a conversion \nonce the CPU has been halted.\n3. If no other interrupts occur before the ADC conversion completes, the ADC interrupt \nwill wake up the CPU and execute the ADC Co nversion Complete interrupt routine. If \nanother interrupt wakes up the CPU before the ADC conversion is complete, that interrupt will be executed, and an ADC Conv ersion Complete interrupt request will be \ngenerated when the ADC conversion complete s. The CPU will remain in active mode \nuntil a new sleep command is executed.\nNote that the ADC will not be automatically turned off when entering other sleep modes than Idle\nmode and ADC Noise Reduction mode. The user is advised to write zero to ADEN before enter-\ning such sleep modes to avoid excessive power consumption.\nIf the ADC is enabled in such sleep modes and the user wants to perform differential conver-\nsions, the user is advised to switch the ADC off and on after waking up from sleep to prompt an\nextended conversion to get a valid result.\n\n284\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.6.1 Analog Input Circuitry\nThe analog input circuitry for single ended channels is illustrated in Figure 26-8.  An analog\nsource applied to ADCn is subjected to the pin capacitance and input leakage of that pin, regard-\nless of whether that channel is selected as input for the ADC. When the channel is selected, the\nsource must drive the S/H capacitor through the series resistance (combined resistance in theinput path).\nThe ADC is optimized for analog signals with an output impedance of approximately 10k \u03a9 or\nless. If such a source is used, the sampling time will be negligible. If a source with higher imped-ance is used, the sampling time  will depend on how long time the source nee ds to charge the\nS/H capacitor, which can vary widely. The user is recommended to only use low impedant\nsources with slowly varying signals, since this mi nimizes the required charge transfer to the S/H\ncapacitor.\nSignal components higher th an the Nyquist frequency (f\nADC/2) should not be present for either\nkind of channels, to avoid distortion from unpredictable signal convolution. The user is advisedto remove high frequency components with a low-pass filter before applying the signals as\ninputs to the ADC.\nFigure 26-8. Analog Input Circuitry\n26.6.2 Analog Noise Canceling Techniques\nDigital circuitry inside and outside the device ge nerates EMI which might affect the accuracy of\nanalog measurements. If conversion accuracy is critical, the noise level can be reduced by\napplying the following techniques:\n1. Keep analog signal paths as short as possible. Make sure analog tracks run over the \nground plane, and keep them well away from high-speed switching digital tracks.\n2. The AVCC pin on the device should be connected to the digital V\nCC supply voltage \nvia an LC network as shown in Figure 26-9 on page 285 .\n3. Use the ADC noise canceler function to reduce induced noise from the CPU.\n4. If any ADC port pins are used as digital outputs, it is essential that these do not \nswitch while a conversion is in progress.ADCnIIH\n1..100 k \u03a9\nCS/H= 14 pF\nVCC/2IIL\n\n285\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-9. ADC Power Connections, ATmega1281/2561.\nFigure 26-10. ADC Power Connections, ATmega640/1280/2560VCC\nGND\n100nF 100nF\n      Ground Plane(ADC0) PF0(ADC7) PF7\n(ADC1) PF1(ADC2) PF2(ADC3) PF3(ADC4) PF4(ADC5) PF5(ADC6) PF6\nAREF\nGND\nAVCC5253\n54\n55\n56\n57\n58\n59\n60\n6161\n6262\n6363\n6464\n151\nPG5PA0\n10\u03bc\u0397\n100nF\n      Gro und Pl ane100\n(OC0B) PG510\u03bc\u039779\n80818283\n84858687888990919293\n949596979899PJ7\nVCC\nGND\n(ADC15/PCINT2 3) PK7\n(ADC14/PCINT22) PK6(ADC1 3/PCINT21) PK5\n(ADC12/PCINT20) PK4(ADC11/PCINT19) PK 3\n(ADC10/PCINT18) PK2\n(ADC9/PCINT17) PK1(ADC8/PCINT16) PK0\n(ADC7/TDI) PF7\n(ADC6/TDO) PF6(ADC5/TMS) PF5\n(ADC4/TCK) PF4\n(ADC 3) PF3\n(ADC2) PF2(ADC1) PF1(ADC0) PF0\nAREF\nGND\nAVCC\n\n286\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.6.3 Offset Compensation Schemes\nThe stage has a built-in offset cancellation circuitr y that nulls the offset of differential measure-\nments as much as possible. The remaining offset in the analog path can be measured directly byselecting the same channel for both differential inputs. This offset residue can be then sub-\ntracted in software from the measurement results. Using this kind of software based offset\ncorrection, offset on any channel can be reduced below one LSB.\n26.6.4 ADC Accuracy Definitions\nAn n-bit single-ended ADC converts a voltage linearly between GND and V\nREF in 2n steps\n(LSBs). The lowest code is read as 0, and the highest code is read as 2n-1.\nSeveral parameters describe the deviation from the ideal behavior:\n\u0081 Offset: The deviation of the first transition (0x000 to 0x001) compared to the ideal transition \n(at 0.5 LSB). Ideal value: 0 LSB.\nFigure 26-11. Offset Error\n\u0081 Gain Error: After adjusting for offset, the Gain Error is found as the deviation of the last \ntransition (0x3FE to 0x3FF) compared to the ideal transition (at 1.5 LSB below maximum). Ideal value: 0 LSB.\nFigure 26-12. Gain ErrorOutput Code\nVREF Input VoltageIdeal ADC\nActual ADC\nOffset\nError\nOutput Code\nVREF Input VoltageIdeal ADC\nActual ADCGain\nError\n\n287\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Integral Non-linearity (INL): Afte r adjusting for offset and gain error, the INL is the maximum \ndeviation of an actual transition compared to an ideal transition for any code. Ideal value: 0 LSB.\nFigure 26-13. Integral Non-linearity (INL)\n\u0081 Differential Non-linearity (DNL ): The maximum deviation of the actual code width (the \ninterval between two adjacent transitions) from the ideal code width (1 LSB). Ideal value: 0 LSB.\nFigure 26-14. Differential Non-linearity (DNL)\n\u0081 Quantization Error: Due to the quantization of the input voltage into a finite number of codes, \na range of input voltages (1 LSB wide) will code to the same  value. Always \u00b10.5 LSB.\n\u0081 Absolute Accuracy: The maximum deviation of an  actual (unadjusted) transition compared \nto an ideal transition for any code. This is the compound effect of offset, gain error, differential error, non-linearity, and quantization error. Ideal value: \u00b10.5 LSB.Output Code\nVREFInput VoltageIdeal ADC\nActual ADCINL\nOutput Code\n0x3FF\n0x000\n0 VREFInput VoltageDNL1 LSB\n\n288\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.7 ADC Conversion Result\nAfter the conversion is complete (ADIF is high ), the conversion result can be found in the ADC\nResult Registers (ADCL, ADCH).\nFor single ended conversion, the result is\nwhere VIN is the voltage on the selected input pin and VREF the selected voltage reference (see\nTable 26-3 on page 289  and Table 26-4 on page 290 ). 0x000 represents analog ground, and\n0x3FF represents the selected reference voltage minus one LSB.\nIf differential channels are used, the result is\nwhere VPOS is the voltage on the positive input pin, VNEG the voltage on the negative input pin,\nand VREF the selected voltage reference. The result is presented in two\u2019s complement form, from\n0x200 (-512d) through 0x1FF (+511d). Note that if the user wants to perform a quick polarity\ncheck of the result, it is sufficient to read the MSB of the result (ADC9 in ADCH). If the bit is one,\nthe result is negative, and if this bit is zero, the result is positive. Figure 26-15  shows the decod-\ning of the differential input range.\nTable 26-2 on page 289  shows the resulting output codes if the differential input channel pair\n(ADCn - ADCm) is selected with a gain of GAIN and a reference voltage of VREF.\nFigure 26-15. Differential Measurement RangeADCVIN1024\u22c5\nVREF--------------------------=\nADCVPOSVNEG\u2013 () 512\u22c5\nVREF---------------------------------------------------- - =\n0Output Code\n0x1FF\n0x000\nVREFDifferential Input\nVoltage (Volts)0x3FF\n0x200- VREF\n\n289\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nExample:\nADMUX = 0xFB (ADC3 - ADC2, 10\u00d7 gain, 2.56V reference, left adjusted result).Voltage on ADC3 is 300mV, voltage on ADC2 is 500mV.\nADCR = 512 \u00d7 10 \u00d7 (300 - 500) / 2560 = -400 = 0x270.\nADCL will thus read 0x00,  and ADCH will read 0x9C. Writing zero to ADLAR right adjusts the\nresult: ADCL = 0x70, ADCH = 0x02.\n26.8 Register Description\n26.8.1 ADMUX \u2013 ADC Multiplexer Selection Register\n\u0081 Bit 7:6 \u2013 REFS1:0: Reference Selection Bits\nThese bits select the voltage reference for the ADC, as shown in Table 26-3 . If these bits are\nchanged during a conversion, the change will not go in effect until this conversion is complete(ADIF in ADCSRA is set). The internal voltage reference options may not be used if an external\nreference voltage is being applied to the AREF pin.\nNote: 1. If 10x or 200x gain is selected, only 2.56V should be used as Internal Voltage Reference. For \ndifferential conversion, only 1.1V cannot  be used as internal voltage reference.Table 26-2. Correlation Between Input Voltage and Output Codes\nVADCn Read Code Corresponding Decimal Value\n VADCm + VREF / GAIN 0x1FF 511\nVADCm + 0.999 VREF / GAIN 0x1FF 511\nVADCm + 0.998 VREF / GAIN 0x1FE 510\n... ... ...\nVADCm + 0.001 VREF / GAIN 0x001 1\nVADCm 0x000 0\nVADCm - 0.001 VREF / GAIN 0x3FF -1\n... ... ...V\nADCm - 0.999 VREF / GAIN 0x201 -511\nVADCm - VREF / GAIN 0x200 -512\nB i t 76543210\n(0x7C) REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 ADMUX\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 26-3. Voltage Reference Selections for ADC\nREFS1 REFS0 Voltage Reference Selection(1)\n0 0 AREF , Internal VREF turned off\n0 1 AVCC with external capacitor at AREF pin\n1 0 Internal 1.1V Voltage Reference with external capacitor at AREF pin\n1 1 Internal 2.56V Voltage Reference with external capacitor at AREF pin\n\n290\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 5 \u2013 ADLAR: ADC Left Adjust Result\nThe ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register.\nWrite one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing the\nADLAR bit will affect t he ADC Data Register immediately,  regardless of any ongoing conver-\nsions. For a complete description of this bit, see \u201cADCL and ADCH \u2013 The ADC Data Register\u201d on\npage 294 .\n\u0081 Bits 4:0 \u2013 MUX4:0: Analog Channel and Gain Selection Bits\nThe value of these bits selects which combination of analog inputs are connected to the ADC.\nSee Table 26-4  for details.  If these bits are changed during a conversion, the change will not go\nin effect until this conversion is complete (ADIF in ADCSRA is set).\n26.8.2 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 3 \u2013 MUX5: Analog Channel and Gain Selection Bit\nThis bit is used together with MUX4:0 in ADMU X to select which combin ation in of analog inputs\nare connected to the ADC. See Table 26-4  for details. If this bit is changed during a conversion,\nthe change will not go in  effect until this co nversion is complete.\nThis bit is not valid for ATmega1281/2561.B i t 76543210\n(0x7B) \u2013 ACME \u2013 \u2013M U X 5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 26-4. Input Channel Selections\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\n000000 ADC0\nN/A000001 ADC1\n000010 ADC2000011 ADC3\n000100 ADC4\n000101 ADC5000110 ADC6\n000111 ADC7\n\n291\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n001000(1)\nN/AADC0 ADC0 10\u00d7\n001001(1)ADC1 ADC0 10\u00d7\n001010(1)ADC0 ADC0 200\u00d7\n001011(1)ADC1 ADC0 200\u00d7\n001100(1)ADC2 ADC2 10\u00d7\n001101(1)ADC3 ADC2 10\u00d7\n001110(1)ADC2 ADC2 200\u00d7\n001111(1)ADC3 ADC2 200\u00d7\n010000 ADC0 ADC1 1\u00d7\n010001 ADC1 ADC1 1\u00d7\n010010 ADC2 ADC1 1\u00d7010011 ADC3 ADC1 1\u00d7\n010100 ADC4 ADC1 1\u00d7\n010101 ADC5 ADC1 1\u00d7010110 ADC6 ADC1 1\u00d7\n010111 ADC7 ADC1 1\u00d7\n011000 ADC0 ADC2 1\u00d7011001 ADC1 ADC2 1\u00d7\n011010\nN/AADC2 ADC2 1\u00d7\n011011 ADC3 ADC2 1\u00d7011100 ADC4 ADC2 1\u00d7\n011101 ADC5 ADC2 1\u00d7\n011110 1.1V (V\nBG)\nN/A\n011111 0V (GND)\n100000 ADC8\nN/A100001 ADC9\n100010 ADC10\n100011 ADC11\n100100 ADC12100101 ADC13\n100110 ADC14\n100111 ADC15Table 26-4. Input Channel Selections (Continued)\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\n\n292\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. To reach the given accuracy, 10\u00d7 or 200\u00d7 Gain should not be used for operating voltage below\n2.7V.\n26.8.3 ADCSRA \u2013 ADC Control and Status Register A\n\u0081 Bit 7 \u2013 ADEN: ADC Enable\nWriting this bit to one enables the ADC. By writing it to zero, the ADC is turned off. Turning the\nADC off while a conversion is in prog ress, will terminate this conversion.101000(1)\nN/AADC8 ADC8 10\u00d7\n101001(1)ADC9 ADC8 10\u00d7\n101010(1)ADC8 ADC8 200\u00d7\n101011(1)ADC9 ADC8 200\u00d7\n101100(1)ADC10 ADC10 10\u00d7\n101101(1)ADC11 ADC10 10\u00d7\n101110(1)ADC10 ADC10 200\u00d7\n101111(1)ADC11 ADC10 200\u00d7\n110000 ADC8 ADC9 1\u00d7\n110001 ADC9 ADC9 1\u00d7\n110010 ADC10 ADC9 1\u00d7110011 ADC11 ADC9 1\u00d7\n110100 ADC12 ADC9 1\u00d7\n110101 ADC13 ADC9 1\u00d7110110 ADC14 ADC9 1\u00d7\n110111 ADC15 ADC9 1\u00d7\n111000 ADC8 ADC10 1\u00d7111001 ADC9 ADC10 1\u00d7\n111010 ADC10 ADC10 1\u00d7\n111011 ADC11 ADC10 1\u00d7111100 ADC12 ADC10 1\u00d7\n111101\nN/A ADC13 ADC10 1\u00d7\n111110 Reserved N/A\n111111 Reserved N/ATable 26-4. Input Channel Selections (Continued)\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\nB i t 76543210\n(0x7A) ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 ADCSRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n293\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ADSC: ADC Start Conversion\nIn Single Conversion mode, write this bit to one to start each conversion. In Free Running mode,\nwrite this bit to one to start the first conversion. The first conversion after ADSC has been written\nafter the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled,\nwill take 25 ADC clock cycles instead of the norma l 13. This first conversi on performs initializa-\ntion of the ADC.\nADSC will read as one as long as  a conversion is in progress. When the conversion is complete,\nit returns to zero. Writing zero to this bit has no effect.\n\u0081 Bit 5 \u2013 ADATE: ADC Auto Trigger Enable\nWhen this bit is written to one,  Auto Triggering of the ADC is enabled. The ADC will start a con-\nversion on a positive edge of the selected trigger signal. The trigger source is selected by setting\nthe ADC Trigger Select bits, ADTS in ADCSRB.\n\u0081 Bit 4 \u2013 ADIF: ADC Interrupt Flag\nThis bit is set when an ADC conversion completes and the Data Registers are updated. The\nADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set.\nADIF is cleared by hardware when executing th e corresponding interrupt handling vector. Alter-\nnatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a Read-Modify-\nWrite on ADCSRA, a pending interrupt can be dis abled. This also applies if the SBI and CBI\ninstructions are used.\n\u0081 Bit 3 \u2013 ADIE: ADC Interrupt Enable\nWhen this bit is written to one and the I-bit in SREG is set, the ADC Conversion Complete Inter-\nrupt is activated.\n\u0081 Bits 2:0 \u2013 ADPS2:0: ADC Prescaler Select Bits\nThese bits determine the division factor between the XTAL frequency and the input clock to the\nADC.\nTable 26-5. ADC Prescaler Selections\nADPS2 ADPS1 ADPS0 Division Factor\n0002\n00120104\n0118\n100 1 6101 3 2\n110 6 4\n111 1 2 8\n\n294\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.8.4 ADCL and ADCH \u2013 The ADC Data Register\n26.8.4.1 ADLAR = 0\n26.8.4.2 ADLAR = 1\nWhen an ADC conversion is complete, the result is found in these two registers. If differential\nchannels are used, the result is presented in two\u2019s complement form.\nWhen ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if\nthe result is left adjusted and no more than 8-bit precision (7 bit + sign bit for differential input\nchannels) is required, it  is sufficient to read ADCH. Otherwise, ADCL must be read first, then\nADCH.\nThe ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from\nthe registers. If ADLAR is set, the result is left adjusted. If ADLA R is cleared (default), the result\nis right adjusted.\n\u0081 ADC9:0: ADC Conversion Result\nThese bits represent the result from the conversion, as detailed in \u201cADC Conversion Result\u201d on\npage 288 .\n26.8.5 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 7 \u2013 Res: Reserved Bit\nThis bit is reserved for future use. To ensure co mpatibility with future de vices, this bit must be\nwritten to zero when ADCSRB is written.\n\u0081 Bit 2:0 \u2013 ADTS2:0: ADC Auto Trigger Source\nIf ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger\nan ADC conversion. If ADATE is cleared, the ADTS2:0 settings will have no effect. A conversion\nwill be triggered by the risi ng edge of the selected Interrupt Flag . Note that switch ing from a trig-B i t 1 51 41 31 21 11 0 9 8\n(0x79) \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 ADC9 ADC8 ADCH\n(0x78) ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADC1 ADC0 ADCL\n76543210\nRead/Wr i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 1 51 41 31 21 11 0 9 8(0x79) ADC9 ADC8 ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADCH\n(0x78) ADC1 ADC0 \u2013 \u2013\u2013\u2013\u2013\u2013 ADCL\n76543210\nRead/Wr i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 76543210(0x7B)\n\u2013 ACME \u2013 \u2013 MUX5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n295\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nger source that is cleared to a trigger source that is set, will generate a positive edge on the\ntrigger signal. If ADEN in ADCSRA is set, this  will start a conversion. Switching to Free Running\nmode (ADTS[2:0]=0) will not cause a trigger event, even if t he ADC Interrupt Flag is set .\nNote: Free running mode cannot be used for differential channels (see chapter \u201cDifferential Channels\u201d \non page 281 ).\n26.8.6 DIDR0 \u2013 Digital In put Disable Register 0\n\u0081 Bit 7:0 \u2013 ADC7D:ADC0D: AD C7:0 Digital Input Disable\nWhen this bit is written logic one, the digital input buffer on the corresponding ADC pin is dis-\nabled. The corresponding PIN Re gister bit will always read as zero when this bit is set. When an\nanalog signal is applied to the ADC7:0 pin and the di gital input from this pin is not needed, this\nbit should be written logic one to reduce power consumption in the digital input buffer.\n26.8.7 DIDR2 \u2013 Digital In put Disable Register 2\n\u0081 Bit 7:0 \u2013 ADC15D:ADC8D: ADC15:8 Digital Input Disable\nWhen this bit is written logic one, the digital input buffer on the corresponding ADC pin is dis-\nabled. The corresponding PIN Re gister bit will always read as zero when this bit is set. When an\nanalog signal is applied to the ADC15:8 pin and the digital input from this pin is not needed, this\nbit should be written logic one to reduce power consumption in the digital input buffer.Table 26-6. ADC Auto Trigger Source Selections\nADTS2 ADTS1 ADTS0 Trigger Source\n0 0 0 Free Running mode\n0 0 1 Analog Comparator\n0 1 0 External Interrupt Request 00 1 1 Timer/Counter0 Compare Match A\n1 0 0 Timer/Counter0 Overflow\n1 0 1 Timer/Counter1 Compare Match B1 1 0 Timer/Counter1 Overflow\n1 1 1 Timer/Counter1 Capture Event\nB i t 76543210\n(0x7E) ADC7D ADC6D ADC5D ADC4D ADC3D ADC2D ADC1D ADC0D DIDR0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x7D) ADC15D ADC14D ADC13D ADC12D ADC11D ADC10D ADC9D ADC8D DIDR2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n296\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n27. JTAG Interface and On-chip Debug System\n27.1 Features\n\u0081JTAG (IEEE std. 1149.1 Compliant) Interface\n\u0081Boundary-scan Ca pabilities According to the I EEE std. 1149.1 (JTAG) Standard\n\u0081Debugger Access to:\n\u2013 All Internal Peripheral Units\u2013 Internal and External RAM\n\u2013 The Internal Register File\n\u2013P r o g r a m  C o u n t e r\u2013 EEPROM and Flash Memories\n\u0081Extensive On-chip Debug Support for Break Conditions, Including\n\u2013 AVR Break Instruction\u2013 Break on Change of Program Memory Flow\n\u2013 Single Step Break\n\u2013 Program Memory Break Points on Single Address or Address Range\u2013 Data Memory Break Points on Si ngle Address or Address Range\n\u0081Programming of Flash, EEPROM , Fuses, and Lock Bits th rough the JTAG Interface\n\u0081On-chip Debugging Supported by AVR Studio\u00ae\n27.2 Overview\nThe AVR IEEE std. 1149.1 compliant JTAG interface can be used for\n\u0081 Testing PCBs by using the JTAG Boundary-scan capability\n\u0081 Programming the non-volatile memories, Fuses and Lock bits\u0081 On-chip debuggingA brief description is given in the following se ctions. Detailed descriptions for Programming via\nthe JTAG interface, and using the Boundary-scan Chain can be found in the sections \u201cProgram-\nming via the JTAG Interface\u201d on page 354  and \u201cIEEE 1149.1 (JTAG) Bo undary-scan\u201d on page\n302, respectively. The On-chip Debug support is considered being private JTAG instructions,\nand distributed within Atmel and to selected third party vendors only.\nFigure 27-1 on page 297  shows a block diagram of the JTAG interface and the On-chip Debug\nsystem. The TAP Controller is a state machine controlled by the TCK and TMS signals. The TAP\nController selects either the JTAG  Instruction Register or one of several Data Registers as the\nscan chain (Shift Register) between the TDI \u2013 input and TDO \u2013 output. The Instruction Registerholds JTAG instructions controlling the behavior of a Data Register.\nThe ID-Register, Bypass Register, and the Bou ndary-scan Chain are the Data Registers used\nfor board-level testing. The JTAG Programming Interface (actually consisting of several physicaland virtual Data Registers) is used for serial programming via the JTAG interface. The Internal\nScan Chain and Break Point Scan Chain are used for On-chip debugging only.\n\n297\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 27-1. Block Diagram\n27.3 TAP - Test Access Port\nThe JTAG interface is accessed through four of the AVR\u2019s pins. In JTAG terminology, these pins\nconstitute the Test Access Port \u2013 TAP. These pins are:\n\u0081TMS : Test mode select. This pin is used for navigating through the TAP-controller state \nmachine.\n\u0081TCK: Test Clock. JTAG operation is synchronous to TCK.\n\u0081TDI: Test Data In. Serial input data to be shifted in to the Instruction Register or Data \nRegister (Scan Chains).\n\u0081TDO : Test Data Out. Serial output data from Instruction Register or Data Register.\nThe IEEE std. 1149.1 also  specifies an optional TAP signal; TRST \u2013 Test ReSeT \u2013 which is not\nprovided.\nWhen the JTAGEN Fuse is unprogrammed, these four TAP pins are normal port pins, and the\nTAP controller is in reset. When programmed, the input TAP signals are internally pulled high\nand the JTAG is enabled for Boundary-scan and programming. The device is shipped with this\nfuse programmed.\nFor the On-chip Debug system, in addition to the JTAG interface pins, the RESET  pin is moni-\ntored by the debugger to be able to detect external reset sources. The debugger can also pull\nthe RESET  pin low to reset the whole system, assuming only open collectors on the reset line\nare used in the application.TAP\nCONTROLLERTDI\nTDO\nTCK\nTMS\nFLASH\nMEMORYAVR CPU\nDIGITAL\nPERIPHERAL\nUNIT S\nJTAG / AVR CORE\nCOMMUNICATION\nINTERFACEBREAKPOINT\nUNITFLOW CONTROL\nUNIT\nOCD STATU S\nAND CONTROLINTERNAL \nSCAN\nCHAIN\nM\nU\nXINSTRUCTION\nREGI STER\nID\nREGI STER\nBYPA SS\nREGI STERJTAG PROGRAMMING\nINTERFACE\nPC\nInstructionAddress\nData\nBREAKPOINT\nSCAN CHAIN\nADDRE SS\nDECODERANALOG\nPERIPHERIAL\nUNIT SI/O PORT 0\nI/O PORT nBOUNDARY SCAN CHAIN\nAnalog inputs\nControl & Clock linesDEVICE BOUNDARY\n\n298\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 27-2. TAP Controller State Diagram\n27.3.1 TAP Controller\nThe TAP controller is a 16-state finite state machine that controls the operation of the Boundary-\nscan circuitry, JTAG programming circuitry, or On-chip Debug system. The state transitions\ndepicted in Figure 27-2  depend on the signal present on TM S (shown adjacent to each state\ntransition) at the time of the rising edge at TCK. The initial state after a Power-on Reset is Test-\nLogic-Reset.\nAs a definition in this document, the LSB is shifted in and out first for all Shift Registers.\nAssuming Run-Test/Idle is the present state, a typical scenario for using the JTAG interface is:\n\u0081 At the TMS input, apply the sequence 1, 1, 0, 0 at the rising edges of TCK to enter the Shift \nInstruction Register \u2013 Shift-IR state. While in this state, shift the four bits of the JTAG \ninstructions into the JTAG Instruction Register from the TDI input at the rising edge of TCK. The TMS input must be held low during input of the 3 LSBs in order to remain in the Shift-IR state. The MSB of the instruction is shifted in when this state is left  by setting TMS high. \nWhile the instruction is shifted in from the TDI pin, the captured IR-state 0x01 is shifted out \non the TDO pin. The JTAG Instruction selects a particular Data Register as path between TDI and TDO and controls the circuitry surrounding the selected Data Register.Test-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n299\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Apply the TMS sequence 1, 1, 0 to re-enter the Run-Test/Idle state. The instruction is \nlatched onto the parallel output from the Shift Register path in the Update-IR state. The Exit-IR, Pause-IR, and Exit2-IR states are onl y used for navigating the state machine.\n\u0081 At the TMS input, apply the sequence 1, 0, 0 at the rising edges of TCK to enter the Shift \nData Register \u2013 Shift-DR state. While in this state, upload the selected Data Register \n(selected by the present JTAG instruction in the JTAG Instruction Register) from the TDI input at the rising edge of TCK. In order to remain in the Shift-DR state, the TMS input must be held low during input of all bits except the MSB. The MSB of the data is shifted in when this state is left by setting TMS high. While the Data Register is sh ifted in from the TDI pin, \nthe parallel inputs to the Data Register captured in the Capture-DR state is shifted out on the TDO pin.\n\u0081 Apply the TMS sequence 1, 1, 0 to re-enter the Run-Test/Idle state. If the selected Data \nRegister has a latched parallel-output, the latching takes place in the Update-DR state. The Exit-DR, Pause-DR, and Exit2-DR states are only used for navigating the state machine.\nAs shown in the state diagram, the Run-Test/Idle state need not be entered between selecting\nJTAG instruction and using Data Registers, and some JTAG instructions may select certain\nfunctions to be performed in the Run-Test/Idle, making it unsuitable as an Idle state.\nNote: Independent of the initial state of the TAP C ontroller, the Test-Logic-R eset state can always be \nentered by holding TMS high for five TCK clock periods.\nFor detailed information on the JTAG specification, refer to the literature listed in \u201cBibliography\u201d\non page 301 .\n27.4 Using the B oundary-scan Chain\nA complete description of the Boundary-sc an capabilities are gi ven in the section \u201cIEEE 1149.1\n(JTAG) Boundary-scan\u201d on page 302 .\n27.5 Using the On-c hip Debug System\nAs shown in Figure 27-1 on page 297 , the hardware support for On-chip Debugging consists\nmainly of:\n\u0081 A scan chain on the interface between the internal AVR CPU and the internal peripheral \nunits\n\u0081 Break Point unit\u0081 Communication interface between the CPU and JTAG systemAll read or modify/write operations needed for implementing the Debugger are done by applying\nAVR instructions via the internal AVR CPU Scan Chain. The CPU sends the result to an I/O\nmemory mapped location which is part of the communication interface between the CPU and the\nJTAG system.\nThe Break Point Unit implements Break on Change of Program Flow, Single Step Break, two\nProgram Memory Break Points, and two combined Break Points. Together, the four Break\nPoints can be configured as either:\n\u0081 4 single Program Memory Break Points\n\u0081 3 Single Program Memory Break Point + 1 single Data Memory Break Point\u0081 2 single Program Memory Break Points + 2 single Data Memory Break Points\u0081 2 single Program Memory Break Points + 1 Program Memory Break Point with mask (\u201crange \nBreak Point\u201d)\n\u0081 2 single Program Memory Break Points + 1 Data Memory Break Point with mask (\u201crange \nBreak Point\u201d)\n\n300\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA debugger, like the AVR Studio, may however use one or more of these resources for its inter-\nnal purpose, leaving less flexibility to the end-user.\nA list of the On-chip Debug specific JTAG instructions is given in \u201cOn-chip Debug Specific JTAG\nInstructions\u201d on page 300 .\nThe JTAGEN Fuse must be programmed to enable the JTAG Test Access Port. In addition, the\nOCDEN Fuse must be programmed and no Lock bits must be set for the On-chip debug system\nto work. As a security feature, the On-chip debug system is disabled when either of the LB1 or\nLB2 Lock bits are set. Otherwise, the On-chi p debug system would have provided a back-door\ninto a secu red device.\nThe AVR Studio\u00ae enables the user to fully control execution of programs on an AVR device with\nOn-chip Debug capability, AVR In- Circuit Emulator, or the built-i n AVR Instruction Set Simulator.\nAVR Studio supports source level execution of  Assembly programs assembled with Atmel Cor-\nporation\u2019s AVR Assembler and C programs compiled with third party vendors\u2019 compilers.\nAVR Studio runs under Microsoft\u00ae Windows\u00ae 95/98/2000 and Microsoft Windows NT\u00ae.\nFor a full description of the AVR Studio, please re fer to the AVR Studio User Guide. Only high-\nlights are presented in this document.\nAll necessary execution commands are available in AVR Studio, both on source level and on\ndisassembly level. The user can execute the program, single step through the code either by\ntracing into or stepping over functions, step out of functions, place the cursor on a statement andexecute until the statement is reached, stop th e execution, and reset the execution target. In\naddition, the user can have an unlimited number of code Break Points (using the BREAK\ninstruction) and up to two data memory Break Points, alternatively combined as a mask (range)Break Point.\n27.6 On-chip Debug Specific JTAG Instructions\nThe On-chip debug support is considered being private JTAG instructions, and distributed withinATMEL and to selected third party vendors only. Instruction opcodes are listed for reference.\n27.6.1 PRIVATE0; 0x8\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.2 PRIVATE1; 0x9\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.3 PRIVATE2; 0xA\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.4 PRIVATE3; 0xB\nPrivate JTAG instruction for accessing On-chip debug system.\n\n301\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n27.7 Using the JTAG Pr ogramming Capabilities\nProgramming of AVR parts via JTAG is performed via the 4-pin JTAG port, TCK, TMS, TDI, and\nTDO. These are the only pins that need to be controlled/observed to perform JTAG program-\nming (in addition to power pins). It is not requi red to apply 12V externally. The JTAGEN Fuse\nmust be programmed and the JTD bit in the MCUCR Register must be cleared to enable the\nJTAG Test Access Port.\nThe JTAG programmi ng capability supports:\n\u0081 Flash programming and verifying\n\u0081 EEPROM programming and verifying\u0081 Fuse programming and verifying\u0081 Lock bit programming and verifyingThe Lock bit security is exactly as in parallel programming mode. If the Lock bits LB1 or LB2 are\nprogrammed, the OCDEN Fuse cannot be programmed unless first doing a chip erase. This is a\nsecurity feature that ensures no back-door exists for reading out the content of a secureddevice.\nThe details on programming through the JTAG interface and programming specific JTAG\ninstructions are given in the section \u201cProgramming via the JTAG Interface\u201d on page 354 .\n27.8 Bibliography\nFor more information about general Boundary-scan, the following literature can be consulted:\n\u0081 IEEE: IEEE Std. 1149.1-1990. IEEE Standard Test Access  Port and Boundary-scan \nArchitecture, IEEE, 1993\n\u0081 Colin Maunder: The Board Designers Guide to Testable Logic Circuits, Addison- Wesley, \n1992\n27.9 On-chip Debug Related Register in I/O Memory\n27.9.1 OCDR \u2013 On-chi p Debug Register\nThe OCDR Register provides a co mmunication channel from the running pr ogram in the micro-\ncontroller to the debugger. The CPU can transfer a byte to the debugger by writing to this\nlocation. At the same time, an in ternal flag; I/O Debug Register Dirty \u2013 IDRD \u2013 is set to indicate\nto the debugger that the register has been written. When the CPU reads the OCDR Register the\n7 LSB will be from the OCDR Regi ster, while the MSB is the IDRD  bit. The debugger clears the\nIDRD bit when it has read the information.\nIn some AVR devices, this register is shared with a standard I/O location. In this case, the OCDR\nRegister can only be accessed if the OCDEN Fuse is programmed, and the debugger enables\naccess to the OCDR Register. In all other cases, the standard I/O location is accessed.\nRefer to the debugger documentation for further information on how to use this register.B i t 7 6543210\n0x31 (0x51) MSB/IDRD LSB OCDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 0 0000000\n\n302\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28. IEEE 1149.1 (JTAG) Boundary-scan\n28.1 Features\n\u0081JTAG (IEEE std. 1149.1 compliant) Interface\n\u0081Boundary-scan Capabilities Acco rding to the JTAG Standard\n\u0081Full Scan of all Port Functions as well as Analog Circuitry having Off-chip Connections\n\u0081Supports the Optional IDCODE Instruction\n\u0081Additional Public AVR_RESET Instruction to Reset the AVR\n28.2 System Overview\nThe Boundary-scan chain has the capability of drivin g and observing the logi c levels on the digi-\ntal I/O pins, as well as the boundary between digi tal and analog logic for analog circuitry having\noff-chip connections. At system level, all ICs having JTAG capabilities ar e connected serially by\nthe TDI/TDO signals to form a long Shift Register. An external controller sets up the devices to\ndrive values at their output pins, and observe the input values received from other devices. Thecontroller compares the received data with the expected result. In this way, Boundary-scan pro-\nvides a mechanism for testing interconnections and integrity of components on Printed Circuits\nBoards by using the four TAP signals only.\nThe four IEEE 1149.1 defined mandatory JTAG in structions IDCODE, BYPASS, SAMPLE/PRE-\nLOAD, and EXTEST, as well as the AVR specif ic public JTAG instruction AVR_RESET can be\nused for testing the Print ed Circuit Board. Initial scanning of the Data Register path will show the\nID-Code of the device, since IDCODE is the default JTAG instruction. It may be desirable to\nhave the AVR device in reset during test mode. If not reset, inputs to the device may be deter-\nmined by the scan operations, and the internal software may be in an undetermined state whenexiting the test mode. En tering reset, the outputs of any po rt pin will instantly enter the high\nimpedance state, making the HIGHZ instruction redundant. If needed, the BYPASS instruction\ncan be issued to make the shortest possible  scan chain through the device. The device can be\nset in the reset state either by pulling the external RESET\n pin low, or issuing the AVR_RESET\ninstruction with appropriate setting of the Reset Data Register.\nThe EXTEST instruction is used for sampling external pins and loading output pins with data.\nThe data from the output latch will be driven out on the pins as soon as  the EXTEST instruction\nis loaded into the JTAG IR-Register. Therefore, the SAMPLE/PRELOAD should also be used for\nsetting initial values to the scan ring, to avoid damaging the board when issuing the EXTEST\ninstruction for the first time. SAMPLE/PRELOAD c an also be used for taking a snapshot of the\nexternal pins during normal operation of the part.\nThe JTAGEN Fuse must be pr ogrammed and the JTD bit in the I/O Register MCUCR must be\ncleared to enable the JTAG Test Access Port.\nWhen using the JTAG interface for Boundary-scan, using a JTAG TCK clock frequency higher\nthan the internal chip frequency is possible. The chip clock is not required to run.\n28.3 Data Registers\nThe Data Registers relevant for Boundary-scan operations are:\n\u0081 Bypass Register\n\u0081 Device Identification Register\u0081 Reset Register\u0081 Boundary-scan Chain\n\n303\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.3.1 Bypass Register\nThe Bypass Register consists of a single Shift Register stage. When the Bypass Register is\nselected as path between TDI and TDO, the register is reset to 0 when leaving the Capture-DRcontroller state. The Bypass Register can be used to shorten the scan chain on a system when\nthe other devices are to be tested.\n28.3.2 Device Identification Register\nFigure 28-1  shows the structure of the De vice Identification Register.\nFigure 28-1. The Format of the Device Identification Register\n28.3.2.1 Version\nVersion is a 4-bit number identifying the revision of the component. The JTAG version number\nfollows the revision of the device. Revision A is 0x0, revision B is 0x1 and so on.\n28.3.2.2 Part Number\nThe part number is a 16-bit code identifying the component. The JTAG Part Number for\nATmega640/1280/1281/2560/2561 is listed in Table 30-6 on page 338 .\n28.3.2.3 Manufacturer ID\nThe Manufacturer ID is a 11-bit code identifying the manufacturer. The JTAG manufacturer ID\nfor ATMEL is listed in Table 30-6 on page 338 .\n28.3.3 Reset Register\nThe Reset Register is a test Data Register used to reset the part. Since the AVR tri-states Port\nPins when reset, the Reset Register can also replace the function of the unimplemented optional\nJTAG instruction HIGHZ.\nA high value in the Reset Register corresponds to pulling the external Reset low. The part is\nreset as long as there is a high value present in the Reset Register. Depending on the fuse set-\ntings for the clock options, the part will remain reset for a reset time-out period (see \u201cClock\nSources\u201d on page 41 ) after releasing the Reset Register. The output from this Data Register is\nnot latched, so the reset will take place immediately, as shown in Figure 28-2 on page 304 .MSB LSB\nBit 31 28 27 12 11 1 0\nDevice ID Version Part Number Manufacturer ID 1\n4 bits 16 bits 11 bits 1-bit\n\n304\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 28-2. Reset Register\n28.3.4 Boundary-scan Chain\nThe Boundary-scan Chain has the capability of driv ing and observing the lo gic levels on the dig-\nital I/O pins, as well as the boundary between di gital and analog logic for analog circuitry having\noff-chip connections.\nSee \u201cBoundary-scan Chain\u201d on page 305  for a complete description.\n28.4 Boundary-scan Specifi c JTAG Instructions\nThe Instruction Register is 4-bit wide, suppor ting up to 16 instructions. Listed below are the\nJTAG instructions useful for Boundary-scan operation. Note that the optional HIGHZ instructionis not implemented, but all outputs with tri-stat e capability can be set in high-impedant state by\nusing the AVR_RESET instruction,  since the initial state for all port pins is tri-state.\nAs a definition in this datasheet, the LSB is shifted in and out first for all Shift Registers.The OPCODE for each instruction is shown behind the instruction name in hex format. The text\ndescribes which Data Register is selected as  path between TDI and TDO for each instruction.\n28.4.1 EXTEST; 0x0\nMandatory JTAG instruction for selecting the Boundary-scan Chain as Data Register for testing\ncircuitry external to the AVR package. For port- pins, Pull-up Disable, Output Control, Output\nData, and Input Data are all accessible in the scan chain. For Analog ci rcuits having off-chip\nconnections, the interface between the analog and th e digital logic is in the scan chain. The con-\ntents of the latched outputs of the Boundary-scan chain is driven out as soon as the JTAG IR-\nRegister is loaded with  the EXTEST instruction.\nThe active states are:\n\u0081Capture-DR : Data on the external pins are sampled into the Boundary-scan Chain\n\u0081Shift-DR : The Internal Scan Chain is shifted by the TCK input\n\u0081Update-DR : Data from the scan chain is applied to output pins\n28.4.2 IDCODE; 0x1\nOptional JTAG instruction selecting the 32-bit ID-Register as Data Register. The ID-Register\nconsists of a version number, a device number and the manufacturer code chosen by JEDEC.\nThis is the default inst ruction after power-up.DQFrom\nTDI\nClockDR \u00b7 AVR_RE SETTo \nTDO\nFrom Other Internal and\nExternal Reset Sources\nInternal reset\n\n305\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe active states are:\n\u0081Capture-DR : Data in the IDCODE Register is sampled into the Boundary-scan Chain\n\u0081Shift-DR : The IDCODE scan chain is shifted by the TCK input\n28.4.3 SAMPLE_PRELOAD; 0x2\nMandatory JTAG instruction for pre-loading the output latches and taking a snap-shot of the\ninput/output pins without affecting the system operation. However, the output latches are not\nconnected to the pins. The Boundary-scan Chain is selected as Data Register.\nThe active states are:\u0081Capture-DR : Data on the external pins are sampled into the Boundary-scan Chain\n\u0081Shift-DR : The Boundary-scan Chain is shifted by the TCK input\n\u0081Update-DR : Data from the Boundary-scan chain is applied to the output latches. However, \nthe output latches are not connected to the pins\n28.4.4 AVR_RESET; 0xC\nThe AVR specific public JTAG instruction for forcing the AVR device into the Reset mode or\nreleasing the JTAG reset source. The TAP controller is not reset by this in struction. The one bit\nReset Register is selected as Da ta Register. Note that the reset will be active as long as there is\na logic \u201cone\u201d in the Reset Chain. The output from this chain is not latched.\nThe active states are:\n\u0081Shift-DR : The Reset Register is shifted by the TCK input\n28.4.5 BYPASS; 0xF\nMandatory JTAG instructio n selecting the Bypass Register for Data Register.\nThe active states are:\n\u0081Capture-DR : Loads a logic \u201c0\u201d into the Bypass Register\n\u0081Shift-DR : The Bypass Register cell between TDI and TDO is shifted\n28.5 Boundary-scan Chain\nThe Boundary-scan chain has the capability of drivin g and observing the logi c levels on the digi-\ntal I/O pins, as well as the boundary between digi tal and analog logic for analog circuitry having\noff-chip connection.\n28.5.1 Scanning the Digital Port Pins\nFigure 28-3 on page 306  shows the Boundary-scan Cell for a bi-directional port pin. The pull-up\nfunction is disabled during Boundary-scan w hen the JTAG IC contains EXTEST or\nSAMPLE_PRELOAD. The cell consists of a bi-dir ectional pin cell that combines the three sig-\nnals Output Control - OCxn, Output Data - ODxn, and Input Data - IDxn, into only a two-stage\nShift Register. The port and pin indexes are not used in the following description.\nThe Boundary-scan logic is not included in the figures in the datasheet. Figure 28-4 on page 307\nshows a simple digital port pin as described in the section \u201cI/O-Ports\u201d on page 70 . The Bound-\nary-scan details from Figure 28-3 on page 306  replaces the dashed box in Figure 28-4 on page\n307.\nWhen no alternate port function is present, the Input Data - ID - corresponds to the PINxn Regis-\nter value (but ID has no synchronizer), Output Data corresponds to the PORT Register, Output\n\n306\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nControl corresponds to the Data Direction - DD Register, and the Pull-up Enable - PUExn - cor-\nresponds to logic expression PUD  \u00b7 DDxn  \u00b7 PORTxn.\nDigital alternate port functions are connected outside the dotted box in Figure 28-4 on page 307\nto make the scan chain read the actual pin value.  For analog function, there is a direct connec-\ntion from the external pin to the analog circuit. There is no scan chain on the interface between\nthe digital and the analog circuitry, but some digi tal control signal to analog circuitry are turned\noff to avoid driving contention on the pads.\nWhen JTAG IR contains EXTEST or SAMPLE_PRELOAD the clock is not sent out on the port\npins even if the CKOUT fuse is programmed. Ev en though the clock is output when the JTAG IR\ncontains SAMPLE_PRELOAD, the clock is not sampled by the boundary scan.\nFigure 28-3. Boundary-scan Cell for Bi-directional Port Pin with Pull-up Function.\nDQ DQ\nG01\n01\nDQ DQ\nG0\n10101\nPort Pin (PXn)Vcc EXTEST To Next Cell ShiftDR\nOutput Control (OC)\nOutput Data (OD)\nInput Data (ID)\nFrom Last Cell UpdateDR ClockDRFF1 LD1\nLD0 FF00\n1Pull-up Enable (PUE)\n\n307\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 28-4. General Port Pin Schematic Diagram\n28.5.2 Scanning the RESET Pin\nThe RESET pin accepts 5V active low logic fo r standard reset operation, and 12V active high\nlogic for High Voltage Parallel programming. An observe-only cell as shown in Figure 28-5  is\ninserted for the 5V reset signal.\nFigure 28-5. Observe-only CellCLKRPxRRxWRxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWRx: WRITE PORTx\nRRx: READ PORTx REGISTER\nRPx: READ PORTx PINPUD: PULLUP DISABLE\nCLK     : I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQ D\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/OI/OSee Boundary-scan \nDescription for Details!\nPUExn\nOCxn\nODxn\nIDxn\nPUExn: PULLUP ENABLE for pin Pxn\nOCxn: OUTPUT CONTROL for pin PxnODxn: OUTPUT DATA to pin Pxn\nIDxn: INPUT DATA from pin Pxn\n0\n1DQ\nFrom\nPrevious\nCellClockDRShiftDRTo\nNext\nCell\nFrom  System Pin To System Logic\nFF1\n\n308\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.6 Boundary-scan Related Re gister in I/O Memory\n28.6.1 MCUCR \u2013 MCU Control Register\nThe MCU Control Register contains control bits for general MCU functions.\n\u0081 Bits 7 \u2013 JTD: JTAG Interface Disable\nWhen this bit is zero, the JTAG interface is enabl ed if the JTAGEN Fuse is programmed. If this\nbit is one, the JTAG interface is disabled. In or der to avoid unintentional disabling or enabling of\nthe JTAG interface, a timed sequence must be followed when changing this bit: The applicationsoftware must write this bit to the desired value twice within four cycles to change its value. Note\nthat this bit must not be altered when using the On-chip Debug system.\n28.6.2 MCUSR \u2013 MCU Status Register\nThe MCU Status Register provides information on which reset source caused an MCU reset.\n\u0081 Bit 4 \u2013 JTRF: JTAG Reset Flag\nThis bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by\nthe JTAG instruction AVR_RESET. This bit is rese t by a Power-on Reset, or by writing a logic\nzero to the flag.\n28.7 ATmega640/1280/1281/2560/ 2561 Boundary-scan Order\nTable 28-1 on page 309  shows the Scan order between TDI and TDO when the Boundary-scan\nchain is selected as data path. Bit 0 is the LSB; the first bit scanned in, and the first bit scannedout. The scan order follows the pin-out order as fa r as possible. Therefore, the bits of Port A and\nPort K is scanned in the opposite bit order of the other ports. Exceptions from the rules are the\nScan chains for the analog circuits, which constitute the most significant bits of the scan chain\nregardless of which physical pin they are connected to. In Figure 28-3 on page 306 , PXn. Data\ncorresponds to FF0, PXn. Control corresponds to FF1, PXn. Bit 4, bit 5, bit 6 and bit 7 of Port F\nis not in the scan chain, since these pins co nstitute the TAP pins when the JTAG is enabled.\n28.8 Boundary-scan Description Language Files\nBoundary-scan Description Language (BSDL) files describe Boundary-scan capable devices in\na standard format used by automated test-generation software. The order and function of bits in\nthe Boundary-scan Data Register are included in th is description. BSDL files are available for\nATmega1281/2561 and ATmega640/1280/2560.B i t 76543210\n0x35 (0x55) JTD \u2013 \u2013 PUD \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RR R / W RR R / W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x34 (0x54)\n\u2013 \u2013 \u2013J T R F WDRF BORF EXTRF PORF MCUSR\nRead/Wr i t e RRR R / W R/W R/W R/W R/W\nInitial Value 0 0 0 See Bit Description\n\n309\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 28-1. ATmega640/1280/2560 Boundary-scan Order\nBit Number Signal Name Module\n164 PG5.Data\nPort G\n163 PG5.Control\n162 PE0.Data\nPort E161 PE0.Control\n160 PE1.Data\n159 PE1.Control\n158 PE2.Data157 PE2.Control\n156 PE3.Data\n155 PE3.Control154 PE4.Data\n153 PE4.Control\n152 PE5.Data151 PE5.Control\n150 PE6.Data\n149 PE6.Control148 PE7.Data\n147 PE7.Control\n146 PH0.Data\nPort H145 PH0.Control\n144 PH1.Data\n143 PH1.Control142 PH2.Data\n141 PH2.Control\n140 PH3.Data139 PH3.Control\n138 PH4.Data\n137 PH4.Control136 PH5.Data\n135 PH5.Control\n134 PH6.Data\n133 PH6.Control\n\n310\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n132 PB0.Data\nPort B131 PB0.Control\n130 PB1.Data\n129 PB1.Control\n128 PB2.Data\n127 PB2.Control126 PB3.Data\n125 PB3.Control\n124 PB4.Data123 PB4.Control\n122 PB5.Data\n121 PB5.Control120 PB6.Data\n119 PB6.Control\n118 PB7.Data117 PB7.Control\n116 PH7.Data\nPort H\n115 PH7.Control\n114 PG3.Data\nPort G113 PG3.Control\n112 PG4.Data111 PG4.Control\n110 RSTT Reset Logic (Observe Only)\n109 PL0.Data\nPort L108 PL0.Control\n107 PL1.Data\n106 PL1.Control105 PL2.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n311\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n104 PL2.Control\n103 PL3.Data\n102 PL3.Control\n101 PL4.Data\n100 PL4.Control\n99 PL5.Data98 PL5.Control\n97 PL6.Data\n96 PL6.Control95 PL7.Data\n94 PL7.Control\n93 PD0.Data\nPort D92 PD0.Control\n91 PD1.Data\n90 PD1.Control89 PD2.Data\n88 PD2.Control\n87 PD3.Data86 PD3.Control\n85 PD4.Data\n84 PD4.Control83 PD5.Data\n82 PD5.Control\n81 PD6.Data80 PD6.Control\n79 PD7.Data\n78 PD7.Control77 PG0.Data\nPort G76 PG0.Control\n75 PG1.Data74 PG1.Control\n73 PC0.Data\nPort C72 PC0.Control\n71 PC1.Data\n70 PC1.Control69 PC2.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n312\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n68 PC2.Control\n67 PC3.Data\n66 PC3.Control\n65 PC4.Data\n64 PC4.Control\n63 PC5.Data62 PC5.Control\n61 PC6.Data\n60 PC6.Control59 PC7.Data\n58 PC7.Control\n57 PJ0.Data\nPort J56 PJ0.Control\n55 PJ1.Data\n54 PJ1.Control53 PJ2.Data\n52 PJ2.Control\n51 PJ3.Data50 PJ3.Control\n49 PJ4.Data\n48 PJ4.Control47 PJ5.Data\n46 PJ5.Control\n45 PJ6.Data44 PJ6.Control\n43 PG2.Data\nPort G\n42 PG2.Control\n41 PA7.Data\nPort A40 PA7.Control\n39 PA6.Data38 PA6.Control\n37 PA5.Data\n36 PA5.Control\n35 PA4.Data\n34 PA4.Control33 PA3.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n313\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32 PA3.Control\n31 PA2.Data\n30 PA2.Control\n29 PA1.Data\n28 PA1.Control\n27 PA0.Data26 PA0.Control\n25 PJ7.Data\nPort J\n24 PJ7.Control\n23 PK7.Data\nPort K22 PK7.Control\n21 PK6.Data20 PK6.Control\n19 PK5.Data\n18 PK5.Control17 PK4.Data\n16 PK4.Control\n15 PK3.Data14 PK3.Control\n13 PK2.Data\n12 PK2.Control11 PK1.Data\n10 PK1.Control\n9 PK0.Data8 PK0.Control\n7P F 3 . D a t a\nPort F6 PF3.Control\n5P F 2 . D a t a\n4 PF2.Control\n3P F 1 . D a t a2 PF1.Control\n1P F 0 . D a t a\n0 PF0.ControlTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n314\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 28-2. ATmega1281/2561 Boundary-scan Order\nBit Number Signal Name Module\n100 PG5.Data\nPort G\n99 PG5.Control\n98 PE0.Data\nPort E97 PE0.Control\n96 PE1.Data95 PE1.Control\n94 PE2.Data\n93 PE2.Control92 PE3.Data\n91 PE3.Control\n90 PE4.Data89 PE4.Control\n88 PE5.Data\n87 PE5.Control86 PE6.Data\n85 PE6.Control\n84 PE7.Data83 PE7.Control\n82 PB0.Data\nPort B81 PB0.Control\n80 PB1.Data\n79 PB1.Control\n78 PB2.Data77 PB2.Control\n76 PB3.Data\n75 PB3.Control74 PB4.Data\n73 PB4.Control\n72 PB5.Data71 PB5.Control\n70 PB6.Data\n69 PB6.Control\n68 PB7.Data\n67 PB7.Control66 PG3.Data Port G\n\n315\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n65 PG3.Control\n64 PG4.Data\n63 PG4.Control\n62 RSTT Reset Logic (Observe Only)\n61 PD0.Data\nPort D60 PD0.Control\n59 PD1.Data\n58 PD1.Control\n57 PD2.Data56 PD2.Control\n55 PD3.Data\n54 PD3.Control53 PD4.Data\n52 PD4.Control\n51 PD5.Data50 PD5.Control\n49 PD6.Data\n48 PD6.Control47 PD7.Data\n46 PD7.Control\n45 PG0.Data\nPort G44 PG0.Control\n43 PG1.Data\n42 PG1.Control41 PC0.Data\nPort C40 PC0.Control\n39 PC1.Data38 PC1.Control\n37 PC2.Data\n36 PC2.Control35 PC3.Data\n34 PC3.Control\n33 PC4.Data\n32 PC4.Control\n31 PC5.Data30 PC5.ControlTable 28-2. ATmega1281/2561 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n316\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29 PC6.Data\n28 PC6.Control\n27 PC7.Data\n26 PC7.Control\n25 PG2.Data\nPort G\n24 PG2.Control\n23 PA7.Data\nPort A22 PA7.Control\n21 PA6.Data20 PA6.Control\n19 PA5.Data\n18 PA5.Control17 PA4.Data\n16 PA4.Control\n15 PA3.Data14 PA3.Control\n13 PA2.Data\n12 PA2.Control11 PA1.Data\n10 PA1.Control\n9P A 0 . D a t a8P A 0 . C o n t r o l\n7P F 3 . D a t a\nPort F6 PF3.Control\n5P F 2 . D a t a\n4 PF2.Control\n3P F 1 . D a t a2 PF1.Control\n1P F 0 . D a t a\n0 PF0.ControlTable 28-2. ATmega1281/2561 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n317\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29. Boot Loader Support \u2013 Read -While-Write Self-Programming\nThe Boot Loader Support provides a real Read- While-Write Self-Programming mechanism for\ndownloading and uploading program code by the M CU itself. This feature a llows flexible applica-\ntion software updates controlled by the MCU using a Flash-resident Boot Loader program. TheBoot Loader program can use any available data interface and associated protocol to read code\nand write (program) that code into the Flash memory, or read the code from the program mem-\nory. The program code within the Boot Loader section has the capability to write into the entireFlash, including the Boot Loader memory. The B oot Loader can thus even modify itself, and it\ncan also erase itself from the code if the feature is not needed anymore. The size of the Boot\nLoader memory is configurable with fuses and t he Boot Loader has two separate sets of Boot\nLock bits which can be set indepen dently. This gives the user a uniq ue flexibility to select differ-\nent levels of protection.\n29.1 Features\n\u0081Read-While-Write Self-Programming\n\u0081Flexible Boot Memory Size\n\u0081High Security (Separate Boot Lock Bits for a Flexible Protection)\n\u0081Separate Fuse to Select Reset Vector\n\u0081Optimized Page(1) Size\n\u0081Code Efficient Algorithm\n\u0081Efficient Read-Modify-Write Support\nNote: 1. A page is a section in the Flash consisting of several bytes (see Table 30-7 on page 338 ) used \nduring programming. The page organization does not affect normal operation.\n29.2 Application and Boot  Loader Flash Sections\nThe Flash memory is organized in two main sections, the Application section and the Boot\nLoader section (see Figure 29-2 on page 320 ). The size of the different sections is configured by\nthe BOOTSZ Fuses as shown in Table 29-7 on page 328  and Figure 29-2 on page 320 . These\ntwo sections can have different level of protecti on since they have different sets of Lock bits.\n29.2.1 Application Section\nThe Application section is the section of the Flash that is used for storing the application code.\nThe protection level for the Application section can be selected by the application Boot Lock bits(Boot Lock bits 0), see Table 29-2 on page 321 . The Application section can never store any\nBoot Loader code since the SPM instruction is disabled when executed from the Application\nsection.\n29.2.2 BLS \u2013 Boot Loader Section\nWhile the Application section is used for storing the application code, the The Boot Loader soft-\nware must be located in the BLS since the SPM instruction can initiate a programming when\nexecuting from the BLS only. The SPM instruct ion can access the entire Flash, including the\nBLS itself. The protection level for the Boot Loader section can be selected by the Boot LoaderLock bits (Boot Lock bits 1), see Table 29-3 on page 321 .\n29.3 Read-While-Write and No R ead-While-Write Flash Sections\nWhether the CPU supports Read- While-Write or if the CPU is halted during a Boot Loader soft-\nware update is dependent on which address that is being programmed. In addition to the twosections that are configurable by the BOOTSZ  Fuses as described above, the Flash is also\n\n318\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ndivided into two fixed sections, the Read- While-Write (R WW) section and the No Read- While-\nWrite (NR WW) section. The limit between the R WW- and NR WW sections is given in Table 29-\n1 and Figure 29-1 on page 319 . The main difference between the two sections is:\n\u0081When erasing or writing a page located inside the R WW section, the NR WW section can be \nread during the operation\n\u0081When erasing or writing a page located inside the NR WW section, the CPU is halted during \nthe entire operation\nNote that the user software can never read any code that is located inside the R WW section dur-\ning a Boot Loader software operation. The syntax \u201cRead- While-Write section\u201d refers to which\nsection that is being programmed (erased or written), not which section that actually is being\nread during a Boot Loader software update.\n29.3.1 RWW \u2013 Read-While-Write Section\nIf a Boot Loader software update is programming a page inside the R WW section, it is possible\nto read code from the Flash, but only code that is located in the NR WW section. During an on-\ngoing programming, the software must ensure that the R WW section never is being read. If the\nuser software is trying to read code that is located inside the R WW section (that is, by load pro-\ngram memory, call, or jump instructions or an interrupt) during programming, the software might\nend up in an unknown state. To avoid this, the in terrupts should either be disabled or moved to\nthe Boot Loader section. The Boot Loader section is always located in the NR WW section. The\nRWW Section Busy bit (R WWSB) in the Store Program Memory Control and Status Register\n(SPMCSR) will be read as lo gical one as long as the R WW section is blocked for reading. After\na programming is completed, the R WWSB must be cleared by software before reading code\nlocated in the R WW section. See \u201cSPMCSR \u2013 Store Program Memory Control and Status Reg-\nister\u201d on page 332.  for details on how to clear R WWSB.\n29.3.2 NRWW \u2013 No Read-While-Write Section\nThe code located in the NR WW section can be read when the Boot Loader software is updating\na page in the R WW section. When the Boot Loader code updates the NR WW section, the CPU\nis halted during the entire Page Erase or Page Write operation.\nTable 29-1. Read- While-Write Features\nWhich Section does the Z-pointer\nAddress during the Programming?Which Section can be \nRead during Programming? CPU Halted?Read-While-Write \nSupported?\nRWW Section NR WW Section No Yes\nNRWW Section None Y es No\n\n319\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 29-1. Read- While-Write vs. No Read- While-Write\nRead-While-Write\n(RWW) Section\nNo Read-While-Write \n(NRWW) SectionZ-pointer\nAddresses RWWSectionZ-pointer\nAddresses NRWWSection\nCPU is Halted\nDuring the Operation\nCode Located in \nNRWW Section\nCan be Read Duringthe Operation\n\n320\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 29-2. Memory Sections\nNote: 1. The parameters in the figure above are given in Table 29-7 on page 328 .\n29.4 Boot Loader Lock Bits\nIf no Boot Loader capability is n eeded, the entire Flash is available for application code. The\nBoot Loader has two separate sets of Boot Lock bits which can be set independently. This givesthe user a unique flexibility to sele ct different levels  of protection.\nThe user can select:\n\u0081 To protect the entire Flash from a software update by the MCU\n\u0081 To protect only the Boot Loader Flash section from a software update by the MCU\u0081 To protect only the Application Flash section from a software update by the MCU\u0081 Allow software update in the entire FlashSee Table 29-2 on page 321  and Table 29-3 on page 321  for further details. The Boot Lock bits\ncan be set in software and in Serial or Parallel Programming mode, but they can be cleared by a\nChip Erase command only. The general Write Lock (Lock Bit mode 2) does not control the pro-\ngramming of the Flash memory by SPM instruction. Similarly, the general Read/ Write Lock\n(Lock Bit mode 1) does not control reading nor writing by (E)LPM/SPM, if it is attempted.0x0000\nFlashendProgram Memory\nBOOTSZ = '11'\nApplication Flash Section\nBoot Loader Flash Section\nFlashendProgram Memory\nBOOTSZ = '10'\n0x0000Program Memory\nBOOTSZ = '01'Program Memory\nBOOTSZ = '00'Application Flash Section\nBoot Loader Flash Section0x0000\nFlashendApplication Flash Section\nFlashendEnd RWW\nStart NRWWApplication Flash Section\nBoot Loader Flash Section\nBoot Loader Flash SectionEnd RWW\nStart NRWWEnd RWW\nStart NRWW\n0x0000\nEnd RWW, End Application\nStart NRWW, Start Boot LoaderApplication Flash Section Application Flash Section\nApplication Flash Section\nRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionEnd Application\nStart Boot LoaderEnd Application\nStart Boot Loader\nEnd Application\nStart Boot Loader\n\n321\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\n29.4.1 Entering the Boot Loader Program\nEntering the Boot Loader takes place by a jump or call from the application program. This may\nbe initiated by a trigger such as a command received via USART, or SPI interface. Alternatively,\nthe Boot Reset Fuse can be programmed so that the Reset Vector is pointing to the Boot Flashstart address after a reset. In this case, the Boot Loader is started after a reset. After the applica-\ntion code is loaded, the program can start execut ing the application code. Note that the fuses\ncannot be changed by the MCU itself. This means that once the Boot Reset Fuse is pro-grammed, the Reset Vector will always point to the Boot Loader Reset and the fuse can only be\nchanged through the serial or parallel programming interface.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.Table 29-2. Boot Lock Bit0 Protection Modes (Application Section)(1)\nBLB0 Mode BLB02 BLB01 Protection\n11 1No restrictions for SPM or (E)LPM accessing the Application \nsection.\n2 1 0 SPM is not allowed to write to the Application section.\n30 0SPM is not allowed to write to the Application section, and \n(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application sectio n. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\n40 1(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application sectio n. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\nTable 29-3. Boot Lock Bit1 Protection Modes (Boot Loader Section)(1)\nBLB1 Mode BLB12 BLB11 Protection\n11 1No restrictions for SPM or (E)L PM accessing the Boot Loader \nsection.\n2 1 0 SPM is not allowed to write to the Boot Loader section.\n30 0SPM is not allowed to write to the Boot Loader section, and \n(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader section. If Interrupt Vectors are placed in the Application section, interrupts are disabled while \nexecuting from the B oot Loader section.\n40 1(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader section. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while \nexecuting from the B oot Loader section.\nTable 29-4. Boot Reset Fuse(1)\nBOOTRST Reset Address\n1 Reset Vector = Application Reset (address 0x0000)\n0 Reset Vector = Boot Loader Reset (see Table 29-7 on page 328 )\n\n322\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.5 Addressing the Flash During Self-Programming\nThe Z-pointer is used to address the SPM commands. The Z pointer consists of the Z-registers\nZL and ZH in the register file, and RAMPZ in the I/O space. The number of bits actually used is\nimplementation dependent. Note that the RAMPZ register is only implemented when the pro-gram space is larger than 64Kbytes.\nSince the Flash is organized in pages (see Table 30-7 on page 338 ), the Program Counter can\nbe treated as having two different sections. One sect ion, consisting of the least significant bits, is\naddressing the words within a page, while the most significant bits are addressing the pages.\nThis is shown in Figure 29-3 . Note that the Page Erase and Page Write operations are\naddressed independently. Therefore it is of major importance that the Boot Loader softwareaddresses the same page in both the Page Erase and Page Write operation. Once a program-\nming operation is initiated, the address is latched and the Z-pointer can be used for other\noperations.\nThe (E)LPM instruction use the Z-pointer to st ore the address. Since this instruction addresses\nthe Flash byte-by-byte, also bit Z0 of the Z-pointer is used.\nFigure 29-3. Addressing the Flash During SPM\n(1)\nNote: 1. The different variables used in Figure 29-3  are listed in Table 29-9 on page 329 .B i t 2 32 22 12 01 91 81 71 6\n15 14 13 12 11 10 9 8\nRAMPZ RAMPZ7 RAMPZ6 RAMPZ5 RAMPZ4 RAMPZ3 RAMPZ2 RAMPZ1 RAMPZ0ZH (R31) Z15 Z14 Z13 Z12 Z11 Z10 Z9 Z8Z L  ( R 3 0 ) Z 7Z 6Z 5Z 4Z 3Z 2Z 1Z 0\n76543210\nPROGRAM MEMORY01 15\nZ - REGI STERBIT\n0ZPAGEM SB\nWORD ADDRE SS\nWITHIN A PAGEPAGE ADDRE SS\nWITHIN THE FLA SHZPCM SB\nINSTRUCTION WORDPAGEPCWORD[PAGEM SB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCM SB PAGEM SB\nPROGRAM\nCOUNTER\n\n323\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6 Self-Programming the Flash\nThe program memory is updated in a page by page fashion. Before programming a page with\nthe data stored in the temporary page buffer, the page must be erased. The temporary page buf-\nfer is filled one word at a time using SPM and the buffer can be filled either before the PageErase command or between a Page Erase and a Page Write operation:\nAlternative 1, fill the bu ffer before a Page Erase\n\u0081 Fill temporary page buffer\n\u0081 Perform a Page Erase\u0081 Perform a Page Write\nAlternative 2, fill the bu ffer after Page Erase\n\u0081 Perform a Page Erase\n\u0081 Fill temporary page buffer\u0081 Perform a Page Write\nIf only a part of the page needs to be changed, the rest of the page must be stored (for example\nin the temporary page buffer) before the erase, and then be rewritten. When using alternative 1,\nthe Boot Loader provides an effective Read-Modify- Write feature which allows the user software\nto first read the page, do the necessary changes, and then write back the modified data. If alter-\nnative 2 is used, it is not possible to read the old data while loading since the page is already\nerased. The temporary page buffer can be accessed in a random sequence. It is essential thatthe page address used in both the Page Erase and Page Write operation is addressing the same\npage. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on page 327  for an assembly\ncode example.\n29.6.1 Performing Page Erase by SPM\nTo execute Page Erase, set up the address in the Z-pointer, write \u201cX0000011\u201d to SPMCSR and\nexecute SPM within four clock cycles after writing SPMCSR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE in the Z-register. Other bits in the Z-pointer will\nbe ignored during this operation.\n\u0081 Page Erase to the R WW section: The NR WW section can be read during the Page Erase\n\u0081 Page Erase to the NR WW section: The CPU is halted during the operation\n29.6.2 Filling the Temporary Buffer (Page Loading)\nTo write an instruction word, set up the address in the Z-pointer and data in R1:R0, write\n\u201c00000001\u201d to SPMCSR and execute SPM within four  clock cycles after writing SPMCSR. The\ncontent of PC WORD in the Z-register is used to address the data in the temporary buffer. The\ntemporary buffer will auto-erase after a Page Write operation or by writing the R WWSRE bit in\nSPMCSR. It is also erased after a system reset. Note that it is not possible to write more thanone time to each address without erasing the temporary buffer.\nIf the EEPROM is written in the middle of an SPM Page Load oper ation, all data loaded is still\nbuffered.\n\n324\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.3 Performing a Page Write\nTo execute Page Write, set up the address in the Z-pointer, write \u201cX0000101\u201d to SPMCSR and\nexecute SPM within four clock cycles after writing SPMCSR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE. Other bits in the Z-pointer must be written to\nzero during this operation.\n\u0081 Page Write to the R WW section: The NR WW section can be read during the Page Write\n\u0081 Page Write to the NR WW section: The CPU is halted during the operation\n29.6.4 Using the SPM Interrupt\nIf the SPM interrupt is en abled, the SPM interrupt will genera te a constant in terrupt when the\nSPMEN bit in SPMCSR is cleared. This means th at the interrupt can be used instead of polling\nthe SPMCSR Register in software. When using the SPM interrupt, the Interrupt Vectors should\nbe moved to the BLS section to avoid that an interrupt is accessing the R WW section when it is\nblocked for reading. How to move the interrupts is described in \u201cInterrupts\u201d on page 105 .\n29.6.5 Consideration While Updating BLS\nSpecial care must be taken if the user allows the Boot Loader section to be updated by leaving\nBoot Lock bit11 unprogrammed. An accidental write to the Boot Loader itself can corrupt the\nentire Boot Loader, and further software updates might  be impossible. If it is not necessary to\nchange the Boot Loader software itself, it is recommended to program the Boot Lock bit11 to\nprotect the Boot Loader software from any internal software changes.\n29.6.6 Prevent Reading the RWW Section During Self-Programming\nDuring Self-Programming (either Page Erase or Page Write), the R WW section is always\nblocked for reading. The user software itself must prevent that this section is addressed duringthe self programming operation. The R WWSB in the SPMCSR will be set as long as the R WW\nsection is busy. During Self-Programming the Interrupt Vector table should be moved to the BLS\nas described in \u201cInterrupts\u201d on page 105 , or the interrupts must be disabled. Before addressing\nthe RWW section after the programming is completed, the user software must clear the\nRWWSB by writing the R WWSRE. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on\npage 327  for an example.\n29.6.7 Setting the Boot Loader Lock Bits by SPM\nTo set the Boot Loader Lock bits and general Lock bits, write the desired data to R0, write\n\u201cX0001001\u201d to SPMCSR and execute SPM within four clock cycles after writing SPMCSR.\nSee Table 29-2 on page 321  and Table 29-3 on page 321  for how the different settings of the\nBoot Loader bits affect the Flash access.\nIf bits 5:0 in R0 are cleare d (zero), the corresponding Loc k bit will be programmed if an SPM\ninstruction is exec uted within four cycles after BLBSET and SPMEN are set in SPMCSR. The Z-\npointer is don\u2019t care during this operation, but fo r future compatibility it is recommended to load\nthe Z-pointer with 0x0001 (same as used for reading the lO\nck bits). For future compatibility it is\nalso recommended to set bits 7 and 6 in R0 to \u201c1\u201d when writing the Lock bits. When program-\nming the Lock bits the entire Flas h can be read during the operation.B i t 76543210\nR0 1 1 BLB12 BLB11 BLB02 BLB01 LB2 LB1\n\n325\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.8 EEPROM Write Prevents Writing to SPMCSR\nNote that an EEPROM write oper ation will block all software progra mming to Flash. Reading the\nFuses and Lock bits  from software will also  be prevented during the EEPROM write operation. It\nis recommended that the user checks the status bit (EEPE) in the EECR Register and verifies\nthat the bit is cleared before writing to the SPMCSR Register.\n29.6.9 Reading the Fuse and Lock Bits from Software\nIt is possible to read both the Fuse and Lock bits from software. To read the Lock bits, load the\nZ-pointer with 0x0001 and set the BLBSET and SPMEN bits in SPMCSR. When an (E)LPM\ninstruction is executed within three CPU cycles after the BLBSET and SPMEN bits are set in\nSPMCSR, the value of the Lock bi ts will be loaded in the desti nation register. The BLBSET and\nSPMEN bits will auto-clear upon comple tion of reading the Lock bits  or if no (E)LPM instruction\nis executed within three CPU cycles or no SPM instruction is executed within four CPU cycles.\nWhen BLBSET and SPMEN are cleared, (E )LPM will work as described in the Instruction set\nManual .\nThe algorithm for reading the Fuse Low byte is  similar to the one described above for reading\nthe Lock bits. To read the Fuse Low byte, load the Z-pointer with 0x0000 and set the BLBSET\nand SPMEN bits in SPMCSR. When an (E)LPM instruction is executed within three cycles after\nthe BLBSET and SPMEN bits are set in the SPMC SR, the value of the Fuse Low byte (FLB) will\nbe loaded in the destination register as shown below. Refer to Table 30-5 on page 337  for a\ndetailed description and mapping of the Fuse Low byte.\nSimilarly, when reading the Fuse High byte, load 0x0003 in the Z-pointer. When an (E)LPM\ninstruction is executed within three cycles after the BLBSET and SPMEN bits are set in the\nSPMCSR, the value of the Fuse High byte (FHB ) will be loaded in the destination register as\nshown below. Refer to Table 30-4 on page 337  for detailed description and mapping of the Fuse\nHigh byte.\nWhen reading the Extended Fuse byte, load 0x0002 in the Z-pointer. When an (E)LPM instruc-\ntion is executed within three cycles after the BLBSET and SPMEN bits are set in the SPMCSR,\nthe value of the Exten ded Fuse byte (EFB) will be loaded in  the destination r egister as shown\nbelow. Refer to Table 30-3 on page 336  for detailed description and mapping of the Extended\nFuse byte.\nFuse and Lock bits that are programmed, will be read as zero. Fuse and Lock bits that are\nunprogrammed, will be  read as one.\n29.6.10 Reading the Signature Row from Software\nTo read the Signature Row from software, load the Z-pointer with the signature byte address\ngiven in Table 29-5 on page 326  and set the SIGRD and SPMEN bits in SPMCSR. When an\nLPM instruction is executed within three CPU cycles after the SIGRD and SPMEN bits are set inB i t 76543210\nRd \u2013 \u2013 BLB12 BLB11 BLB02 BLB01 LB2 LB1\nB i t 76543210\nRd FLB7 FLB6 FLB5 FLB4 FLB3 FLB2 FLB1 FLB0\nB i t 76543210\nRd FHB7 FHB6 FHB5 FHB4 FHB3 FHB2 FHB1 FHB0\nB i t 76543210\nRd \u2013 \u2013 \u2013 \u2013 \u2013 EFB2 EFB1 EFB0\n\n326\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSPMCSR, the signature byte valu e will be loaded in the destin ation register. The SIGRD and\nSPMEN bits will auto-clear upon completion of re ading the Signature Row Lo ck bits or if no LPM\ninstruction is executed within three CPU cycles. When SIGRD and SPMEN are cleared, LPM will\nwork as described in the Instruction set Manual .\nNote: All other addresses are reserved for future use.\n29.6.11 Preventing Flash Corruption\nDuring periods of low VCC, the Flash program can be corrupted because the supply voltage is\ntoo low for the CPU and the Flash to operate properly. These issues are the same as for board\nlevel systems using the Flash, and the same design solutions should be applied.\nA Flash program corruption can be caused by two situ ations when the voltage is too low. First, a\nregular write sequence to the Flash requires a minimum voltage to operate correctly. Secondly,\nthe CPU itself can execute instruct ions incorrectly, if the supply voltage for executing instructions\nis too low.\nFlash corruption can easily be avoided by following these design recommendations (one is\nsufficient):\n1. If there is no need for a Boot Loader update in the system, program the Boot Loader Lock \nbits to prevent any Boot Loader software updates.\n2. Keep the AVR RESET active (low) during peri ods of insufficient power supply voltage. \nThis can be done by enabling the internal Brown-out Detector (BOD) if the operating volt-age matches the detection level. If not, an external low V\nCC reset protection circuit can be \nused. If a reset occurs while a write operatio n is in progress, the write operation will be \ncompleted provided that the power supply voltage is sufficient.\n3. Keep the AVR core in Power-down sleep mode during periods of low VCC. This will pre-\nvent the CPU from attempting to decode and execute instructions, effectively protecting the SPMCSR Register and thus the Flash from unintentional writes.\n29.6.12 Programming Time for Flash when Using SPM\nThe calibrated RC Oscillator is  used to time Flash accesses. Table 29-6  shows the typical pro-\ngramming time for Flash accesses from the CPU.Table 29-5. Signature Row Addressing\nSignature Byte Z-Pointer Address\nDevice Signature Byte 1 0x0000Device Signature Byte 2 0x0002\nDevice Signature Byte 3 0x0004\nRC Oscillator Calibration Byte 0x0001\nTable 29-6. SPM Programming Time\nSymbol Min Programming Time Max Programming Time\nFlash write (Page Erase, Page Write, and \nwrite Lock bits by SPM)3.7ms 4.5ms\n\n327\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.13 Simple Assembly Code Example for a Boot Loader\n;-the routine writes one page of data from RAM to Flash\n; the first data location in RAM is pointed to by the Y pointer; the first data location in Flash is pointed to by the Z-pointer\n;-error handling is not included\n;-the routine must be placed inside the Boot space; (at least the Do_spm sub routine). Only code inside NRWW section can\n; be read during Self-Programming (Page Erase and Page Write).\n;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24), \n; loophi (r25), spmcrval (r20)\n; storing and restoring of registers is not included in the routine; register usage can be optimized at the expense of code size\n;-It is assumed that either the interrupt table is moved to the Boot\n; loader section or that the interrupts are disabled.\n.equ PAGESIZEB = PAGESIZE*2 ;PAGESIZEB is page size in BYTES, not words\n.org SMALLBOOTSTART\nWrite_page:\n; Page Erase\nldi spmcrval, (1<<PGERS) | (1<<SPMEN)\ncall Do_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)call Do_spm\n; transfer data from RAM to Flash page buffer\nldi looplo, low(PAGESIZEB) ;init loop variable\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nWrloop:\nld r0, Y+\nld r1, Y+\nldi spmcrval, (1<<SPMEN)call Do_spm\nadiw ZH:ZL, 2\nsbiw loophi:looplo, 2 ;use subi for PAGESIZEB<=256brne Wrloop\n; execute Page Write\nsubi ZL, low(PAGESIZEB) ;restore pointer\nsbci ZH, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nldi spmcrval, (1<<PGWRT) | (1<<SPMEN)call Do_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\ncall Do_spm\n; read back and check, optional\nldi looplo, low(PAGESIZEB) ;init loop variable\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256subi YL, low(PAGESIZEB) ;restore pointer\nsbci YH, high(PAGESIZEB)\nRdloop:\nelpm r0, Z+\nld r1, Y+cpse r0, r1\njmp Error\nsbiw loophi:looplo, 1 ;use subi for PAGESIZEB<=256brne Rdloop\n\n328\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n; return to RWW section\n; verify that RWW section is safe to read\nReturn:\nin temp1, SPMCSRsbrs temp1, RWWSB ; If RWWSB is set, the RWW section is not ready yet\nret\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\ncall Do_spmrjmp Return\nDo_spm:\n; check for previous SPM complete\nWait_spm:\nin temp1, SPMCSRsbrc temp1, SPMEN\nrjmp Wait_spm\n; input: spmcrval determines SPM action; disable interrupts if enabled, store status\nin temp2, SREG\ncli; check that no EEPROM write access is present\nWait_ee:\nsbic EECR, EEPErjmp Wait_ee\n; SPM timed sequence\nout SPMCSR, spmcrvalspm\n; restore SREG (to enable interrupts if originally enabled)\nout SREG, temp2ret\n29.6.14 ATmega640 Boot Loader Parameters\nIn Table 29-7  through Table 29-9 on page 329 , the parameters used in the description of the\nSelf-Programming are given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .Table 29-7. Boot Size Configuration, ATmega640(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset\nAddress\n(Start Boot Loader Section)\n11512\nwords40x0000 - \n0x7DFF0x7E00 - \n0x7FFF0x7DFF 0x7E00\n101024\nwords80x0000 - \n0x7BFF0x7C00 - \n0x7FFF0x7BFF 0x7C00\n012048\nwords160x0000 - \n0x77FF0x7800 - \n0x7FFF0x77FF 0x7800\n004096\nwords320x0000 - \n0x6FFF0x7000 - \n0x7FFF0x6FFF 0x7000\n\n329\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page \n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .\nNote: 1. Z0: should be zero for all SPM commands, byte select for the (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.Table 29-8. Read- While-Write Limit, ATmega640\nSection(1)Pages Address\nRead- While-Write section (R WW) 224 0x0000 - 0x6FFF\nNo Read- While-Write section (NR WW) 32 0x7000 - 0x7FFF\nTable 29-9. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega640\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 14Most significant bit in the Program Counter. \n(The Program Counter is 15 bits PC[14:0]).\nPAGEMSB 6Most significant bit which is used to address \nthe words within one page (128 words in a \npage requires seven bits PC [6:0]).\nZPCMSB Z15Bit in Z-pointer that is mapped to PCMSB. \nBecause Z0 is not used, the ZPCMSB equals \nPCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. \nBecause Z0 is not used, the ZPAGEMSB \nequals PAGEMSB + 1.\nPCPAGE PC[14:7] Z15:Z8Program Counter page address: Page select, \nfor Page Erase and Page Write.\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, \nfor filling temporary buffer (must be zero \nduring Page Write operation).\n\n330\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.15 ATmega1280/1281 Boot Loader Parameters\nIn Table 29-10  and Table 29-11 , the parameters used in the description of the Self-Programming\nare given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page\n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .Table 29-10. Boot Size Configuration, ATmega1280/1281(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset Address\n(Start Boot LoaderSection)\n11512\nwords40x0000 - \n0xFDFF0xFE00 - \n0xFFFF0xFDFF 0xFE00\n101024\nwords80x0000 - \n0xFBFF0xFC00 - \n0xFFFF0xFBFF 0xFC00\n012048\nwords160x0000 - \n0xF7FF0xF800 - \n0xFFFF0xF7FF 0xF800\n004096\nwords320x0000 - \n0xEFFF0xF000 - \n0xFFFF0xEFFF 0xF000\nTable 29-11. Read- While-Write Limit, ATmega1280/1281\nSection(1)Pages Address\nRead- While-Write section (R WW) 480 0x0000 - 0xEFFF\nNo Read- While-Write section (NR WW) 32 0xF000 - 0xFFFF\nTable 29-12. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega1280/1281\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 15Most significant bit in the Program Counter. (The \nProgram Counter is 16 bits PC[15:0])\n\n331\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. Z0: should be zero for all SPM command s, byte select for t he (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.\n3. The Z-register is only 16 bits wide. Bit 16 is  located in the RAMPZ register in the I/O map.\n29.6.16 ATmega2560/2561 Boot Loader Parameters\nIn Table 29-13  through Table 29-15 on page 332 , the parameters used in the description of the\nSelf-Programming are given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .PAGEMSB 6Most significant bit which is used to address the \nwords within one page (128 words in a page \nrequires seven bits PC [6:0]).\nZPCMSB Z16(3) Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPCMSB equals PCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPAGEMSB equals PAGEMSB + \n1.\nPCPAGE PC[15:7] Z16(3):Z8Program Counter page address: Page select, for \nPage Erase and Page Write\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, for \nfilling temporary buffer (must be zero during Page \nWrite operation)Table 29-12. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega1280/1281 (Continued)\nVariableCorresponding\nZ-value(2)Description(1)\nTable 29-13. Boot Size Configuration, ATmega2560/2561(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset Address\n(Start Boot LoaderSection)\n11512\nwords40x00000 - \n0x1FDFF0x1FE00 - \n0x1FFFF0x1FDFF 0x1FE00\n101024\nwords80x00000 - \n0x1FBFF0x1FC00 - \n0x1FFFF0x1FBFF 0x1FC00\n012048\nwords160x00000 - \n0x1F7FF0x1F800 - \n0x1FFFF0x1F7FF 0x1F800\n004096\nwords320x00000 - \n0x1EFFF0x1F000 - \n0x1FFFF0x1EFFF 0x1F000\n\n332\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page \n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .\nNotes: 1. Z0: should be zero for all SPM command s, byte select for t he (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.\n3. The Z-register is only 16 bits wide. Bit 16 is  located in the RAMPZ register in the I/O map.\n29.7 Register Description\n29.7.1 SPMCSR \u2013 Store Program Memory Control and Status Register\nThe Store Program Memory Control and Status Register contains the control bits needed to con-\ntrol the Boot Loader operations.\n\u0081 Bit 7 \u2013 SPMIE: SPM Interrupt Enable\nWhen the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM\nready interrupt will be enabled. The SPM ready In terrupt will be ex ecuted as long as the SPMEN\nbit in the SPMCSR Register is cleared.Table 29-14. Read- While-Write Limit, ATmega2560/2561\nSection(1)Pages Address\nRead- While-Write section (R WW) 992 0x00000 - 0x1EFFF\nNo Read- While-Write section (NR WW) 32 0x1F000 - 0x1FFFF\nTable 29-15. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega2560/2561\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 16Most significant bit in the Program Counter. (The \nProgram Counter is 17 bits PC[16:0]).\nPAGEMSB 6Most significant bit which is used to address the \nwords within one page (128 words in a page \nrequires seven bits PC [6:0]).\nZPCMSB Z17:Z16(3) Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPCMSB equals PCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPAGEMSB equals PAGEMSB + \n1.\nPCPAGE PC[16:7] Z17(3):Z8Program Counter page address: Page select, for \nPage Erase and Page Write.\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, for \nfilling temporary buffer (must be zero during Page Write operation).\nBit 7 6 5 4 3 2 1 0\n0x37 (0x57) SPMIE RWWSB SIGRD RWWSRE BLBSET PGWRT PGERS SPMEN SPMCSR\nRead/Write R/ W RR / W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n333\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 RWWSB: Read-While-Write Section Busy\nWhen a Self-Programming (Page Erase or Page Write) operation to the R WW section is initi-\nated, the R WWSB will be set (one) by hardware. When the R WWSB bit is set, the R WW section\ncannot be accessed. The R WWSB bit will be cleared if the R WWSRE bit is written to one after a\nSelf-Programming operation is completed. Alternatively the R WWSB bit will automatically be\ncleared if a page load operation is initiated.\n\u0081 Bit 5 \u2013 SIGRD: Signature Row Read\nIf this bit is written to one at the same time as SPMEN, the next LPM instruction within three\nclock cycles will read a byte from the signatu re row into the dest ination register. see \u201cReading\nthe Signature Row from Software\u201d on page 325  for details. An SPM inst ruction within four cycles\nafter SIGRD and SPMEN are set will have no effect. This operation is reserved for future useand should not be used.\n\u0081 Bit 4 \u2013 RWWSRE: Read-While-Write Section Read Enable\nWhen programming (Page Erase or Page Write) to the R WW section, the R WW section is\nblocked for reading (the R WWSB will be set by hardware). To re-enable the R WW section, the\nuser software must wait unt il the programming is complet ed (SPMEN will be cl eared). Then, if\nthe RWWSRE bit is written to one at the same time  as SPMEN, the next SPM instruction within\nfour clock cycles re-enables the R WW section. The R WW section cannot be re-enabled while\nthe Flash is busy with a Page Erase or a Page Write (SPMEN is set). If the R WWSRE bit is writ-\nten while the Flash is being loaded, the Flas h load operation will abort and the data loaded will\nbe lost.\n\u0081 Bit 3 \u2013 BLBSET: Boot Lock Bit Set\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles sets Boot Lock bits, according to the data in R0. The data in R1 and the address in the Z-pointer are ignored. The BLBSET bit will autom atically be cleared upon completion of the Lock\nbit set, or if no SPM instruction is executed within four clock cycles.\nAn (E)LPM instructio n within three cycles after BLBSET and SPMEN are set in the SPMCSR\nRegister, will read either the Lock bits or the Fuse bits (depending on Z0 in th e Z-pointer) into the\ndestination register. See \u201cReading the Fuse and Lock Bits from Software\u201d on page 325  for\ndetails.\n\u0081 Bit 2 \u2013 PGWRT: Page Write\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes Page Write, with the data stored in the temporary buffer. The page address is\ntaken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PG WRT bit\nwill auto-clear upon co mpletion of a Page Write, or if no SPM instruction is executed within four\nclock cycles. The CPU is halted during the entire Page W\nrite operation if the NR WW section is\naddressed.\n\u0081 Bit 1 \u2013 PGERS: Page Erase\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes Page Erase. The page address is taken from the high part of the Z-pointer. The\ndata in R1 and R0  are ignored. The PGERS bi t will auto-clear upon comp letion of a Page Erase,\nor if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire\nPage Write operation if the NR WW section is addressed.\n\n334\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 SPMEN: Store Program Memory Enable\nThis bit enables the SPM instruction for the next four clock cycles. If written to one together with\neither R WWSRE, BLBSET, PG WRT\u2019 or PGERS, the following SPM instruction will have a spe-\ncial meaning, see description abo ve. If only SPMEN is written, the following SPM instruction will\nstore the value in R1:R0 in the temporary page buffer addressed by the Z-pointer. The LSB of\nthe Z-pointer is ignored. The SPMEN bit will aut o-clear upon completion of an SPM instruction,\nor if no SPM instruction is executed within four clock cycles. During Page Erase and Page Write,\nthe SPMEN bit remains high until the operation is completed.\nWriting any other combination than \u201c10001\u201d, \u201c01001\u201d, \u201c00101\u201d, \u201c00011\u201d or \u201c00001\u201d in the lower\nfive bits will have no effect.\nNote: Only one SPM instruction should be active at any time.\n\n335\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30. Memory Programming\n30.1 Program And Data Memory Lock Bits\nThe ATmega640/1280/1281/2560/2561 provides six Lock bits which can be left unprogrammed\n(\u201c1\u201d) or can be programmed (\u201c0\u201d) to obtain the additional features listed in Table 30-2 . The Lock\nbits can only be erased to \u201c1\u201d with the Chip Erase command.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmedTable 30-1. Lock Bit Byte(1)\nLock Bit Byte Bit No Description Default Value\n7 \u2013 1 (unprogrammed)\n6 \u2013 1 (unprogrammed)\nBLB12 5 Boot Lock bit 1 (unprogrammed)\nBLB11 4 Boot Lock bit 1 (unprogrammed)\nBLB02 3 Boot Lock bit 1 (unprogrammed)BLB01 2 Boot Lock bit 1 (unprogrammed)\nLB2 1 Lock bit 1 (unprogrammed)\nLB1 0 Lock bit 1 (unprogrammed)\nTable 30-2. Lock Bit Protection Modes(1)(2) \nMemory Lock Bits Protection Type\nLB Mode LB2 LB1\n1 1 1 No memory lock features enabled.\n21 0Further programming of the Flash and EEPROM is disabled in \nParallel and Serial Programming mode. The Fuse bits are \nlocked in both Serial and Parallel Programming mode.(1)\n30 0Further programming and verification of the Flash and EEPROM \nis disabled in Parallel and Serial Programming mode. The Boot \nLock bits and Fuse bits are locked in both Serial and Parallel Programming mode.\n(1)\nBLB0 Mode BLB02 BLB01\n11 1No restrictions for SPM or (E)LPM accessing the Application \nsection.\n2 1 0 SPM is not allowed to write to the Application section.\n30 0SPM is not allowed to write to  the Application section, and \n(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application section. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while executing from the Application section.\n40 1(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application section. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\n\n336\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. Program the Fuse bits and Boot Lock bits before programming the LB1 and LB2.\n2. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\n30.2 Fuse Bits\nThe ATmega640/1280/1281/2560/2561 has three Fuse bytes. Table 30-3  through Table 30-5 on\npage 337  describe briefly the functionality of all the fuses and how they are mapped into the\nFuse bytes. Note that the fuses are read as logical zero, \u201c0\u201d, if they are programmed.\nNote: 1. See \u201cSystem and Reset Characteristics\u201d on page 372  for BODLEVEL Fuse decoding.BLB1 Mode BLB12 BLB11\n11 1No restrictions for SPM or (E)LPM accessing the Boot Loader \nsection.\n2 1 0 SPM is not allowed to write to the Boot Loader section.\n30 0SPM is not allowed to write to the Boot Loader section, and \n(E)LPM executing from the Application section is not allowed to read from the Boot Loader sect ion. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while \nexecuting from the Boot Loader section.\n40 1(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader sect ion. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while executing from the Boot Loader section.Table 30-2. Lock Bit Protection Modes(1)(2)  (Continued)\nMemory Lock Bits Protection Type\nTable 30-3. Extended Fuse Byte\nExtended Fuse Byte Bit No Description Default Value\n\u20137 \u2013 1\n\u20136 \u2013 1\u20135 \u2013 1\n\u20134 \u2013 1\n\u20133 \u2013 1\nBODLEVEL2\n(1)2 Brown-out Detector trigger level 1 (unprogrammed)\nBODLEVEL1(1)1 Brown-out Detector trigger level 1 (unprogrammed)\nBODLEVEL0(1)0 Brown-out Detector trigger level 1 (unprogrammed)\n\n337\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. The SPIEN Fuse is not accessible in serial programming mode.\n2. The default value of BOOTSZ1:0 results in maximum Boot Size. See Table 29-7 on page 328  \nfor details.\n3. See \u201cWDTCSR \u2013 Watchdog Timer Control Register\u201d on page 67  for details.\n4. Never ship a product with the OCDEN Fuse prog rammed regardless of the setting of Lock bits \nand JTAGEN Fuse. A programmed OCDEN Fuse en ables some parts of the clock system to \nbe running in all sleep modes. This may increase the power consumption.\nNotes: 1. The default value of SUT1:0 results in maxi mum start-up time for the default clock source. See \n\u201cSystem and Reset Characteristics\u201d on page 372  for details.\n2. The default setting of CKSEL3:0 results in internal RC Oscillator @ 8 MHz. See Table 10-1 on \npage 41  for details.\n3. The CKOUT Fuse allow the system cl ock to be output on PORTE7. See \u201cClock Output Buffer\u201d \non page 49  for details.\n4. See \u201cSystem Clock Prescaler\u201d on page 49  for details.\nThe status of the Fuse bits is not affected by Chip Erase. Note that the Fuse bits are locked if\nLock bit1 (LB1) is programmed. Program the Fuse bits before programming the Lock bits.Table 30-4. Fuse High Byte\nFuse High Byte Bit No Description Default Value\nOCDEN(4)7 Enable OCD1 (unprogrammed, OCD \ndisabled)\nJTAGEN 6 Enable JTAG 0 (programmed, JTAG enabled)\nSPIEN(1)5Enable Serial Program and Data \nDownloading0 (programmed, SPI prog. \nenabled)\nWDTON(3)4 Watchdog Timer always on 1 (unprogrammed)\nEESAVE 3EEPROM memory is preserved \nthrough the Chip Erase1 (unprogrammed, EEPROM \nnot preserved)\nBOOTSZ1 2Select Boot Size (see Table 30-9 on \npage 339  for details)0 (programmed)(2)\nBOOTSZ0 1Select Boot Size (see Table 30-9 on \npage 339  for details)0 (programmed)(2)\nBOOTRST 0 Select Reset Vector 1 (unprogrammed)\nTable 30-5. Fuse Low Byte\nFuse Low Byte Bit No Description Default Value\nCKDIV8(4)7 Divide clock by 8 0 (programmed)\nCKOUT(3)6 Clock output 1 (unprogrammed)\nSUT1 5 Select start-up time 1 (unprogrammed)(1)\nSUT0 4 Select start-up time 0 (programmed)(1)\nCKSEL3 3 Select Clock source 0 (programmed)(2)\nCKSEL2 2 Select Clock source 0 (programmed)(2)\nCKSEL1 1 Select Clock source 1 (unprogrammed)(2)\nCKSEL0 0 Select Clock source 0 (programmed)(2)\n\n338\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.2.1 Latching of Fuses\nThe fuse values are latched when the device enters programming mode and changes of the\nfuse values will have no effect until the part leaves Programming mode. This does not apply tothe EESAVE Fuse which will take effect once it is  programmed. The fuse s are also latched on\nPower-up in Normal mode.\n30.3 Signature Bytes\nAll Atmel microcontrollers have a three-byte signature code which identifies the device. This\ncode can be read in both serial and parallel mode, also when the device is locked. The three\nbytes reside in a separate address space. For the ATmega640/1280/1281/2560/2561 the signa-\nture bytes are given in Table 30-6 .\n30.4 Calibration Byte\nThe ATmega640/1280/1281/2560/2561 has a byte calibration value for the internal RC Oscilla-\ntor. This byte resides in t he high byte of address 0x000 in the signature address space. During\nreset, this byte is automatically written into the OSCCAL Register to ensure correct frequency of\nthe calibrated RC Oscillator.\n30.5 Page Size\n30.6 Parallel Programming Paramete rs, Pin Mapping,  and Commands\nThis section describes how to parallel program and verify Flash Program memory, EEPROM\nData memory, Memory Lock bits, and Fuse bits in the ATmega640/1280/1281/2560/2561.\nPulses are assumed to be at least 250ns unless otherwise noted.Table 30-6. Device and JTAG ID\nPartSignature Bytes Address JTAG\n0x000 0x001 0x002 Part Number Manufacture ID\nATmega640 0x1E 0x96 0x08 9608 0x1F\nATmega1280 0x1E 0x97 0x03 9703 0x1F\nATmega1281 0x1E 0x97 0x04 9704 0x1FATmega2560 0x1E 0x98 0x01 9801 0x1F\nATmega2561 0x1E 0x98 0x02 9802 0x1F\nTable 30-7. No. of Words in a Page and No. of Pages in the Flash\nFlash Size Page Size PCWORDNo. of \nPages PCPAGE PCMSB\n128K words (256Kbytes) 128 words PC[6:0] 1024 PC[16:7] 16\nTable 30-8. No. of Words in a Page and No . of Pages in the EEPROM\nEEPROM Size Page Size PCWORDNo. of \nPages PCPAGE EEAMSB\n4Kbytes 8 bytes EEA[2:0] 512 EEA[11:3] 11\n\n339\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.6.1 Signal Names\nIn this section, some pins of the ATmega640/1280/1281/2560/2561 are referenced by signal\nnames describing their functionality during parallel programming, see Figure 30-1  and Table 30-\n9. Pins not described in the following table are referenced by pin names.\nThe XA1/XA0 pins determine the action executed  when the XTAL1 pin is given a positive pulse.\nThe bit coding is shown in Table 30-12 on page 340 .\nWhen pulsing WR or OE , the command loaded determines the action executed. The different\ncommands are shown in Table 30-13 on page 340 .\nFigure 30-1. Parallel Programming(1)\nNote: 1. Unused Pins should be left floating.\nTable 30-9. Pin Name Mapping\nSignal Name in \nProgramming Mode Pin Name I/O Function\nRDY/BSY PD1 O0: Device is busy programming, 1: Device is ready for \nnew command\nOE PD2 I Output Enable (Active low)\nWR PD3 I Write Pulse (Active low)\nBS1 PD4 I Byte Select 1\nXA0 PD5 I XTAL Action Bit 0XA1 PD6 I XTAL Action Bit 1\nPAGEL PD7 I Program Memory and EEPROM data Page Load\nBS2 PA0 I Byte Select 2\nDATA PB7-0 I/O Bi-directional Data bus (Output when OE is low\n)VCC+5V\nGNDXTAL1PD1\nPD2PD3PD4PD5PD6\n PB7 - PB0 DATA\nRESETPD7\n+12VBS1\nXA0XA1OERDY/ B SY\nPAGEL\nPA0WR\nBS2AVCC+5V\n\n340\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 30-10. BS2 and BS1 Encoding\nBS2 BS1Flash / EEPROM \nAddressFlash Data \nLoading / \nReadingFuse \nProgrammingReading Fuse \nand Lock Bits\n0 0 Low Byte Low Byte Low Byte Fuse Low Byte\n0 1 High Byte High Byte High Byte Lockbits\n10Extended High \nByteReserved Extended ByteExtended Fuse \nByte\n1 1 Reserved Reserved Reserved Fuse High Byte\nTable 30-11. Pin Values Used to Enter Programming Mode\nPin Symbol Value\nPAGEL Prog_enable[3] 0\nXA1 Prog_enable[2] 0XA0 Prog_enable[1] 0\nBS1 Prog_enable[0] 0\nTable 30-12. XA1 and XA0 Enoding\nXA1 XA0 Action when  XTAL1 is Pulsed\n0 0 Load Flash or EEPROM Address (High or low address byte determined \nby BS2 and BS1)\n0 1 Load Data (High or Low data byte for Flash determined by BS1)\n1 0 Load Command\n1 1 No Action, Idle\nTable 30-13. Command Byte Bit Encoding\nCommand Byte Command Executed\n1000 0000 Chip Erase\n0100 0000 Write Fuse bits\n0010 0000 Write Lock bits\n0001 0000 Write Flash\n0001 0001 Write EEPROM\n0000 1000 Read Signature Bytes and Calibration byte\n0000 0100 Read Fuse and Lock bits\n0000 0010 Read Flash\n0000 0011 Read EEPROM\n\n341\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.7 Parallel Programming\n30.7.1 Enter Programming Mode\nThe following algorithm puts the devi ce in parallel programming mode:\n1. Apply 4.5V - 5.5V between VCC and GND.\n2. Set RESET  to \u201c0\u201d and toggle XTAL1 at least six times.\n3. Set the Prog_enable pins listed in Table 30-11 on page 340  to \u201c0000\u201d and wait at least\n100ns.\n4. Apply 11.5V - 12.5V to RESET . Any activity on Prog_enable pins within 100ns after +12V\nhas been applied to RESET , will cause the device to fa il entering programming mode.\n5.Wait at least 50\u00b5s before sending a new command.\n30.7.2 Considerations for Efficient Programming\nThe loaded command and address are retained in the device during programming. For efficient\nprogramming, the following should be considered.\n\u0081 The command needs only be loaded once when writing or reading multiple memory \nlocations\n\u0081 Skip writing the data value 0xFF , that is t he contents of the enti re EEPROM (unless the \nEESAVE Fuse is programmed) and Flash after a Chip Erase\n\u0081 Address high byte needs only be loaded before programming or reading a new 256 word \nwindow in Flash or 256 byte EEPROM. This consideration also applies to Signature bytes reading\n30.7.3 Chip Erase\nThe Chip Erase will erase the Flash and EEPROM\n(1) memories plus Lock bits. The Lock bits are\nnot reset until the program memory has been completely erased. The Fuse bits are notchanged. A Chip Erase must be perfor med before the Flas h and/or EEPROM are\nreprogrammed.\nNote: 1. The EEPRPOM memory is preserved duri ng Chip Erase if the EESAVE Fuse is programmed.\nLoad Command \u201cChip Erase\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set BS1 to \u201c0\u201d.3. Set DATA to \u201c1000 0000\u201d. This is the command for Chip Erase.4. Give XTAL1 a positive pulse. This loads the command.5. Give WR\n a negative pulse. This starts the Chip Erase. RDY/BSY  goes low.\n6.Wait until RDY/BSY  goes high before loading a new command.\n30.7.4 Programming the Flash\nThe Flash is organized in pages, see Table 30-7 on page 338 . When programming the Flash,\nthe program data is latched into a page buffer. This allows one page of program data to be pro-\ngrammed simultaneously. The following procedure describes how to program the entire Flashmemory:\nA. Load Command \u201c Write Flash\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set BS1 to \u201c0\u201d.\n\n342\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n3. Set DATA to \u201c0001 0000\u201d. This is the command for Write Flash.\n4. Give XTAL1 a positive pulse. This loads the command.B. Load Address Low byte (Address bits 7:0)\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c00\u201d. This selects the address low byte.3. Set DATA = Address low byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address low byte.C. Load Data Low Byte\n1. Set XA1, XA0 to \u201c01\u201d. This enables data loading.\n2. Set DATA = Data low byte (0x00 - 0xFF).3. Give XTAL1 a positive pulse. This loads the data byte.D. Load Data High Byte\n1. Set BS1 to \u201c1\u201d. This selects high data byte.\n2. Set XA1, XA0 to \u201c01\u201d. This enables data loading.3. Set DATA = Data high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the data byte.E. Latch Data\n1. Set BS1 to \u201c1\u201d. This selects high data byte.\n2. Give PAGEL a positive pulse. This latches the data bytes. See Figure 30-3 on page 343\nfor signal waveforms.\nF. Repeat B through E until the entire buffer is filled or until all data within the page is loaded\nWhile the lower bits in the address are mapped to words within the page, the higher bits address\nthe pages within the FLASH . This is illustrated in Figure 30-2 on page 343 . Note that if less than\neight bits are required to address words in the page (pagesize < 256), the most significant bit(s)\nin the address low byte are used to address the page when performing a Page Write.\nG. Load Address High byte (Address bits15:8)1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c01\u201d. This selects the address high byte.3. Set DATA = Address high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address high byte.H. Load Address Extended High byte (Address bits 23:16)\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c10\u201d. This selects the address extended high byte.3. Set DATA = Address extended high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address high byte.I. Program Page\n1. Set BS2, BS1 to \u201c00\u201d.\n2. Give WR\n a negative pulse. This starts programming of the entire page of data. RDY/BSY\ngoes low.\n3.Wait until RDY/BSY  goes high (see Figure 30-3 on page 343  for signal waveforms).\nJ. Repeat B through I until the entire Flash is programmed or until all data has been\nprogrammed\n\n343\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nK. End Page Programming\n1. 1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set DATA to \u201c0000 0000\u201d. This is the command for No Operation.3. Give XTAL1 a positive pulse. This loads the command, and the internal write signals are\nreset.\nFigure 30-2. Addressing the Flash Which is Organized in Pages\n(1)\nNote: 1. PCPAGE and PC WORD are listed in Table 30-7 on page 338 .\nFigure 30-3. Programming the Flash Waveforms(1)\nNote: 1. \u201cXX\u201d is don\u2019t care. The letters refer to the programming description above.\n30.7.5 Programming the EEPROM\nThe EEPROM is organized in pages, see Table 30-8 on page 338 . When programming the\nEEPROM, the program data is latche d into a page buffer. This al lows one page of data to be\nprogrammed simultaneously. Th e programming algorithm for th e EEPROM data memory is asPROGRAM MEMORYWORD ADDRE SS\nWITHIN A PAGEPAGE ADDRE SS\nWITHIN THE FLA SH\nINSTRUCTION WORDPAGEPCWORD[PAGEM SB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCM SB PAGEM SB\nPROGRAM\nCOUNTER\nRDY/B SYWR\nOERESET+12V\nPAGELBS20x10 ADDR. LOW ADDR. HIGHDATADATA LOW DATA HIGH ADDR. LOW DATA LOW DATA HIGH\nXA1\nXA0\nBS1\nXTAL1XX XX XXABCD E BCD E GF\nADDR. EXT.HH I\n\n344\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nfollows (refer to \u201cProgramming the Flash\u201d on page 341  for details on Command, Address and\nData loading):\n1. A: Load Command \u201c0001 0001\u201d.\n2. G: Load Address High Byte (0x00 - 0xFF).3. B: Load Address Low Byte (0x00 - 0xFF).4. C: Load Data (0x00 - 0xFF).5. E: Latch data (give PAGEL a positive pulse).K: Repeat 3 through 5 until the entire buffer is filled\nL: Program EEPROM page1. Set BS2, BS1 to \u201c00\u201d.\n2. Give WR\n a negative pulse. This starts pr ogramming of the EEPROM page. RDY/BSY\ngoes low.\n3.Wait until to RDY/BSY  goes high before programming the next page (see Figure 30-4  for\nsignal waveforms).\nFigure 30-4. Programming the EEPROM Waveforms\n30.7.6 Reading the Flash\nThe algorithm for reading the Flash memory is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0010\u201d.\n2. H: Load Address Extended Byte (0x00- 0xFF).3. G: Load Address High Byte (0x00 - 0xFF).4. B: Load Address Low Byte (0x00 - 0xFF).5. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The Flash word low byte can now be read at DATA.\n6. Set BS to \u201c1\u201d. The Flash word high byte can now be read at DATA.7. Set OE\n to \u201c1\u201d.RDY/B SYWR\nOERESET +12V\nPAGEL\nBS20x11 ADDR. HIGHDATAADDR. LOW DATA ADDR. LOW DATA XX\nXA1\nXA0\nBS1\nXTAL1XXAGBC E B C E LK\n\n345\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.7.7 Reading the EEPROM\nThe algorithm for reading the EEPROM memory is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0011\u201d.\n2. G: Load Address High Byte (0x00 - 0xFF).3. B: Load Address Low Byte (0x00 - 0xFF).4. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The EEPROM Data byte can now be read at DATA.\n5. Set OE  to \u201c1\u201d.\n30.7.8 Programming the Fuse Low Bits\nThe algorithm for programming the Fuse Low bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n30.7.9 Programming the Fuse High Bits\nThe algorithm for programming the Fuse High bits is as follows (refer to \u201cProgramming the\nFlash\u201d on page 341  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. Set BS2, BS1 to \u201c01\u201d. This selects high data byte.4. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n5. Set BS2, BS1 to \u201c00\u201d. This selects low data byte.\n30.7.10 Programming the Extended Fuse Bits\nThe algorithm for programming the Extended Fuse bits is as follows (refer to \u201cProgramming the\nFlash\u201d on page 341  for details on Command and Data loading):\n1. 1. A: Load Command \u201c0100 0000\u201d.\n2. 2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. 3. Set BS2, BS1 to \u201c10\u201d. This selects extended data byte.4. 4. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n5. 5. Set BS2, BS1 to \u201c00\u201d. This selects low data byte.\n\n346\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-5. Programming the FUSES Waveforms\n30.7.11 Programming the Lock Bits\nThe algorithm for programming the Lock bits is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Data loading):\n1. A: Load Command \u201c0010 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs the Lock bit. If LB mode 3 is programmed\n(LB1 and LB2 is programmed), it is not possible to program the Boot Lock bits by anyExternal Programming mode.\n3. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\nThe Lock bits can only be cleared by executing Chip Erase.\n30.7.12 Reading the Fuse and Lock Bits\nThe algorithm for reading the Fuse and Lock bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command loading):\n1. A: Load Command \u201c0000 0100\u201d.\n2. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c00\u201d. The status of the Fuse Low bits can now be read at\nDATA (\u201c0\u201d means programmed).\n3. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c11\u201d. The status of the Fuse High bits can now be read at\nDATA (\u201c0\u201d means programmed).\n4. Set OE to \u201c0\u201d, and BS2, BS1 to \u201c10\u201d. The status of the Extended Fuse bits can now be\nread at DATA (\u201c0\u201d means programmed).\n5. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c01\u201d. The status of the Lock bits can now be read at DATA\n(\u201c0\u201d means programmed).\n6. Set OE  to \u201c1\u201d.RDY/B SYWR\nOERESET +12V\nPAGEL0x40DATADATA XX\nXA1\nXA0\nBS1\nXTAL1AC\n0x40 DATA XXACWrite Fuse Low byte Write Fuse high byte\n0x40 DATA XXACWrite Extended Fuse byte\nBS2\n\n347\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-6. Mapping Between BS1, BS2 and the Fuse and Lock Bits During Read\n30.7.13 Reading the Signature Bytes\nThe algorithm for reading the Signatur e bytes is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d.\n2. B: Load Address Low Byte (0x00 - 0x02).3. Set OE\n to \u201c0\u201d, and BS to \u201c0\u201d. The selected Signature byte can now be read at DATA.\n4. Set OE  to \u201c1\u201d.\n30.7.14 Reading the Calibration Byte\nThe algorithm for reading the Calibration byte is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d.\n2. B: Load Address Low Byte, 0x00.3. Set OE\n to \u201c0\u201d, and BS1 to \u201c1\u201d. The Calibration byte can now be read at DATA.\n4. Set OE  to \u201c1\u201d.\n30.7.15 Parallel Programming Characteristics\nFigure 30-7. Parallel Programming Timing, Including some General Timing RequirementsLock Bits 0\n1\nBS2Fuse High Byte0\n1\nBS1DATAFuse Low Byte 0\n1\nBS2Extended Fuse Byte\nData & Contol\n(DATA, XA0/1, B S1, BS2)XTAL1tXHXL\ntWLWHtDVXH tXLDX\ntPLWL\ntWLRHWR\nRDY/B SYPAGEL tPHPLtPLBX tBVPHtXLWL\ntWLBXtBVWL\nWLRL\n\n348\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-8. Parallel Programming Timing, Loading Sequence with Timing Requirements(1)\nNote: 1. The timing requirements shown in Figure 30-7 on page 347  (that is, tDVXH , tXHXL, and tXLDX)\nalso apply to loading operation.\nFigure 30-9. Parallel Programming Timing, Reading Sequence (within the Same Page) with \nTiming Requirements(1)\nNote: 1. The timing requirements shown in Figure 30-7 on page 347  (that is, tDVXH , tXHXL, and tXLDX) \nalso apply to reading operation.\nTable 30-14. Parallel Programming Characteristics, VCC = 5V \u00b110% \nSymbol Parameter Min Typ Max Units\nVPP Programming Enable Voltage 11.5 12.5 V\nIPP Programming Enable Current 250 \u03bcAXTAL1\nPAGELtPLXH XLXHttXLPH\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRE SS\n(LOW BYTE)LOAD DATA \n(LOW BYTE)LOAD DATA\n(HIGH BYTE)LOAD DATA LOAD ADDRE SS\n(LOW BYTE)\nXTAL1\nOE\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRE SS\n(LOW BYTE)READ DATA \n(LOW BYTE)READ DATA\n(HIGH BYTE)LOAD ADDRE SS\n(LOW BYTE)\ntBVDV\ntOLDVtXLOL\ntOHDZ\n\n349\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1.  tWLRH is valid for the Write Flash, Write EEPROM, Write Fuse bits and Write Lock bits \ncommands.\n2.  tWLRH_CE is valid for the Chip Erase command.\n30.8 Serial Downloading\nBoth the Flash and EEPROM memo ry arrays can be programmed using a serial programming\nbus while RESET  is pulled to GND. The serial programming interface consists of pins SCK, PDI\n(input) and PDO (output). After RESET  is set low, the Programming Enable instruction needs to\nbe executed first before program/erase operations can be executed. NOTE, in Table 30-15 on\npage 350 , the pin mapping for serial programming is  listed. Not all packages use the SPI pins\ndedicated for the internal Serial Peripheral Interface - SPI.tDVXH Data and Control Valid before XTAL1 High 67\nnstXLXH XTAL1 Low to XTAL1 High 200\ntXHXL XTAL1 Pulse Width High 150\ntXLDX Data and Control Hold after XTAL1 Low 67\ntXLWL XTAL1 Low to WR Low 0\ntXLPH XTAL1 Low to PAGEL high 0\ntPLXH PAGEL low to XTAL1 high 150\ntBVPH BS1 Valid before PAGEL High 67\ntPHPL PAGEL Pulse Width High 150\ntPLBX BS1 Hold after PAGEL Low 67\ntWLBX BS2/1 Hold after WR Low 67\ntPLWL PAGEL Low to WR Low 67\ntBVWL BS2/1 Valid to WR Low 67\ntWLWH WR Pulse Width Low 150\ntWLRL WR Low to RDY/BSY  Low 0 1 \u03bcs\ntWLRH WR Low to RDY/BSY  High(1)3.7 4.5\nms\ntWLRH_CE WR Low to RDY/BSY  High for Chip Erase(2)7.5 9\ntXLOL XTAL1 Low to OE  Low 0\nnstBVDV BS1 Valid to DATA valid 0 250\ntOLDV OE Low to DATA Valid 250\ntOHDZ OE High to DATA Tri-stated 250Table 30-14. Parallel Programming Characteristics, VCC = 5V \u00b110%  (Continued)\nSymbol Parameter Min Typ Max Units\n\n350\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.8.1 Serial Programming Pin Mapping\nFigure 30-10. Serial Programming and Verify(1)\nNotes: 1. If the device is clocked by the internal Oscillator, it is no need to connect a clock source to the \nXTAL1 pin.\n2. VCC - 0.3V < AVCC < VCC + 0.3V, however, AVCC should always be within 1.8V - 5.5V. When \nprogramming the EEPROM, an auto-erase cycle is built into the self-timed programming oper-\nation (in the Serial mode ONL Y) and there is  no need to first execute the Chip Erase \ninstruction. The Chip Erase operation turns the content of every memory location in both the \nProgram and EEPROM arrays into 0xFF .\nDepending on CKSEL Fuses, a valid clock must be present. The minimum low and high periods\nfor the serial clock (SCK) input are defined as follows:\nLow: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck >= 12MHz\nHigh: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck >= 12MHz\n30.8.2 Serial Programming Algorithm\nWhen writing serial data to the ATmega640/1280/1281/2560/2561, data is clocked on the rising\nedge of SCK.\nWhen reading data from the ATmega640/1280/1281/2560/2561, data is clocked on the falling\nedge of SCK. See Figure 30-12 on page 353  for timing details.Table 30-15. Pin Mapping Serial Programming\nSymbolPins \n(TQFP-100)Pins\n(TQFP-64) I/O Description\nPDI PB2 PE0 I Serial Data in\nPDO PB3 PE1 O Serial Data out\nSCK PB1 PB1 I Serial Clock\nVCC\nGNDXT AL1SCKPDOPDI\nRESET+1.8V - 5.5V\nAVCC+1.8V - 5.5V(2)\n\n351\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTo program and verify the ATmega640/1280/1281/2560/2561 in the serial programming mode,\nthe following sequence is recommended (see four byte instruction formats in Table 30-17 on\npage 352 ):\n1. Power-up sequence:\nApply power between VCC and GND while RESET  and SCK are set to \u201c0\u201d. In some sys-\ntems, the programmer can not guarantee that SCK is held low during power-up. In thiscase, RESET\n must be given a positive pulse of at least two CPU clock cycles duration\nafter SCK has been set to \u201c0\u201d.\n2.Wait for at least 20ms and enable serial programming by sending the Programming\nEnable serial instruction to pin PDI.\n3. The serial programming instructions will not wo rk if the communication is out of synchro-\nnization. When in sync. the second byte (0x53), w ill echo back when issuing the third\nbyte of the Programming Enable instruction. Whether the echo is correct or not, all four\nbytes of the instruction must be transmitted. If the 0x53 did not echo back, give RESET  a\npositive pulse and issue a new Programming Enable command.\n4. The Flash is programmed one page at a time. The memory page is loaded one byte at a\ntime by supplying the 7 LSB of the address and data together with the Load ProgramMemory Page instruction. To ensure correct loading of the page, the data low byte mustbe loaded before data high byte is applied for a given address. The Program MemoryPage is stored by loading the Write Program Memory Page instruction with the address\nlines 15:8. Before issuing this command, make sure the instruction Load ExtendedAddress Byte has been used to define the MSB of the address. The extended addressbyte is stored until the command is re-issued, that is, the command needs only be issuedfor the first page, and when crossing the 64K Word boundary. If polling (\nRDY/BSY ) is not\nused, the user must wait at least tWD_FLASH  before issuing the next page (see Table 30-\n16). Accessing the serial programming interface before the Flash write operation com-\npletes can result in incorrect programming.\n5. The EEPROM array is programmed one byte at  a time by supplyin g the address and data\ntogether with the appropriate Write instruction. An EEPROM memory location is first\nautomatically erased before new data is written. If polling is not used, the user must waitat least t\nWD_EEPROM before issuing the next byte (see Table 30-16 ). In a chip erased\ndevice, no 0xFFs in the data file(s) need to be programmed.\n6. Any memory location can be verified by using the Read instruction which returns the con-\ntent at the selected address at serial output PDO. When reading the Flash memory, use\nthe instruction Load Extended Address Byte to define the upper address byte, which isnot included in the Read Program Memory instruction. The extended address byte isstored until the command is re-issued, that is, the command needs only be issued for thefirst page, and when crossing the 64K Word boundary.\n7. At the end of the programming session, RESET\n can be set high to commence normal\noperation.\n8. Power-off sequence (if needed):\nSet RESET  to \u201c1\u201d.\nTur n VCC power off.\nTable 30-16. Minimum Wait Delay Before Writing the Next Flas h or EEPROM Location\nSymbol Minimum Wait Delay\ntWD_FLASH 4.5ms\ntWD_EEPROM 3.6ms\ntWD_ERASE 9.0ms\n\n352\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.8.3 Serial Programming Instruction set\nTable 30-17  and Figure 30-11 on page 353  describes the Instruction set.\nNotes: 1. Not all instructions are applicable for all parts.\n2. a = address.3. Bits are programmed \u20180\u2019, unprogrammed \u20181\u2019.\n4. To ensure future compatibility, unused Fuses and Lock bits should be unprogrammed (\u20181\u2019).\n5. Refer to the correspondig section for Fuse and Lock bits, Calibration and Signature bytes and \nPage size.\n6. See htt://www.atmel.com/avr  for Application Notes regarding programming and programmers.\nIf the LSB in RDY/BSY data byte out is \u20181\u2019,  a programming operation is still pending. Wait until\nthis bit returns \u20180\u2019 before the ne xt instruction is carried out.Table 30-17. Serial Programming Instruction Set\nInstruction/OperationInstruction Format\nByte 1 Byte 2 Byte 3 Byte 4\nProgramming Enable $AC $53 $00 $00\nChip Erase (Program Memory/EEPROM) $AC $80 $00 $00Poll RDY/BSY\n$F0 $00 $00 data byte out\nLoad Instructions\nLoad Extended Address byte(1)$4D $00 Extended adr $00\nLoad Program Memory Page, High byte $48 $00 adr LSB high data byte in\nLoad Program Memory Page, Low byte $40 $00 adr LSB low data byte in\nLoad EEPROM Memory Page (page access) $C1 $00 0000 000aa data byte inRead Instructions\nRead Program Memory, High byte $28 adr MSB adr LSB high data byte out\nRead Program Memory, Low byte $20 adr MSB adr LSB low data byte outRead EEPROM Memory $A0 0000 aaaa aaaa aaaa data byte out\nRead Lock bits $58 $00 $00 data byte out\nRead Signature Byte $30 $00 0000 000aa data byte outRead Fuse bits $50 $00 $00 data byte out\nRead Fuse High bits $58 $08 $00 data byte out\nRead Extended Fuse Bits $50 $08 $00 data byte outRead Calibration Byte $38 $00 $00 data byte out\nWrite Instructions\nWrite Program Memory Page $4C adr MSB adr LSB $00\nWrite EEPROM Memory $C0 0000 aaaa aaaa aaaa data byte in\nWrite EEPROM Memory Page (page access) $C2 0000 aaaa aaaa 00 $00\nWrite Lock bits $AC $E0 $00 data byte in\nWrite Fuse bits $AC $A0 $00 data byte in\nWrite Fuse High bits $AC $A8 $00 data byte in\nWrite Extended Fuse Bits $AC $A4 $00 data byte in\n\n353\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWithin the same page, the low data byte must be loaded prior to the high data byte.\nAfter data is loaded to the page buffer, program the EEPROM page, see Figure 30-11 .\nFigure 30-11. Serial Programming Instruction example\n30.8.4 Serial Programming Characteristics\nFor characteristics of the Serial Programming module, see \u201cSPI Timing Characteristics\u201d on page\n375.\nFigure 30-12. Serial Programming WaveformsByte 1 Byte 2 Byte 3 Byte 4\nAdr LSB\nBit 15  B        0Serial Programming Instruction\nProgram Memory/\nEEPROM MemoryPage 0\nPage 1\nPage 2\nPage N-1Page BufferWrite Program Memory Page/\nWrite EEPROM Memory PageLoad Program Memory Page (High/Low Byte)/\nLoad EEPROM Memory Page (page access)\nByte 1 Byte 2 Byte 3 Byte 4\nBit 15  B        0Adr MSB\nPage Offset\nPage NumberAdr MMSSB A AAdrr LLSBB\nMSB\nMSBLSB\nLSB\nSERIAL CLOCK INPUT\n(SCK)SERIAL DATA INPUT\n (MO SI)\n(MISO)\nSAMPLESERIAL DATA OUTPUT\n\n354\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9 Programming via the JTAG Interface\nProgramming through the JTAG interface requires control of the four JTAG specific pins: TCK,\nTMS, TDI, and TDO. Control of the reset and clock pins is not required.\nTo be able to use the JTAG interface, the JTAGEN Fuse must be programmed. The device is\ndefault shipped with the fuse pr ogrammed. In addition, the JTD bit in MCUCR must be cleared.\nAlternatively, if the JTD bit is set, the external reset can be fo rced low. Then, the JTD bit will be\ncleared after two chip clocks, and the JTAG pins are available for programming. This provides a\nmeans of using the JTAG pins as normal port pi ns in Running mode while still allowing In-Sys-\ntem Programming via the JTAG interface. Note th at this technique can not be used when using\nthe JTAG pins for Boundary-scan or On-chip Debug. In these cases the JTAG pins must be ded-icated for this purpose.\nDuring programming the clock frequency of the TCK Input must be less than the maximum fre-\nquency of the chip. The System Clock Prescaler can not be used to divide the TCK Clock Inputinto a sufficiently low frequency.\nAs a definition in this datasheet, the LSB is shifted in and out first of all Shift Registers.\n30.9.1 Programming Specific JTAG Instructions\nThe Instruction Register is 4-bit wide, supporting up to 16 instructions. The JTAG instructions\nuseful for programming are listed below.\nThe OPCODE for each instruction is shown behind the instruction name in hex format. The text\ndescribes which Data Register is selected as  path between TDI and TDO for each instruction.\nThe Run-Test/Idle state of the TAP controller is used to generate internal clocks. It can also be\nused as an idle state between JTAG sequences . The state machine sequence for changing the\ninstruction word is shown in Figure 30-13 on page 355 .\n\n355\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-13. State Machine Sequence for Changing the Instruction Word\n30.9.2 AVR_RESET (0xC)\nThe AVR specific public JTAG in struction for setting the AVR device in the Reset mode or taking\nthe device out from the Reset mode. The TAP controller is not reset by this instruction. The onebit Reset Register is selected as Data Register. No te that the reset will be active as long as there\nis a logic \u201cone\u201d in the Reset Chain. The output from this chain is not latched.\nThe active states are:\u0081Shift-DR : The Reset Register is shifted by the TCK input\n30.9.3 PROG_ENABLE (0x4)\nThe AVR specific public JTAG instruction for enabling programming via the JTAG port. The 16-\nbit Programming Enable Register is selected as Data Register. The active states are the\nfollowing:\n\u0081Shift-DR : The programming enable signature is shifted into the Data Register\n\u0081Update-DR : The programming enable signature is compared to the correct value, and \nProgramming mode is entered if the signature is validTest-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n356\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.4 PROG_COMMANDS (0x5)\nThe AVR specific public JTAG instruction for entering programming commands via the JTAG\nport. The 15-bit Programming Command Register is selected as Data Register. The active\nstates are the following:\n\u0081Capture-DR : The result of the previous command is loaded into the Data Register\n\u0081Shift-DR : The Data Register is shifted by the TCK input, shifting out the result of the \nprevious command and shifting in the new command\n\u0081Update-DR : The programming command is applied to the Flash inputs\n\u0081Run-Test/Idle : One clock cycle is generated, executing the applied command\n30.9.5 PROG_PAGELOAD (0x6)\nThe AVR specific public JTAG instruction to directly load the Flash data page via the JTAG port.\nAn 8-bit Flash Data Byte Register is selected as  the Data Register. This is physically the 8 LSBs\nof the Programming Command Register. The active states are the following:\n\u0081Shift-DR : The Flash Data Byte Register is shifted by the TCK input.\n\u0081Update-DR : The content of the Flash Data Byte Register is copied into a temporary register. \nA write sequence is initiated that within 11 TCK cycles loads the content of the temporary register into the Flash page buffer. The AVR automatically alternates between writing the low and the high byte for each new Update-DR state, starting with the low byte for the first Update-DR encountered after entering the PROG_PAGELOAD command. The Program Counter is pre-incremented before  writing the low byte, except fo r the first written byte. This \nensures that the first data is written to the address set up by PROG_COMMANDS, and loading the last location in the page buffer does not make the program counter increment into the next page.\n30.9.6 PROG_PAGEREAD (0x7)\nThe AVR specific public JTAG instruction to dire ctly capture the Flash content via the JTAG port.\nAn 8-bit Flash Data Byte Register is selected as  the Data Register. This is physically the 8 LSBs\nof the Programming Command Register. The active states are the following:\n\u0081Capture-DR : The content of the selected Flash byte is captured into the Flash Data Byte \nRegister. The AVR automatically alternates between reading the low and the high byte for each new Capture-DR state, starting with the low byte for the first Capture-DR encountered after entering the PROG_PAGEREAD command. The Program Counter is post-incremented after reading each high byte, including the first read byte. This ensures that the first data is \ncaptured from the first address set up by PROG_COMMANDS, and reading the last location in the page makes the program counter increment into the next page.\n\u0081Shift-DR : The Flash Data Byte Register is shifted by the TCK input.\n30.9.7 Data Registers\nThe Data Registers are selected by the JTAG  instruction registers described in section \u201cPro-\ngramming Specific JTAG Instructions\u201d on page 354 . The Data Registers relevant for\nprogramming operations are:\n\u0081 Reset Register\n\u0081 Programming Enable Register\u0081 Programming Command Register\u0081 Flash Data Byte Register\n\n357\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.8 Reset Register\nThe Reset Register is a Test Data Register used to reset the part during programming. It is\nrequired to reset the part before entering Programming mode.\nA high value in the Reset Register  corresponds to pulling the external  reset low. The part is reset\nas long as there is a high value present in t he Reset Register. Depending on the Fuse settings\nfor the clock options, the part will remain reset for a Re set Time-out period (refer to \u201cClock\nSources\u201d on page 41 ) after releasing the Reset Register. The output from this Data Register is\nnot latched, so the reset will take place immediately, as shown in Figure 28-2 on page 304 .\n30.9.9 Programming Enable Register\nThe Programming Enable Register is a 16-bit regist er. The contents of this register is compared\nto the programming enable signature, binary code 0b1010_0011_0111_0000. When the con-\ntents of the register is equal to the programming enable signature, programming via the JTAG\nport is enabled. The register is reset to 0 on Power-on Reset, and should always be reset when\nleaving Programming mode.\nFigure 30-14. Programming Enable Register\n30.9.10 Programming Command Register\nThe Programming Command Register is a 15-bit regist er. This register is us ed to serially shift in\nprogramming commands, and to serially shift out the result of the previous command, if any. TheJTAG Programming Instruction Set is shown in Table 30-18 on page 359 . The state sequence\nwhen shifting in the programmi ng commands is  illustrated in Figure 30-16 on page 362 .TDI\nTDOD\nA\nT\nA=DQ\nClockDR & PROG_ENABLEProgramming Enable0xA370\n\n358\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-15. Programming Command Register\nTDI\nTDOS\nT\nR\nO\nBES\nA\nDDR\nESS\n/\nD\nA\nT\nAFlash\nEEPROM\nFuses\nLock Bits\n\n359\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 30-18. JTAG Programming Instruction \nSet  a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, o = data out, \ni = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n1a. Chip Erase0100011_10000000\n0110001_100000000110011_100000000110011_10000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx\n1b. Poll for Chip Erase Complete 0110011_10000000 xxxxx ox_xxxxxxxx (2)\n2a. Enter Flash Write 0100011_00010000 xxxxxxx_xxxxxxxx\n2b. Load Address Extended High Byte 0001011_ cccccccc xxxxxxx_xxxxxxxx (10)\n2c. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx\n2d. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n2e. Load Data Low Byte 0010011_ iiiiiiii xxxxxxx_xxxxxxxx\n2f. Load Data High Byte 0010111_ iiiiiiii xxxxxxx_xxxxxxxx\n2g. Latch Data0110111_00000000\n1110111_000000000110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx(1)\n2h. Write Flash Page0110111_00000000\n0110101_00000000\n0110111_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n2i. Poll for Page Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n3a. Enter Flash Read 0100011_00000010 xxxxxxx_xxxxxxxx\n3b. Load Address Extended High Byte 0001011_ cccccccc xxxxxxx_xxxxxxxx (10)\n3c. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx\n3d. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n3e. Read Data Low and High Byte0110010_00000000\n0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\nxxxxxxx_ ooooooooLow byte\nHigh byte\n4a. Enter EEPROM Write 0100011_00010001 xxxxxxx_xxxxxxxx\n4b. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx (10)\n4c. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n4d. Load Data Byte 0010011_ iiiiiiii xxxxxxx_xxxxxxxx\n4e. Latch Data0110111_00000000\n1110111_000000000110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx(1)\n4f. Write EEPROM Page0110011_00000000\n0110001_00000000\n0110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n\n360\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n4g. Poll for Page Write Complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n5a. Enter EEPROM Read 0100011_00000011 xxxxxxx_xxxxxxxx\n5b. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx (10)\n5c. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n5d. Read Data Byte0110011_ bbbbbbbb\n0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n6a. Enter Fuse Write 0100011_01000000 xxxxxxx_xxxxxxxx\n6b. Load Data Low Byte(6)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6c. Write Fuse Extended Byte0111011_00000000\n0111001_00000000\n0111011_00000000\n0111011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6d. Poll for Fuse Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n6e. Load Data Low Byte(7)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6f. Write Fuse High Byte0110111_00000000\n0110101_00000000\n0110111_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6g. Poll for Fuse Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n6h. Load Data Low Byte(7)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6i. Write Fuse Low Byte0110011_00000000\n0110001_00000000\n0110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6j. Poll for Fuse Write Complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n7a. Enter Lock Bit Write 0100011_00100000 xxxxxxx_xxxxxxxx\n7b. Load Data Byte(9)0010011_11 iiiiii xxxxxxx_xxxxxxxx (4)\n7c. Write Lock Bits0110011_00000000\n0110001_000000000110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n7d. Poll for Lock Bit Write complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n8a. Enter Fuse/Lock Bit Read 0100011_00000100 xxxxxxx_xxxxxxxx\n8b. Read Extended Fuse Byte\n(6)0111010_00000000\n0111011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n8c. Read Fuse High Byte(7)0111110_00000000\n0111111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ ooooooooTable 30-18. JTAG Programming Instruction  (Continued)\nSet  (Continued) a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, \no = data out, i = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n\n361\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This command sequence is not required if the seven MSB are correctly set by the previous command sequence (which is \nnormally the case).\n2. Repeat until o = \u201c1\u201d.\n3. Set bits to \u201c0\u201d to program the corresponding Fuse, \u201c1\u201d to unprogram the Fuse.\n4. Set bits to \u201c0\u201d to program the corresponding Lock bit, \u201c1\u201d to leave the Lock bit unchanged.5. \u201c0\u201d = programmed, \u201c1\u201d = unprogrammed.\n6. The bit mapping for Fuses Extended byte is listed in Table 30-3 on page 336 .\n7. The bit mapping for Fuses High byte is listed in Table 30-4 on page 337 .\n8. The bit mapping for Fuses Low byte is listed in Table 30-5 on page 337 .\n9. The bit mapping for Lock bits byte is listed in Table 30-1 on page 335 .\n10. Address bits exceeding PCMSB and EEAMSB ( Table 30-7 on page 338  and Table 30-8 on page 338 ) are don\u2019t care.\n11. All TDI and TDO sequences are represented by binary digits (0b...).8d. Read Fuse Low Byte\n(8)0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n8e. Read Lock Bits(9)0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xx oooooo(5)\n8f. Read Fuses and Lock Bits0111010_00000000\n0111110_000000000110010_00000000\n0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo(5)\nFuse Ext. byteFuse High byte\nFuse Low byte\nLock bits\n9a. Enter Signature Byte Read 0100011_00001000 xxxxxxx_xxxxxxxx\n9b. Load Address Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n9c. Read Signature Byte0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n10a. Enter Calibration Byte Read 0100011_00001000 xxxxxxx_xxxxxxxx10b. Load Address Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n10c. Read Calibration Byte0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n11a. Load No Operation Command0100011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxTable 30-18. JTAG Programming Instruction  (Continued)\nSet  (Continued) a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, \no = data out, i = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n\n362\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-16. State Machine Sequence for Changing/Reading the Data Word\n30.9.11 Flash Data Byte Register\nThe Flash Data Byte Register provides an ef ficient way to load the entire Flash page buffer\nbefore executing Page Write, or to read out/verify the content of the Flash. A state machine sets\nup the control signals to the Flash and senses the strobe signals from the Flash, thus only the\ndata words need to be shifted in/out.\nThe Flash Data Byte Register actually consists of the 8-bit scan chain and a 8-bit temporary reg-\nister. During page load, the Update-DR state copies the content of the scan chain over to the\ntemporary register and initiates a write sequence that within 11 TCK cycles loads the content of\nthe temporary register into the Flash page bu ffer. The AVR automatically alternates between\nwriting the low and the high byte for each new Update-DR state, starting with the low byte for the\nfirst Update-DR encountered after entering the PROG_PAGELOAD command. The Program\nCounter is pre-incremented before writing the low byte, except for the first written byte. Thisensures that the first data is written to the address set up by PROG_COMMANDS, and loadingthe last location in the page buffer does not make the Program Counter increment into the next\npage.\nDuring Page Read, the content of the selected Flash byte is captured into the Flash Data Byte\nRegister during the Capture-DR state. The AVR  automatically alternates between reading the\nlow and the high byte for each new Capture-DR state, starting with the low byte for the first Cap-Test-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n363\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nture-DR encountered after entering the PROG_PAGEREAD command. The Program Counter is\npost-incremented after reading each high byte, including the first read byte. This ensures that\nthe first data is captured from the first ad dress set up by PROG_COMMANDS, and reading the\nlast location in the page makes the program counter increment into the next page.\nFigure 30-17. Flash Data Byte Register\nThe state machine controlling the Flash Data By te Register is clocked by TCK. During normal\noperation in which eight bits are shifted for eac h Flash byte, the clock cycles needed to navigate\nthrough the TAP controller automatically feeds the state machine for the Flash Data Byte Regis-\nter with sufficient number of clock pulses to complete its operation transparently for the user.\nHowever, if too few bits are shifted between each Update-DR state during page load, the TAPcontroller should stay in the Run-Test/Idle state for some TCK cycles to ensure that there are at\nleast 11 TCK cycles between each Update-DR state.\n30.9.12 Programming Algorithm\nAll references below of type \u201c1a\u201d, \u201c1b\u201d, and so on, refer to Table 30-18 on page 359 .\n30.9.13 Entering Programming Mode\n1. Enter JTAG instruction AVR_RESET and shift 1 in the Reset Register.\n2. Enter instruction PROG_ENABLE and shift 0b1010_0011_0111_0000 in the Program-\nming Enable Register.\n30.9.14 Leaving Programming Mode\n1. Enter JTAG instruction PROG_COMMANDS.2. Disable all programming instructions by using no operation instruction 11a.3. Enter instruction PROG_ENABLE and shift 0b0000_0000_0000_0000 in the program-\nming Enable Register.\n4. Enter JTAG instruction AVR_RESET and shift 0 in the Reset Register.TDI\nTDOD\nA\nT\nAFlash\nEEPROM\nFuses\nLock BitsSTROBE S\nADDRE SSState\nMachine\n\n364\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.15 Performing Chip Erase\n1. Enter JTAG instruction PROG_COMMANDS.2. Start Chip Erase using pr ogramming instruction 1a.\n3. Poll for Chip Erase complete using programming instruction 1b, or wait for t\nWLRH_CE  (refer\nto Table 30-14 on page 348 ).\n30.9.16 Programming the Flash\nBefore programming the Flash a Chip Erase must be performed, see \u201cPerforming Chip Erase\u201d\non page 364.\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash write using programming instruction 2a.3. Load address Extended High byte using programming instruction 2b.4. Load address High byte using programming instruction 2c.5. Load address Low byte using programming instruction 2d.6. Load data using programming instructions 2e, 2f and 2g.7. Repeat steps 5 and 6 for all instruction words in the page.8.Write the page using programming instruction 2h.\n9. Poll for Flash write complete using programming instruction 2i, or wait for t\nWLRH (refer to\nTable 30-14 on page 348 ).\n10. Repeat steps 3 to 9 until all data have been programmed.A more efficient data transfer can be achieved using the PROG_PAGELOAD instruction:\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash write using programming instruction 2a.3. Load the page address using programming instructions 2b, 2c and 2d. PC WORD (refer\nto Table 30-7 on page 338 ) is used to address within one page and must be written as 0.\n4. Enter JTAG instruction PROG_PAGELOAD.5. Load the entire page by shifting in all instruction words in the page byte-by-byte, starting\nwith the LSB of the first instruction in the page and ending with the MSB of the lastinstruction in the page. Use Update-DR to copy the contents of the Flash Data Byte Reg-\nister into the Flash page location and to auto-increment the Program Counter before\neach new word.\n6. Enter JTAG instruction PROG_COMMANDS.7.Write the page using programming instruction 2h.\n8. Poll for Flash write complete using programming instruction 2i, or wait for t\nWLRH (refer to\nTable 30-14 on page 348 ).\n9. Repeat steps 3 to 8 until all data have been programmed.\n30.9.17 Reading the Flash\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Flash read using programming instruction 3a.3. Load address using programming instructions 3b, 3c and 3d.4. Read data using programming instruction 3e.5. Repeat steps 3 and 4 until all data have been read.\n\n365\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA more efficient data transfer can be ac hieved using the PROG_PAGEREAD instruction:\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash read using programming instruction 3a.3. Load the page address using programming instructions 3b, 3c and 3d. PC WORD (refer\nto Table 30-7 on page 338 ) is used to address within one page and must be written as 0.\n4. Enter JTAG instruction PROG_PAGEREAD.5. Read the entire page (or Flash) by shifting out all instruction words in the page (or Flash),\nstarting with the LSB of the first instruction in the page (Flash) and ending with the MSBof the last instruction in the page (Flash). The Capture-DR state both captures the datafrom the Flash, and also auto-increments the program counter after each word is read.Note that Capture-DR comes before the shift-DR state. Hence, the first byte which isshifted out contains valid data.\n6. Enter JTAG instruction PROG_COMMANDS.7. Repeat steps 3 to 6 until all data have been read.\n30.9.18 Programming the EEPROM\nBefore programming the EEPROM a Chip Erase must be performed, see \u201cPerforming Chip\nErase\u201d on page 364 .\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable EEPROM write using programming instruction 4a.3. Load address High byte using programming instruction 4b.4. Load address Low byte using programming instruction 4c.5. Load data using programming instructions 4d and 4e.6. Repeat steps 4 and 5 for all data bytes in the page.7.Write the data using programming instruction 4f.\n8. Poll for EEPROM write complete using pr ogramming instruction 4g, or wait for t\nWLRH\n(refer to Table 30-14 on page 348 ).\n9. Repeat steps 3 to 8 until all data have been programmed.\nNote that the PROG_ PAGELOAD instruction can not be us ed when program ming the EEPROM.\n30.9.19 Reading the EEPROM\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable EEPROM read using programming instruction 5a.3. Load address using programming instructions 5b and 5c.4. Read data using programming instruction 5d.5. Repeat steps 3 and 4 until all data have been read.Note that the PROG_PAGEREAD instructio n can not be used when reading the EEPROM.\n30.9.20 Programming the Fuses\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Fuse write using programming instruction 6a.3. Load data high byte using programming instru ctions 6b. A bit value of \u201c0\u201d will program the\ncorresponding fuse, a \u201c1\u201d will unprogram the fuse.\n4.Write Fuse High byte using programming instruction 6c.\n\n366\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5. Poll for Fuse write complete using prog ramming instruction 6d, or wait for tWLRH (refer to\nTable 30-14 on page 348 ).\n6. Load data low byte using programming inst ructions 6e. A \u201c0\u201d will pr ogram the fuse, a \u201c1\u201d\nwill unprogram the fuse.\n7.Write Fuse low byte using programming instruction 6f.\n8. Poll for Fuse write complete using prog ramming instruction 6g, or wait for tWLRH (refer to\nTable 30-14 on page 348 ).\n30.9.21 Programming the Lock Bits\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Lock bit write using programming instruction 7a.3. Load data using prog ramming instructions 7b. A bit va lue of \u201c0\u201d will program the corre-\nsponding lock bit, a \u201c1\u201d will leave the lock bit unchanged.\n4.Write Lock bits using programming instruction 7c.\n5. Poll for Lock bit write complete using programming instruction 7d, or wait for t\nWLRH (refer\nto Table 30-14 on page 348 ).\n30.9.22 Reading the Fuses and Lock Bits\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Fuse/Lock bit read using programming instruction 8a.3. To read all Fuses and Lock bits, use programming instruction 8e.\nTo only read Fuse High byte, use programming instruction 8b.To only read Fuse Low byte, use programming instruction 8c.To only read Lock bits, use programming instruction 8d.\n30.9.23 Reading the Signature Bytes\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Signature byte read using programming instruction 9a.3. Load address 0x00 using programming instruction 9b.4. Read first signature byte using programming instruction 9c.5. Repeat steps 3 and 4 with address 0x01 and address 0x02 to read the second and third\nsignature bytes, respectively.\n30.9.24 Reading the Calibration Byte\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Calibration byte read using programming instruction 10a.3. Load address 0x00 using programming instruction 10b.4. Read the calibration byte using programming instruction 10c.\n\n367\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31. Electrical Characteristics\nAbsolute Maximum Ratings*\n31.1 DC CharacteristicsOperating Temperature.................................. -55 \u00b0C to +125 \u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or \nother conditions beyond those indicated in the \noperational sections of th is specification is not \nimplied. Exposure to absolute maximum rating \nconditions for extended periods may affect \ndevice reliability.Storage Temperature ..................................... -65\u00b0C to +150\u00b0C\nVoltage on any Pin except RESET\nwith respect to Ground ................................-0.5V to VCC+0.5V\nVoltage on RESET with respect to Ground......-0.5V to +13.0V\nMaximum Operating Voltage ............................................ 6.0VDC Current per I/O Pin ................................................ 40.0mA\nDC Current \nVCC and GND Pins................................. 200.0mA\nTA = -40 \u00b0C to 85 \u00b0C, VCC = 1.8V to 5.5V (unless otherwise noted) \nSymbol Parameter Condition Min. Typ. Max. Units\nVILInput Low Voltage,Except \nXTAL1 and Reset pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V-0.5\n-0.50.2VCC(1)\n0.3VCC(1)\nVVIL1Input Low Voltage,\nXTAL1 pinVCC = 1.8V - 5.5V -0.5 0.1VCC(1)\nVIL2Input Low Voltage, \nRESET pinVCC = 1.8V - 5.5V -0.5 0.1VCC(1)\nVIHInput High Voltage, \nExcept XTAL1 and \nRESET pinsVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.7VCC(2)\n0.6VCC(2)VCC + 0.5\nVCC + 0.5\nVIH1Input High Voltage, \nXTAL1 pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.8VCC(2)\n0.7VCC(2)VCC + 0.5\nVCC + 0.5\nVIH2Input High Voltage, \nRESET pinVCC = 1.8V - 5.5V 0.9VCC(2)VCC + 0.5\nVOLOutput Low Voltage(3),\nExcept RESET pinIOL = 20mA, VCC = 5V\nIOL = 10mA, VCC = 3V0.9\n0.6\nVOHOutput High Voltage(4),\nExcept RESET pinIOH = -20mA, VCC = 5V\nIOH = -10mA, VCC = 3V4.2\n2.3\nIILInput Leakage\nCurrent I/O PinVCC = 5.5V, pin low\n(absolute value)1\n\u00b5A\nIIHInput Leakage\nCurrent I/O PinVCC = 5.5V, pin high\n(absolute value)1\nRRST Reset Pull-up Resistor 30 60\nk\u03a9\nRPU I/O Pin Pull-up Resistor 20 50\n\n368\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. \"Max\" means the highest value where the pin is guaranteed to be read as low.\n2. \"Min\" means the lowest value where the pin is guaranteed to be read as high.\n3. Although each I/O port can sink more than the test conditi ons (20mA at VCC = 5V, 10mA at VCC = 3V) under steady state \nconditions (non-transient), th e following must be observed:\nATmega1281/2561:\n1.)The sum of all IOL, for ports A0-A7, G2, C4-C7 should not exceed 100mA.\n2.)The sum of all IOL, for ports C0-C3,  G0-G1, D0-D7 should not exceed 100mA.\n3.)The sum of all IOL, for ports G3-G5,  B0-B7, E0-E7 should not exceed 100mA.\n4.)The sum of all IOL, for ports F0-F7 should not exceed 100mA.\nATmega640/1280/2560:1.)The sum of all IOL, for ports J0-J 7, A0-A7, G2 should not exceed 200mA.\n2.)The sum of all IOL, for ports C0-C7, G0 -G1, D0-D7, L0-L7 s hould not exceed 200mA.\n3.)The sum of all IOL, for ports G3-G4,  B0-B7, H0-B7 should not exceed 200mA.\n4.)The sum of all IOL, for ports E0-E7, G5 should not exceed 100mA.\n5.)The sum of all IOL, for ports F0-F7, K0-K7 should not exceed 100mA.\nIf IOL exceeds the test condition, VOL may exceed the related sp ecification. Pins are not guar anteed to sink current greater \nthan the listed test condition.\n4. Although each I/O port can source more than the test co nditions (20mA at VCC = 5V, 10mA at VCC = 3V) under steady \nstate conditions (non-transient), the following must be observed:ATmega1281/2561:\n1)The sum of all IOH, for ports A0-A7, G2, C4-C7 should not exceed 100mA.\n2)The sum of all IOH, for ports C0-C3, G0-G1, D0-D7 should not exceed 100mA.\n3)The sum of all IOH, for ports G3-G5, B0-B7, E0-E7 should not exceed 100mA.\n4)The sum of all IOH, for ports F0-F7 should not exceed 100mA.ATmega640/1280/2560:\n1)The sum of all IOH, for ports J0-J7, G2, A0-A7 should not exceed 200mA.\n2)The sum of all IOH, for ports C0-C7, G0 -G1, D0-D7, L0-L7 should not exceed 200mA.\n3)The sum of all IOH, for ports G3-G4, B0-B7, H0-H7 should not exceed 200mA.\n4)The sum of all IOH, for ports E0-E7, G5 should not exceed 100mA.I\nCCPower Supply Current(5)Active 1MHz, VCC = 2V\n(ATmega640/1280/2560/1V)0.5 0.8\nmAActive 4MHz, VCC = 3V\n(ATmega640/1280/2560/1L)3.2 5\nActive 8MHz, VCC = 5V\n(ATmega640/1280/1281/2560/2561)10 14\nIdle 1MHz, VCC = 2V\n(ATmega640/1280/2560/1V)0.14 0.22\nIdle 4MHz, VCC = 3V\n(ATmega640/1280/2560/1L)0.7 1.1\nIdle 8MHz, VCC = 5V\n(ATmega640/1280/1281/2560/2561)2.7 4\nPower-down modeWDT enabled, VCC = 3V <5 15\n\u00b5A\nWDT disabled, VCC = 3V <1 7.5\nVACIOAnalog Comparator \nInput Offset VoltageVCC = 5V\nVin = VCC/2<10 40 mV\nIACLKAnalog Comparator \nInput Leakage CurrentVCC = 5V\nVin = VCC/2-50 50 nA\ntACIDAnalog Comparator \nPropagation DelayVCC = 2.7V\nVCC = 4.0V750\n500nsTA = -40 \u00b0C to 85 \u00b0C, VCC = 1.8V to 5.5V (unless otherwise noted)  (Continued)\nSymbol Parameter Condition Min. Typ. Max. Units\n\n369\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5)The sum of all IOH, for ports F0-F7, K0-K7 should not exceed 100mA.\nIf IOH exceeds the test condition, VOH ma y exceed the related specification. Pins  are not guaranteed to source current \ngreater than the listed test condition.\n5. Values with \u201cPRR1 \u2013 Power Reduction Register 1\u201d  enabled (0xFF).\n31.2 Speed Grades\nMaximum frequency is depending on VCC. As shown in Figure 31-1  trough Figure 31-4 on page\n370, the Maximum Frequency vs. VCC curve is linear between 1.8V < VCC < 2.7V and between\n2.7V < VCC < 4.5V.\n31.2.1 8MHz\nFigure 31-1. Maximum Frequency vs. VCC, ATmega640V/1280V/1281V/2560V/2561V\nFigure 31-2. Maximum Frequency vs. VCC when also No-Read- While-Write Section(1), \nATmega2560V/ATmega2561V, is used\nNote: 1. When only using the Read- While-Write Section of the program memory, a higher speed can \nbe achieved at low voltage, see \u201cRead- While-Write and No Read- While-Write Flash Sections\u201d \non page 317  for addresses.8 MHz\n4 MHz\n1.8V 2.7V 5.5VSafe Operating Area\n8 MHz\n2 MHz\n1.8V 2.7V 5.5VSafe Operating Area\n\n370\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.2.2 16 MHz\nFigure 31-3. Maximum Frequency vs. VCC, ATmega640/ATmega1280/ATmega1281\nFigure 31-4. Maximum Frequency vs. VCC, ATmega2560/ATmega256116 MHz\n8 MHz\n2.7V 4.5V 5.5VSafe Operating Area\n16 MHz\n4.5V 5.5VSafe Operating Area\n\n371\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.3 Clock Characteristics\n31.3.1 Calibrated Internal RC Oscillator Accuracy\nNotes: 1. Voltage range for ATmega640V/1281V/1280V/2561V/2560V.\n2. Voltage range for ATmega640/1281/1280/2561/2560.\n31.3.2 External Clock Drive Waveforms\nFigure 31-5. External Clock Drive Waveforms\n31.4 External Clock DriveTable 31-1. Calibration Accuracy of Internal RC Oscillator\nFrequency VCC Temperature Calibration Accuracy\nFactory Calibration 8.0MHz 3V 25 \u00b0C\u00b1 1 0 %\nUser Calibration 7.3MHz - 8.1MHz1.8V - 5.5V(1)\n2.7V - 5.5V(2) -40\u00b0C - 85 \u00b0C\u00b1 1 %\nVIL1VIH1\nTable 31-2. External Clock Drive\nSymbol ParameterVCC = 1.8V - 5.5V VCC = 2.7V - 5.5V VCC = 4.5V - 5.5V\nUnits Min. Max. Min. Max. Min. Max.\n1/tCLCLOscillator \nFrequency02080 1 6 M H z\ntCLCL Clock Period 500 125 62.5\nns tCHCX High Time 200 50 25\ntCLCX Low Time 200 50 25\ntCLCH Rise Time 2.0 1.6 0.5\n\u03bcs\ntCHCL Fall Time 2.0 1.6 0.5\n\u0394tCLCLChange in period \nfrom one clock \ncycle to the next22 2 %\n\n372\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.5 System and Reset Characteristics\nNote: 1. The Power-on Reset will not work unless the supply voltage has been below VPOT (falling).\n31.5.1 Standard Power-On Reset\nThis implementation of power-on reset existed in early versions of\nATmega640/1280/1281/2560/2561. The table below de scribes the characteristics of this power-\non reset and it is valid for the following devices only:\n\u0081 ATmega640: revision A\n\u0081 ATmega1280: revision A\u0081 ATmega1281: revision A\u0081 ATmega2560: revision A to E\u0081 ATmega2561: revision A to E\nTable 31-4. Characteristics of Standard Power-On Reset. T\nA= -40 to +85\u00b0C.\nNotes: 1. Values are guidelines only.\n2. Threshold where device is released from reset when voltage is rising.\n3. The power-on reset threshold voltage (falling) will not work unless the supply voltage has been\nbelow VPOT.Table 31-3. Reset, Brown-out and Internal voltage CharacteristicsCharacteristics\nSymbol Parameter Condi tion Min Typ Max Units\nVRST RESET  Pin Threshold Voltage 0.2 VCC 0.9VCC V\ntRST Minimum pulse width on RESET  Pin 2.5 \u00b5s\nVHYST Brown-out Detector Hysteresis 50 mV\ntBOD Min Pulse Width on Brown-out Reset 2 \u00b5s\nVBG Bandgap reference voltage VCC=2.7V, TA= 25\u00b0C 1.0 1.1 1.2 V\ntBG Bandgap reference start-up time VCC=2.7V, TA= 25\u00b0C4 0 7 0 \u00b5 s\nIBG Bandgap reference current consumption VCC=2.7V, TA= 25\u00b0C1 0 \u00b5 A\nSymbol Parameter Min.(1)Typ.(1)Max.(1)Units\nVPOTPower-on Reset Threshold Voltage (rising)(2)0.7 1.0 1.4 V\nPower-on Reset Threshold Voltage (falling)(3)0.05 0.9 1.3 V\nVPSR Power-on slope rate 0.01 4.5 V/ms\n\n373\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.5.2 Enhanced Power-On Reset\nThis implementation of power-on reset exists in newer versions of\nATmega640/1280/1281/2560/2561. The table below de scribes the characteristics of this power-\non reset and it is valid for the following devices only:\n\u0081 ATmega640: revision B and newer\n\u0081 ATmega1280: revision B and newer\u0081 ATmega1281: revision B and newer\u0081 ATmega2560: revision F and newer\u0081 ATmega2561: revision F and newerTable 31-5. Characteristics of Enhanced Power-On Reset. T\nA= -40 to +85\u00b0C.\nNotes: 1. Values are guidelines only.\n2. Threshold where device is released from reset when voltage is rising.\n3. The power-on reset threshold voltage (falling) will not work unless the supply voltage has been\nbelow VPOT.\nNote: 1. VBOT may be below nominal minimum operating voltage for some devices. For devices where this is the case, the device is \ntested down to VCC = VBOT during the production test. This guarantees  that a Brown-Out Reset will occur before VCC drops to \na voltage where correct operation of the microcontroller is no longer guaran teed. The test is performed using \nBODLEVEL = 110 for 4MHz operation of ATmega640V/1280V/ 1281V/2560V/2561V, BODLEVEL = 101 for 8MHz operation \nof ATmega640V/1280V/1281V/2560V/2561V  and ATmega640/1280/1281, and BODLEVEL = 100 for 16MHz operation of \nATmega640/1280/1281/2560/2561.\n31.6 2-wire Serial Inte rface Characteristics\nTable 31-7 on page 374  describes the requirements for devices connected to the 2-wire Serial\nBus. The ATmega640/1280/1281/2560/2561 2-wire Serial Interface meets or exceeds these\nrequirements under the noted conditions.\nTiming symbols refer to Figure 31-6 on page 375 .Symbol Parameter Min.(1)Typ.(1)Max.(1)Units\nVPOTPower-on Reset Threshold Voltage (rising)(2)1.1 1.4 1.6 V\nPower-on Reset Threshold Voltage (falling)(3)0.6 1.3 1.6 V\nVPSR Power-On Slope Rate 0.01 V/ms\nTable 31-6. BODLEVEL Fuse Coding(1)\nBODLEVEL 2:0 Fuses Min VBOT Typ VBOT Max VBOT Units\n111 BOD Disabled110 1.7 1.8 2.0\nV 101 2.5 2.7 2.9\n100 4.1 4.3 4.5011\nReserved010\n001000\n\n374\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. In ATmega640/1280/1281/2560/2561, this parameter is characterized and not 100% tested.\n2. Required only for fSCL > 100kHz.\n3. Cb = capacitance of one bus line in pF .\n4. fCK = CPU clock frequency.Table 31-7. 2-wire Serial Bus Requirements \nSymbol Parameter Condition Min Max Units\nVIL Input Low-voltage -0.5 0.3 VCC\nVVIH Input High-voltage 0.7 VCC VCC + 0.5\nVhys(1)Hysteresis of Schmitt Trigger Inputs 0.05 VCC(2)\u2013\nVOL(1)Output Low-voltage 3mA sink current 0 0.4\ntr(1)Rise Time for both SDA and SCL20 + \n0.1Cb(3)(2) 300\nnstof(1)Output Fall Time from VIHmin to VILmax 10pF < Cb < 400pF(3) 20 + \n0.1Cb(3)(2) 250\ntSP(1)Spikes Suppressed by Input Filter 0 50(2)\nIi Input Current each I/O Pin 0.1VCC < Vi < 0.9VCC -10 10 \u00b5A\nCi(1)Capacitance for each I/O Pin \u2013 10 pF\nfSCL SCL Clock FrequencyfCK(4) > max(16fSCL, \n250kHz)(5) 0 400 kHz\nRp Value of Pull-up resistorfSCL \u2264 100kHz\nfSCL > 100kHz\ntHD;STA Hold Time (repeated) START ConditionfSCL \u2264 100kHz 4.0 \u2013\n\u00b5sfSCL > 100kHz 0.6 \u2013\ntLOW Low Period of the SCL ClockfSCL \u2264 100kHz(6)4.7 \u2013\nfSCL > 100kHz(7)1.3 \u2013\ntHIGH High period of the SCL clockfSCL \u2264 100kHz 4.0 \u2013\nfSCL > 100kHz 0.6 \u2013\ntSU;STA Set-up time for a repeated START conditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 0.6 \u2013\ntHD;DAT Data hold timefSCL \u2264 100kHz 0 3.45\nfSCL > 100kHz 0 0.9\ntSU;DAT Data setup timefSCL \u2264 100kHz 250 \u2013\nfSCL > 100kHz 100 \u2013\ntSU;STO Setup time for STOP conditionfSCL \u2264 100kHz 4.0 \u2013\nfSCL > 100kHz 0.6 \u2013\ntBUFBus free time between a STOP and START \nconditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 1.3 \u2013VCC0.4V\u2013\n3mA----------------------------1000ns\nCb-------------------\n\u03a9\nVCC0.4V\u2013\n3mA----------------------------300 ns\nCb----------------- -\n\n375\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5. This requirement applies to all ATme ga640/1280/1281/2560/2561 2-wire Serial Interface operation. Other devices con-\nnected to the 2-wire Serial Bus need only obey the general fSCL requirement.\n6. The actual low period generated by the ATmega640/ 1280/1281/2560/2561 2-wire Serial Interface is (1/fSCL - 2/fCK), thus fCK \nmust be greater than 6MHz for the low time requirement to be strictly met at fSCL = 100kHz.\n7. The actual low period generated by the ATmega640/1280/1281/2560/2561 2-wire Serial Interface is (1/fSCL - 2/fCK), thus the \nlow time requirement will not be strictly met for fSCL > 308kHz when fCK = 8MHz. Still, ATmega640/1280/1281/2560/2561 \ndevices connected to the bus may communicate at fu ll speed (400kHz) with other ATmega640/1280/1281/2560/2561 \ndevices, as well as any other device with a proper tLOW acceptance margin.\nFigure 31-6. 2-wire Serial Bus Timing\n31.7 SPI Timing Characteristics\nSee Figure 31-7 on page 376  and Figure 31-8 on page 376  for details.\nNote: 1. In SPI Programming mode the minimum SCK high/low period is:\n- 2 tCLCL for fCK < 12MHz\n- 3 tCLCL for fCK > 12MHztSU;STAtLOWtHIGH\ntLOWtof\ntHD;STA tHD;DAT tSU;DATtSU;STO\ntBUFSCL\nSDAtr\nTable 31-8. SPI Timing Parameters\nDescription Mode Min Typ Max\n1 SCK period MasterSee Table 21-5 on \npage 203\nns2 SCK high/low Master 50% duty cycle\n3 Rise/Fall time Master 3.64 Setup Master 10\n5H o l dM a s t e r 1 0\n6 Out to SCK Master 0.5 \u0081 t\nsck\n7 SCK to out Master 10\n8 SCK to out high Master 10\n9S S  low to out Slave 15\n10 SCK period Slave 4 \u0081 tck\n11 SCK high/low(1)Slave 2 \u0081 tck\n12 Rise/Fall time Slave 160013 Setup Slave 10\n14 Hold Slave t\nck\n15 SCK to out Slave 15\n16 SCK to SS  high Slave 20\n17 SS  high to tri-state Slave 10\n18 SS  low to SCK Slave 20\n\n376\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-7. SPI Interface Timing Requirements (Master Mode)\nFigure 31-8. SPI Interface Timing Requirements (Slave Mode)MOSI\n(Data Output)SCK\n(CPOL = 1)\nMISO\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...61\n22\n3 45\n8 7\nMISO\n(Data Output)SCK\n(CPOL = 1)\nMOSI\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...10\n11 11\n12 13 14\n17 159\nX16\n\n377\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.8 ADC Characteristics  \u2013 Preliminary Data\nNote: 1. Values are guidelines only.Table 31-9. ADC Characteristics, Singel Ended Channels\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nResolution Single Ended Conversion 10 Bits\nAbsolute accuracy (Including \nINL, DNL, quantization error, \ngain and offset error)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC= 200kHz2.25 2.5\nLSBSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 1MHz3\nSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz\nNoise Reduction Mode2\nSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 1MHz\nNoise Reduction Mode3\nIntegral Non-Linearity (INL)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz1.25\nDifferential Non-Linearity (DNL)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz0.5\nGain ErrorSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC= 200kHz2\nOffset ErrorSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz-2\nConversion Time Free Running Conversion 13 260 \u00b5s\nClock Frequency Single Ended Conversion 50 1000 kHz\nAVCC Analog Supply Voltage VCC - 0.3 VCC + 0.3\nV VREF Reference Voltage 1.0 AVCC\nVIN Input Voltage GND VREF\nInput Bandwidth 38,5 kHz\nVINT1 Internal Voltage Reference 1.1V 1.0 1.1 1.2\nV\nVINT2 Internal Voltage Reference 2.56V 2.4 2.56 2.8\nRREF Reference Input Resistance 32 k \u03a9\nRAIN Analog Input Resistance 100 M \u03a9\n\n378\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 31-10. ADC Characteristics, Differential Channels\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nResolutionGain =  1\u00d7 8\nBits Gain = 10\u00d7 8\nGain = 200\u00d7 7\nAbsolute Accuracy(In cluding INL, DNL, \nQuantization Error, Gain and Offset Error)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz18\nLSBGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz17\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz9\nIntegral Non-Linearity (INL)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2.5\nGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz5\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz9\nDifferential Non-Linearity (DNL)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz0.75\nGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz1.5\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz10\nGain ErrorGain = 1\u00d7 1.7\n% Gain = 10\u00d7 1.7\nGain = 200\u00d7 0.5\nOffset ErrorGain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2\nLSBGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz3\nClock Frequency 50 200 kHz\nConversion Time 65 260 \u00b5s\n\n379\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: Values are guidelines only.\n31.9 External Data Memory Timing\nNotes: 1. This assumes 50% clock duty cycl e. The half peri od is actually the high time of the external clock, XTAL1.\n2. This assumes 50% clock duty cycle. The half period  is actually the low time of the external clock, XTAL1.AVCC Analog Supply Voltage VCC - 0.3 VCC + 0.3\nVVREF Reference Voltage 2.7 AVCC - 0.5\nVIN Input Voltage GND VCC\nVDIFF Input Differential Voltage -VREF/Gain VREF/Gain\nADC Conversion Output -511 511 LSB\nInput Bandwidth 4k H z\nVINT Internal Voltage Reference 2.3 2.56 2.8 V\nRREF Reference Input Resistance 32 k \u03a9\nRAIN Analog Input Resistance 100 M \u03a9\nTable 31-11. External Data Memory Characteristics, 4.5 to 5.5 Volts, No Wait-state \nSymbol Parameter8MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n1tLHLL ALE Pulse Width 115 1.0tCLCL-10\nns2tAVLL Address Valid A to ALE Low 57.5 0.5tCLCL-5(1)\n3a tLLAX_STAddress Hold After ALE Low, \nwrite access55\n3b tLLAX_LDAddress Hold after ALE Low, \nread access55\n4tAVLLC Address Valid C to ALE Low 57.5 0.5tCLCL-5(1)\n5tAVRL Address Valid to RD Low 115 1.0tCLCL-10\n6tAVWL Address Valid to WR Low 115 1.0tCLCL-10\n7tLLWL ALE Low to WR Low 47.5 67.5 0.5tCLCL-15(2)0.5tCLCL+5(2)\n8tLLRL ALE Low to RD Low 47.5 67.5 0.5tCLCL-15(2)0.5tCLCL+5(2)\n9tDVRH Data Setup to RD High 40 40\n10 tRLDV Read Low to Data Valid 75 1.0tCLCL-50\n11 tRHDX Data Hold After RD High 0 0\n12 tRLRH RD Pulse Width 115 1.0tCLCL-10\n13 tDVWL Data Setup to WR Low 42.5 0.5tCLCL-20(1)\n14 tWHDX Data Hold After WR High 115 1.0tCLCL-10\n15 tDVWH Data Valid to WR High 125 1.0tCLCL\n16 tWLWH WR Pulse Width 115 1.0tCLCL-10Table 31-10. ADC Characteristics, Differe ntial Channels (Continued)\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\n\n380\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 31-12. External Data Memory Characterist ics, 4.5 to 5.5 Volts, 1 Cycle Wait-state\nSymbol Parameter8MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 200 2.0tCLCL-50\nns12 tRLRH RD Pulse Width 240 2.0tCLCL-10\n15 tDVWH Data Valid to WR High 240 2.0tCLCL\n16 tWLWH WR Pulse Width 240 2.0tCLCL-10\nTable 31-13. External Data Memory Characteristics, 4.5 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 0\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 325 3.0tCLCL-50\nns12 tRLRH RD Pulse Width 365 3.0tCLCL-10\n15 tDVWH Data Valid to WR High 375 3.0tCLCL\n16 tWLWH WR Pulse Width 365 3.0tCLCL-10\nTable 31-14. External Data Memory Characteristics, 4.5 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 325 3.0tCLCL-50\nns12 tRLRH RD Pulse Width 365 3.0tCLCL-10\n14 tWHDX Data Hold After WR High 240 2.0tCLCL-10\n15 tDVWH Data Valid to WR High 375 3.0tCLCL\n16 tWLWH WR Pulse Width 365 3.0tCLCL-10\nTable 31-15. External Data Memory Characteristics, 2.7 to 5.5 Volts, No Wait-state \nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n\n381\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This assumes 50% clock duty cycl e. The half peri od is actually the high time of the external clock, XTAL1.\n2. This assumes 50% clock duty cycle. The half period  is actually the low time of the external clock, XTAL1.1tLHLL ALE Pulse Width 235 tCLCL-15\nns2tAVLL Address Valid A to ALE Low 115 0.5tCLCL-10(1)\n3a tLLAX_STAddress Hold After ALE Low, \nwrite access55\n3b tLLAX_LDAddress Hold after ALE Low, \nread access55\n4tAVLLC Address Valid C to ALE Low 115 0.5tCLCL-10(1)\n5tAVRL Address Valid to RD Low 235 1.0tCLCL-15\n6tAVWL Address Valid to WR Low 235 1.0tCLCL-15\n7tLLWL ALE Low to WR Low 115 130 0.5tCLCL-10(2)0.5tCLCL+5(2)\n8tLLRL ALE Low to RD Low 115 130 0.5tCLCL-10(2)0.5tCLCL+5(2)\n9tDVRH Data Setup to RD High 45 45\n10 tRLDV Read Low to Data Valid 190 1.0tCLCL-60\n11 tRHDX Data Hold After RD High 0 0\n12 tRLRH RD Pulse Width 235 1.0tCLCL-15\n13 tDVWL Data Setup to WR Low 105 0.5tCLCL-20(1)\n14 tWHDX Data Hold After WR High 235 1.0tCLCL-15\n15 tDVWH Data Valid to WR High 250 1.0tCLCL\n16 tWLWH WR Pulse Width 235 1.0tCLCL-15Table 31-15. External Data Memory Characteristics, 2.7 to 5.5 Volts, No Wait-state  (Continued)\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\nTable 31-16. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 0, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 440 2.0tCLCL-60\nns12 tRLRH RD Pulse Width 485 2.0tCLCL-15\n15 tDVWH Data Valid to WR High 500 2.0tCLCL\n16 tWLWH WR Pulse Width 485 2.0tCLCL-15\n\n382\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-9. External Memory Timing (SR Wn1 = 0, SR Wn0 = 0Table 31-17. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 0\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 690 3.0tCLCL-60\nns12 tRLRH RD Pulse Width 735 3.0tCLCL-15\n15 tDVWH Data Valid to WR High 750 3.0tCLCL\n16 tWLWH WR Pulse Width 735 3.0tCLCL-15\nTable 31-18. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 690 3.0tCLCL-60\nns12 tRLRH RD Pulse Width 735 3.0tCLCL-15\n14 tWHDX Data Hold After WR High 485 2.0tCLCL-15\n15 tDVWH Data Valid to WR High 750 3.0tCLCL\n16 tWLWH WR Pulse Width 735 3.0tCLCL-15\nALET1 T2 T3\nWrite\nReadWRT4\nA15: 8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9\n\n383\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-10. External Memory Timing (SR Wn1 = 0, SR Wn0 = 1)\nFigure 31-11. External Memory Timing (SR Wn1 = 1, SR Wn0 = 0)ALET1 T2 T3\nWrite\nReadWRT5\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4\nALET1 T2 T3\nWrite\nReadWRT6\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4 T5\n\n384\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-12. External Memory Timing (SR Wn1 = 1, SR Wn0 = 1)()\nThe ALE pulse in the last period (T 4-T7) is only present if the next instruction accesses the RAM\n(internal or external). ALET1 T2 T3\nWrite\nReadWRT7\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4 T5 T6\n\n385\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32. Typical Characteristics\nThe following charts show typical behavior. T hese figures are not tested during manufacturing.\nAll current consumption measurements are performed with all I/O pins configured as inputs and\nwith internal pull-ups enabled. A sine wave generator with rail-to-rail output is used as clocksource.\nAll Active- and Idle current consumption measurem ents are done with all bits in the PRR regis-\nters set and thus, the corresponding I/O modules are turned off. Also the Analog Comparator isdisabled during these measurements. Table 32-1 on page 390  and Table 32-2 on page 391\nshow the additional current consumption compared to I\nCC Active and ICC Idle for every I/O mod-\nule controlled by the Power Reduction Register. See \u201cPower Reduction Register\u201d on page 54  for\ndetails.\nThe power consumption in Power-down mode is independent of clock selection.\nThe current consumption is a function of several factors such as: operating voltage, operating\nfrequency, loading of I/O pins, switching rate  of I/O pins, code executed and ambient tempera-\nture. The dominating factors are operating voltage and frequency.\nThe current drawn from capacitive loaded pi ns may be estimated (for one pin) as CL \u00d7 VCC \u00d7 f\nwhere CL = load capacitance, VCC = operating voltage and f = average switching frequency of I/O\npin.\nThe parts are characterized at frequencies higher than test limits. Parts are not guaranteed to\nfunction properly at frequencies higher than the ordering code indicates.\nThe difference between current consumption in Power-down mode with Watchdog Timer\nenabled and Power-down mode with Watchdog Timer disabled represents the differential cur-\nrent drawn by the Watchdog Timer.\n32.1 Active Supply Current\nFigure 32-1. Active Supply Current vs. frequency (0.1MHz - 1.0MHz)\n5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.511.522.5\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1\nFrequency (MHz)ICC (mA)\n\n386\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-2. Active Supply Current vs . Frequency (1MHz - 16MHz)\nFigure 32-3. Active Supply Current vs. VCC (Internal RC O scillator, 8MHz)5.5V\n5.0V\n4.5V\n0510152025\n0246 8 10 12 14 16\nFrequency (MHz)ICC (m A)4.0V\n3.3V\n2.7V\n1.8V\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n02468101214\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n\n387\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-4. Active Supply Current vs. VCC (Internal RC O scillator, 1MHz)\nFigure 32-5. Active Supply Current vs. VCC (Internal RC O scillator, 128kHz)85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.7\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n\n388\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.2 Idle Supply Current\nFigure 32-6. Idle Supply Current vs. Low Frequency (0.1MHz - 1.0MHz)\nFigure 32-7. Idle Supply Current vs. Frequency (1MHz - 16MHz)5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.10.20.30.40.50.6\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (mA)\n5.5V\n5.0V\n4.5V\n012345678\n0246 8 10 12 14 16Frequency (MHz)ICC (mA)\n4.0V\n3.3V\n2.7V\n1.8V\n\n389\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-8. Idle Supply Current vs. VCC (Internal RC O scillator, 8MHz)\nFigure 32-9. Idle Supply Current vs. VCC (Internal RC O scillator, 1MHz)85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.533.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n85\u00b0C\n25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.70.80.9\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n\n390\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-10. Idle Supply Current vs. VCC (Internal RC O scillator, 128kHz)I\n32.2.1 Supply Current of IO modules\nThe tables and formulas below can be used to calculate the additional current consumption for\nthe different I/O modules in Active and Idle mode. The enabling or disabling of the I/O modulesare controlled by the Power Reduction Register. See \u201cPower Reduction Register\u201d on page 54  for\ndetails.85\u00b0C25\u00b0C-40\u00b0C\n00.050.10.150.20.250.3\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (m     A )\nTable 32-1. Additional Current Consumption for the different I/O modules (absolute values)\nPRR bit Typical numbers\nVCC = 2V, F = 1MHz VCC = 3V, F = 4MHz VCC = 5V, F = 8MHz\nPRUSART3 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRUSART2 8.0\u00b5A 51\u00b5A 220\u00b5APRUSART1 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRUSART0 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRTWI 12\u00b5A 75\u00b5A 315\u00b5A\nPRTIM5 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM4 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM3 6.0\u00b5A 39\u00b5A 150\u00b5APRTIM2 11\u00b5A 72\u00b5A 300\u00b5A\nPRTIM1 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM0 4.0\u00b5A 24\u00b5A 100\u00b5APRSPI 15\u00b5A 95\u00b5A 400\u00b5A\nPRADC 12\u00b5A 75\u00b5A 315\u00b5A\n\n391\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIt is possible to calculate the typical current consumption based on the numbers from Table 32-1\non page 390  for other VCC and frequency settings than listed in Table 32-2 .\n32.2.1.1 Example 1\nCalculate the expected current consumption in idle mode with USART0, TIMER1, and T WI\nenabled at VCC = 2.0V and F = 1MHz. From Table 32-2 , third column, we see that we need to\nadd 17% for the USART0, 24% for the T WI, and 10% for the TIMER1 module. Reading from Fig-\nure 32-6 on page 388 , we find that the idle current consumption is ~0.15mA at VCC = 2.0V and F\n= 1MHz. The total current consumption in idle mode with USART0, TIMER1, and T WI enabled,\ngives:Table 32-2. Additional Current Consumption (percentage) in Active and Idle mode\nPRR bitAdditional Current consumption \ncompared to Active wi th external clock Additional Current consumption \ncompared to Idle with external clock \nPRUSART3 3.0% 17%\nPRUSART2 3.0% 17%\nPRUSART1 3.0% 17%\nPRUSART0 3.0% 17%\nPRTWI4 . 4 % 2 4 %\nPRTIM5 1.8% 10%\nPRTIM4 1.8% 10%\nPRTIM3 1.8% 10%PRTIM2 4.3% 23%\nPRTIM1 1.8% 10%\nPRTIM0 1.5% 8.0%PRSPI 3.3% 18%\nPRADC 4.5% 24%\nICCtotal 0.15mA 10 . 1 70 . 2 40 . 1 0+++()\u2022 0.227 mA \u2248\u2248\n\n392\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.3 Power-down Supply Current\nFigure 32-11. Power-down Supply Current vs. VCC (Watchdog Timer Disabled)\nFigure 32-12. Power-down Supply Current vs. VCC (Watchdog Timer Enabled) 85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.522.533.54\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n25\u00b0C-40\u00b0C\n024681012\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)85\u00b0C\n\n393\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.4 Power-save Supply Current\nFigure 32-13. Power-save Supply Current vs. VCC (Watchdog Timer Disabled)\nFigure 32-14. Power-save Supply Current vs. VCC (Watchdog Timer Enabled)g\n25\u00b0C\n4567891011\n1.5 2 2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC(uA)\n0123456789\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (\u00b5A)25\u00b0C\n\n394\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.5 Standby Supply Current\nFigure 32-15. Standby Supply Current vs. VCC (Watchdog Timer Disabled)\n32.6 Pin Pull-up\nFigure 32-16. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 1.8V)    6MHz xtal\n    6MHz res\n    4MHz xtal    4MHz res\n    455kHz res\n    32kHz xtal    2MHz xtal    2MHz res\n    1MHz res\n00.020.040.060.080.10.120.140.160.180.2\n1.5 2 2.5 3 3.5 4 4.5 5 5.5 VCC (V)ICC (mA)\n85\u00b0C25\u00b0C\n-40\u00b0C0102030405060\n0 0.2 0.4 0.6 0. 8 1 1.2 1.4 1.6 1. 8 2\nVOP (V)IOP (\u00b5A)\n\n395\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-17. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 2.7V)\nFigure 32-18. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 5V)85\u00b0C\n25\u00b0C\n-40\u00b0C0102030405060708090\n0 0.5 1 1.5 2 2.5 3VOP (V)IOP (\u00b5A)\n85\u00b0C25\u00b0C\n-40\u00b0C020406080100120140160\n0123456VOP (V)IOP (\u00b5A)\n\n396\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-19. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 1.8V)\nFigure 32-20. Reset pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 2.7V)85\u00b0C25\u00b0C\n-40\u00b0C\n0510152025303540\n0 0.2 0.4 0.6 0. 8 1 1.2 1.4 1.6 1. 8 2VRESET (V)IRESET (\u00b5A)\n85\u00b0C25\u00b0C\n-40\u00b0C\n010203040506070\n0 0.5 1 1.5 2 2.5 3\nVRESET (V)IRESET (\u00b5A)\n\n397\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-21. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 5V)\n32.7 Pin Driver Strength\nFigure 32-22. I/O Pin output Voltage vs.Sink Current (VCC = 3V)85\u00b0C25\u00b0C\n-40\u00b0C\n020406080100120\n0123 456\nVRESET (V)IRESET (\u00b5A)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.10.20.30.40.50.60.70.80.91\n0 5 10 15 20 25 IOL (mA)VOL (V)\n\n398\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-23. I/O Pin Output Voltage vs. Sink Current (VCC = 5V)\nFigure 32-24. I/O Pin Output Voltage vs. Source Current (VCC = 3V)25\u00b0C\n-40\u00b0C\n00.10.20.30.40.50.6\n0 5 10 15 20 25IOL (mA)VOL (V)85\u00b0C\n85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.5\n0 5 10 15 20 25\nIOH (mA)VOH (V)\n\n399\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-25. I/O Pin Output Voltage vs. Source Current (VCC = 5V)\n32.8 Pin Threshold and Hysteresis\nFigure 32-26. I/O Pin Input Threshold Voltage vs. VCC (VIH, IO Pin Read as \u201c1\u201c)85\u00b0C25\u00b0C-40\u00b0C\n4.34.44.54.64.74.84.955.1\n0 5 10 15 20 25IOH (mA)VOH (V)\n85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n\n400\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-27. I/O Pin Input Threshold Voltage vs. VCC (VIL, IO Pin Read as \u201c0\u201c)  \nFigure 32-28. I/O Pin Input Hysteresis85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.70.8\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)Input Hyst eresis  (mV)\n\n401\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-29. Reset Input Threshold Voltage vs. VCC (VIH, IO Pin Read as \u201c1\u201c)\nFigure 32-30. Reset Input Threshold Voltage vs. VCC (VIL, IO Pin Read as \u201c0\u201c)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Thres hold (V )\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n\n402\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-31. Reset Pin Input Hysteresis vs. VCC  \n32.9 BOD Threshold and Analog Comparator Offset\nFigure 32-32. BOD Threshold vs. Temperature (BOD Level is 4.3V)85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.7\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Input  Hy steresis (mV)\nRising Vcc\nFalling Vcc\n4.24.254.34.354.4\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)Threshold (V)\n\n403\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-33. BOD Threshold vs. Temperature (BOD Level is 2.7V)\nFigure 32-34. BOD Threshold vs. Temperature (BOD Level is 1.8V)Rising Vcc\nFalling Vcc\n2.62.652.72.752.8\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)Threshold (V)\nRising Vcc\nFallling  Vcc\n1.71.751.81.851.9\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)T hre shold (V )\n\n404\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.10 Internal Oscillator Speed\nFigure 32-35. Watchdog Oscillator Frequency vs. VCC\nFigure 32-36. Watchdog Oscillator Freq uency vs. Temperature85\u00b0C25\u00b0C-40\u00b0C\n114116118120122124126128\n2 2.5 3 3.5 4 4.5 5 5.5VCC (V)FRC (kHz)\n5.5V4.0V3.3V2.7V2.1V\n114116118120122124126128\n-60 -40 -20 0 20 40 60 80 100Temperature (\u00b0C)FRC (kHz )\n\n405\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-37. Calibrated 8MHz RC Oscillator Frequency vs. VCC\nFigure 32-38. Calibrated 8MHz RC Oscillator Frequency vs. Temperature85\u00b0C\n25\u00b0C\n-40\u00b0C\n7.67.77.87.988.18.28.3\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)FRC (MHz)\n5.0V\n3.0V\n7.988.18.28.38.48.5\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)FRC (MHz)\n\n406\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-39. Calibrated 8MHz RC Oscillator Frequency vs. Osccal Value\n32.11 Current Consumption of Peripheral Units\nFigure 32-40. Brownout Detector Current vs. VCC85\u00b0C\n25\u00b0C\n-40\u00b0C\n0246810121416\n01 6 3 2 4 864 80 96 112 12 8144 160 176 192 20 8224 240 256\nOSCCAL (X1)FRC (MHz)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n051015202530\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n407\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-41. ADC Current vs. VCC (AREF = AVCC)\nFigure 32-42. AREF External Reference Current vs. VCC85\u00b0C25\u00b0C-40\u00b0C\n050100150200250300350\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n85\u00b0C25\u00b0C-40\u00b0C\n050100150200250\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n408\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-43. Watchdog Timer Current vs. VCC\nFigure 32-44. Analog Comparator Current vs. VCC85\u00b0C25\u00b0C-40\u00b0C\n0123456789\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (\u00b5A)\n85\u00b0C25\u00b0C-40\u00b0C\n0102030405060708090100\n1.5 2 2.5 3 3.5 4 4.5 5 5.5 VCC (V)ICC (\u00b5A)\n\n409\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-45. Programming Current vs. VCC\n32.12 Current Consumption in Reset and Reset Pulsewidth\nFigure 32-46. Reset Supply Current vs VCC (0.1MHz - 1.0MHz, Excluding Current Through The \nReset Pull-up)85\u00b0C25\u00b0C-40\u00b0C\n0246810121416\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.050.10.150.20.250.30.35\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (m A )\n\n410\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-47. Reset Supply Current vs. VCC (1MHz - 16MHz, Excluding Current Through The \nReset Pull-up)\nFigure 32-48. Minimum Reset Pulse Width vs. VCC5.5V\n5.0V\n4.5V\n00.511.522.533.54\n0246 8 10 12 14 16\nFrequency (MHz)ICC (m A)\n4.0V\n3.3V\n2.7V\n1.8V\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n05001000150020002500\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)Pu l sew i d t h  (ns)\n\n411\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n33. Register Summary\nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n(0x1FF) Reserved - - - - - - - -\n... Reserved - - - - - - - -\n(0x13F) Reserved\n(0x13E) Reserved\n(0x13D) Reserved\n(0x13C) Reserved\n(0x13B) Reserved\n(0x13A) Reserved\n(0x139) Reserved\n(0x138) Reserved\n(0x137) Reserved\n(0x136) UDR3  USART3 I/O Data Register 222\n(0x135) UBRR3H - - - - USART3 Baud Rate Register High Byte 227\n(0x134) UBRR3L  USART3 Baud Rate Register Low Byte 227\n(0x133) Reserved - - - - - - - -\n(0x132) UCSR3C UMSEL31 UMSEL30 UPM 31 UPM30 USBS3 UCSZ31 UCSZ30 UCPOL3 239\n(0x131) UCSR3B RXCIE3 TXCIE3 UDR IE3 RXEN3 TXEN3 UCSZ32 RXB83 TXB83 238\n(0x130) UCSR3A RXC3 TXC3 UDRE3 FE3 DOR3 UPE3 U2X3 MPCM3 238\n(0x12F) Reserved - - - - - - - -\n(0x12E) Reserved - - - - - - - -\n(0x12D) OCR5CH Timer/Counter5 - Output Compare Register C High Byte 165\n(0x12C) OCR5CL Timer/Counter5 - Output Compare Register C Low Byte 165\n(0x12B) OCR5BH Timer/Counter5 - Output Compare Register B High Byte 165\n(0x12A) OCR5BL Timer/Counter5 - Output Compare Register B Low Byte 165\n(0x129) OCR5AH Timer/Counter5 - Output Compare Register A High Byte 164\n(0x128) OCR5AL Timer/Counter5 - Output Compare Register A Low Byte 164\n(0x127) ICR5H Timer/Counter5 - Input Capture Register High Byte 165\n(0x126) ICR5L Timer/Counter5 - Input Capture Register Low Byte 165\n(0x125) TCNT5H Timer/Counter5 - Counter Register High Byte 163\n(0x124) TCNT5L Timer/Counter5 - Counter Register Low Byte 163\n(0x123) Reserved - - - - - - - -\n(0x122) TCCR5C FOC5A FOC5B FOC5C - - - - - 162\n(0x121) TCCR5B ICNC5 ICES5 - WGM53 WGM52 CS52 CS51 CS50 160\n(0x120) TCCR5A COM5A1 COM5A0 COM5B1 COM5B0 COM5C1 COM5C0 WGM51 WGM50 158\n(0x11F) Reserved - - - - - - - -\n(0x11E) Reserved - - - - - - - -\n(0x11D) Reserved - - - - - - - -\n(0x11C) Reserved - - - - - - - -\n(0x11B) Reserved - - - - - - - -\n(0x11A) Reserved - - - - - - - -\n(0x119) Reserved - - - - - - - -\n(0x118) Reserved - - - - - - - -\n(0x117) Reserved - - - - - - - -\n(0x116) Reserved - - - - - - - -\n(0x115) Reserved - - - - - - - -\n(0x114) Reserved - - - - - - - -\n(0x113) Reserved - - - - - - - -\n(0x112) Reserved - - - - - - - -\n(0x111) Reserved - - - - - - - -\n(0x110) Reserved - - - - - - - -\n(0x10F) Reserved - - - - - - - -\n(0x10E) Reserved - - - - - - - -\n(0x10D) Reserved - - - - - - - -\n(0x10C) Reserved - - - - - - - -\n(0x10B) PORTL PORTL7 PORTL6 PORTL5 PORTL4 PORTL3 PORTL2 PORTL1 PORTL0 104\n(0x10A) DDRL DDL7 DDL6 DDL5 DDL4 DDL3 DDL2 DDL1 DDL0 104\n(0x109) PINL PINL7 PINL6 PINL5 PINL4 PINL3 PINL2 PINL1 PINL0 104\n(0x108) PORTK PORTK7 PORTK6 PORTK5 PORTK4 PORTK3 PORTK2 PORTK1 PORTK0 103\n(0x107) DDRK DDK7 DDK6 DDK5 DDK4 DDK3 DDK2 DDK1 DDK0 103\n(0x106) PINK PINK7 PINK6 PINK5 PINK4 PINK3 PINK2 PINK1 PINK0 103\n(0x105) PORTJ PORTJ7 PORTJ6 PORTJ5 PORTJ4 PORTJ3 PORTJ2 PORTJ1 PORTJ0 103\n(0x104) DDRJ DDJ7 DDJ6 DDJ5 DDJ4 DDJ3 DDJ2 DDJ1 DDJ0 103\n(0x103) PINJ PINJ7 PINJ6 PINJ5 PINJ4 PINJ3 PINJ2 PINJ1 PINJ0 103\n(0x102) PORTH PORTH7 PORTH6 PORTH5 PORTH4 PORTH3 PORTH2 PORTH1 PORTH0 102\n(0x101) DDRH DDH7 DDH6 DDH5 DDH4 DDH3 DDH2 DDH1 DDH0 103\n\n412\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0x100) PINH PINH7 PINH6 PINH5 PINH4 PINH3 PINH2 PINH1 PINH0 103\n(0xFF) Reserved - - - - - - - -\n(0xFE) Reserved - - - - - - - -\n(0xFD) Reserved - - - - - - - -\n(0xFC) Reserved - - - - - - - -\n(0xFB) Reserved - - - - - - - -\n(0xFA) Reserved - - - - - - - -\n(0xF9) Reserved - - - - - - - -\n(0xF8) Reserved - - - - - - - -\n(0xF7) Reserved - - - - - - - -\n(0xF6) Reserved - - - - - - - -\n(0xF5) Reserved - - - - - - - -\n(0xF4) Reserved - - - - - - - -\n(0xF3) Reserved - - - - - - - -\n(0xF2) Reserved - - - - - - - -\n(0xF1) Reserved - - - - - - - -\n(0xF0) Reserved - - - - - - - -\n(0xEF) Reserved - - - - - - - -\n(0xEE) Reserved - - - - - - - -\n(0xED) Reserved - - - - - - - -\n(0xEC) Reserved - - - - - - - -\n(0xEB) Reserved - - - - - - -\n(0xEA) Reserved - - - - - - - -\n(0xE9) Reserved - - - - - - - -\n(0xE8) Reserved - - - - - - - -\n(0xE7) Reserved - - - - - - -\n(0xE6) Reserved - - - - - - - -\n(0xE5) Reserved - - - - - - - -\n(0xE4) Reserved - - - - - - - -\n(0xE3) Reserved - - - - - - -\n(0xE2) Reserved - - - - - - - -\n(0xE1) Reserved - - - - - - -\n(0xE0) Reserved - - - - - - -\n(0xDF) Reserved - - - - - - - -\n(0xDE) Reserved - - - - - - - -\n(0xDD) Reserved - - - - - - -\n(0xDC) Reserved - - - - - - - -\n(0xDB) Reserved - - - - - - - -\n(0xDA) Reserved - - - - - - - -\n(0xD9) Reserved - - - - - - -\n(0xD8) Reserved - - - - - - - -\n(0xD7) Reserved - - - - - - - -\n(0xD6) UDR2  USART2 I/O Data Register 222\n(0xD5) UBRR2H - - - - USART2 Baud Rate Register High Byte 227\n(0xD4) UBRR2L  USART2 Baud Rate Register Low Byte 227\n(0xD3) Reserved - - - - - - - -\n(0xD2) UCSR2C UMSEL21 UMSEL20 UPM2 1 UPM20 USBS2 UCSZ21 UCSZ20 UCPOL2 239\n(0xD1) UCSR2B RXCIE2 TXCIE2 UDRIE 2 RXEN2 TXEN2 UCSZ22 RXB82 TXB82 238\n(0xD0) UCSR2A RXC2 TXC2 UDRE2 FE2 DOR2 UPE2 U2X2 MPCM2 238\n(0xCF) Reserved - - - - - - - -\n(0xCE) UDR1  USART1 I/O Data Register 222\n(0xCD) UBRR1H - - - - USART1 Baud Rate Register High Byte 227\n(0xCC) UBRR1L  USART1 Baud Rate Register Low Byte 227\n(0xCB) Reserved - - - - - - - -\n(0xCA) UCSR1C UMSEL11 UMSEL10 UPM1 1 UPM10 USBS1 UCSZ11 UCSZ10 UCPOL1 239\n(0xC9) UCSR1B RXCIE1 TXCIE1 UDRIE 1 RXEN1 TXEN1 UCSZ12 RXB81 TXB81 238\n(0xC8) UCSR1A RXC1 TXC1 UDRE1 FE1 DOR1 UPE1 U2X1 MPCM1 238\n(0xC7) Reserved - - - - - - - -\n(0xC6) UDR0  USART0 I/O Data Register 222\n(0xC5) UBRR0H - - - - USART0 Baud Rate Register High Byte 227\n(0xC4) UBRR0L  USART0 Baud Rate Register Low Byte 227\n(0xC3) Reserved - - - - - - - -\n(0xC2) UCSR0C UMSEL01 UMSEL00 UPM0 1 UPM00 USBS0 UCSZ01 UCSZ00 UCPOL0 239\n(0xC1) UCSR0B RXCIE0 TXCIE0 UDRIE 0 RXEN0 TXEN0 UCSZ02 RXB80 TXB80 238\n(0xC0) UCSR0A RXC0 TXC0 UDRE0 FE0 DOR0 UPE0 U2X0 MPCM0 238\n(0xBF) Reserved - - - - - - - -Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n413\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0xBE) Reserved - - - - - - - -\n(0xBD) T WAMR T WAM6 T WAM5 T WAM4 T WAM3 T WAM2 T WAM1 T WAM0 - 269\n(0xBC) T WCR T WINT T WEA T WSTA T WSTO T WWCT WEN -T WIE 266\n(0xBB) T WDR  2-wire Serial Interface Data Register 268\n(0xBA) T WAR T WA6 T WA5 T WA4 T WA3 T WA2 T WA1 T WA0 T WGCE 269\n(0xB9) T WSR T WS7 T WS6 T WS5 T WS4 T WS3 -T WPS1 T WPS0 268\n(0xB8) T WBR 2-wire Serial Interface Bit Rate Register 266\n(0xB7) Reserved - - - - - - - -\n(0xB6) ASSR - EXCLK AS2 TCN2UB OCR2AUB OCR2BUB TCR2AUB TCR2BUB 184\n(0xB5) Reserved - - - - - - - -\n(0xB4) OCR2B  Timer/Counter2 Output Compare Register B 191\n(0xB3) OCR2A  Timer/Counter2 Output Compare Register A 191\n(0xB2) TCNT2  Timer/Counter2 (8 Bit) 191\n(0xB1) TCCR2B FOC2A FOC2B - - WGM22 CS22 CS21 CS20 190\n(0xB0) TCCR2A COM2A1 COM2A0 COM2B1 COM2B0 - - WGM21 WGM20 191\n(0xAF) Reserved - - - - - - - -\n(0xAE) Reserved - - - - - - - -\n(0xAD) OCR4CH Timer/Counter4 - Output Compare Register C High Byte 164\n(0xAC) OCR4CL Timer/Counter4 - Output Compare Register C Low Byte 164\n(0xAB) OCR4BH Timer/Counter4 - Output Compare Register B High Byte 164\n(0xAA) OCR4BL Timer/Counter4 - Output Compare Register B Low Byte 164\n(0xA9) OCR4AH Timer/Counter4 - Output Compare Register A High Byte 164\n(0xA8) OCR4AL Timer/Counter4 - Output Compare Register A Low Byte 164\n(0xA7) ICR4H Timer/Counter4 - Input Capture Register High Byte 165\n(0xA6) ICR4L Timer/Counter4 - Input Capture Register Low Byte 165\n(0xA5) TCNT4H Timer/Counter4 - Counter Register High Byte 163\n(0xA4) TCNT4L Timer/Counter4 - Counter Register Low Byte 163\n(0xA3) Reserved - - - - - - - -\n(0xA2) TCCR4C FOC4A FOC4B FOC4C - - - - - 162\n(0xA1) TCCR4B ICNC4 ICES4 - WGM43 WGM42 CS42 CS41 CS40 160\n(0xA0) TCCR4A COM4A1 COM4A0 COM4B1 COM4B0 COM4C1 COM4C0 WGM41 WGM40 158\n(0x9F) Reserved - - - - - - - -\n(0x9E) Reserved - - - - - - - -\n(0x9D) OCR3CH Timer/Counter3 - Output Compare Register C High Byte 164\n(0x9C) OCR3CL Timer/Counter3 - Output Compare Register C Low Byte 164\n(0x9B) OCR3BH Timer/Counter3 - Output Compare Register B High Byte 164\n(0x9A) OCR3BL Timer/Counter3 - Output Compare Register B Low Byte 164\n(0x99) OCR3AH Timer/Counter3 - Output Compare Register A High Byte 163\n(0x98) OCR3AL Timer/Counter3 - Output Compare Register A Low Byte 163\n(0x97) ICR3H Timer/Counter3 - Input Capture Register High Byte 165\n(0x96) ICR3L Timer/Counter3 - Input Capture Register Low Byte 165\n(0x95) TCNT3H Timer/Counter3 - Counter Register High Byte 162\n(0x94) TCNT3L Timer/Counter3 - Counter Register Low Byte 162\n(0x93) Reserved - - - - - - - -\n(0x92) TCCR3C FOC3A FOC3B FOC3C - - - - - 162\n(0x91) TCCR3B ICNC3 ICES3 - WGM33 WGM32 CS32 CS31 CS30 160\n(0x90) TCCR3A COM3A1 COM3A0 COM3B1 COM3B0 COM3C1 COM3C0 WGM31 WGM30 158\n(0x8F) Reserved - - - - - - - -\n(0x8E) Reserved - - - - - - - -\n(0x8D) OCR1CH Timer/Counter1 - Output Compare Register C High Byte 163\n(0x8C) OCR1CL Timer/Counter1 - Output Compare Register C Low Byte 163\n(0x8B) OCR1BH Timer/Counter1 - Output Compare Register B High Byte 163\n (0x8A) OCR1BL Timer/Counter1 - Output Compare Register B Low Byte 163\n(0x89) OCR1AH Timer/Counter1 - Output Compare Register A High Byte 163\n(0x88) OCR1AL Timer/Counter1 - Output Compare Register A Low Byte 163\n(0x87) ICR1H Timer/Counter1 - Input Capture Register High Byte 165\n(0x86) ICR1L Timer/Counter1 - Input Capture Register Low Byte 165\n(0x85) TCNT1H Timer/Counter1 - Counter Register High Byte 162\n(0x84) TCNT1L Timer/Counter1 - Counter Register Low Byte 162\n(0x83) Reserved - - - - - - - -\n(0x82) TCCR1C FOC1A FOC1B FOC1C - - - - - 161\n(0x81) TCCR1B ICNC1 ICES1 - WGM13 WGM12 CS12 CS11 CS10 160\n(0x80) TCCR1A COM1A1 COM1A0 COM1B1 COM1B0 COM1C1 COM1C0 WGM11 WGM10 158\n(0x7F) DIDR1 - - - - - -A I N 1 D A I N 0 D 274\n(0x7E) DIDR0 ADC7D ADC6D ADC5D ADC4D ADC3D ADC2D ADC1D ADC0D 295\n(0x7D) DIDR2 ADC15D ADC14D ADC13D ADC12D ADC11D ADC10D ADC9D ADC8D 295Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n414\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0x7C) ADMUX REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 289\n(0x7B) ADCSRB -A C M E - - MUX5 ADTS2 ADTS1 ADTS0 272, 290, 294\n(0x7A) ADCSRA ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 292\n(0x79) ADCH ADC Data Register High byte 294\n(0x78) ADCL ADC Data Register Low byte 294\n(0x77) Reserved - - - - - - - -\n(0x76) Reserved - - - - - - - -\n(0x75) XMCRB XMBK - - - - XMM2 XMM1 XMM0 38\n(0x74) XMCRA SRE SRL2 SRL1 SRL0 SR W11 SR W10 SR W01 SR W00 37\n(0x73) TIMSK5 - -I C I E 5 - OCIE5C OCIE5B OCIE5A TOIE5 166\n(0x72) TIMSK4 - -I C I E 4 - OCIE4C OCIE4B OCIE4A TOIE4 166\n(0x71) TIMSK3 - -I C I E 3 - OCIE3C OCIE3B OCIE3A TOIE3 166\n(0x70) TIMSK2 - - - - - OCIE2B OCIE2A TOIE2 193\n(0x6F) TIMSK1 - -I C I E 1 - OCIE1C OCIE1B OCIE1A TOIE1 166\n(0x6E) TIMSK0 - - - - - OCIE0B OCIE0A TOIE0 134\n(0x6D) PCMSK2 PCINT23 PCINT22 PCINT21 PCINT20 PCINT19 PCINT18 PCINT17 PCINT16 116\n(0x6C) PCMSK1 PCINT15 PCINT14 PCINT13 P CINT12 PCINT11 PCINT10 PCINT9 PCINT8 116\n(0x6B) PCMSK0 PCINT7 PCINT6 PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 117\n(0x6A) EICRB ISC71 ISC70 ISC61 ISC60 ISC51 ISC50 ISC41 ISC40 114\n(0x69) EICRA ISC31 ISC30 ISC21 ISC20 ISC11 ISC10 ISC01 ISC00 113\n(0x68) PCICR - - - - - PCIE2 PCIE1 PCIE0 115\n(0x67) Reserved - - - - - - - -\n(0x66) OSCCAL Oscillator Calibration Register 50\n(0x65) PRR1 - - PRTIM5 PRTIM4 PRTIM3 PRUSART3 PRUSART2 PRUSART1 57\n(0x64) PRR0 PRT WI PRTIM2 PRTIM0 - PRTIM1 PRSPI PRUSART0 PRADC 56\n(0x63) Reserved - - - - - - - -\n(0x62) Reserved - - - - - - - -\n(0x61) CLKPR CLKPCE - - - CLKPS3 CLKPS2 CLKPS1 CLKPS0 50\n(0x60) WDTCSR WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 67\n0x3F (0x5F) SREG I T H S V N Z C 14\n0x3E (0x5E) SPH SP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 16\n0x3D (0x5D) SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 16\n0x3C (0x5C) EIND - - - - - - -E I N D 0 17\n0x3B (0x5B) RAMPZ - - - - - - RAMPZ1 RAMPZ0 17\n0x3A (0x5A) Reserved - - - - - - - -\n0x39 (0x59) Reserved - - - - - - - -\n0x38 (0x58) Reserved - - - - - - - -\n0x37 (0x57) SPMCSR SPMIE R WWSB SIGRD R WWSRE BLBSET PG WRT PGERS SPMEN 332\n0x36 (0x56) Reserved - - - - - - - -\n0x35 (0x55) MCUCR JTD - -P U D - - IVSEL IVCE 67, 110, 100, 308\n0x34 (0x54) MCUSR - - -J T R F WDRF BORF EXTRF PORF 308\n0x33 (0x53) SMCR - - - - SM2 SM1 SM0 SE 52\n0x32 (0x52) Reserved - - - - - - - -\n0x31 (0x51) OCDR OCDR7 OCDR6 OCDR5 OCDR4 OCDR3 OCDR2 OCDR1 OCDR0 301\n0x30 (0x50) ACSR ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 272\n0x2F (0x4F) Reserved - - - - - - - -\n0x2E (0x4E) SPDR  SPI Data Register 204\n0x2D (0x4D) SPSR SPIF WCOL - - - - - SPI2X 203\n0x2C (0x4C) SPCR SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 202\n0x2B (0x4B) GPIOR2 General Purpose I/O Register 2 37\n0x2A (0x4A) GPIOR1 General Purpose I/O Register 1 37\n0x29 (0x49) Reserved - - - - - - - -\n0x28 (0x48) OCR0B  Timer/Counter0 Output Compare Register B 133\n0x27 (0x47) OCR0A  Timer/Counter0 Output Compare Register A 133\n0x26 (0x46) TCNT0  Timer/Counter0 (8 Bit) 133\n0x25 (0x45) TCCR0B FOC0A FOC0B - - WGM02 CS02 CS01 CS00 132\n0x24 (0x44) TCCR0A COM0A1 COM0A0 COM0B1 COM0B0 - - WGM01 WGM00 129\n0x23 (0x43) GTCCR TSM - - - - - PSRASY PSRSYNC 170, 194\n0x22 (0x42) EEARH - - - - EEPROM Address Register High Byte 35\n0x21 (0x41) EEARL EEPROM Address Register Low Byte 35\n0x20 (0x40) EEDR EEPROM Data Register 35\n0x1F (0x3F) EECR - - EEPM1 EEPM0 EERIE EEMPE EEPE EERE 35\n0x1E (0x3E) GPIOR0 General Purpose I/O Register 0 37\n0x1D (0x3D) EIMSK INT7 INT6 INT5 INT4 INT3 INT2 INT1 INT0 115\n0x1C (0x3C) EIFR INTF7 INTF6 INTF5 INTF4 INTF3 INTF2 INTF1 INTF0 115\n0x1B (0x3B) PCIFR - - - - - PCIF2 PCIF1 PCIF0 116Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n415\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. For compatibility with future devices, reserved bits s hould be written to zero if accessed. Reserved I/O memory address es \nshould never be written.\n2. I/O registers within the address range $00 - $1F are directly bit-accessible using th e SBI and CBI instructions. In these reg -\nisters, the value of single bits can be checked by using the SBIS and SBIC instructions.\n3. Some of the status flags are cleared by writing a logical o ne to them. Note that the CBI and SBI instructions will operate on  \nall bits in the I/O register, writing a one back into any flag r ead as set, thus clearing the fl ag. The CBI and SBI instruction s \nwork with registers 0x00 to 0x1F only.\n4.When using the I/O specific commands IN and OU T, the I/O addresses $00 - $3F must be used. When addressing I/O regis-\nters as data space using LD and ST instructions, $20 must be added to these addresses. The \nATmega640/1280/1281/2560/2561 is a complex microcontroller with  more peripheral units than can be supported within the \n64 location reserved in Opcode for the IN  and OUT instructions. For the Extended I/O space from $60 - $1FF in SRAM, only \nthe ST/STS/STD and LD/LDS/LDD instructions can be used.0x1A (0x3A) TIFR5 - -I C F 5 - OCF5C OCF5B OCF5A TOV5 166\n0x19 (0x39) TIFR4 - -I C F 4 - OCF4C OCF4B OCF4A TOV4 167\n0x18 (0x38) TIFR3 - -I C F 3 - OCF3C OCF3B OCF3A TOV3 167\n0x17 (0x37) TIFR2 - - - - - OCF2B OCF2A TOV2 193\n0x16 (0x36) TIFR1 - -I C F 1 - OCF1C OCF1B OCF1A TOV1 167\n0x15 (0x35) TIFR0 - - - - - OCF0B OCF0A TOV0 134\n0x14 (0x34) PORTG - - PORTG5 PORTG4 PORTG3 PORTG2 PORTG1 PORTG0 102\n0x13 (0x33) DDRG - - DDG5 DDG4 DDG3 DDG2 DDG1 DDG0 102\n0x12 (0x32) PING - - PING5 PING4 PING3 PING2 PING1 PING0 102\n0x11 (0x31) PORTF PORTF7 PORTF6 PORTF5 PORTF4 PORTF3 PORTF2 PORTF1 PORTF0 101\n0x10 (0x30) DDRF DDF7 DDF6 DDF5 DDF4 DDF3 DDF2 DDF1 DDF0 102\n0x0F (0x2F) PINF PINF7 PINF6 PINF5 PINF4 PINF3 PINF2 PINF1 PINF0 102\n0x0E (0x2E) PORTE PORTE7 PORTE6 PORTE 5 PORTE4 PORTE3 PORTE2 PORTE1 PORTE0 101\n0x0D (0x2D) DDRE DDE7 DDE6 DDE5 DDE4 DDE3 DDE2 DDE1 DDE0 101\n0x0C (0x2C) PINE PINE7 PINE6 PINE5 PINE4 PINE3 PINE2 PINE1 PINE0 102\n0x0B (0x2B) PORTD PORTD7 PORTD6 PORTD 5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 101\n0x0A (0x2A) DDRD DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 101\n0x09 (0x29) PIND PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 101\n0x08 (0x28) PORTC PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 101\n0x07 (0x27) DDRC DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 101\n0x06 (0x26) PINC PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 101\n0x05 (0x25) PORTB PORTB7 PORTB6 PORTB 5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 100\n0x04 (0x24) DDRB DDB7 DDB6 D DB5 DDB4 DDB3 DDB2 DDB1 DDB0 100\n0x03 (0x23) PINB PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 100\n0x02 (0x22) PORTA PORTA7 PORTA6 PORTA 5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 100\n0x01 (0x21) DDRA DDA7 DDA6 D DA5 DDA4 DDA3 DDA2 DDA1 DDA0 100\n0x00 (0x20) PINA PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 100Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n416\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n34. Instruction Set Summary\nMnemonics Operands Description Operation Flags #Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \u2190 Rd + Rr Z, C, N, V, H 1\nADC Rd, Rr Add with Carry two Registers Rd \u2190 Rd + Rr + C Z, C, N, V, H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \u2190 Rdh:Rdl + K Z, C, N, V, S 2\nSUB Rd, Rr Subtract two Registers Rd \u2190 Rd - Rr Z, C, N, V, H 1\nSUBI Rd, K Subtract Constant from Register Rd \u2190 Rd - K Z, C, N, V, H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \u2190 Rd - Rr - C Z, C, N, V, H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \u2190 Rd - K - C Z, C, N, V, H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \u2190 Rdh:Rdl - K Z, C, N, V, S 2\nAND Rd, Rr Logical AND Registers Rd \u2190 Rd \u2022 Rr Z, N, V 1\nANDI Rd, K Logical AND Register and Constant Rd \u2190 Rd \u2022 K Z, N, V 1\nOR Rd, Rr Logical OR Registers Rd \u2190 Rd v Rr Z, N, V 1\nORI Rd, K Logical OR Register and Constant Rd \u2190 Rd v K Z, N, V 1\nEOR Rd, Rr Exclusive OR Registers Rd \u2190 Rd \u2295 Rr Z, N, V 1\nCOM Rd One\u2019s Complement Rd \u2190 0xFF \u2212 Rd Z, C, N, V 1\nNEG Rd Two\u2019s Complement Rd \u2190 0x00 \u2212 Rd Z, C, N, V, H 1\nSBR Rd,K Set Bit(s) in Register Rd \u2190 Rd v K Z, N, V 1\nCBR Rd,K Clear Bit(s) in Register Rd \u2190 Rd \u2022 (0xFF - K) Z, N, V 1\nINC Rd Increment Rd \u2190 Rd + 1 Z, N, V 1\nDEC Rd Decrement Rd \u2190 Rd \u2212 1 Z, N, V 1\nTST Rd Test for Zero or Minus Rd \u2190 Rd \u2022 Rd Z, N, V 1\nCLR Rd Clear Register Rd  \u2190 Rd \u2295 Rd Z, N, V 1\nSER Rd Set Register Rd \u2190 0xFF None 1\nMUL Rd, Rr Multiply Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nMULS Rd, Rr Multiply Signed R1:R0 \u2190 Rd x Rr Z, C 2\nMULSU Rd, Rr Multiply Signed with Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nFMUL Rd, Rr Fractional Multiply Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULS Rd, Rr Fractional Multiply Signed R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULSU Rd, Rr Fractional Multiply Signed with Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nBRANCH INSTRUCTIONSRJMP k Relative Jump PC  \u2190 PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \u2190 Z None 2\nEIJMP Extended Indirect Jump to (Z) PC \u2190(EIND:Z) None 2\nJMP k Direct Jump PC  \u2190 kN o n e 3\nRCALL k Relative Subroutine Call PC \u2190 PC + k + 1 None 4\nICALL Indirect Call to (Z) PC \u2190 ZN o n e 4\nEICALL Extended Indirect Call to (Z) PC \u2190(EIND:Z) None 4\nCALL k Direct Subroutine Call PC \u2190 kN o n e 5\nRET Subroutine Return PC \u2190 STACK None 5\nRETI Interrupt Return PC \u2190 STACK I 5\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC  \u2190 PC + 2 or 3 None 1/2/3\nCP Rd,Rr Compare Rd \u2212 Rr Z, N, V, C, H 1 \nCPC Rd,Rr Compare with Carry Rd \u2212 Rr \u2212 C Z, N, V, C, H 1\nCPI Rd,K Compare Register with Immediate Rd \u2212 K Z, N, V, C, H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \u2190 PC + 2 or 3 None 1/2/3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \u2190 PC + 2 or 3 None 1/2/3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \u2190 PC + 2 or 3 None 1/2/3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \u2190 PC + 2 or 3 None 1/2/3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \u2190PC+k + 1 None 1/2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \u2190PC+k + 1 None 1/2\nBREQ  k Branch if Equal if (Z = 1) then PC \u2190 PC + k + 1 None 1/2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \u2190 PC + k + 1 None 1/2\nBRCS  k Branch if Carry Set if (C = 1) then PC \u2190 PC + k + 1 None 1/2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \u2190 PC + k + 1 None 1/2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \u2190 PC + k + 1 None 1/2\nBRLO  k Branch if Lower if (C = 1) then PC \u2190 PC + k + 1 None 1/2\nBRMI  k Branch if Minus if (N = 1) then PC \u2190 PC + k + 1 None 1/2\nBRPL  k Branch if Plus if (N = 0) then PC \u2190 PC + k + 1 None 1/2\nBRGE  k Branch if Greater or Equal, Signed if (N \u2295 V= 0) then PC \u2190 PC + k + 1 None 1/2\nBRLT  k Branch if Less Than Zero, Signed if (N \u2295 V= 1) then PC \u2190 PC + k + 1 None 1/2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \u2190 PC + k + 1 None 1/2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \u2190 PC + k + 1 None 1/2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \u2190 PC + k  + 1 None 1/2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \u2190 PC + k + 1 None 1/2\n\n417\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \u2190 PC + k + 1 None 1/2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \u2190 PC + k + 1 None 1/2\nBRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \u2190 PC + k + 1 None 1/2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \u2190 PC + k + 1 None 1/2\nBIT AND BIT-TEST INSTRUCTIONS\nSBI P,b Set Bit in I/O Register I/O(P,b) \u2190 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \u2190 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \u2190 Rd(n), Rd(0) \u2190 0 Z, C, N, V 1\nLSR Rd Logical Shift Right Rd(n) \u2190 Rd(n+1), Rd(7) \u2190 0 Z, C, N, V 1\nROL Rd Rotate Left Through Carry Rd(0) \u2190C,Rd(n+1) \u2190 Rd(n),C \u2190Rd(7) Z, C, N, V 1\nROR Rd Rotate Right Through Carry Rd(7) \u2190C,Rd(n) \u2190 Rd(n+1),C \u2190Rd(0) Z, C, N, V 1\nASR Rd Arithmetic Shift Right Rd(n) \u2190 Rd(n+1), n=0..6 Z, C, N, V 1\nSWAP Rd Swap Nibbles Rd(3..0) \u2190Rd(7..4),Rd(7..4) \u2190Rd(3..0) None 1\nBSET s Flag Set SREG(s) \u2190 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \u2190 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \u2190 Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \u2190 TN o n e 1\nSEC Set Carry C \u2190 1C 1\nCLC Clear Carry C \u2190 0 C 1\nSEN Set Negative Flag N \u2190 1N 1\nCLN Clear Negative Flag N \u2190 0 N 1\nSEZ Set Zero Flag Z \u2190 1Z 1\nCLZ Clear Ze ro Flag Z \u2190 0 Z 1\nSEI Global Interrupt Enable I \u2190 1I 1\nCLI Global Interrupt Disable I  \u2190 0 I 1\nSES Set Signed Test Flag S \u2190 1S 1\nCLS Clear Signed Test Flag S \u2190 0 S 1\nSEV Set Twos Complement Overflow. V \u2190 1V 1\nCLV Clear Twos Complement Overflow V \u2190 0 V 1\nSET Set T in SREG T \u2190 1T 1\nCLT Clear T in SREG T \u2190 0 T 1\nSEH Set Half Carry Flag in SREG H \u2190 1H 1\nCLH Clear Half Carry Flag in SREG H \u2190 0 H 1\nDATA TRANSFER INSTRUCTIONS\nMOV Rd, Rr Move Between Registers Rd \u2190 Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \u2190 Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \u2190 KN o n e 1\nLD Rd, X Load Indirect Rd \u2190 (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \u2190 (X), X \u2190 X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \u2190 X - 1, Rd \u2190 (X) None 2\nLD Rd, Y Load Indirect Rd \u2190 (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \u2190 (Y), Y \u2190 Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \u2190 Y - 1, Rd \u2190 (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \u2190 (Y + q) None 2\nLD Rd, Z Load Indirect Rd \u2190 (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \u2190 (Z), Z \u2190 Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \u2190 Z - 1, Rd \u2190 (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \u2190 (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \u2190 (k) None 2\nST X, Rr Store Indirect (X)  \u2190 Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X)  \u2190 Rr, X \u2190 X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \u2190 X - 1, (X) \u2190 Rr None 2\nST Y, Rr Store Indirect (Y) \u2190 Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \u2190 Rr, Y \u2190 Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \u2190 Y - 1, (Y) \u2190 Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \u2190 Rr None 2\nST Z, Rr Store Indirect (Z) \u2190 Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \u2190 Rr, Z \u2190 Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \u2190 Z - 1, (Z) \u2190 Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \u2190 Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \u2190 Rr None 2\nLPM Load Program Memory R0 \u2190 (Z) None 3\nLPM Rd, Z Load Program Memory Rd \u2190 (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \u2190 (Z), Z \u2190 Z+1 None 3\nELPM Extended Load Program Memory R0 \u2190 (RAMPZ:Z) None 3\nELPM Rd, Z Extended Load Program Memory Rd \u2190 (RAMPZ:Z) None 3Mnemonics Operands Description Operation Flags #Clocks\n\n418\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: EICALL and EIJMP do not exist in ATmega640/1280/1281.\nELPM does not exist in ATmega640.ELPM Rd, Z+ Extended Load Program Memory Rd \u2190 (RAMPZ:Z), RAMPZ:Z \u2190RAMPZ:Z+1 None 3\nSPM Store Program Memory (Z) \u2190 R1:R0 None -\nIN Rd, P In Port Rd \u2190 PN o n e 1\nOUT P, Rr Out Port P \u2190 Rr None 1\nPUSH Rr Push Register on Stack STACK \u2190 Rr None 2\nPOP Rd Pop Register from Stack Rd \u2190 STACK None 2\nMCU CONTROL INSTRUCTIONSNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1\nWDR Watchdog Reset (see specific descr. for WDR/timer) None 1\nBREAK Break For On-chip Debug Only None N/AMnemonics Operands Description Operation Flags #Clocks\n\n419\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n35. Ordering Information\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2.See \u201cSpeed Grades\u201d on page 369.\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.1 ATmega640\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8 - 5.5VATmega640V-8AU\nATmega640V-8AUR(4)\nATmega640V-8CUATmega640V-8CUR\n(4)100A100A\n100C1\n100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 2.7 - 5.5VATmega640-16AU\nATmega640-16AUR\n(4)\nATmega640-16CUATmega640-16CUR\n(4)100A100A\n100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n420\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.2 ATmega1280\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8V - 5.5VATmega1280V-8AU\nATmega1280V-8AUR(4)\nATmega1280V-8CU\nATmega1280V-8CUR(4)100A\n100A\n100C1100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 2.7V - 5.5VATmega1280-16AU\nATmega1280-16AUR\n(4)\nATmega1280-16CU\nATmega1280-16CUR(4)100A\n100A100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n421\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.3 ATmega1281\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8 - 5.5VATmega1281V-8AU\nATmega1281V-8AUR(4)\nATmega1281V-8MUATmega1281V-8MUR\n(4)64A64A\n64M2\n64M2 Industrial\n(-40\u00b0C to 85 \u00b0C)\n16 2.7 - 5.5VATmega1281-16AU\nATmega1281-16AUR\n(4)\nATmega1281-16MU\nATmega1281-16MUR(4)64A\n64A\n64M264M2\nPackage Type\n64A 64-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n64M2 64-pad, 9mm \u00d7 9mm \u00d7 1.0mm Body, Quad Flat No-lead/Micro Lead Frame Package (QFN/MLF)\n\n422\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.4 ATmega2560\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8V - 5.5VATmega2560V-8AU\nATmega2560V-8AUR(4)\nATmega2560V-8CU\nATmega2560V-8CUR(4)100A\n100A\n100C1100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 4.5V - 5.5VATmega2560-16AU\nATmega2560-16AUR\n(4)\nATmega2560-16CU\nATmega2560-16CUR(4)100A\n100A100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n423\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.5 ATmega2561\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n81 . 8 V  -  5 . 5 VATmega1281V-8AU\nATmega1281V-8AUR(4)\nATmega1281V-8MU\nATmega1281V-8MUR(4)64A\n64A\n64M264M2 Industrial\n(-40\u00b0C to 85 \u00b0C)\n16 4.5V - 5.5VATmega1281-16AU\nATmega1281-16AUR\n(4)\nATmega1281-16MU\nATmega1281-16MUR(4)64A\n64A64M2\n64M2\nPackage Type\n64A 64-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n64M2 64-pad, 9mm \u00d7 9mm \u00d7 1.0mm Body, Quad Flat No-lead/Micro Lead Frame Package (QFN/MLF)\n\n424\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36. Packaging Information\n36.1 100A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n100A,  100-le ad, 14 x 14 mm Body Size, 1.0 mm Body Thickne ss,\n0.5 mm Le ad Pitch, Thin Profile Pl astic Quad Flat Package (TQFP) D 100A2010-10-20PIN 1 IDENTIFIER\n0\u00b0~7\u00b0PIN 1 \nLC\nA1 A2 AD1\nDe E1 EB\n A \u2013 \u2013 1.20\n A1 0.05 \u2013 0.15 A2  0.95 1.00 1.05            D 15.75 16.00 16.25 D1 1 3.90 14.00 14.10 Note 2\n E 15.75 16.00 16.25 E1 1 3.90 14.00 14.10 Note 2\n B           0.17 \u2013 0.27 C 0.09 \u2013 0.20 L 0.45 \u2013  0.75 e  0.50 TYPNotes: \n 1. Thi s package conform s to JEDEC reference MS-026, V ariation AED. \n 2. Dimen sions D1 and E1 do not incl ude mold protr usion.  Allow able \n  protr usion is 0.25 mm per side. Dimen sions D1 and E1 are maximum \n  p l astic body size dimen sions including mold mi smatch.\n 3. Lead copl anarity is 0.08 mm m aximum.COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n\n425\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.2 100C1\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n100C1 , 100-ball, 9 x 9 x 1.2 mm Body, Ball Pitch 0.80 mm \nChip Array BGA Package (CBGA)   A 100C15/25/06TOP VIEWSIDE VIEW\nBOTTOM VIEWCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 1.10  \u2013  1.20\n A1 0.30 0.35 0.40\n D 8.90 9.00 9.10\n E 8.90 9.00 9.10\n D1 7.10 7.20 7.30\n E1 7.10 7.20 7.30\n \u00d8b 0.35 0.40 0.45\n e  0.80 TYPMarked A1 Identifier\n1 2 3 4 5 67 8\nA\nB\nC\nD\nE 9\nF\nG\nH\nI\nJ100.90 TYP\n0.90 TYPA1 Corner0.12 Z\nE\nD\ne\ne \u00d8bA\nA1\nE1D1\n\n426\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.3 64A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n64A,  64-le ad, 14 x 14 mm Body Size, 1.0 mm Body Thickne ss,\n0.8 mm Le ad Pitch, Thin Profile Pl astic Quad Flat Package (TQFP) C 64A2010-10-20PIN 1 IDENTIFIER\n0\u00b0~7\u00b0PIN 1 \nLC\nA1 A2 AD1\nDe\nE1 EB\nCOMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes:\n     1.Thi s package conform s to JEDEC reference MS-026, V ariation AEB. \n 2. Dimen sions D1 and E1 do not incl ude mold protr usion.  Allow able \n  protr usion is 0.25 mm per side. Dimen sions D1 and E1 are maximum \n  p l astic body size dimen sions including mold mi smatch.\n 3. Lead copl anarity is 0.10 mm m aximum. A \u2013 \u2013 1.20\n A1 0.05 \u2013 0.15 A2  0.95 1.00 1.05            D 15.75 16.00 16.25 D1 1 3.90 14.00 14.10 Note 2\n E 15.75 16.00 16.25 E1 1 3.90 14.00 14.10 Note 2\n B           0. 30 \u2013 0.45\n C 0.09 \u2013 0.20 L 0.45 \u2013  0.75 e  0.80 TYP\n\n427\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.4 64M2\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n64M2 , 64-p ad, 9 x 9 x 1.0 mm Body, Le ad Pitch 0.50 mm, E 64M22010-10-20COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 0.80 0.90 1.00\n A1 \u2013 0.02 0.05 \nb \n0.18 0.25 0. 30  \nD  \n \nD2 \n7.50 7.65 7.808.90 9.00 9.10\n8.90 9.00 9.10 \nE \n \nE2 \n7.50 7.65 7.80  \ne  \n0.50 BSC\nL0 . 35 0.40 \n0.45 TOP VIEW\nSIDE VIEW\nBOTTOM VIEWD\nEMarked Pin# 1 ID\nSEATING PLANE\nA1C\nA\nC 0.08\n1\n23\nK 0.20 0.27 0.40\n  2. Dimen sion and toler ance conform to ASMEY14.5M-1994. 0.20 REF A3A3\nE2D2\nb ePin #1 CornerL\nPin #1 \nTriangle\nPin #1 \nChamfer\n(C 0. 30)Option A\nOption B\nPin #1 \nNotch(0.20 R)Option CK\nK\nNotes:  1. JEDEC St andard MO-220, (SAW Sing ulation) Fig. 1, VMMD.\n7.65 mm Expo sed Pad, Micro Le ad Frame P ackage (MLF) \n\n428\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37. Errata\n37.1 ATmega640 rev. B\n\u0081Inaccurate ADC conversion in differential mode with 200\u00d7 gain\n\u0081High current consumption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.2 ATmega640 rev. A\n\u0081Inaccurate ADC conversion in differential mode with 200\u00d7 gain\n\u0081High current consumption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.3 ATmega1280 rev. B\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\n\n429\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.4 ATmega1280 rev. A\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.5 ATmega1281 rev. B\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n\n430\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.6 ATmega1281 rev. A\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.7 ATmega2560 rev. F\nNot sampled.\n37.8 ATmega2560 rev. E\nNo known errata.\n37.9 ATmega2560 rev. D\nNot sampled.\n37.10 ATmega2560 rev. C\n\u0081High current consumption in sleep mode\n1. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.11 ATmega2560 rev. B\nNot sampled.\n\n431\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.12 ATmega2560 rev. A\n\u0081Non-Read-While-Write area  of flash not functional\n\u0081Part does not work under 2.4 volts\n\u0081Incorrect ADC reading in differential mode\n\u0081Internal ADC reference has too low value\n\u0081IN/OUT instructions may be executed twice when Stack is in external RAM\n\u0081EEPROM read from appli cation code does not work in Lock Bit Mode 3\n1.  Non-Read-While-Write area of flash not functional\nThe Non-Read- While-Write area of the flash is not working as expected. The problem is\nrelated to the speed of the part when reading the flash of this area.\nProblem Fix/Workaround\n- Only use the first 248K of the flash.\n- If boot functionality is needed, run the code in the Non-Read- While-Write area at maximum\n1/4th of the maximum frequency of the device at any given voltage. This is done by writing\nthe CLKPR register before entering the boot section of the code.\n2. Part does not work under 2.4 volts\nThe part does not execute code correctly below 2.4 volts.\nProblem Fix/Workaround\nDo not use the part at voltages below 2.4 volts.\n3. Incorrect ADC reading in differential mode\nThe ADC has high noise in differential mode. It can give up to 7 LSB error.\nProblem Fix/Workaround\nUse only the 7 MSB of the result when using the ADC in differential mode.\n4. Internal ADC reference has too low value\nThe internal ADC reference has a value lower than specified.\nProblem Fix/Workaround\n- Use AVCC or external reference.\n- The actual value of the reference can be measured by applying a known voltage to the\nADC when using the internal reference. The result when doing later conversions can then becalibrated.\n5. IN/OUT instructions may be executed twice when Stack is in external RAM\nIf either an IN or an OUT instruction is exec uted directly before an interrupt occurs and the\nstack pointer is located in exte rnal ram, the instruction will be ex ecuted twice. In some cases\nthis will cause a prob lem, for example:\n- If reading SREG it will appear that the I-flag is cleared.\n- If writing to the PIN regist ers, the port will toggle twice.\n- If reading registers with interrupt flags, the flags will appea r to be cleared.\n\n432\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nThere are two application work-arounds, where selecting one of them, will be omitting the\nissue:\n- Replace IN and OUT with LD/LDS/L DD and ST/STS/STD instructions.\n- Use internal RAM for stack pointer.\n6. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does\nnot work from the application code.\nProblem Fix/Workaround\nDo not set Lock Bit Protection Mode 3 when the application code needs to read from\nEEPROM.\n37.13 ATmega2561 rev. F\nNot sampled.\n37.14 ATmega2561 rev. E\nNo known errata.\n37.15 ATmega2561 rev. D\nNot sampled.\n37.16 ATmega2561 rev. C\n\u0081High current consumpt ion in sleep mode.\n1. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.17 ATmega2561 rev. B\nNot sampled.\n37.18 ATmega2561 rev. A\n\u0081Non-Read-While-Write area of flash not functional\n\u0081Part does not work under 2.4 Volts\n\u0081Incorrect ADC reading in differential mode\n\u0081Internal ADC reference has too low value\n\u0081IN/OUT instructions may be executed twice when Stack is in external RAM\n\u0081EEPROM read from applicat ion code does not work  in Lock Bit Mode 3\n\n433\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1.  Non-Read-While-Write area of flash not functional\nThe Non-Read- While-Write area of the flash is not working as expected. The problem is\nrelated to the speed of the part when reading the flash of this area.\nProblem Fix/Workaround\n- Only use the first 248K of the flash.\n- If boot functionality is needed, run the code in the Non-Read- While-Write area at maximum\n1/4th of the maximum frequency of the device at any given voltage. This is done by writing\nthe CLKPR register before entering the boot section of the code.\n2. Part does not work under 2.4 volts\nThe part does not execute code correctly below 2.4 volts.\nProblem Fix/Workaround\nDo not use the part at voltages below 2.4 volts.\n3. Incorrect ADC reading in differential mode\nThe ADC has high noise in differential mode. It can give up to 7 LSB error.\nProblem Fix/Workaround\nUse only the 7 MSB of the result when using the ADC in differential mode.\n4. Internal ADC reference has too low value\nThe internal ADC reference has a value lower than specified.\nProblem Fix/Workaround\n- Use AVCC or external reference.\n- The actual value of the reference can be measured by applying a known voltage to the\nADC when using the internal reference. The result when doing later conversions can then be\ncalibrated.\n5. IN/OUT instructions may be executed twice when Stack is in external RAM\nIf either an IN or an OUT instruction is exec uted directly before an interrupt occurs and the\nstack pointer is located in exte rnal ram, the instruction will be ex ecuted twice. In some cases\nthis will cause a prob lem, for example:\n- If reading SREG it will appear that the I-flag is cleared.\n- If writing to the PIN regist ers, the port will toggle twice.\n- If reading registers with interrupt flags, the flags will appea r to be cleared.\nProblem Fix/Workaround\nThere are two application workarounds, wher e selecting one of them, will be omitting the\nissue:\n- Replace IN and OUT with LD/LDS/L DD and ST/STS/STD instructions.\n- Use internal RAM for stack pointer.\n6. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does\nnot work from the application code.\n\n434\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nDo not set Lock Bit Protection Mode 3 when the application code needs to read from\nEEPROM.\n\n435\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38. Datasheet Revision History\nPlease note that the referring page numbers in this section are referring to this document.The\nreferring revision in this  section are referring to  the document revision.\n38.1 Rev. 2549N-05/11\n38.2 Rev. 2549M-09/10\n38.3 Rev. 2549L-08/071. Added Atmel QTouch Library Support and  QTouch Sensing Capablity Features\n2. Updated Cross-reference in \u201cBit 5, 2:0 - WDP3:0: Watchdog Timer Prescaler 3, 2, 1 and 0\u201d on\npage 68\n3. Updated Assembly codes in section \u201cUSART Initialization\u201d on page 210\n4. Added \u201cStandard Power-On Reset\u201d on page 372 .\n5. Added \u201cEnhanced Power-On Reset\u201d on page 373 .\n6. Updated Figure 32-13 on page 393\n7. Updated \u201cOrdering Information\u201d on page 419  to include Tape & Reel devices.\n1. Updated typos in Figure 26-9 on page 285  and in Figure 26-10 on page 285 .\n2. Note is added below Table 1-1 on page 3 .\n3. The values for \u201ctypical characteristics\u201d in Table 31-9 on page 377  and Table 31-10 on page 378 ,\nhas been rounded.\n4. Units for tRST and tBOD in Table 31-3 on page 372  have been changed from \u201cns\u201d to \u201c\u00b5s\u201d.\n5. The figure text for Table 31-2 on page 371  has been changed.\n6. Text in first column in Table 30-3 on page 336  has been changed from \u201cFuse Low Byte\u201d to\n\u201cExtended Fuse Byte\u201d.\n7. The text in \u201cPower Reduction Register\u201d on page 54  has been changed.\n8. The value of the inductor in Figure 26-9 on page 285  and Figure 26-10 on page 285  has been\nchanged to 10 \u00b5H.\n9. \u201cPort A\u201d has been changed into \u201cPort K\u201d in the first paragraph of \u201cFeatures\u201d on page 275 .\n10. Minimum wait delay for t WD_EEPROM in Table 30-16 on page 351  has been changed from\n9.0ms to 3.6ms\n11. Dimension A3 is added in \u201c64M2\u201d on page 427 .\n12. Several cross-references are corrected.13. \u201cCOM0A1:0\u201d on page 130 is corrected to \u201cCOM0B1:0\u201d.\n14. Corrected some Figure and Table numbering.\n15. Updated Section 10.6 \u201cLow Frequency Cr ystal Oscillator\u201d on page 45 .\n1. Updated note in Table 10-11 on page 47 .\n2. Updated Table 10-3 on page 43 , Table 10-5 on page 44 , Table 10-9 on page 47 .\n3. Updated typos in \u201cDC Characteristics\u201d on page 367\n4. Updated \u201cClock Characteristics\u201d on page 371\n5. Updated \u201cExternal Clock Drive\u201d on page 371 . \n6. Added \u201cSystem and Reset Characteristics\u201d on page 372 .\n\n436\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.4 Rev. 2549K-01/07\n38.5 Rev. 2549J-09/06\n38.6 Rev. 2549I-07/06\n38.7 Rev. 2549H-06/067. Updated \u201cSPI Timing Characteristics\u201d on page 375 .\n8. Updated \u201cADC Characteristics \u2013 Preliminary Data\u201d on page 377 .\n9. Updated ordering code in \u201cATmega640\u201d on page 419 .\n1. Updated Table 1-1 on page 3 .\n2. Updated \u201cPin Descriptions\u201d on page 7 .\n3. Updated \u201cStack Pointer\u201d on page 16 .\n4. Updated \u201cBit 1 \u2013 EEPE: EEPROM Programming Enable\u201d on page 36 .\n5. Updated Assembly code example in \u201cThus, when the BOD is not enabled, after setting the ACBG\nbit or enabling the ADC, the user  must always allow the refer ence to start up before the output\nfrom the Analog Comparator or ADC is used. To reduce power consumption in Power-down\nmode, the user can avoid the three conditions above to ensure that the reference is turned offbefore entering Power-down mode.\u201d on page 63 .\n6: Updated \u201cEIMSK \u2013 External Interrupt Mask Register\u201d on page 115 .\n7. Updated Bit description in \u201cPCIFR \u2013 Pin Change Interrupt Flag Register\u201d on page 116 .\n8. Updated code example in \u201cUSART Initialization\u201d on page 210 .\n9. Updated Figure 26-8 on page 284 .\n10. Updated \u201cDC Characteristics\u201d on page 367 .\n1. Updated \u201c\u201d on page 46 .\n2. Updated code example in \u201cMoving Interrupts Between Applicat ion and Boot Section\u201d on page\n109.\n3. Updated \u201cTimer/Counter Prescaler\u201d on page 186 .\n4. Updated \u201cDevice Identification Register\u201d on page 303 .\n5. Updated \u201cSignature Bytes\u201d on page 338 .\n6. Updated \u201cInstruction Set Summary\u201d on page 416 .\n1. Added \u201cData Retention\u201d on page 11 .\n2. Updated Table 16-3 on page 129 , Table 16-6 on page 130 , Table 16-8 on page 131 , Table 17-2\non page 148 , Table 17-4 on page 159 , Table 17-5 on page 160 , Table 20-3 on page 187 , Table\n20-6 on page 188  and Table 20-8 on page 189 .\n3. Updated \u201cFast P WM Mode\u201d on page 150 .\n1. Updated \u201c\u201d on page 46 .\n2. Updated \u201cOSCCAL \u2013 Oscillator Calibration Register\u201d on page 50 .\n3. Added Table 31-1 on page 371\n.\n\n437\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.8 Rev. 2549G-06/06\n38.9 Rev. 2549F-04/06\n38.10 Rev. 2549E-04/06\n38.11 Rev. 2549D-12/051. Updated \u201cFeatures\u201d on page 1 .\n2. Added Figure 1-2 on page 3 , Table 1-1 on page 3 .\n3. Updated \u201c\u201d on page 46 .\n4. Updated \u201cPower Management and Sleep Modes\u201d on page 52 .\n5. Updated note for Table 12-1 on page 68 .\n6. Updated Figure 26-9 on page 285  and Figure 26-10 on page 285 .\n7. Updated \u201cSetting the Boot Loader Lock Bits by SPM\u201d on page 324 .\n8. Updated \u201cOrdering Information\u201d on page 419 .\n9. Added Package information \u201c100C1\u201d on page 425 .\n10. Updated \u201cErrata\u201d on page 428 .\n1. Updated Figure 9-3 on page 31 , Figure 9-4 on page 31  and Figure 9-5 on page 32 . \n2. Updated Table 20-2 on page 187  and Table 20-3 on page 187 .\n3. Updated Features in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275 .\n4. Updated \u201cFuse Bits\u201d on page 336 .\n1. Updated \u201cFeatures\u201d on page 1 .\n2. Updated Table 12-1 on page 62 .\n3. Updated note for Table 12-1 on page 62 .\n4. Updated \u201cBit 6 \u2013 ACBG: Analog Comparator Bandgap Select\u201d on page 273 .\n5. Updated \u201cPrescaling and Conversion Timing\u201d on page 278 .\n5. Updated \u201cMaximum speed vs. VCC\u201d on page 373 .\n6. Updated \u201cOrdering Information\u201d on page 419 .\n1. Advanced Information Status changed to Preliminary.\n2. Changed number of I/O Ports from 51 to 54.\n3. Updatet typos in \u201cTCCR0A \u2013 Timer/Counter Cont rol Register A\u201d on page 129 .\n4. Updated Features in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275 .\n5. Updated Operation in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275\n6. Updated Stabilizing Time in \u201cChanging Channel or Reference Selection\u201d on page 282 .\n7. Updated Figure 26-1 on page 276 , Figure 26-9 on page 285 , Figure 26-10 on page 285 .\n8. Updated Text in \u201cADCSRB \u2013 ADC Control and Status Register B\u201d on page 290 .\n9. Updated Note for Table 4 on page 43 , Table 13-15 on page 86 , Table 26-3 on page 289  and\nTable 26-6 on page 295 .\n10. Updated Table 31-9 on page 377  and Table 31-10 on page 378 .\n11. Updated \u201cFilling the Temporary Buffer (Page Loading)\u201d on page 323 .\n12. Updated \u201cTypical Characteristics\u201d on page 385 .\n13. Updated \u201cPackaging Information\u201d on page 424 .\n14. Updated \u201cErrata\u201d on page 428 .\n\n438\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.12 Rev. 2549C-09/05\n38.13 Rev. 2549B-05/05\n38.14 Rev. 2549A-03/051. Updated Speed Grade in section \u201cFeatures\u201d on page 1 .\n2. Added \u201cResources\u201d on page 11 .\n3. Updated \u201cSPI \u2013 Serial Peripheral Interface\u201d on page 195 . In Slave mode, low and high period SPI\nclock must be larger than 2 CPU cycles.\n4. Updated \u201cBit Rate Generator Unit\u201d on page 247 .\n5. Updated \u201cMaximum speed vs. VCC\u201d on page 373 .\n6. Updated \u201cOrdering Information\u201d on page 419 .\n7. Updated \u201cPackaging Information\u201d on page 424 . Package 64M1 replaced by 64M2.\n8. Updated \u201cErrata\u201d on page 428 .\n1. JTAG ID/Signature for ATmega640 updated: 0x9608.\n2. Updated Table 13-7 on page 81 .\n3. Updated \u201cSerial Programming Instruction set\u201d on page 352 .\n4. Updated \u201cErrata\u201d on page 428 .\n1. Initial version.\n\n2549N\u2013AVR\u201305/11Atmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel:  (+1)(408) 441-0311\nFax: (+1)(408) 487-2600 \nwww.atmel.comAtmel Asia Limited\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHONG KONG\nTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4\nD-85748 Garching b. MunichGERMANY\nTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033JAPAN\nTel: (+81)(3) 3523-3551\nFax: (+81)(3) 3523-7581\n\u00a9 2011 Atmel Corporation. All rights reserved.\nAtmel\n\u00ae, Atmel logo and combinations thereof, AVR\u00ae, QTouch\u00ae, QMatrix\u00ae, AVR Studio\u00ae and others are registered trademarks or trade-\nmarks of Atmel Corporation or its subsidiaries. Windows\u00ae and others are registered trademarks of Microsoft Corporation in U.S. and \nother countries. Other terms and product names may be trademarks of others.\nDisclaimer:  The information in this document is provided in connection wi th Atmel products. No license, ex press or implied, by estoppel or  otherwise, to \nany intellectual property right is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL \nTERMS AND CONDITIONS OF SALES LOCATED ON THE ATMEL WEBSITE,  ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY \nEXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRO DUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURP OSE, OR NON-INFRINGEMENT. IN NO EVEN T SHALL ATMEL BE LIABLE FOR ANY DIRECT, \nINDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATI ON, DAMAGES FOR LOSS AND PROF-\nITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL \nHAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no representations or warranties with respect to the accuracy or com-\npleteness of the contents of th is document and reserves the right to make changes  to specifications and product descriptions at  any time without notice. \nAtmel does not make any commitment to update the information cont ained herein. Unless specifically  provided otherwise, Atmel pr oducts are not suit-\nable for, and shall not be used in, automotive applications. Atme l products are not intended, authorized, or warranted for use as components in applica-\ntions intended to support or sustain life.\n\ni\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable of Contents\nFeatures ................ ................ .............. ............... .............. .............. ............ 1\n1 Pin Configurations ..... ................ ................. ................ ................. ............ 2\n2 Overview ............ ................ ................ ............... .............. .............. ............ 5\n2.1 Block Diagram ...................................................................................................5\n2.2 Comparison Between ATmega1281/2561 and ATmega640/1280/2560 ...........72.3 Pin Descriptions .................................................................................................7\n3 Resources .............. .............. .............. ............... .............. .............. .......... 11\n4 About Code Examples ........ .............. ............... .............. .............. .......... 11\n5 Data Retention .......... ................ ................ ................. ................ ............. 11\n6 Capacitive touch sensing  ................. ............... .............. .............. .......... 11\n7 AVR CPU Core  ................. ................ ................. .............. .............. .......... 12\n7.1 Introduction ......................................................................................................12\n7.2 Architectural Overview .....................................................................................127.3 ALU \u2013 Arithmetic Logic Unit .............................................................................137.4 Status Register ................................................................................................147.5 General Purpose Register File ........................................................................157.6 Stack Pointer ...................................................................................................167.7 Instruction Execution Timing ...........................................................................177.8 Reset and Interrupt Handling ...........................................................................18\n8 AVR Memories .......... ................ ................ ................. ................ ............. 21\n8.1 In-System Reprogrammable Flash Program Memory .....................................21\n8.2 SRAM Data Memory ........................................................................................218.3 EEPROM Data Memory . ................. ................ ............. ............ ............. ..........23\n8.4 I/O Memory ......................................................................................................27\n9 External Memory Interface . .............. ............... .............. .............. .......... 28\n9.1 Overview ..........................................................................................................28\n9.2 Register Description ........................................................................................359.3 General Purpose registers ...............................................................................379.4 External Memory registers ...............................................................................37\n10 System Clock and Clock Options  .............. ................ ................. .......... 40\n10.1 Overview ..........................................................................................................40\n\nii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.2 Clock Systems and their Distribution ...............................................................40\n10.3 Clock Sources .................................................................................................4110.4 Low Power Crystal Oscillator ...........................................................................4210.5 Full Swing Crystal Oscillator ............... .............................................................44\n10.6 Low Frequency Crystal Oscillator ....................................................................4510.7 Calibrated Internal RC Oscillator .....................................................................46\n10.8 128 kHz Internal Oscillator ..............................................................................4710.9 External Clock .................................................................................................4810.10 Clock Output Buffer .........................................................................................4910.11 Timer/Counter Oscillator ..................................................................................4910.12 System Clock Prescaler ..................................................................................4910.13 Register Description ........................................................................................50\n11 Power Management and Sleep Modes ........ ................. .............. .......... 52\n11.1 Sleep Modes ....................................................................................................52\n11.2 Idle Mode .........................................................................................................5211.3 ADC Noise Reduction Mode ............................................................................5311.4 Power-down Mode ...........................................................................................5311.5 Power-save Mode ............................................................................................5311.6 Standby Mode .................................................................................................5411.7 Extended Standby Mode .................................................................................5411.8 Power Reduction Register ...............................................................................5411.9 Minimizing Power Consumption ......................................................................5411.10 Register Description ........................................................................................56\n12 System Control and Reset .... .............. .............. .............. .............. ........ 59\n12.1 Resetting the AVR ...........................................................................................59\n12.2 Reset Sources .................................................................................................5912.3 Internal Voltage Reference ..............................................................................6212.4 Watchdog Timer ..............................................................................................63\n12.5 Register Description ........................................................................................67\n13 I/O-Ports ........ ................ ................. ................ ................. .............. .......... 70\n13.1 Introduction ......................................................................................................70\n13.2 Ports as General Digital I/O .............................................................................7113.3 Alternate Port Functions ..................................................................................7513.4 Register Description for I/O-Ports ..................................................................100\n14 Interrupts ............. .............. .............. .............. .............. .............. ........... 105\n\niii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.1 Interrupt Vectors in ATmega640/1280/1281/2560/2561 ................................105\n14.2 Reset and Interrupt Vector placement ...........................................................10714.3 Moving Interrupts Between Application and Boot Section .............................10914.4 Register Description ......................................................................................110\n15 External Interrupts .......... ................ .............. .............. .............. ........... 112\n15.1 Pin Change Interrupt Timing ..........................................................................112\n15.2 Register Description ......................................................................................113\n16 8-bit Timer/Counter0 with PWM ................... .............. .............. ........... 118\n16.1 Features ........................................................................................................118\n16.2 Overview ........................................................................................................11816.3 Timer/Counter Clock Sources .......................................................................11916.4 Counter Unit ..................................................................................................11916.5 Output Compare Unit .....................................................................................12016.6 Compare Match Output Unit ..........................................................................12216.7 Modes of Operation .......................................................................................12316.8 Timer/Counter Timing Diagrams ...................................................................12716.9 Register Description ......................................................................................129\n17 16-bit Timer/Counter (Timer /Counter 1, 3, 4, and 5) ............... ........... 136\n17.1 Features ........................................................................................................136\n17.2 Overview ........................................................................................................13617.3 Accessing 16-bit Registers ............................................................................13817.4 Timer/Counter Clock Sources .......................................................................14117.5 Counter Unit ..................................................................................................14217.6 Input Capture Unit .........................................................................................14317.7 Output Compare Units ...................................................................................14517.8 Compare Match Output Unit ..........................................................................14717.9 Modes of Operation .......................................................................................14817.10 Timer/Counter Timing Diagrams ...................................................................15617.11 Register Description ......................................................................................158\n18 Timer/Counter 0, 1,  3, 4, and 5 Prescaler ........... ............ ............ ........ 169\n18.1 Internal Clock Source ....................................................................................169\n18.2 Prescaler Reset .............................................................................................16918.3 External Clock Source ...................................................................................16918.4 Register Description ......................................................................................170\n\niv\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n19 Output Compare Modulato r (OCM1C0A) ....... .............. .............. ........ 172\n19.1 Overview ........................................................................................................172\n19.2 Description .....................................................................................................172\n20 8-bit Timer/Counter2 with PW M and Asynchronous Operation ...... 174\n20.1 Overview ........................................................................................................174\n20.2 Timer/Counter Clock Sources .......................................................................17520.3 Counter Unit ..................................................................................................17520.4 Modes of Operation .......................................................................................17620.5 Output Compare Unit .....................................................................................18020.6 Compare Match Output Unit ..........................................................................18220.7 Timer/Counter Timing Diagrams ...................................................................18320.8 Asynchronous Operation of Timer/Counter2 .................................................18420.9 Timer/Counter Prescaler ...............................................................................18620.10 Register Description ......................................................................................187\n21 SPI \u2013 Serial Peripheral Interface ......... .............. .............. ............ ........ 195\n21.1 SS  Pin Functionality ......................................................................................200\n21.2 Register Description ......................................................................................202\n22 USART ............. ................. ................ .............. .............. .............. ........... 205\n22.1 Features ........................................................................................................205\n22.2 Clock Generation ...........................................................................................20622.3 Frame Formats ..............................................................................................20922.4 USART Initialization .......................................................................................210\n22.5 Data Transmission \u2013 The USART Transmitter ..............................................212\n22.6 Data Reception \u2013 The USART Receiver .......................................................21422.7 Asynchronous Data Reception ......................................................................21822.8 Multi-processor Communication Mode ..........................................................22122.9 Register Description ......................................................................................22222.10 Examples of Baud Rate Setting .....................................................................227\n23 USART in SPI Mode .......... .............. .............. .............. .............. ........... 232\n23.1 Overview ........................................................................................................232\n23.2 USART MSPIM vs. SPI .................................................................................23223.3 SPI Data Modes and Timing ..........................................................................23323.4 Frame Formats ..............................................................................................23423.5 Data Transfer .................................................................................................23623.6 USART MSPIM Register Description ............................................................237\n\nv\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24 2-wire Serial Interface ..... ................ .............. .............. .............. ........... 241\n24.1 Features ........................................................................................................241\n24.2 2-wire Serial Interface Bus Definition ............................................................24124.3 Data Transfer and Frame Format ..................................................................24224.4 Multi-master Bus Systems, Arbitration and Synchronization .........................24524.5 Overview of the T WI Module .........................................................................246\n24.6 Using the T WI ................................................................................................249\n24.7 Transmission Modes .....................................................................................25224.8 Multi-master Systems and Arbitration ............................................................26524.9 Register Description ......................................................................................266\n25 AC \u2013 Analog Comparator ... .............. ............... .............. .............. ........ 271\n25.1 Analog Comparator Multiplexed Input ...........................................................271\n25.2 Register Description ......................................................................................272\n26 ADC \u2013 Analog to Digital Co nverter .............. .............. .............. ........... 275\n26.1 Features ........................................................................................................275\n26.2 Operation .......................................................................................................27626.3 Starting a Conversion ....................................................................................27726.4 Prescaling and Conversion Timing ................................................................27826.5 Changing Channel or Reference Selection ...................................................28226.6 ADC Noise Canceler .....................................................................................28326.7 ADC Conversion Result .................................................................................28826.8 Register Description ......................................................................................289\n27 JTAG Interface and On-chi p Debug System ............ .............. ........... 296\n27.1 Features ........................................................................................................296\n27.2 Overview ........................................................................................................29627.3 TAP - Test Access Port .................................................................................29727.4 Using the Boundary-scan Chain ....................................................................29927.5 Using the On-chip Debug System .................................................................29927.6 On-chip Debug Specific JTAG Instructions ...................................................30027.7 Using the JTAG Programming Capabilitie s ...................................................301\n27.8 Bibliography ...................................................................................................30127.9 On-chip Debug Related Register in I/O Memory ...........................................301\n28 IEEE 1149.1 (JTAG)  Boundary-scan ....... ................. ................ ........... 302\n28.1 Features ........................................................................................................302\n28.2 System Overview ...........................................................................................302\n\nvi\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.3 Data Registers ...............................................................................................302\n28.4 Boundary-scan Specific JTAG Instructions ...................................................30428.5 Boundary-scan Chain ....................................................................................30528.6 Boundary-scan Related Register in I/O Memory ...........................................30828.7 ATmega640/1280/1281/2560/2561 Boundary-scan Order ............................30828.8 Boundary-scan Description Language Files ..................................................308\n29 Boot Loader Support \u2013 Read-While-Wri te Self-Programming ......... 317\n29.1 Features ........................................................................................................317\n29.2 Application and Boot Loader Flash Sections .................................................31729.3 Read- While-Write and No Read- While-Write Flash Sections ........................317\n29.4 Boot Loader Lock Bits ...................................................................................32029.5 Addressing the Flash During Self-Programming ...........................................32229.6 Self-Programming the Flash ..........................................................................32329.7 Register Description ......................................................................................332\n30 Memory Programming ........ .............. ............... .............. .............. ........ 335\n30.1 Program And Data Memory Lock Bits ...........................................................335\n30.2 Fuse Bits ........................................................................................................33630.3 Signature Bytes .............................................................................................33830.4 Calibration Byte .............................................................................................33830.5 Page Size ......................................................................................................33830.6 Parallel Programming Parameters, Pin Mapping, and Commands ...............33830.7 Parallel Programming ....................................................................................34130.8 Serial Downloading ........................................................................................34930.9 Programming via the JTAG Interface ............................................................354\n31 Electrical Characteristics ... .............. ............... .............. .............. ........ 367\n31.1 DC Characteristics .........................................................................................367\n31.2 Speed Grades ...............................................................................................36931.3 Clock Characteristics .....................................................................................37131.4 External Clock Drive ......................................................................................37131.5 System and Reset Characteristics ................................................................37231.6 2-wire Serial Interface Characteristics ...........................................................37331.7 SPI Timing Characteristics ............................................................................37531.8 ADC Characteristics \u2013 Preliminary Data ........................................................37731.9 External Data Memory Timing .......................................................................379\n32 Typical Characteristics ....... .............. ............... .............. .............. ........ 385\n\nvii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.1 Active Supply Current ....................................................................................385\n32.2 Idle Supply Current ........................................................................................38832.3 Power-down Supply Current ..........................................................................39232.4 Power-save Supply Current ...........................................................................39332.5 Standby Supply Current ................................................................................39432.6 Pin Pull-up .....................................................................................................39432.7 Pin Driver Strength ........................................................................................39732.8 Pin Threshold and Hysteresis ........................................................................39932.9 BOD Threshold and Analog Comparator Offset ............................................40232.10 Internal Oscillator Speed ...............................................................................40432.11 Current Consumption of Peripheral Units ......................................................40632.12 Current Consumption in Reset and Reset Pulsewidth ..................................409\n33 Register Summary ............ .............. .............. .............. .............. ........... 411\n34 Instruction Set Summary ... .............. ............... .............. .............. ........ 416\n35 Ordering Information .......... .............. ............... .............. .............. ........ 419\n35.1 ATmega640 ...................................................................................................419\n35.2 ATmega1280 .................................................................................................42035.3 ATmega1281 .................................................................................................42135.4 ATmega2560 .................................................................................................42235.5 ATmega2561 .................................................................................................423\n36 Packaging Information .......... ................ ................. ................ ............. 424\n36.1 100A ..............................................................................................................424\n36.2 100C1 ............................................................................................................42536.3 64A ................................................................................................................42636.4 64M2 ..............................................................................................................427\n37 Errata ........... ................ ................ ................. ................ .............. ........... 428\n37.1 ATmega640 rev. B .........................................................................................428\n37.2 ATmega640 rev. A .........................................................................................42837.3 ATmega1280 rev. B .......................................................................................42837.4 ATmega1280 rev. A .......................................................................................42937.5 ATmega1281 rev. B .......................................................................................42937.6 ATmega1281 rev. A .......................................................................................43037.7 ATmega2560 rev. F .......................................................................................43037.8 ATmega2560 rev. E .......................................................................................430\n\nviii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.9 ATmega2560 rev. D ......................................................................................430\n37.10 ATmega2560 rev. C ......................................................................................43037.11 ATmega2560 rev. B .......................................................................................43037.12 ATmega2560 rev. A .......................................................................................43137.13 ATmega2561 rev. F .......................................................................................43237.14 ATmega2561 rev. E .......................................................................................43237.15 ATmega2561 rev. D ......................................................................................43237.16 ATmega2561 rev. C ......................................................................................43237.17 ATmega2561 rev. B .......................................................................................43237.18 ATmega2561 rev. A .......................................................................................432\n38 Datasheet Revision History .. ................ ................. ................ ............. 435\n38.1 Rev. 2549N-05/11 .........................................................................................435\n38.2 Rev. 2549M-09/10 .........................................................................................43538.3 Rev. 2549L-08/07 ..........................................................................................43538.4 Rev. 2549K-01/07 ..........................................................................................43638.5 Rev. 2549J-09/06 ..........................................................................................43638.6 Rev. 2549I-07/06 ...........................................................................................43638.7 Rev. 2549H-06/06 .........................................................................................43638.8 Rev. 2549G-06/06 .........................................................................................43738.9 Rev. 2549F-04/06 ..........................................................................................43738.10 Rev. 2549E-04/06 ..........................................................................................43738.11 Rev. 2549D-12/05 .........................................................................................43738.12 Rev. 2549C-09/05 .........................................................................................43838.13 Rev. 2549B-05/05 ..........................................................................................43838.14 Rev. 2549A-03/05 ..........................................................................................438\nTable of Contents.......... ................. ................ ................. ................ ........... i\n\n2549N\u2013AVR\u201305/11Atmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel:  (+1)(408) 441-0311\nFax: (+1)(408) 487-2600 \nwww.atmel.comAtmel Asia Limited\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHONG KONG\nTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4\nD-85748 Garching b. MunichGERMANY\nTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033JAPAN\nTel: (+81)(3) 3523-3551\nFax: (+81)(3) 3523-7581\n\u00a9 2011 Atmel Corporation. All rights reserved.\nAtmel\n\u00ae, Atmel logo and combinations thereof, AVR\u00ae, QTouch\u00ae, QMatrix\u00ae, AVR Studio\u00ae and others are registered trademarks or trade-\nmarks of Atmel Corporation or its subsidiaries. Windows\u00ae and others are registered trademarks of Microsoft Corporation in U.S. and \nother countries. Other terms and product names may be trademarks of others.\nDisclaimer:  The information in this document is provided in connection wi th Atmel products. No license, ex press or implied, by estoppel or  otherwise, to \nany intellectual property right is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL \nTERMS AND CONDITIONS OF SALES LOCATED ON THE ATMEL WEBSITE,  ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY \nEXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRO DUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURP OSE, OR NON-INFRINGEMENT. IN NO EVEN T SHALL ATMEL BE LIABLE FOR ANY DIRECT, \nINDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATI ON, DAMAGES FOR LOSS AND PROF-\nITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL \nHAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no representations or warranties with respect to the accuracy or com-\npleteness of the contents of th is document and reserves the right to make changes  to specifications and product descriptions at  any time without notice. \nAtmel does not make any commitment to update the information cont ained herein. Unless specifically  provided otherwise, Atmel pr oducts are not suit-\nable for, and shall not be used in, automotive applications. Atme l products are not intended, authorized, or warranted for use as components in applica-\ntions intended to support or sustain life.", "atmega 32.pdf": "Features\n\u2022High-performance, Low-power Atmel\u00ae AVR\u00ae 8-bit Microcontroller\n\u0081Advanced RISC Architecture\n\u2013 131 Powerful Instructions \u2013 Most  Single-clock Cycle Execution\n\u2013 32 x 8 General Purpose Working Registers\u2013 Fully Static Operation\n\u2013 Up to 16 MIPS Throughput at 16 MHz\n\u2013 On-chip 2-cycle Multiplier\n\u0081High Endurance Non-volatile Memory segments\n\u2013 32 Kbytes of In-System Self-pro grammable Flash program memory\n\u2013 1024 Bytes EEPROM\n\u2013 2 Kbyte Internal SRAM\n\u2013 Write/Erase Cycles: 10,000 Flash/1 00,000 EEPROM\n\u2013 Data retention: 20 years at 85\u00b0C/100 years at 25\u00b0C(1)\n\u2013 Optional Boot Code Section with Independent Lock Bits\nIn-System Programming by On-chip Boot Program\nTrue Read-While-W rite Operation\n\u2013 Programming Lock for Software Security\n\u0081JTAG (IEEE std. 1149.1 Compliant) Interface\n\u2013 Boundary-scan Capabilities A ccording to the JTAG Standard\n\u2013 Extensive On-chip Debug Support\n\u2013 Programming of Flash, EEPROM, Fuses, an d Lock Bits through the JTAG Interface\n\u0081Peripheral Features\n\u2013 Two 8-bit Timer/Counters with Se parate Prescalers and Compare Modes\n\u2013 One 16-bit Timer/Counter with Separate Prescaler, Compare Mode, and Capture \nMode\n\u2013 Real Time Counter with Separate Oscillator\n\u2013 Four PWM Channels\u2013 8-channel, 10-bit ADC\n8 Single-ended Channels\n7 Differential Channels in TQFP Package Only2 Differential Channels with Prog rammable Gain at 1x, 10x, or 200x\n\u2013 Byte-oriented Two-wi re Serial Interface\n\u2013 Programmable Serial USART\u2013 Master/Slave SPI Serial Interface\n\u2013 Programmable Watchdog Timer with Separate On-chip Oscillator\n\u2013 On-chip Analog Comparator\n\u0081Special Microcontroller Features\n\u2013 Power-on Reset and Programmable Brown-out Detection\n\u2013 Internal Calibrated RC Oscillator\u2013 External and Internal Interrupt Sources\n\u2013 Six Sleep Modes: Idle, ADC Noise Reduction, Power-save, Power-down, Standby \nand Extended Standby\n\u0081I/O and Packages\n\u2013 32 Programmable I/O Lines\n\u2013 40-pin PDIP, 44-lead TQFP, and 44-pad QFN/MLF\n\u0081Operating Voltages\n\u2013 2.7V - 5.5V for ATmega32L\n\u2013 4.5V - 5.5V for ATmega32\n\u0081Speed Grades\n\u2013 0 - 8 MHz for ATmega32L\n\u2013 0 - 16 MHz for ATmega32\n\u0081Power Consumption at 1 MHz, 3V, 25 \u00b0C for ATmega32L\n\u2013 Active: 1.1 mA\u2013 Idle Mode: 0.35 mA\n\u2013 Power-down Mode: < 1 \u00b5A8-bit  \nMicrocontroller with 32K Bytes In-SystemProgrammable \nFlash\nATmega32\nATmega32L\nSummary\n2503PS\u2013AVR\u201307/10\n\n2\n2503PS\u2013AVR\u201307/10ATmega32(L)\nPin \nConfigurations\nFigure 1.  Pinout ATmega32\n(XCK/T0)  PB0\n(T1)  PB1\n(INT2/AIN0)  PB2\n(OC0/AIN1)  PB3\n(SS)  PB4\n(MOSI)  PB5(MISO)  PB6\n(SCK)  PB7\nRESET\nVCC\nGND\nXTAL2XTAL1\n(RXD)  PD0\n(TXD)  PD1\n(INT0)  PD2(INT1)  PD3\n(OC1B)  PD4(OC1A)  PD5\n(ICP1)  PD6PA0  (ADC0)PA1  (ADC1)PA2  (ADC2)PA3  (ADC3)PA4  (ADC4)PA5  (ADC5)PA6  (ADC6)PA7  (ADC7)AREFGNDAVCCPC7  (TOSC2)PC6  (TOSC1)PC5  (TDI)PC4  (TDO)PC3  (TMS)PC2  (TCK)PC1  (SDA)PC0  (SCL)PD7  (OC2)\nPA4  (ADC4)PA5  (ADC5)PA6  (ADC6)PA7  (ADC7)AREFGNDAVCCPC7  (TOSC2)PC6  (TOSC1)PC5  (TDI)PC4  (TDO)(MOSI)  PB5\n(MISO)  PB6\n(SCK)  PB7\nRESET\nVCC\nGND\nXTAL2XTAL1\n(RXD)  PD0\n(TXD)  PD1\n(INT0)  PD2\n(INT1)  PD3\n(OC1B)  PD4(OC1A)  PD5\n(ICP1)  PD6\n(OC2)  PD7\nVCC\nGND\n(SCL)  PC0\n(SDA)  PC1\n(TCK)  PC2\n(TMS)  PC3PB4  (SS)\nPB3  (AIN1/OC0)PB2  (AIN0/INT2)PB1  (T1)PB0  (XCK/T0)GNDVCCPA0  (ADC0)PA1  (ADC1)PA2  (ADC2)PA3  (ADC3)PDIP\nTQFP/MLF\nNote: \nBottom pad shouldbe soldered to ground.\n\n3\n2503PS\u2013AVR\u201307/10ATmega32(L)\nOverview The ATmega32 is a low-power CMOS 8-bit microcontroller based on the AVR enhanced RISC\narchitecture. By executing powerful instructi ons in a single clock cycle, the ATmega32 achieves\nthroughputs approaching 1 MIPS per MHz allowing the system designer to optimize power con-sumption versus processing speed.\nBlock Diagram Figure 2.  Block Diagram\nINTERNAL\nOSCILLATOROSCILLATOR\nWATCHDOG\nTIMER\nMCU CTRL.\n& TIMINGOSCILLATORTIMERS/\nCOUNTERS\nINTERRUPT\nUNITSTACK\nPOINTER\nEEPROMSRAM\nSTATUS\nREGISTER\nUSARTPROGRAM\nCOUNTER\nPROGRAM\nFLASH\nINSTRUCTION\nREGISTER\nINSTRUCTION\nDECODER\nPROGRAMMING\nLOGICSPIADC\nINTERFACE\nCOMP .\nINTERFACEPORTA DRIVERS/BUFFERS\nPORTA DIGITAL INTERFACE\nGENERAL\nPURPOSE\nREGISTERS\nX\nY\nZ\nALU\n+\n-PORTC DRIVERS/BUFFERS\nPORTC DIGITAL INTERFACE\nPORTB DIGITAL INTERFACE\nPORTB DRIVERS/BUFFERSPORTD DIGITAL INTERFACE\nPORTD DRIVERS/BUFFERSXTAL1\nXTAL2\nRESET\nCONTROL\nLINESVCC\nGND\nMUX &\nADC\nAREFPA0 - PA7 PC0 - PC7\nPD0 - PD7 PB0 - PB7AVR CPUTWIAVCC\nINTERNAL\nCALIBRATED\nOSCILLATOR\n\n4\n2503PS\u2013AVR\u201307/10ATmega32(L)\nThe AVR core combines a rich instruction set with 32 general purpose working registers. All the\n32 registers are directly connected to the Arithmetic Logic Unit (ALU), allowing two independentregisters to be accessed in one single instruction executed  in one clock cycle. The resulting\narchitecture is more code efficient while achiev ing throughputs up to ten times faster than con-\nventional CISC microcontrollers.\nThe ATmega32 provides the following features: 32 Kbytes of In-System Programmable Flash\nProgram memory with Read-Wh ile-Write capabilities, 1024 bytes EEPROM, 2 Kbyte SRAM, 32\ngeneral purpose I/O lines, 32 general purpose working registers, a JTAG interface for Boundary-scan, On-chip Debugging support and programming , three flexible Timer/Counters with com-\npare modes, Internal and External Interrupts , a serial programmable USART, a byte oriented\nTwo-wire Serial Interface, an 8-channel, 10-bi t ADC with optional differential input stage with\nprogrammable gain (TQFP package only), a programmable Watchdog Timer with Internal Oscil-lator, an SPI serial port, and six software selectable power saving modes. The Idle mode stopsthe CPU while allowing the USART,  Two-wire interface, A/D Converter, SRAM, Timer/Counters,\nSPI port, and interrupt system to continue functioning. The Power-down mode saves the registercontents but freezes the Oscillator,  disabling all other ch ip functions until the next External Inter-\nrupt or Hardware Reset. In Power-save mode, the Asynchronous Timer continues to run,allowing the user to maintain a timer base while the rest of the device is sleeping. The ADCNoise Reduction mode stops the CPU and all I /O modules except Asynchronous Timer and\nADC, to minimize switching noise during ADC conversions. In Standby mode, the crystal/reso-nator Oscillator is running while the rest of the dev ice is sleeping. This allows very fast start-up\ncombined with low-power consum ption. In Extended Standby mode,  both the main Oscillator\nand the Asynchronous Timer continue to run. \nThe device is manufactured using Atmel\u2019s high density nonvolatile memory technology. The On-\nchip ISP Flash allows the prog ram memory to be repr ogrammed in-system th rough an SPI serial\ninterface, by a conventional nonvolatile memory programmer, or by an On-chip Boot programrunning on the AVR core. The boot program can use any interface to download the application\nprogram in the Application Flash memory. Software in the Boot Flash section will continue to runwhile the Application Flash section is updated, providing true Read-While-Write operation. By\ncombining an 8-bit RISC CPU with In-System Self-Programmable Flash on a monolithic chip,the Atmel ATmega32 is a powerful microcontroller th at provides a highly-flexible and cost-effec-\ntive solution to many embedded control applications.\nThe ATmega32 AVR is supported with a full su ite of program and system development tools\nincluding: C compilers, macro assemblers, program debugger/simulators, in-circuit emulators,and evaluation kits.\nPin Descriptions\nVCC Digital supply voltage.\nGND Ground.\nPort A (PA7..PA0) Port A serves as the analog inputs to the A/D Converter.\nPort A also serves as an 8-bit bi-directional I/O por t, if the A/D Converter is not used. Port pins\ncan provide internal pull-up resistors (selected for each bit). The Port A output buffers have sym-metrical drive characteristics with both high sink and source capability. When pins PA0 to PA7are used as inputs and are externally pulled low, they will source current if the internal pull-upresistors are activated. The Port A pins are tri-stated when a reset condition becomes active,even if the clock is not running.\n\n5\n2503PS\u2013AVR\u201307/10ATmega32(L)\nPort B (PB7..PB0) Port B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort B output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port B pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port B pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort B also serves the functions of various special features of the ATmega32 as listed on page\n57.\nPort C (PC7..PC0) Port C is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort C output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port C pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port C pins are tri-stated when a reset condition becomes active,even if the clock is not running. If the JTAG interface is enabled, the pull-up resistors on pinsPC5(TDI), PC3(TMS) and PC 2(TCK) will be activated even if a reset occurs.\nThe TD0 pin is tri-stated unless TAP states that shift out data are entered.Port C also serves the functions of the JTAG interface and other special features of the\nATmega32 as listed on page 60 .\nPort D (PD7..PD0) Port D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort D output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port D pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port D pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort D also serves the functions of various special features of the ATmega32 as listed on page\n62. \nRESET\nReset Input. A low level on this pin for longer than the minimum pulse length will generate a\nreset, even if the clock is not running. The minimum pulse length is given in Table 15 on page\n37. Shorter pulses are not guaranteed to generate a reset.\nXTAL1 Input to the inverting Oscillato r amplifier and input to the in ternal clock operating circuit.\nXTAL2 Output from the invert ing Oscillator amplifier.\nAVCC AVCC is the supply voltage pin for Port A and the A/D Converter. It should be externally con-\nnected to VCC, even if the ADC is not used. If the ADC is used, it should be connected to VCC\nthrough a low-pass filter. \nAREF AREF is the analog reference pin for the A/D Converter.\n\n6\n2503PS\u2013AVR\u201307/10ATmega32(L)\nResources A comprehensive set of development tools, app lication notes and datasheets are available for\ndownload on http:// www.atmel.com/avr.\nNote: 1.\nData Retention Reliability Qualification results show that the pr ojected data retention failure rate is much less\nthan 1 PPM over 20 years at 85\u00b0C or 100 years at 25\u00b0C.\nAbout Code \nExamples This documentation contains simple code examples  that briefly show how to use various parts of\nthe device. These code examples assume that the part specific header file is included beforecompilation. Be aware that not all C Compiler vendors include bit definitions in the header files\nand interrupt handling in C is compiler dependent. Please confirm with the C Compiler documen-tation for more details.\n\n7\n2503PS\u2013AVR\u201307/10ATmega32(L)\nRegister Summary\nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n$3F ($5F) SREG I T H S V N Z C 10\n$3E ($5E) SPH \u2013 \u2013 \u2013 \u2013 SP11 SP10 SP9 SP8 12\n$3D ($5D) SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 12\n$3C ($5C) OCR0 Timer/Counter0 Output Compare Register 82\n$3B ($5B) GICR INT1 INT0 INT2 \u2013 \u2013 \u2013 IVSEL IVCE 47, 67 \n$3A ($5A) GIFR INTF1 INTF0 INTF2 \u2013 \u2013 \u2013 \u2013 \u20136 8\n$39 ($59) TIMSK OCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 OCIE0 TOIE0 82, 112, 130$38 ($58) TIFR OCF2 TOV2 ICF1 OCF1A OCF1B TOV1 OCF0 TOV0 83, 112, 130\n$37 ($57) SPMCR SPMIE RWWSB\n\u2013 RWWSRE BLBSET PGWRT PGERS SPMEN 248\n$36 ($56) TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE 177\n$35 ($55) MCUCR SE SM2 SM1 SM0 ISC11 ISC10 ISC01 ISC00 32, 66\n$34 ($54) MCUCSR JTD ISC2 \u2013 JTRF WDRF BORF EXTRF PORF 40, 67, 228\n$33 ($53) TCCR0 FOC0 WGM00 COM01 COM00 WGM01 CS02 CS01 CS00 80$32 ($52) TCNT0 Timer/Counter0 (8 Bits) 82\n$31\n(1) ($51)(1)OSCCAL Oscillator Calibration Register 30\nOCDR On-Chip Debug Register 224\n$30 ($50) SFIOR ADTS2 ADTS1 ADTS0 \u2013 ACME PUD PSR2 PSR10 56,85,131,198,218\n$2F ($4F) TCCR1A COM1A1 COM1A0 COM1B1 COM1B0 FOC1A FOC1B WGM11 WGM10 107\n$2E ($4E) TCCR1B ICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 110\n$2D ($4D) TCNT1H Timer/Counter1 \u2013 Counter Register High Byte 111\n$2C ($4C) TCNT1L Timer/Counter1 \u2013 Counter Register Low Byte 111\n$2B ($4B) OCR1AH Timer/Counter1 \u2013 Output Compare Register A High Byte 111\n$2A ($4A) OCR1AL Timer/Counter1 \u2013 Output Compare Register A Low Byte 111\n$29 ($49) OCR1BH Timer/Counter1 \u2013 Output Compare Register B High Byte 111\n$28 ($48) OCR1BL Timer/Counter1 \u2013 Output Compare Register B Low Byte 111\n$27 ($47) ICR1H Timer/Counter1 \u2013 Input Capture Register High Byte 111\n$26 ($46) ICR1L Timer/Counter1 \u2013 Input Capture Register Low Byte 111\n$25 ($45) TCCR2 FOC2 WGM20 COM21 COM20 WGM21 CS22 CS21 CS20 125\n$24 ($44) TCNT2 Timer/Counter2 (8 Bits) 127\n$23 ($43) OCR2 Timer/Counter2 Output Compare Register 127\n$22 ($42) ASSR \u2013 \u2013 \u2013 \u2013 AS2 TCN2UB OCR2UB TCR2UB 128\n$21 ($41) WDTCR \u2013 \u2013 \u2013 WDTOE WDE WDP2 WDP1 WDP0 42\n$20(2) ($40)(2)UBRRH URSEL \u2013 \u2013 \u2013 UBRR[11:8] 164\nUCSRC URSEL UMSEL UPM1 UPM0 USBS UCSZ1 UCSZ0 UCPOL 162\n$1F ($3F) EEARH \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 EEAR9 EEAR8 19\n$1E ($3E) EEARL EEPROM Address Register Low Byte 19\n$1D ($3D) EEDR EEPROM Data Register 19\n$1C ($3C) EECR \u2013 \u2013 \u2013 \u2013 EERIE EEMWE EEWE EERE 19\n$1B ($3B) PORTA PORTA7 PORTA6 PORTA5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 64$1A ($3A) DDRA DDA7 DDA6 DDA5 DDA4 DDA3 DDA2 DDA1 DDA0 64\n$19 ($39) PINA PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 64\n$18 ($38) PORTB PORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 64$17 ($37) DDRB DDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 64\n$16 ($36) PINB PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 65\n$15 ($35) PORTC PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 65$14 ($34) DDRC DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 65\n$13 ($33) PINC PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 65\n$12 ($32) PORTD PORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 65$11 ($31) DDRD DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 65\n$10 ($30) PIND PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 65\n$0F ($2F) SPDR  SPI Data Register 138\n$0E ($2E) SPSR SPIF WCOL\n\u2013 \u2013 \u2013 \u2013 \u2013 SPI2X 138\n$0D ($2D) SPCR SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 136\n$0C ($2C) UDR  USART I/O Data Register 159\n$0B ($2B) UCSRA RXC TXC UDRE FE DOR PE U2X MPCM 160\n$0A ($2A) UCSRB RXCIE TXCIE UDRIE RXEN TXEN UCSZ2 RXB8 TXB8 161\n$09 ($29) UBRRL  USART Baud Rate Register Low Byte 164\n$08 ($28) ACSR ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 199\n$07 ($27) ADMUX REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 214\n$06 ($26) ADCSRA ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 216$05 ($25) ADCH ADC Data Register High Byte 217\n$04 ($24) ADCL ADC Data Register Low Byte 217\n$03 ($23) TWDR Two-wire Serial Interface Data Register 179\n$02 ($22) TWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE 179\n\n8\n2503PS\u2013AVR\u201307/10ATmega32(L)\nNotes: 1. When the OCDEN Fuse is unprogrammed, the OSCCAL Regist er is always accessed on this address. Refer to the debug-\nger specific documentation for details  on how to use the OCDR Register.\n2. Refer to the USART description for details on how to access UBRRH and UCSRC.3. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory addresses\nshould never be written.\n4. Some of the Status Flags are cleared by writing a logical one to them. Note that the CBI and  SBI instructions will operate on\nall bits in the I/O Register, writing a one back into any flag read as set, thus clearing the flag. The CBI and SBI instruction s\nwork with registers $00 to $1F only.$01 ($21) TWSR TWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 178\n$00 ($20) TWBR Two-wire Serial Interface Bit Rate Register 177Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n9\n2503PS\u2013AVR\u201307/10ATmega32(L)\nInstruction Set Summary\nMnemonics Operands Description Operation Flags #Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \u2190 Rd + Rr Z,C,N,V,H 1\nADC Rd, Rr Add with Carry two Registers Rd \u2190 Rd + Rr + C Z,C,N,V,H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \u2190 Rdh:Rdl + K Z,C,N,V,S 2\nSUB Rd, Rr Subtract two Registers Rd \u2190 Rd - Rr Z,C,N,V,H 1\nSUBI Rd, K Subtract Constant from Register Rd \u2190 Rd - K Z,C,N,V,H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \u2190 Rd - Rr - C Z,C,N,V,H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \u2190 Rd - K - C Z,C,N,V,H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \u2190 Rdh:Rdl - K Z,C,N,V,S 2\nAND Rd, Rr Logical AND Registers Rd \u2190 Rd \u2022 Rr Z,N,V 1\nANDI Rd, K Logical AND Register and Constant Rd \u2190 Rd \u2022 K Z,N,V 1\nOR Rd, Rr Logical OR Registers Rd \u2190 Rd v Rr Z,N,V 1\nORI Rd, K Logical OR Register and Constant Rd \u2190 Rd v K Z,N,V 1\nEOR Rd, Rr Exclusive OR Registers Rd \u2190 Rd \u2295 Rr Z,N,V 1\nCOM Rd One\u2019s Complement Rd \u2190 $FF \u2212 Rd Z,C,N,V 1\nNEG Rd Two\u2019s Complement Rd \u2190 $00 \u2212 Rd Z,C,N,V,H 1\nSBR Rd,K Set Bit(s) in Register Rd \u2190 Rd v K Z,N,V 1\nCBR Rd,K Clear Bit(s) in Register Rd \u2190 Rd \u2022 ($FF - K) Z,N,V 1\nINC Rd Increment Rd \u2190 Rd + 1 Z,N,V 1\nDEC Rd Decrement Rd \u2190 Rd \u2212 1 Z,N,V 1\nTST Rd Test for Zero or Minus Rd \u2190 Rd \u2022 Rd Z,N,V 1\nCLR Rd Clear Register Rd  \u2190 Rd \u2295 Rd Z,N,V 1\nSER Rd Set Register Rd \u2190 $FF None 1\nMUL Rd, Rr Multiply Unsigned R1:R0 \u2190 Rd x Rr Z,C 2\nMULS Rd, Rr Multiply Signed R1:R0 \u2190 Rd x Rr Z,C 2\nMULSU Rd, Rr Multiply Signed with Unsigned R1:R0 \u2190 Rd x Rr Z,C 2\nFMUL Rd, Rr Fractional Multiply Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nFMULS Rd, Rr Fractional Multiply Signed R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nFMULSU Rd, Rr Fractional Multiply Signed with Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nBRANCH INSTRUCTIONSRJMP k Relative Jump PC  \u2190 PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \u2190 Z None 2\nJMP k Direct Jump PC  \u2190 kN o n e 3\nRCALL k Relative Subroutine Call PC \u2190 PC + k + 1 None 3\nICALL Indirect Call to (Z) PC \u2190 ZN o n e 3\nCALL k Direct Subroutine Call PC \u2190 kN o n e 4\nRET Subroutine Return PC \u2190 Stack None 4\nRETI Interrupt Return PC \u2190 Stack I 4\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC  \u2190 PC + 2 or 3 None 1 / 2 / 3\nCP Rd,Rr Compare Rd \u2212 Rr Z, N,V,C,H 1 \nCPC Rd,Rr Compare with Carry Rd \u2212 Rr \u2212 C Z, N,V,C,H 1\nCPI Rd,K Compare Register with Immediate Rd \u2212 K Z, N,V,C,H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \u2190PC+k + 1 None 1 / 2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \u2190PC+k + 1 None 1 / 2\nBREQ  k Branch if Equal if (Z = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRCS  k Branch if Carry Set if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLO  k Branch if Lower if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRMI  k Branch if Minus if (N = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRPL  k Branch if Plus if (N = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRGE  k Branch if Greater or Equal, Signed if (N \u2295 V= 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLT  k Branch if Less Than Zero, Signed if (N \u2295 V= 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \u2190 PC + k  + 1 None 1 / 2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \n\u2190 PC + k + 1 None 1 / 2\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \u2190 PC + k + 1 None 1 / 2\n\n10\n2503PS\u2013AVR\u201307/10ATmega32(L)\nBRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \u2190 PC + k + 1 None 1 / 2\nDATA TRANSFER INSTRUCTIONS\nMOV Rd, Rr Move Between Registers Rd \u2190 Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \u2190 Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \u2190 KN o n e 1\nLD Rd, X Load Indirect Rd \u2190 (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \u2190 (X), X \u2190 X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \u2190 X - 1, Rd \u2190 (X) None 2\nLD Rd, Y Load Indirect Rd \u2190 (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \u2190 (Y), Y \u2190 Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \u2190 Y - 1, Rd \u2190 (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \u2190 (Y + q) None 2\nLD Rd, Z Load Indirect Rd \u2190 (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \u2190 (Z), Z \u2190 Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \u2190 Z - 1, Rd \u2190 (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \u2190 (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \u2190 (k) None 2\nST X, Rr Store Indirect (X)  \u2190 Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X)  \u2190 Rr, X \u2190 X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \u2190 X - 1, (X) \u2190 Rr None 2\nST Y, Rr Store Indirect (Y) \u2190 Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \u2190 Rr, Y \u2190 Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \u2190 Y - 1, (Y) \u2190 Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \u2190 Rr None 2\nST Z, Rr Store Indirect (Z) \u2190 Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \u2190 Rr, Z \u2190 Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \u2190 Z - 1, (Z) \u2190 Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \u2190 Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \u2190 Rr None 2\nLPM Load Program Memory R0 \u2190 (Z) None 3\nLPM Rd, Z Load Program Memory Rd \u2190 (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \u2190 (Z), Z \u2190 Z+1 None 3\nSPM Store Program Memory (Z) \u2190 R1:R0 None -\nIN Rd, P In Port Rd \u2190 PN o n e 1\nOUT P, Rr Out Port P \u2190 Rr None 1\nPUSH Rr Push Register on Stack Stack \u2190 Rr None 2\nPOP Rd Pop Register from Stack Rd \u2190 Stack None 2\nBIT AND BIT-TEST INSTRUCTIONS\nSBI P,b Set Bit in I/O Register I/O(P,b) \u2190 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \u2190 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \u2190 Rd(n), Rd(0) \u2190 0 Z,C,N,V 1\nLSR Rd Logical Shift Right Rd(n) \u2190 Rd(n+1), Rd(7) \u2190 0 Z,C,N,V 1\nROL Rd Rotate Left Through Carry Rd(0) \u2190C,Rd(n+1) \u2190 Rd(n),C \u2190Rd(7) Z,C,N,V 1\nROR Rd Rotate Right Through Carry Rd(7) \u2190C,Rd(n) \u2190 Rd(n+1),C \u2190Rd(0) Z,C,N,V 1\nASR Rd Arithmetic Shift Right Rd(n) \u2190 Rd(n+1), n=0..6 Z,C,N,V 1\nSWAP Rd Swap Nibbles Rd(3..0) \u2190Rd(7..4),Rd(7..4) \u2190Rd(3..0) None 1\nBSET s Flag Set SREG(s) \u2190 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \u2190 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \u2190 Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \u2190 TN o n e 1\nSEC Set Carry C \u2190 1C 1\nCLC Clear Carry C \u2190 0 C 1\nSEN Set Negative Flag N \u2190 1N 1\nCLN Clear Negative Flag N \u2190 0 N 1\nSEZ Set Zero Flag Z \u2190 1Z 1\nCLZ Clear Zero Flag Z \u2190 0 Z 1\nSEI Global Interrupt Enable I \u2190 1I 1\nCLI Global Interrupt Disable I  \u2190 0 I 1\nSES Set Signed Test Flag S \u2190 1S 1\nCLS Clear Signed Test Flag S \u2190 0 S 1\nSEV Set Twos Complement Overflow. V \u2190 1V 1\nCLV Clear Twos Complement Overflow V \u2190 0 V 1\nSET Set T in SREG T \u2190 1T 1\nCLT Clear T in SREG T \u2190 0 T 1\nSEH Set Half Carry Flag in SREG H \u2190 1H 1Mnemonics Operands Description Operation Flags #Clocks\n\n11\n2503PS\u2013AVR\u201307/10ATmega32(L)\nCLH Clear Half Carry Flag in SREG H \u2190 0 H 1\nMCU CONTROL INSTRUCTIONSNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1\nWDR Watchdog Reset (see specific  descr. for WDR/timer) None 1\nBREAK Break For On-Chip Debug Only None N/AMnemonics Operands Description Operation Flags #Clocks\n\n12\n2503PS\u2013AVR\u201307/10ATmega32(L)\nOrdering Information\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation\nand minimum quantities.\n2. Pb-free packaging complies to the European Directive for Re striction of Hazardous Substances (RoHS directive). Also\nHalide free and fully Green.Speed (MHz) Power Supply Ordering Code Package(1)Operational Range\n8 2.7V - 5.5VATmega32L-8AU(2)\nATmega32L-8PU(2)\nATmega32L-8MU(2)44A\n40P6\n44M1Industrial\n(-40oC to 85oC)\n16 4.5V - 5.5VATmega32-16AU(2)\nATmega32-16PU(2)\nATmega32-16MU(2)44A\n40P644M1Industrial\n(-40\noC to 85oC)\nPackage Type\n44A 44-lead, 10 \u00d7 10 \u00d7 1.0 mm, Thin Prof ile Plastic Quad Flat Package (TQFP)\n40P6 40-pin, 0.600\u201d Wide, Plastic Dual Inline Package (PDIP)\n44M1 44-pad, 7 \u00d7 7 \u00d7 1.0 mm, Quad Flat No -Lead/Micro Lead Frame Package (QFN/MLF)\n\n13\n2503PS\u2013AVR\u201307/10ATmega32(L)\nPackaging Information\n44A\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n44A,  44-lead, 10 x 10 mm Body Size, 1.0 mm Body Thickness,\n0.8 mm Lead Pitch, Thin Profile Plastic Quad Flat Package (TQFP) B 44A10/5/2001PIN 1 IDENTIFIER\n0\u02da~7\u02daPIN 1 \nLC\nA1 A2 AD1\nDe E1 EB\nCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. This package conforms to JEDEC reference MS-026, Variation ACB. \n2. Dimensions D1 and E1 do not include mold protrusion. Allowable \nprotrusion is 0.25 mm per side. Dimensions D1 and E1 are maximum plastic body size dimensions including mold mismatch.\n3. Lead coplanarity is 0.10 mm maximum.A \u2013 \u2013 1.20\nA1 0.05 \u2013 0.15A2  0.95 1.00 1.05           D 11.75 12.00 12.25D1 9.90 10.00 10.10 Note 2E 11.75 12.00 12.25E1 9.90 10.00 10.10 Note 2B           0.30 \u2013 0.45C 0.09 \u2013 0.20L 0.45 \u2013  0.75e 0.80 TYP\n\n14\n2503PS\u2013AVR\u201307/10ATmega32(L)\n40P6\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n40P6 , 40-lead (0.600\"/15.24 mm Wide) Plastic Dual \nInline Package (PDIP)  B 40P609/28/01PIN\n1\nE1\nA1\nB\nREFEB1\nCLSEATING PLANEA\n0\u00ba ~ 15\u00ba  D\ne\neBCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nA \u2013 \u2013 4.826\nA1 0.381 \u2013 \u2013D 52.070 \u2013 52.578 Note 2E 15.240 \u2013 15.875E1 13.462 \u2013 13.970 Note 2B 0.356 \u2013 0.559B1 1.041 \u2013 1.651L 3.048 \u2013 3.556C 0.203 \u2013      0.381     eB 15.494 \u2013 17.526e 2.540 TYPNotes: 1. This package conforms to JEDEC reference MS-011, Variation AC. \n2. Dimensions D and E1 do not include mold Flash or Protrusion.\nMold Flash or Protrusion shall not exceed 0.25 mm (0.010\").\n\n15\n2503PS\u2013AVR\u201307/10ATmega32(L)\n44M1\nTITLE DRAWING NO. GPC REV.\n   Package Drawing Contact:\n packagedrawings@atmel.com 44M1 ZWS H44M1, 44-pad, 7 x 7 x 1.0 mm Body,  Lead \nPitch 0.50 mm, 5.20 mm Exposed Pad, Thermally Enhanced Plastic Very Thin Quad Flat No Lead Package (VQFN)  9/26/08COMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 0.80 0.90 1.00\n A1 \u2013 0.02 0.05\n A3  0.20 REF\n b 0.18 0.23 0.30\n D  \n D2 5.00 5.20 5.40\n6.90 7.00 7.106.90 7.00 7.10\n E\n E2 5.00 5.20 5.40\n e  0.50 BSC\n L 0.59 0.64 0.69\nK 0.20 0.26 0.41Note:  JEDEC Standard MO-220, Fig. 1 (SAW Singulation) VKKD-3. TOP VIEW\nSIDE VIEW\nBOTTOM VIEWD\nEMarked Pin# 1 ID\nE2D2\nb ePin #1 CornerLA1\nA3\nASEATING PLANE\nPin #1 \nTriangle\nPin #1 \nChamfer(C 0.30)Option A\nOption B\nPin #1 \nNotch(0.20 R)Option CK\nK1\n2\n3\n\n16\n2503PS\u2013AVR\u201307/10ATmega32(L)\nErrata\nATmega32, rev. A \nto F\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexpect ed interrup t request.\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lo st if a timer register that is synchr onous timer clock is written when the\nasynchronous Timer/Counter register (TCNTx) is 0x00.\nProblem Fix/WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register (TCCRx), asynchronous-Timer Counter Register (TCNTx), or asynchronous Output Compare Register (OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega32 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega32 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega32 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega32 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\n\n17\n2503PS\u2013AVR\u201307/10ATmega32(L)\nDatasheet \nRevision \nHistoryPlease note that the referring page numbers in th is section are referred to this document. The\nreferring revision in this  section are referring to  the document revision.\nChanges from Rev. \n2503O-07/09 to \nRev. 2503P-07/101. Inserted Note in \u201cPerforming Page Erase by SPM\u201d on page 251 .\n2. Note 6 and Note 7 in Table 119 on page 290  have been removed.\n3. Updated \u201cPerforming Page Erase by SPM\u201d on page 251 .\nChanges from Rev. \n2503N-06/08 to \nRev.2503O-07/091. Updated \u201cErrata\u201d on page 336  .\n2. Updated the TOC with new template (version 5.10)\nChanges from Rev. \n2503M-05/08 to \nRev.\n2503N-06/081. Added the note \u201cNot recommended for new designs\u201d on \u201cFeatures\u201d on page 1 .\nChanges from Rev. \n2503L-05/08 to \nRev.\n2503M-05/081. Updated \u201cOrdering Information\u201d on page 12 :\n- Commercial ordering codes removed.- Non Pb-free package option removed.\n2. Removed note from Feature list in \u201cAnalog to Digital Converter\u201d on page 201 .\n3. Removed note from Table 84 on page 215 .\nChanges from Rev. \n2503K-08/07 to \nRev.\n2503L-05/081. Updated \u201cFast PWM Mode\u201d on page 75  in \u201c8-bit Timer/Counter0 with PWM\u201d on page\n69:\n\u2013 Removed the last section describing how to achieve a frequency with 50% duty \ncycle waveform output in fast PWM mode.\nChanges from Rev. \n2503J-10/06 to \nRev.\n2503K-08/071. Renamed \u201cInput Capture Trigger Source\u201d to \u201cInput Capture Pin Source\u201d on page 94 .\n2. Updated \u201cFeatures\u201d on page 1 .\n3. Added \u201cData Retention\u201d on page 6 .\n4. Updated \u201cErrata\u201d on page 336 .\n5. Updated \u201cSlave Mode\u201d on page 136 .\nChanges from Rev. \n2503I-04/06 to Rev.2503J-10/061. Updated \u201cFast PWM Mode\u201d on page 99 .\n2. Updated Table 38 on page 80 , Table 40 on page 81 , Table 45 on page 108 , Table 47 on\npage 109 , Table 50 on page 125  and Table 52 on page 126 .\n\n18\n2503PS\u2013AVR\u201307/10ATmega32(L)\n3. Updated typo in table note 6 in \u201cDC Characteristics\u201d on page 287 .\n4. Updated \u201cErrata\u201d on page 336 .\nChanges from Rev. \n2503H-03/05 to \nRev. 2503I-04/061. Updated Figure 1 on page 2 .\n2. Added \u201cResources\u201d on page 6 .\n3. Added note to \u201cTimer/Counter Oscillator\u201d on page 31 .\n4. Updated \u201cSerial Peripheral Interface \u2013 SPI\u201d on page 132 .\n5. Updated note in \u201cBit Rate Generator Unit\u201d on page 175 .\n6. Updated Table 86 on page 218 .\n7. Updated \u201cDC Characteristics\u201d on page 287 .\nChanges from Rev. \n2503G-11/04 to \nRev. 2503H-03/051. MLF-package alternative changed to \u201cQuad Flat No-Lead/Micro Lead Frame Package\nQFN/MLF\u201d.\n2. Updated \u201cElectrical Characteristics\u201d on page 287\n3. Updated \u201cOrdering Information\u201d on page 332 .\nChanges from Rev. \n2503F-12/03 to Rev. 2503G-11/041. \u201cChannel\u201d renamed \u201cCompare unit\u201d in Timer/Counter sections, ICP renamed ICP1.\n2. Updated Table 7 on page 29 , Table 15 on page 37 , Table 81 on page 206 , Table 114 on\npage 272 , Table 115 on page 273 , and Table 118 on page 289 .\n3. Updated Figure 1 on page 2 , Figure 46 on page 100 .\n4. Updated \u201cVersion\u201d on page 226 .\n5. Updated \u201cCalibration Byte\u201d on page 258 .\n6. Added section \u201cPage Size\u201d on page 258 .\n7. Updated \u201cATmega32 Typical Characteristics\u201d on page 296 .\n8. Updated \u201cOrdering Information\u201d on page 332 .\nChanges from Rev. \n2503E-09/03 to \nRev. 2503F-12/031. Updated \u201cCalibrated Internal RC Oscillator\u201d on page 29 .\nChanges from Rev. \n2503D-02/03 to \nRev. 2503E-09/031. Updated and changed \u201cOn-chip Debug System\u201d to \u201cJTAG Interface and On-chip\nDebug System\u201d on page 35 .\n2. Updated Table 15 on page 37 .\n3. Updated \u201cTest Access Port \u2013 TAP\u201d on page 219  regarding the JTAGEN fuse.\n\n19\n2503PS\u2013AVR\u201307/10ATmega32(L)\n4. Updated description for Bit 7 \u2013 JTD: JTAG Interface Disable on page 228 .\n5. Added a note regarding JTAGEN fuse to Table 104 on page 257 .\n6. Updated Absolute Maximum Ratings* , DC Characteristics and ADC Characteristics in\n\u201cElectrical Characteristics\u201d on page 287 .\n7. Added a proposal for solving problems regarding the JTAG instruction IDCODE in\n\u201cErrata\u201d on page 336 .\nChanges from Rev. \n2503C-10/02 to Rev. 2503D-02/031. Added EEAR9 in EEARH in \u201cRegister Summary\u201d on page 327 .\n2. Added Chip Erase as a first step in \u201cProgramming the Flash\u201d on page 284  and \u201cPro-\ngramming the EEPROM\u201d on page 285 .\n3. Removed reference to \u201cMulti-purpose Oscillator\u201d application note and \u201c32 kHz Crys-\ntal Oscillator\u201d application note, which do not exist.\n4. Added information about PWM symmetry for Timer0 and Timer2.5. Added note in \u201cFilling the Temporary Buffer (Page Loading)\u201d on page 251  about writ-\ning to the EEPROM during an SPM Page Load.\n6. Added \u201cPower Consumption\u201d data in \u201cFeatures\u201d on page 1 .\n7. Added section \u201cEEPROM Write During Power-down Sleep Mode\u201d on page 22 .\n8. Added note about Differential Mode with Auto Triggering in \u201cPrescaling and Conver-\nsion Timing\u201d on page 204 .\n9. Updated Table 89 on page 232 .\n10.Added updated \u201cPackaging Information\u201d on page 333 .\nChanges from Rev. \n2503B-10/02 to \nRev. 2503C-10/021. Updated the \u201cDC Characteristics\u201d on page 287 .\nChanges from Rev. \n2503A-03/02 to Rev. 2503B-10/021. Canged the endurance on the Flash to 10,000 Write/Erase Cycles.\n2. Bit nr.4 \u2013 ADHSM \u2013 in SFIOR Register removed.3. Added the section \u201cDefault Clock Source\u201d on page 25 .\n4. When using External Clock there are some limitations regards to change of fre-\nquency. This is described in \u201cExternal Clock\u201d on page 31  and Table 117 on page 289 .\n5. Added a sub section regarding OCD-system and power consumption in the section\n\u201cMinimizing Power Consumption\u201d on page 34 .\n6. Corrected typo (WGM-bit setting) for:\n\u2013\u201cFast PWM Mode\u201d on page 75  (Timer/Counter0)\n\u2013\u201cPhase Correct PWM Mode\u201d on page 76  (Timer/Counter0)\n\n20\n2503PS\u2013AVR\u201307/10ATmega32(L)\n\u2013\u201cFast PWM Mode\u201d on page 120  (Timer/Counter2)\n\u2013\u201cPhase Correct PWM Mode\u201d on page 121  (Timer/Counter2)\n7. Corrected Table 67 on page 164  (USART).\n8. Updated VIL, IIL, and IIH parameter in \u201cDC Characteristics\u201d on page 287 .\n9. Updated Description of OSCCAL Calibration Byte.\nIn the datasheet, it was not explained how to take advantage of the calibration bytes for 2, 4,\nand 8 MHz Oscillator selections. This is  now added in the following sections:\nImproved description of \u201cOscillator Calibration Regi ster \u2013 OSCCAL\u201d on page 30  and \u201cCali-\nbration Byte\u201d on page 258 .\n10. Corrected typo in Table 42 .\n11. Corrected description in Table 45  and Table 46 .\n12. Updated Table 118 , Table 120 , and Table 121 .\n13. Added \u201cErrata\u201d on page 336 .\n\n2503PS\u2013AVR\u201307/10Headquarters International\nAtmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel: 1(408) 441-0311\nFax: 1(408) 487-2600Atmel Asia\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHong Kong\nTel: (852) 2245-6100Fax: (852) 2722-1369Atmel Europe\nLe Krebs\n8, Rue Jean-Pierre Timbaud\nBP 30978054 Saint-Quentin-en-\nYvelines Cedex\nFranceTel: (33) 1-30-60-70-00 \nFax: (33) 1-30-60-71-11Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033Japan\nTel: (81) 3-3523-3551\nFax: (81) 3-3523-7581\nProduct Contact\nWeb Sitewww.atmel.comTechnical Support\navr@atmel.comSales Contact\nwww.atmel.com/contacts\nLiterature Requests\nwww.atmel.com/literature\nDisclaimer:  The information in this document is provided in connection with  Atmel products. No license, express or implied, by estoppel or  otherwise, to any\nintellectual property right is granted by this document  or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN ATMEL \u2019S TERMS AND CONDI-\nTIONS OF SALE LOCATED ON ATMEL \u2019S WEB SITE, ATMEL ASSUMES NO LI ABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTOR Y\nWARRANTY RELATING TO ITS PRODUCTS INCLUDING,  BUT NOT LIMITED TO, THE IMPLIED WARRANTY  OF MERCHANTABILITY, FITNESS FOR A PARTICU LAR\nPURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR I NCIDEN-\nTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING  OUT OF\nTHE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATME L HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH DAMAGES.  Atmel makes no\nrepresentations or warranties with respect to the accuracy or comp leteness of the contents of this document and reserves the rig ht to make changes to specifications\nand product descriptions at any time without notice. Atmel does  not make any commitment to update the information contained her ein. Unless specifically provided\notherwise, Atmel products are not suitable for, and shall not be used in, automotive applications. Atmel\u2019s products are not int ended, authorized, or warranted for use\nas components in applications in tended to support or sustain life.\n\u00a9 2010 Atmel Corporation. All rights reserved. Atmel\u00ae, Atmel logo and combinations thereof, AVR\u00ae and others are registered trademarks or\ntrademarks of Atmel Corporation or its subsidiaries. Other terms and product names may be trademarks of others.", "atmega 640.pdf": "Features\n\u2022High Performance, Low Power Atmel\u00ae AVR\u00ae 8-Bit Microcontroller\n\u0081Advanced RISC Architecture\n\u2013 135 Powerful Instructions \u2013 Most Single Clock Cycle Execution\n\u2013 32 \u00d7 8 General Purpose Working Registers\n\u2013 Fully Static Operation\u2013 Up to 16 MIPS Throughput at 16MHz\u2013 On-Chip 2-cycle Multiplier\n\u0081High Endurance Non-volatile Memory Segments\n\u2013 64K/128K/256KBytes of In-System Self-Programmable Flash \n\u2013 4Kbytes EEPROM\n\u2013 8Kbytes Internal SRAM\u2013 Write/Erase Cycles:10,000 Flash/100,000 EEPROM\u2013 Data retention: 20 years at 85 \u00b0C/ 100 years at 25 \u00b0C\n\u2013 Optional Boot Code Section with Independent Lock Bits\n\u0081 In-System Programming by On-chip Boot Program\n\u0081 True Read-While-Write Operation\n\u2013 Programming Lock for Software Security\n\u0081 Endurance: Up to 64Kbytes Optional External Memory Space\n\u0081Atmel\u00ae QTouch\u00ae library support\n\u2013 Capacitive touch buttons, sliders and wheels\u2013 QTouch and QMatrix\u00ae acquisition\n\u2013 Up to 64 sense channels\n\u0081JTAG (IEEE std. 1149.1 compliant) Interface\n\u2013 Boundary-scan Capabilities According to the JTAG Standard\u2013 Extensive On-chip Debug Support\u2013 Programming of Flash, EEPROM, Fuses, and Lock Bits through the JTAG Interface\n\u0081Peripheral Features\n\u2013 Two 8-bit Timer/Counters with Separate Prescaler and Compare Mode\u2013 Four 16-bit Timer/Counter with Separate Prescaler, Compare- and Capture Mode\u2013 Real Time Counter with Separate Oscillator\u2013 Four 8-bit PWM Channels\u2013 Six/Twelve PWM Channels with Programmable Resolution from 2 to 16 Bits\n(ATmega1281/2561, ATmega640/1280/2560)\n\u2013 Output Compare Modulator\u2013 8/16-channel, 10-bit ADC (ATmega1281/2561, ATmega640/1280/2560)\u2013 Two/Four Programmable Serial USART (ATmega1281/2561, ATmega640/1280/2560)\u2013 Master/Slave SPI Serial Interface\u2013 Byte Oriented 2-wire Serial Interface\n\u2013 Programmable Watchdog Timer with Separate On-chip Oscillator\n\u2013 On-chip Analog Comparator\u2013 Interrupt and Wake-up on Pin Change\n\u0081Special Microcontroller Features\n\u2013 Power-on Reset and Programmable Brown-out Detection\u2013 Internal Calibrated Oscillator\n\u2013 External and Internal Interrupt Sources\n\u2013 Six Sleep Modes: Idle, ADC Noise Reduction, Power-save, Power-down, Standby,\nand Extended Standby\n\u0081I/O and Packages\n\u2013 54/86 Programmable I/O Lines (ATmega1281/2561, ATmega640/1280/2560)\u2013 64-pad QFN/MLF, 64-lead TQFP (ATmega1281/2561)\n\u2013 100-lead TQFP, 100-ball CBGA (ATmega640/1280/2560)\n\u2013 RoHS/Fully Green\n\u0081Temperature Range:\n\u2013- 4 0 \u00b0C to 85 \u00b0C Industrial\n\u0081Ultra-Low Power Consumption\n\u2013 Active Mode: 1MHz, 1.8V: 500\u00b5A\n\u2013 Power-down Mode: 0.1\u00b5A at 1.8V\n\u0081Speed Grade:\n\u2013 ATmega640V/ATmega1280V/ATmega1281V:\n\u0081 0 - 4MHz @ 1.8V - 5.5V, 0 - 8MHz @ 2.7V - 5.5V\n\u2013 ATmega2560V/ATmega2561V:\n\u0081 0 - 2MHz @ 1.8V - 5.5V, 0 - 8MHz @ 2.7V - 5.5V\n\u2013 ATmega640/ATmega1280/ATmega1281:\n\u0081 0 - 8MHz @ 2.7V - 5.5V, 0 - 16MHz @ 4.5V - 5.5V\n\u2013 ATmega2560/ATmega2561:\n\u0081 0 - 16MHz @ 4.5V - 5.5V8-bit Atmel \nMicrocontroller with 64K/128K/256K Bytes In-SystemProgrammable \nFlash\nATmega640/V\nATmega1280/VATmega1281/VATmega2560/VATmega2561/V\nPreliminary\n 2549N\u2013AVR\u201305/11\n\n2\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1. Pin Configurations\nFigure 1-1. TQFP-pinout ATmega640/1280/2560\nGND\nVCCPA0 (AD0) PA1 (AD1) PA2 (AD2)\nPA3 (AD3)\nPA4 (AD4)PA5 (AD5)PA6 (AD6)PA7 (AD7)\nPG2 (ALE)AVCC\nGND\nAREF PF0 (ADC0) PF1 (ADC1) PF2 (ADC2) PF3 (ADC3) PF4 (ADC4/TCK) PF5 (ADC5/TMS) PF6 (ADC6/TDO) PF7 (ADC7/TDI)\n100 99 9897 96 95 94 93 92 91 908988878685848382818079 7877 76\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n2575\n74\n73\n72\n71\n70\n69\n68\n67\n66\n65\n64\n63\n62\n61\n60\n59\n58\n57\n56\n55\n54\n53\n52\n51\n26 2829 31 27 36 30 32 35 37 33 34 3839 40 41 42 43 44 45 46 47 4849 50PK0 (ADC8/PCINT16)\nPK1 (ADC9/PCINT17)\nPK2 (ADC10/PCINT18)\nPK3 (ADC11/PCINT19)\nPK4 (ADC12/PCINT20)\nPK5 (ADC13/PCINT21)\nPK6 (ADC14/PCINT22)\nPK7 (ADC15/PCINT23)\n(OC2B) PH6\n(TOSC2) PG3 (TOSC1) PG4 RESET (T4) PH7\n(ICP4) PL0VCCGND\nXTAL2 XTAL1PL6 PL7GND\nVCC(OC0B) PG5\nVCC\nGND\n(RXD2) PH0\n(TXD2) PH1\n(XCK2) PH2\n(OC4A) PH3\n(OC4B) PH4\n(OC4C) PH5(RXD0/PCI NT8) PE0\n(TXD0) PE1\n(XCK0/AI N0) PE2\n(OC3A/AI N1) PE3\n(OC3B/I NT4) PE4\n(OC3C/I NT5) PE5\n(T3/INT6) PE6\n(CLKO/ICP3/I NT7) PE7\n(SS/PCI NT0) PB0\n(SCK/PCI NT1) PB1\n(MOSI/PCI NT2) PB2\n(MISO/PCI NT3) PB3\n(OC2A/PCI NT4) PB4\n(OC1A/PCI NT5) PB5\n(OC1B/PCI NT6) PB6\n(OC0A/OC1C/PCINT7) PB7PC7 (A15)\nPC6 (A14)\nPC5 (A13)\nPC4 (A12)\nPC3 (A11)\nPC2 (A10)\nPC1 (A9)\nPC0 (A 8)\nPG1 (RD)\nPG0 (WR)\n(TXD1/INT3) PD3\n(ICP1) PD4(XCK1) PD5(T1) PD6 (T0) PD7\n(SCL/INT0) PD0\n(SDA/INT1) PD1\n(RXD1/INT2) PD2\n(ICP5) PL1(T5) PL2\n(OC5A) PL3 (OC5B) PL4PJ6 (PCI NT15)\nPJ5 (PCI NT14)\nPJ4 (PCI NT13)\nPJ3 (PCI NT12)\nPJ2 (XCK3/PCI NT11)\nPJ1 (TXD3/PCI NT10)\nPJ0 (RXD3/PCI NT9)PJ7\n(OC5C) PL5INDEX COR NER\n\n3\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 1-2. CBGA-pinout ATmega640/1280/2560 \nNote: The functions for each pin is the same as for the 100 pin packages shown in Figure 1-1 on page 2 .A\nBCDEFGHJK1234567891 0\nA\nBCDEFGHJK1 098765432 1\nTop view Bottom view\nTable 1-1. CBGA-pinout ATmega640/1280/2560\n1 2 3 4 5 678 91 0\nA GND AREF PF0 PF2 PF5 PK0 PK3 PK6 GND VCC\nB AVCC PG5 PF1 PF3 PF6 PK1 PK4 PK7 PA0 PA2\nC PE2 PE0 PE1 PF4 PF7 PK2 PK5 PJ7 PA1 PA3\nD PE3 PE4 PE5 PE6 PH2 PA4 PA5 PA6 PA7 PG2\nE PE7 PH0 PH1 PH3 PH5 PJ6 PJ5 PJ4 PJ3 PJ2\nF VCC PH4 PH6 PB0 PL4 PD1 PJ1 PJ0 PC7 GND\nG GND PB1 PB2 PB5 PL2 PD0 PD5 PC5 PC6 VCC\nH PB3 PB4 RESET PL1 PL3 PL7 PD4 PC4 PC3 PC2\nJ PH7 PG3 PB6 PL0 XTAL2 PL6 PD3 PC1 PC0 PG1\nK PB7 PG4 VCC GND XTAL1 PL5 PD2 PD6 PD7 PG0\n\n4\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 1-3. Pinout ATmega1281/2561\nNote: The large center pad underneath the QFN/ML F package is made of metal and internally con-\nnected to GND. It should be soldered or glued to  the board to ensure good mechanical stability. If \nthe center pad is left unc onnected, the package might loosen from the board.(RXD0/PCI NT8/PDI) PE0\n(TXD0/PDO) PE1\n(XCK0/AI N0) PE2\n(OC3A/AI N1) PE3\n(OC3B/I NT4) PE4\n(OC3C/I NT5) PE5\n(T3/INT6) PE6\n(ICP3/CLKO/I NT7) PE7\n(SS/PCI NT0) PB0(OC0B) PG5\n(SCK/PCI NT1) PB1\n(MOSI/PCI NT2) PB2\n(MISO/PCI NT3) PB3\n(OC2A/ PCI NT4) PB4\n(OC1A/PCI NT5) PB5\n(OC1B/PCI NT6) PB6\n(OC0A/OC1C/PCINT7) PB7\n(TOSC2) PG3(TOSC1) PG4 RESETVCCGND\nXTAL2 XTAL1\n(SCL/INT0) PD0\n(SDA/INT1) PD1\n(RXD1/INT2) PD2\n(TXD1/INT3) PD3\n(ICP1) PD4(XCK1) PD5PA3 (AD3)\nPA4 (AD4)\nPA5 (AD5)PA6 (AD6)PA7 (AD7)\nPG2 (ALE)\nPC7 (A15)\nPC6 (A14)\nPC5 (A13)\nPC4 (A12)PC3 (A11)\nPC2 (A10)\nPC1 (A9)\nPC0 (A 8)\nPG1 (RD)PG0 (WR)AVCC\nGND\nAREF PF0 (ADC0) PF1 (ADC1) PF2 (ADC2) PF3 (ADC3) PF4 (ADC4/TCK) PF5 (ADC5/TMS) PF6 (ADC6/TDO) PF7 (ADC7/TDI) GND\nVCCPA0 (AD0) PA1 (AD1) PA2 (AD2)\n(T1) PD6 (T0) PD7INDEX COR NER1\n2\n345\n6\n7\n8\n9\n1011\n12\n13\n14\n15\n1664 63 62 61 60 59 5857 56 55 54 53 52 51 50 49\n48\n47\n46\n45\n44\n43\n42\n41\n403938\n37\n36\n35\n34\n33\n17 1819 20 21 22 23 24 25 26 27 2829 30 31 32\n\n5\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2. Overview\nThe ATmega640/1280/1281/2560/2561 is a low-power CMOS 8-bit microcontroller based on the\nAVR enhanced RISC architecture. By executing pow erful instructions in a single clock cycle, the\nATmega640/1280/1281/2560/2561 achieves throughputs approaching 1 MIPS per MHz allowingthe system designer to optimize power consumption versus processing speed.\n2.1 Block Diagram\nFigure 2-1. Block Diagram\n CPUGNDVCC\nRESETPo w er\nS upervision\nPOR /  BOD &\nRESET\nWatchdog\nOscillatorWatchdog\nTimer\nOscillator\nCi rcu i t s /\nCl ock\nGenerat i onXTAL1\nXTAL2\nPC7..0 PORT C (8)P A7..0 PORT A (8)\nPORT D (8)\nPD7..0PORT B (8)\nPB7..0PORT E (8)PE7..0\nPORT F (8)PF7..0\nPORT J (8)PJ7..0\nPG5..0 PORT G (6)\nPORT H (8)\nPH7..0PORT K (8)PK7..0\nPORT L (8)\nPL7..0XRAM\nTWI SPIEEPROMJTAG\n8 bit T/C 0 8 bit T/C 216 bit T/C 116 bit T/C 3\nSRAM FLASH16 bit T/C 416 bit T/C 5\nUSART 2USART 1USART 0\nInternal \nBandgap referenceAnalog \nCo m p ar at o rA/D\nCo n ver t er\nUSART 3\nNOTE:Shaded parts only availablein the 100-pin version. \nC omplete functionality for\nt h e ADC, T/ C4, an d  T/ C5 on l y available in the 100-pin version.\n\n6\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Atmel\u00ae AVR\u00ae core combines a rich instruction set with 32 general purpose working regis-\nters. All the 32 registers are directly connected to  the Arithmetic Logic Unit (ALU), allowing two\nindependent registers to be accessed in one single instruction executed in one clock cycle. The\nresulting architecture is more code efficient wh ile achieving throughputs up to ten times faster\nthan conventional CISC microcontrollers.\nThe ATmega640/1280/1281/2560/2561 provides the following features: 64K/128K/256K bytes of\nIn-System Programmable Flash with Read- While-Write capabilities, 4Kbytes EEPROM, 8\nKbytes SRAM, 54/86 general purpose I/O lines, 32 general purpose working registers, Real\nTime Counter (RTC), six flexible Timer/Counters with compare modes and P WM, 4 USARTs, a\nbyte oriented 2-wire Serial Interface, a 16-c hannel, 10-bit ADC with optional differential input\nstage with programmable gain, programmable Watchdog Timer with Internal Oscillator, an SPI\nserial port, IEEE\u00ae std. 1149.1 compliant JTAG test interface, also used for accessing the On-\nchip Debug system and programming and six software selectable power saving modes. The Idlemode stops the CPU while allowing the SRAM, Timer/Counters, SPI port, and interrupt system\nto continue functioning. The Power-down mode saves the register contents but freezes the\nOscillator, disabling all other ch ip functions until the next interr upt or Hardware Reset. In Power-\nsave mode, the asynchronous timer continues to run, allowing the user to maintain a timer base\nwhile the rest of the device is sleeping. The ADC Noise Reduction mode stops the CPU and all\nI/O modules except Asynchronous Timer and ADC, to minimize switching noise during ADCconversions. In Standby mode, the Crystal/Resonato r Oscillator is running while the rest of the\ndevice is sleeping. This allows very fast st art-up combined with lo w power consumption. In\nExtended Standby mode, bo th the main Oscillator and the Asynchronous Ti mer continue to run.\nAtmel offers the QTouch\n\u00ae library for embedding capacitive touch buttons, sliders and wheels-\nfunctionality into AVR microcontrollers. The patented charge-transfer signal acquisition\noffersrobust sensing and includes fully debounced reporting of touch keys and includes AdjacentKeySuppression\n\u00ae (AKS\u2122) technology for unambiguous detection of key events. The easy-to-use\nQTouch Suite toolchain allows you to explore, develop and debug your own touch applications.\nThe device is manufactured using Atmel\u2019s high- density nonvolatile memory technology. The On-\nchip ISP Flash allows the prog ram memory to be repr ogrammed in-system th rough an SPI serial\ninterface, by a conventional nonvolatile memory programmer, or by an On-chip Boot program\nrunning on the AVR core. The boot program can use any interface to download the application\nprogram in the applicatio n Flash memory. Software in the Boot  Flash section will continue to run\nwhile the Application Flash section is updated, providing true Read- While-Write operation. By\ncombining an 8-bit RISC CPU with In-System Self-Programmable Flash on a monolithic chip,\nthe Atmel ATmega640/1280/1281/2560/2561 is a powerful microcontroller that provides a highlyflexible and cost effective solution to many embedded control applications.\nThe ATmega640/1280/1281/2560/2561 AVR is supported with a full suite of program and sys-\ntem development tools including: C compilers, macro assemblers, programdebugger/simulators, in-circuit emulators, and evaluation kits.\n\n7\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2.2 Comparison Between ATme ga1281/2561 and AT mega640/1280/2560\nEach device in the ATmega640/1280/1281/2560/2561 family differs only in memory size and\nnumber of pins. Table 2-1  summarizes the different configurations for the six devices.\n2.3 Pin Descriptions\n2.3.1 VCC\nDigital supply voltage.\n2.3.2 GND\nGround.\n2.3.3 Port A (PA7..PA0)\nPort A is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort A output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port A pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port A pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort A also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 78 .\n2.3.4 Port B (PB7..PB0)\nPort B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort B output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port B pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port B pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort B has better driving capabilities than the other ports.\nPort B also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 79 .\n2.3.5 Port C (PC7..PC0)\nPort C is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort C output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port C pi ns that are externally pulled lo w will source current if the pull-upTable 2-1. Configuration Summary\nDevice Flash EEPROM RAMGeneral\nPurpose I/O pins16 bits resolution\nPWM channelsSerial\nUSARTsADC\nChannels\nATmega640 64KB 4KB 8KB 86 12 4 16\nATmega1280 128KB 4KB 8KB 86 12 4 16ATmega1281 128KB 4KB 8KB 54 6 2 8\nATmega2560 256KB 4KB 8KB 86 12 4 16\nATmega2561 256KB 4KB 8KB 54 6 2 8\n\n8\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nresistors are activated. The Port C pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort C also serves the functions of special features of the ATmega640/1280/1281/2560/2561 as\nlisted on page 82 .\n2.3.6 Port D (PD7..PD0)\nPort D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort D output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port D pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port D pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort D also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 83 .\n2.3.7 Port E (PE7..PE0)\nPort E is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort E output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port E pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port E pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort E also serves the functions of various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 86 .\n2.3.8 Port F (PF7..PF0)\nPort F serves as analog inputs to the A/D Converter.\nPort F also serves as an 8-bit bi-directional I/O port, if the A/D Converter is not used. Port pins\ncan provide internal pull-up resistors (selected for each bit). The Port F output buffers have sym-\nmetrical drive characteristics with both high sink  and source capa bility. As inputs, Port F pins\nthat are externally pulled low will source current if the pull-up resistors are ac tivated. The Port F\npins are tri-stated when a reset condition becomes active, even if the clock is not running. If the\nJTAG interface is enabled, the pull-up resistors on pins PF7( TDI), PF5(TMS), and PF4(TCK) will\nbe activated even if a reset occurs.\nPort F also serves the functions of the JTAG interface.\n2.3.9 Port G (PG5..PG0)\nPort G is a 6-bit I/O port with internal pull-up resistors (selected for each bit). The Port G output\nbuffers have symmetrical drive characteristic s with both high sink and source capability. As\ninputs, Port G pins that are externally pulled lo w will source current if the pull-up resistors are\nactivated. The Port G pins are tri-stated when a reset condition becomes active, even if the clock\nis not running.\nPort G also serves the functions of  various special features of the\nATmega640/1280/1281/2560/2561 as listed on page 90 .\n2.3.10 Port H (PH7..PH0)\nPort H is a 8-bit bi-directional I/O port with inte rnal pull-up resistors (selected for each bit). The\nPort H output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port H pi ns that are externally pulled lo w will source current if the pull-up\n\n9\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nresistors are activated. The Port H pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort H also serves the functions of various  special features of the ATmega640/1280/2560 as\nlisted on page 92 .\n2.3.11 Port J (PJ7..PJ0)\nPort J is a 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort J output buffers have symmetrical drive characteristics with both high sink and source capa-\nbility. As inputs, Port J pins that are externally pulled low will source current if the pull-up\nresistors are activated. The Port J pins are tr i-stated when a reset condition becomes active,\neven if the clock is not running.\nPort J also serves the functions of various special features of the ATmega640/1280/2560 as\nlisted on page 94 .\n2.3.12 Port K (PK7..PK0)\nPort K serves as analog inputs to the A/D Converter.\nPort K is a 8-bit bi-directional I/O port with inte rnal pull-up resistors (selected for each bit). The\nPort K output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port K pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port K pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort K also serves the functions of vari ous special features of the ATmega640/1280/2560 as\nlisted on page 96 .\n2.3.13 Port L (PL7..PL0)\nPort L is a 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort L output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port L pins  that are externally pulled low will source current  if the pull-up\nresistors are activated. The Port L pins are tri-stated when a reset condition becomes active,\neven if the clock is not running.\nPort L also serves the functions of variou s special features of the ATmega640/1280/2560 as\nlisted on page 98 .\n2.3.14 RESET\nReset input. A low level on this pin for longer than the minimum pulse length will generate a\nreset, even if the clock is not runni ng. The minimum pulse length is given in \u201cSystem and Reset\nCharacteristics\u201d on page 372 . Shorter pulses are not guaranteed to generate a reset.\n2.3.15 XTAL1\nInput to the inverting Oscillato r amplifier and input to the in ternal clock operating circuit.\n2.3.16 XTAL2\nOutput from the invert ing Oscillator amplifier.\n\n10\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n2.3.17 AVCC\nAVCC is the supply voltage pin for Port F and the A/D Converter. It should be externally con-\nnected to VCC, even if the ADC is not used. If the ADC is used, it should be connected to VCC\nthrough a low-pass filter.\n2.3.18 AREF\nThis is the analog reference pin for the A/D Converter.\n\n11\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n3. Resources\nA comprehensive set of development tools a nd application notes, and datasheets are available\nfor download on http://www.atmel.com/avr .\n4. About Code Examples\nThis documentation contains simple code examples  that briefly show how to use various parts of\nthe device. Be aware that not all C compiler vendors include bit definitions in the header files\nand interrupt handling in C is compiler dependent. Please confirm with the C compiler documen-\ntation for more details.\nThese code examples assume that the part specific header file is included before compilation.\nFor I/O registers located in extended I/O map, \"I N\", \"OUT\", \"SBIS\", \"SBIC\", \"CBI\", and \"SBI\"\ninstructions must be replaced with instructio ns that allow access to extended I/O. Typically\n\"LDS\" and \"STS\" combined with \"SBRS\", \"SBRC\", \"SBR\", and \"CBR\".\n5. Data Retention\nReliability Qualification results show that the pr ojected data retention failure rate is much less\nthan 1 ppm over 20 years at 85\u00b0C or 100 years at 25\u00b0C.\n6. Capacitive touch sensing\nThe Atmel\u00aeQTouch\u00ae Library provides a simple to use so lution to realize touch sensitive inter-\nfaces on most Atmel AVR\u00ae microcontrollers. The QTouch Library includes support for the\nQTouch and QMatrix\u00ae acquisition methods.\nTouch sensing can be added to any application by linking the appropriate Atmel QTouch Library\nfor the AVR Microcontroller. This is done by using a simple set of APIs to define the touch chan-\nnels and sensors, and then calling the touch sens ing API\u2019s to retrieve the channel information\nand determine the touch sensor states.\nThe QTouch Library is FREE and downloadable from the Atmel website at the following location:\nwww.atmel.com/qtouchlibrary . For implementation details and other information, refer to the\nAtmel QTouch Library User Guide  - also available for download from the Atmel website.\n\n12\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7. AVR CPU Core\n7.1 Introduction\nThis section discusses the AVR core architecture in general. The main function of the CPU core\nis to ensure correct program execution. The CPU must therefore be able to access memories,perform calculations, control peripherals, and handle interrupts.\n7.2 Architectural Overview\nFigure 7-1. Block Diagram of the AVR Architecture \nIn order to maximize performance and parallelism, the AVR uses a Harvard architecture \u2013 with\nseparate memories and buses for program and data. Instructions in the program memory are\nexecuted with a sing le level pipelining. While one instruction is being executed, the next instruc-\ntion is pre-fetched from the program memory. This concept enables instructions to be executed\nin every clock cycle. The program memory is In-System Reprogrammable Flash memory.Flash\nProgram\nMemory\nInstruction\nReg i st er\nInstruction\nDecoderProgram\nCoun t er\nC ontrol Lines32 x 8\nGeneral\nPurp ose\nReg i st er s\nALUSt at u s\nand Control\nI/O LinesEEPROMData Bus 8-bit \nData\nSRAMDirect Addressing Indirect AddressingInterrupt\nUnit\nSPI\nUnit\nWatchdog\nTimer\nAnalog\nComparator\nI/O Module 2I/O Module1\nI/O Module n\n\n13\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe fast-access Register File contains 32 \u00d7 8-bit general purpose working registers with a single\nclock cycle access time. This allows single-cycle Ar ithmetic Logic Unit (ALU ) operation. In a typ-\nical ALU operation, two operands are output from the Register File, the operation is executed,\nand the result is stored back in the Register File \u2013 in one clock cycle.\nSix of the 32 registers can be used as three 16-b it indirect address register pointers for Data\nSpace addressing \u2013 enabling efficient address calculations. One of the these address pointers\ncan also be used as an address pointer for look up tables in Flash program memory. Theseadded function registers are the 16-bit X-, Y-, and Z-register, described later in this section.\nThe ALU supports arithmetic and logic operations between registers or between a constant and\na register. Single register operations can also be executed in the ALU. After an arithmetic opera-tion, the Status Register is updated to reflect information about the result of the operation.\nProgram flow is provided by conditional and uncon ditional jump and call instructions, able to\ndirectly address the whole address space. Most AVR instructions have a single 16-bit word for-\nmat. Every program memory address contains a 16-bit or 32-bit instruction.\nProgram Flash memory space is divided in two sections, the Boot Program section and the\nApplication Program section. Both sections have dedicated Lock bits for write and read/write\nprotection. The SPM instruction that writes into the Application Flash memory section must\nreside in the Boot Program section.\nDuring interrupts and subroutine calls, the return address Program Counter (PC) is stored on the\nStack. The Stack is effectively allocated in the general data SRAM, and consequently the Stack\nsize is only limited by the to tal SRAM size and the usage of the SRAM. All user programs must\ninitialize the SP in the Reset routine (before subroutines or interrupts are executed). The Stack\nPointer (SP) is read/write accessible in the I/O space. The data SRAM can easily be accessed\nthrough the five different addressing modes supported in the AVR architecture.\nThe memory spaces in the AVR  architecture are all linear and regular memory maps.\nA flexible interrupt module has its control r egisters in the I/O space with an additional Global\nInterrupt Enable bit in the Status  Register. All interrupts have a separate Interrupt Vector in the\nInterrupt Vector table. The interrupts have priority in accordance with their Interrupt Vector posi-tion. The lower the Interrupt Vector address, the higher the priority.\nThe I/O memory space contains 64 addresses for CPU peripheral functi ons as Control Regis-\nters, SPI, and other I/O functions. The I/O Memory can be accessed directly, or as the Data\nSpace locations following those of the Register File, 0x20 - 0x5F. In addition, theATmega640/1280/1281/2560/2561 has Extended I/O space from 0x60 - 0x1FF in SRAM where\nonly the ST/STS/STD and LD/LDS/LDD instructions can be used.\n7.3 ALU \u2013 Arithm etic Logic Unit\nThe high-performance AVR ALU operates in dire ct connection with all the 32 general purpose\nworking registers. Within a single clock cycle, arithmetic operations between general purpose\nregisters or between a register and an immediate are executed. The ALU operations are divided\ninto three main categories \u2013 arithmetic, logical, and bit-functions. Some implementations of thearchitecture also provide a powerful multiplier supporting both signed/unsigned multiplication\nand fractional format. See the \u201cInstruction Set Summary\u201d on page 416  for a detailed description.\n\n14\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.4 Status Register\nThe Status Register contains information about the result of the most recently executed arithme-\ntic instruction. This information can be used for altering program flow in order to perform\nconditional operations. Note that the Status Register is updated after all ALU operations, asspecified in the \u201cInstruction Set Summary\u201d on page 416 . This will in many cases remove the\nneed for using the dedicated compare instructions, resulting in faster and more compact code.\nThe Status Register is not automatically stored when entering an interrupt routine and restored\nwhen returning from an interrupt. This must be handled by software.\n7.4.1 SREG \u2013 AVR Status Register\nThe AVR Status Register \u2013 SREG \u2013 is defined as:\n\u0081 Bit 7 \u2013 I: Global Interrupt Enable\nThe Global Interrupt Enable bit must be set for th e interrupts to be enabled. The individual inter-\nrupt enable control is then performed in separate control registers. If the Global Interrupt Enable\nRegister is cleared, none of the interrupts are enabled independent of the individual interruptenable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by\nthe RETI instruction to enable subsequent interrupts. The I-bit can also be set and cleared by\nthe application with the SEI and CLI instructions, as described in the \u201cInstruction Set Summary\u201d\non page 416 .\n\u0081 Bit 6 \u2013 T: Bit Copy Storage\nThe Bit Copy instructions BLD (Bit LoaD) and BST (B it STore) use the T-bit as source or desti-\nnation for the operated bit. A bit from a register in  the Register File can be copied into T by the\nBST instruction, and a bit in T can be copied into a bit in a register in the Register File by theBLD instruction.\n\u0081 Bit 5 \u2013 H: Half Carry Flag \nThe Half Carry Flag H indicates a Half Carry in so me arithmetic operations.  Half Carry Is useful\nin BCD arithmetic. See the \u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 4 \u2013 S: Sign Bit, S = N\n \u2295 V\nThe S-bit is always an exclusive or between the Negative Flag N and the Two\u2019s Complement\nOverflow Flag V. See the \u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 3 \u2013 V: Two\u2019s Complement Overflow Flag\nThe Two\u2019s Complement Overflow Flag V suppor ts two\u2019s complement arithmetics. See the\n\u201cInstruction Set Summary\u201d on page 416  for detailed information.\n\u0081 Bit 2 \u2013 N: Negative Flag\nThe Negative Flag N indicates a negative result in an arithmetic or logic operation. See the\n\u201cInstruction Set Summary\u201d on page 416  for detailed information.B i t 76543210\n0x3F (0x5F) IT H S V N Z C S R E G\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n15\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1 \u2013 Z: Zero Flag\nThe Zero Flag Z indicates a zero result in an arithmetic or logic operation. See the \u201cInstruction\nSet Summary\u201d on page 416  for detailed information.\n\u0081 Bit 0 \u2013 C: Carry Flag\nThe Carry Flag C indicates a carry in an arithmetic or logic operation. See the \u201cInstruction Set\nSummary\u201d on page 416  for detailed information.\n7.5 General Purpose Register File\nThe Register File is optimized for the AVR Enhanc ed RISC instruction set. In order to achieve\nthe required performance and flex ibility, the following in put/output schemes ar e supported by the\nRegister File:\n\u0081 One 8-bit output operand and one 8-bit result input\n\u0081 Two 8-bit output operands and one 8-bit result input\u0081 Two 8-bit output operands and one 16-bit result input\u0081 One 16-bit output operand and one 16-bit result inputFigure 7-2  shows the structure of the 32 general purpose working registers in the CPU.\nFigure 7-2. AVR CPU General Purpose Working Registers\nMost of the instructions operating on the Register File have direct access to all registers, and\nmost of them are single cycle instructions.\nAs shown in Figure 7-2 , each register is also assigned a data memory address, mapping them\ndirectly into the first 32 locations of the user  Data Space. Although not being physically imple-\nmented as SRAM locations, this memory organization provides great flexibility in access of theregisters, as the X-, Y- and Z-pointer registers can be set to index any register in the file.\n7.5.1 The X-register, Y-register, and Z-register\nThe registers R26..R31 have some added functions to their general purpose usage. These reg-\nisters are 16-bit address pointers for indirect addressing of the data space. The three indirect\naddress registers X, Y, and Z are defined as described in Figure 7-3 on page 16 .7 0 Addr.\nR0 0x00\nR1 0x01R2 0x02\n\u2026\nR13 0x0D\nGeneral R14 0x0E\nPurpose R15 0x0F\nWorking R16 0x10\nRegisters R17 0x11\n\u2026\nR26 0x1A X-register Low Byte\nR27 0x1B X-register High Byte\nR28 0x1C Y-register Low ByteR29 0x1D Y-register High ByteR30 0x1E Z-register Low ByteR31 0x1F Z-register High Byte\n\n16\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 7-3. The X-, Y -, and Z-registers\nIn the different addressing modes these address registers have functions as fixed displacement,\nautomatic increment, and automatic decrement (see the \u201cInstruction Set Summary\u201d on page 416\nfor details).\n7.6 Stack Pointer\nThe Stack is mainly used for storing temporary data, for storing local variables and for storing\nreturn addresses after interrupts and subroutine calls. The Stack Pointer Register always points\nto the top of the Stack. Note that the Stack is implemented as growing from higher memory loca-tions to lower memory locations. This implies that a Stack PUSH command decreases the Stack\nPointer.\nThe Stack Pointer points to the data SRAM Stack area where the Subroutine and Interrupt\nStacks are located. This Stack space in the data SRAM must be defined by the program before\nany subroutine calls are executed or interrupts are enabled. The Stack Pointer must be set to\npoint above 0x0200. The initial value of the stack pointer is the last address of the internalSRAM. The Stack Pointer is decremented by one when data is pushed onto the Stack with the\nPUSH instruction, and it is decremented by two for ATmega640/1280/1281 and three for\nATmega2560/2561 when the return address is pushed onto the Stack with subroutine call orinterrupt. The Stack Pointer is incremented by one when data is popped from the Stack with the\nPOP instruction, and it is incremented by two for ATmega640/1280/1281 and three for\nATmega2560/2561 when data is popped from the Stack with return from subroutine RET orreturn from interrupt RETI.\nThe AVR Stack Pointer is implemented as two 8- bit registers in the I/O space. The number of\nbits actually used is implementation dependent. Note that the data space in some implementa-\ntions of the AVR architecture is so small that only SPL is needed. In this case, the SPH Register\nwill not be present.15 XH XL 0\nX-register 70 7 0\nR27 (0x1B) R26 (0x1A)\n15 YH YL 0\nY-register 70 7 0\nR29 (0x1D) R28 (0x1C)\n15 ZH ZL 0\nZ-register 70 7 0\nR31 (0x1F) R30 (0x1E)\nB i t 1 51 41 31 21 11 0 9 80x3E (0x5E) SP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 SPH\n0x3D (0x5D) SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 SPL\n76543210\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 1 0 0 0 0 1\n11111111\n\n17\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.6.1 RAMPZ \u2013 Extended Z-pointer Register for ELPM/SPM\nFor ELPM/SPM instructions, the Z-pointer is a concatenation of RAMPZ, ZH, and ZL, as shown\nin Figure 7-4.  Note that LPM is not affected by the RAMPZ setting.\nFigure 7-4. The Z-pointer used by ELPM and SPM\nThe actual number of bits is  implementation depen dent. Unused bits in an implementation will\nalways read as zero. For compatibility with future devices, be su re to write these bits to zero.\n7.6.2 EIND \u2013 Extended Indirect Register\nFor EICALL/EIJMP instructions, the Indirect-pointer  to the subroutine/routine is a concatenation\nof EIND, ZH, and ZL, as shown in Figure 7-5.  Note that ICALL and IJMP are not affected by the\nEIND setting.\nFigure 7-5. The Indirect-pointer used by EICALL and EIJMP\nThe actual number of bits is  implementation depen dent. Unused bits in an implementation will\nalways read as zero. For compatibility with future devices, be su re to write these bits to zero.\n7.7 Instruction Execution Timing\nThis section describes the general access timi ng concepts for instruction execution. The AVR\nCPU is driven by the CPU clock clkCPU, directly generated from the selected clock source for the\nchip. No internal clo ck division is used.\nFigure 7-6 on page 18  shows the parallel instruction fetches and instruction executions enabled\nby the Harvard architecture and the fast-access R egister File concept. This is the basic pipelin-\ning concept to obtain up to 1 MIPS per MHz with the corresponding unique results for functions\nper cost, functions per clocks, and functions per power-unit.B i t 765432 1 0\n0x3B (0x5B) RAMPZ7 RAMPZ6 RAMPZ5 RAMPZ4 RAMPZ3 RAMPZ2 RAMPZ1 RAMPZ0 RAMPZ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nBit (\nIndividually)70 7 0 7 0\nRAMPZ ZH ZL\nBit (Z-pointer) 23 16 15 8 7 0\nB i t 765432 1 0\n0x3C (0x5C) EIND7 EIND6 EIND5 EIND4 EI ND3 EIND2 EIND1 EIND0 EIND\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nBit (Individual-\nly)70 70 70\nEIND ZH ZL\nBit (Indirect-\npointer)23 16 15 8 7 0\n\n18\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 7-6. The Parallel Instruction Fetches and Instruction Executions\nFigure 7-7  shows the internal timing concept for the Register File. In a single clock cycle an ALU\noperation using two register operands  is executed, and the result is stored back to the destina-\ntion register.\nFigure 7-7. Single Cycle ALU Operation\n7.8 Reset and Inte rrupt Handling\nThe AVR provides several different interrupt sources. These interrupts and the separate Reset\nVector each have a separate program vector in the program memory space. All interrupts are\nassigned individual enable bits which must be written logic one together with the Global Interrupt\nEnable bit in the Status Register in orde r to enable the interrupt. Depending on the Program\nCounter value, interrupts may be automatically disabled when Boot Lock bits BLB02 or BLB12\nare programmed. This feature improves software security. See the section \u201cMemory Program-\nming\u201d on page 335  for details.\nThe lowest addresses in the program memory space are by default defined as the Reset and\nInterrupt Vectors. The complete list of vectors is shown in \u201cInterrupts\u201d on page 105 . The list also\ndetermines the priority levels of the different interrupts. The lower the address the higher is the\npriority level. RESET has the highest priority, and  next is INT0 \u2013 the External Interrupt Request\n0. The Interrupt Vectors can be moved to the start of the Boot Flash section by setting the IVSEL\nbit in the MCU Control Register (MCUCR). Refer to \u201cInterrupts\u201d on page 105  for more informa-\ntion. The Reset Vector can also be moved to the start of the Boot Flash section by programmingthe BOOTRST Fuse, see \u201cMemory Programming\u201d on page 335 .\nWhen an interrupt occurs, the Global Interrupt Enable I-bit is cleared and all interrupts are dis-\nabled. The user software can write logic one to the I-bit to enable nested interrupts. All enabledinterrupts can then interrupt the current interrupt routine. The I-bit is automatically set when a\nReturn from Interrupt instruction \u2013 RETI \u2013 is executed.clk\n1st Instruction Fetch\n1st Instruction Execute\n2nd Instruction Fetch\n2nd Instruction Execute\n3rd Instruction Fetch\n3rd Instruction Execute\n4th Instruction FetchT1 T2 T3 T4\nCPU\nTotal Execution Time\nRegister Operands Fetch\nALU Operation Execute\nResult Write BackT1 T2 T3 T4\nclkCPU\n\n19\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThere are basically two types of interrupts. The fi rst type is triggered by an event that sets the\nInterrupt Flag. For these interrupts, the Program Counter is vectored to the actual Interrupt Vec-\ntor in order to execute the interrupt handling routine, and hardware clears the corresponding\nInterrupt Flag. Interrupt Flags can also be cleared by writing a logic one to the flag bit position(s)to be cleared. If an interrupt condition occurs while the corresponding interrupt enable bit is\ncleared, the Interrupt Fl ag will be set and remember ed until the interrupt is  enabled, or the flag is\ncleared by software. Similarly, if one or more interrupt conditions occur while the Global InterruptEnable bit is clea red, the corres ponding Interrupt Fl ag(s) will be set and remembered until the\nGlobal Interrupt Enable bit is set, and will then be exec uted by order of priority.\nThe second type of interrupts will trigger as long as the interrupt condition is present. These\ninterrupts do not necessarily have Interrupt Flags. If the interrupt condition disappears before the\ninterrupt is enabled, the in terrupt will not be triggered.\nWhen the AVR exits from an interrupt, it will alwa ys return to the main program and execute one\nmore instruction before any pending interrupt is served.\nNote that the Status Register is not automatica lly stored when entering an interrupt routine, nor\nrestored when returning from an interrupt routine. This must be handled by software.\nWhen using the CLI instruction to disable interrupts, the interrup ts will be immediately disabled.\nNo interrupt will be executed af ter the CLI instruction,  even if it occurs simultaneously with the\nCLI instruction. The following example shows how this can be used to avoid interrupts during thetimed EEPROM write sequence.\nWhen using the SEI instruction to enable interrupt s, the instruction following SEI will be exe-\ncuted before any pending interrupts, as shown in this example.Assembly Code Example\ninr16, SREG ; store SREG value\ncli ; disable interrupts during timed sequence\nsbiEECR, EEMPE ; start EEPROM write\nsbiEECR, EEPE\noutSREG, r16 ; restore SREG value (I-bit)\nC Code Example\nchar cSREG;\ncSREG = SREG; /* store SREG value */\n/* disable interrupts during timed sequence */\n__disable_interrupt(); \nEECR |= (1<<EEMPE); /* start EEPROM write */\nEECR |= (1<<EEPE);\nSREG = cSREG; /* restore SREG value (I-bit) */\n\n20\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n7.8.1 Interrupt Response Time\nThe interrupt execution response for all the enab led AVR interrupts is five clock cycles minimum.\nAfter five clock cycles the program vector address for the actual interrupt handling routine is exe-\ncuted. During these five clock cycle period, the Program Counter is pushed onto the Stack. Thevector is normally a jump to the interrupt routine, and this jump takes three clock cycles. If an\ninterrupt occurs during execution of a multi-cycle instruction, this instruction is completed before\nthe interrupt is served. If an interrupt occurs w hen the MCU is in sleep mode, the interrupt exe-\ncution response time is increased by five cloc k cycles. This increase comes in addition to the\nstart-up time from the selected sleep mode.\nA return from an interrupt handling routine takes fi ve clock cycles. During these five clock cycles,\nthe Program Counter (three bytes) is popped back from the Stack, the Stack Pointer is incre-\nmented by three, and the I-bit in SREG is set.Assembly Code Example\nsei; set Global Interrupt Enable\nsleep; enter sleep, waiting for interrupt\n; note: will enter sleep before any pending \n; interrupt(s)\nC Code Example\n__enable_interrupt(); /* set Global Interrupt Enable */\n__sleep(); /* enter sleep, waiting for interrupt */\n/* note: will enter sleep before any pending interrupt(s) */\n\n21\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8. AVR Memories\nThis section describes the different memories in the ATmega640/1280/1281/2560/2561. The\nAVR architecture has two main memory spaces, the Data Memory and the Program Memory\nspace. In addition, the ATme ga640/1280/1281/2560 /2561 features an EEPROM Memory for\ndata storage. All three memory spaces are linear and regular.\n8.1 In-System Reprogrammable Flash Program Memory\nThe ATmega640/1280/1281/2560/2561 contains 64K /128K/256K bytes On-chip In-System\nReprogrammable Flash memory for program storage, see Figure 8-1 . Since all AVR instructions\nare 16 bit or 32 bit wide, the Flash is organiz ed as 32K/64K/128K \u00d7 16. For software security,\nthe Flash Program memory space is divided into two sections, Boot Program section and Appli-\ncation Program section.\nThe Flash memory has an endurance of at least 10,000 write/erase cycles. The\nATmega640/1280/1281/2560/2561 Program Counter (PC) is 15/16/17 bits wide, thus addressing\nthe 32K/64K/128K program memory locations. The operation of Boot Program section and asso-ciated Boot Lock bits for software pr otection are described in detail in \u201cBoot Loader Support \u2013\nRead- While-Write Self-Programming\u201d on page 317 . \u201cMemory Programming\u201d on page 335  con-\ntains a detailed description on Flash data seri al downloading using the SPI pins or the JTAG\ninterface.\nConstant tables can be allocated within the entire program memory address space (see the LPM\n\u2013 Load Program Memory instruction description and ELPM - Extended Load Program Memoryinstruction description).\nTiming diagrams for instruction fetch and execution are presented in \u201cInstruction Execution Tim-\ning\u201d on page 17 .\n8.2 SRAM Data Memory\nFigure 8-2 on page 23  shows how the ATmega640/1280/1281/2560/2561 SRAM Memory is\norganized.\nThe ATmega640/1280/1281/2560/2561 is a complex microcontroller with more peripheral units\nthan can be supported within the 64 location reserved in the Opcode for the IN and OUT instruc-\ntions. For the Extended I/O space from $060 - $1FF in SRAM, only the ST/STS/STD and\nLD/LDS/LDD instructions can be used.\nThe first 4,608/8,704 Data Memory locations address both the Register File, the I/O Memory,\nExtended I/O Memory, and the internal data SR AM. The first 32 locations address the Register\nfile, the next 64 location the standard I/O Memory, then 416 locations of Extended I/O memoryand the next 8,192 locations address the internal data SRAM.Figure 8-1. Program Flash Memory Map\nAddress (HEX)\n0\nApplication Flash Section\nBoot Flash Section\n0x7FFF/0xFFFF/0x1FFFF\n\n22\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nAn optional external data SRAM can be used with the ATmega640/1280/1281/2560/2561. This\nSRAM will occupy an area in the remaining addr ess locations in the 64K address space. This\narea starts at the address following the internal SRAM. The Register file, I/O, Extended I/O and\nInternal SRAM occupies the lowest 4,608/8, 704 bytes, so when using 64Kbytes (65,536 bytes)\nof External Memory, 60,478/56,832 Bytes of  External Memory are available. See \u201cExternal\nMemory Interface\u201d on page 28  for details on how to take advantage of the external memory map.\nWhen the addresses accessing the SRAM memory space exceeds the internal data memory\nlocations, the external data SRAM is accessed using the same instructions as for the internal\ndata memory access. When the internal data memories are accessed, the read and write strobe\npins (PG0 and PG1) are inacti ve during the whole access cycl e. External SRAM operation is\nenabled by setting the SRE bit in the XMCRA Register.\nAccessing external SRAM takes one additional clock cycle per byte compared to access of the\ninternal SRAM. This means that the commands LD, ST, LDS, STS, LDD, STD, PUSH, and POPtake one additional clock cycle. If the Stack is placed in external SRAM, interrupts, subroutine\ncalls and returns take three clock cycles extra because the three-byte program counter is\npushed and popped, and external memory access does not take advantage of the internal pipe-\nline memory access. When external SRAM interface is used with wait-state, one-byte external\naccess takes two, three, or four additional cl ock cycles for one, two, and three wait-states\nrespectively. Interrupts, subroutine calls and returns will need  five, seven, or nine clock cycles\nmore than specified in the instruction set manual  for one, two, and three wait-states.\nThe five different addressing modes for the data memory cover: Direct, Indirect with Displace-\nment, Indirect, Indirect with Pre-decrement, and Indirect with Post-increment. In the Register file,registers R26 to R31 feature the indirect addressing pointer registers.\nThe direct addressing reaches the entire data space.\nThe Indirect with Displacement mode reaches 63 address locations from the base address given\nby the Y-register or Z-register.\nWhen using register indirect addressing modes with automatic pre-decrement and post-incre-\nment, the address registers X, Y, and Z are decremented or incremented.\nThe 32 general purpose working registers, 64 I/O registers, and the 4,196/8,192 bytes of internal\ndata SRAM in the ATmega640/1280/1281/2560/2561 are all accessible through all these\naddressing modes. The Register File is described in \u201cGeneral Purpose Register File\u201d on page\n15.\n\n23\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.2.1 Data Memory Access Times\nThis section describes the general access timi ng concepts for internal memory access. The\ninternal data SRAM access is performed in two clkCPU cycles as described in Figure 8-3 .\nFigure 8-3. On-chip Data SRAM Access Cycles\n8.3 EEPROM Data Memory\nThe ATmega640/1280/1281/2560/2561 contains 4Kbytes of data EEPROM memory. It is orga-\nnized as a separate data spac e, in which single bytes can be read and written. The EEPROM\nhas an endurance of at least 100,000 write/erase cycles. The access between the EEPROM and\nthe CPU is described in the following, specif ying the EEPROM Address Registers, the EEPROM\nData Register, and the EEPROM Control Register.\nFor a detailed description of SPI, JTAG and Parallel data downloading to the EEPROM, see\n\u201cSerial Downloading\u201d on page 349 , \u201cProgramming via the JTAG Interface\u201d on page 354 , and\n\u201cProgramming the EEPROM\u201d on page 343  respectively.Figure 8-2. Data Memory Map\nAddress (HEX)\n0 - 1F 32 Registers\n20 - 5F 64 I/O Registers\n60 - 1FF 416 External I/O Registers\n200Internal SRAM\n(8192 \u00d7 8)21FF\n2200External SRAM\n(0 - 64K \u00d7 8)\nFFFF\nclk\nWR\nRDData\nDataAddress Address validT1 T2 T3\nCompute Address\nReadWriteCPU\nMemory Access Instruction Next Instruction\n\n24\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.3.1 EEPROM Read/Write Access\nThe EEPROM Access Registers are accessible in the I/O space, see \u201cRegister Description\u201d on\npage 35 .\nThe write access time for the EEPROM is given in Table 8-1 . A self-timing function, however,\nlets the user software detect when the next byte can be written. If the user code contains instruc-\ntions that write the EEPROM, some precautions must be taken. In heavily filtered powersupplies, V\nCC is likely to rise or fall slowly on po wer-up/down. This causes the device for some\nperiod of time to run at a voltage lower than specified as minimum for the clock frequency used.\nSee \u201cPreventing EEPROM Co rruption\u201d on page 26.  for details on how to avoid problems in these\nsituations.\nIn order to prevent unintentional EEPROM writes, a specific write procedure must be followed.\nSee the description of the EEPROM Cont rol Register for details on this; \u201cRegister Description\u201d\non page 35 .\nWhen the EEPROM is read, the CPU is halted for four  clock cycles before the next in struction is\nexecuted. When the EEPROM is written, the CPU is halted for two clock cycles before the next\ninstruction is executed.\nThe calibrated Oscillator is used to time the EEPROM accesses. Table 8-1  lists the typical pro-\ngramming time for EEPROM access from the CPU.\nThe following code examples show one assembly and one C function for writing to the\nEEPROM. The examples assume that interrupts are controlled (for example by disabling inter-rupts globally) so that no inte rrupts will occur during execution of these functi ons. The examples\nalso assume that no Flash Boot Loader is present in the software. If such code is present, the\nEEPROM write function must also wait fo r any ongoing SPM co mmand to finish.Table 8-1. EEPROM Programming Time\nSymbol Number of Calibrated RC Osc illator Cycles Typ Programming Time\nEEPROM write \n(from CPU)26,368 3.3ms\n\n25\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nEEPROM_write:\n; Wait for completion of previous write\nsbic EECR,EEPE\nrjmp EEPROM_write    \n; Set up address (r18:r17) in address register\nout EEARH, r18\nout EEARL, r17\n; Write data (r16) to Data Register\nout EEDR,r16\n; Write logical one to EEMPE\nsbi EECR,EEMPE\n; Start eeprom write by setting EEPEsbi EECR,EEPE\nret\nC Code Example(1)\nvoid EEPROM_write( unsigned int  uiAddress, unsigned char  ucData)\n{\n/* Wait for completion of previous write  */\nwhile(EECR & (1<<EEPE))\n;\n/* Set up address and Data Registers */\nEEAR = uiAddress;EEDR = ucData;\n/* Write logical one to EEMPE */\nEECR |= (1<<EEMPE);/* Start eeprom write by setting EEPE */\nEECR |= (1<<EEPE);\n}\n\n26\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe next code examples show assembly and C functions for reading the EEPROM. The exam-\nples assume that interrupts are controlled so that no interrupts will occur during execution of\nthese functions.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n8.3.2 Preventing EEPROM Corruption\nDuring periods of low VCC, the EEPROM data can be corrupted because the supply voltage is\ntoo low for the CPU and the EEPROM to operate properly. These issues are the same as for\nboard level systems using EEPR OM, and the same design so lutions should be applied.\nAn EEPROM data corruption can be caused by two situations when the voltage is too low. First,\na regular write sequence to the EEPROM requires a minimum voltage to operate correctly. Sec-\nondly, the CPU itself can execute instructions incorrectly, if the supp ly voltage is too low.\nEEPROM data corruption can ea sily be avoided by followin g this design recommendation:\nKeep the AVR RESET active (low) during periods of insufficient power su pply voltage. This can\nbe done by enabling the internal Brown-out Detector (BOD). If the detection level of the internal\nBOD does not match the needed detection level, an external low VCC reset Protection circuit can\nbe used. If a reset occurs while a write operation is in progress , the write operation will be com-\npleted provided that the power supply voltage is sufficient.Assembly Code Example(1)\nEEPROM_read:\n; Wait for completion of previous write\nsbic EECR,EEPE\nrjcmp EEPROM_read\n; Set up address (r18:r17) in address registerout EEARH, r18\nout EEARL, r17\n; Start eeprom read by writing EEREsbi EECR,EERE\n; Read data from Data Register\nin r16,EEDR\nret\nC Code Example(1)\nunsigned char  EEPROM_read( unsigned int  uiAddress)\n{\n/* Wait for completion of previous write */\nwhile(EECR & (1<<EEPE))\n;\n/* Set up address register */\nEEAR = uiAddress;\n/* Start eeprom read by writing EERE */\nEECR |= (1<<EERE);\n/* Return data from Data Register */\nreturn EEDR;\n}\n\n27\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n8.4 I/O Memory\nThe I/O space definition of the ATmega640/1280/1281/2560/2561 is shown in \u201cRegister Sum-\nmary\u201d on page 411 .\nAll ATmega640/1280/1281/2560/2561 I/Os and peripherals are placed in the I/O space. All I/O\nlocations may be accessed by the LD/LDS/LDD and ST/STS/STD instructions, transferring data\nbetween the 32 general purpose working registers and the I/O space. I/O Registers within the\naddress range 0x00 - 0x1F are directly bit-acce ssible using the SBI an d CBI instructions. In\nthese registers, the value of single bits can be checked by using the SBIS and SBIC instructions.\nRefer to the \u201cInstruction Set Summary\u201d on page 416  for more details. When using the I/O spe-\ncific commands IN and OUT, the I/O addresses 0x00 - 0x3F must be used. When addressing I/O\nRegisters as data space using LD and ST instructions, 0x20 must be added to these addresses.\nThe ATmega640/1280/1281/2560/2561 is a complex microcontroller with more peripheral units\nthan can be supported within the 64 location reserved in Opcode for the IN and OUT instruc-tions. For the Extended I/O space from 0x60 - 0x1FF in SRAM, only the ST/STS/STD and\nLD/LDS/LDD instructions can be used.\nFor compatibility with future devices, reserved  bits should be written to zero if accessed.\nReserved I/O memory addresses should never be written.\nSome of the Status Flags are cleared by writing a logical one to them. Note that, unlike most\nother AVRs, the CBI and SBI instructions will only  operate on the specified bit, and can therefore\nbe used on registers containing such Status Flags. The CBI and SBI instructions work with reg-\nisters 0x00 to 0x1F only.\nThe I/O and peripherals control registers are explained in later sections.\n8.4.1 General Purpose I/O Registers\nThe ATmega640/1280/1281/2560/2561 contains three General Purpose I/O Registers. These\nregisters can be used for storing any information, and they are particularly useful for storing\nglobal variables and Status Flags. General Pu rpose I/O Registers within the address range 0x00\n- 0x1F are directly bit-accessible using the SBI, CBI, SBIS, and SBIC instructions. See \u201cRegister\nDescription\u201d on page 35 .\n\n28\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9. External Memory Interface\nWith all the features the External Memory Interf ace provides, it is well suited to operate as an\ninterface to memory devices such as External  SRAM and Flash, and peripherals such as LCD-\ndisplay, A/D, and D/A. The main features are:\n\u0081Four different wait-s tate settings (includi ng no wait-state)\n\u0081Independent wait-state setting fo r different External Memory sect ors (configurable sector size)\n\u0081The number of bits dedicated to  address high byte is selectable\n\u0081Bus keepers on data lines to minimi ze current consumption (optional)\n9.1 Overview\nWhen the eXternal MEMory (XMEM) is enabled , address space outside the internal SRAM\nbecomes available using the dedicated External Memory pins (see Figure 1-3 on page 4 , Table\n13-3 on page 78 , Table 13-9 on page 82 , and Table 13-21 on page 90 ). The memory configura-\ntion is shown in Figure 9-1 .\nFigure 9-1. External Memory with Sector Select\nMemory Confi guration A\n0x0000\n0x21FF\nExtern al Memory\n(0 - 60K x 8)\n0xFFFFIntern al memory\nSRL[2..0]\nSRW11\nSRW10SRW01\nSRW00Lower sector\nUpper sector0x2200\n\n29\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9.1.1 Using the External Memory Interface\nThe interface consists of:\n\u0081 AD7:0: Multiplexed low-order address bus and data bus\n\u0081 A15:8: High-order address bus (configurable number of bits)\n\u0081 ALE: Address latch enable\n\u0081R D : Read strobe\n\u0081WR: Write strobe\nThe control bits for the External Memory Interface are located in two registers, the External\nMemory Control Register A \u2013 XMCRA, and the External Memory Control Register B \u2013 XMCRB.\nWhen the XMEM interface is enabled, the XMEM in terface will override th e setting in the data\ndirection registers that corresponds to the ports dedicated to the XMEM interface. For details\nabout the port override, see the alternate functions in section \u201cI/O-Ports\u201d on page 70 . The XMEM\ninterface will auto-detect wh ether an access is internal or extern al. If the access is external, the\nXMEM interface will output  address, data, and the control si gnals on the ports according to Fig-\nure 9-3 on page 31  (this figure shows the wave  forms without wait-states). When ALE goes from\nhigh-to-low, there is a valid address on AD7:0. ALE is low during a data transfer. When the\nXMEM interface is enabled, also an internal access will cause ac tivity on address, data and ALE\nports, but the RD  and WR strobes will not toggle during internal access. When the External\nMemory Interface is disabled, the normal pin and data direction settings are used. Note thatwhen the XMEM interface is disabled, the address space above the internal SRAM boundary is\nnot mapped into the internal SRAM. Figure 9-2 on page 30  illustrates how to connect an external\nSRAM to the AVR using an octal latch (typically \u201c74 \u00d7 573\u201d or equivalent) which is transparent\nwhen G is high.\n9.1.2 Address Latch Requirements\nDue to the high-speed operation of the XRAM interface, the address latch must be selected with\ncare for system frequencies above 8MHz @ 4V and 4MHz @ 2.7V. When operating at condi-\ntions above these frequencies, the typical old style 74HC series latch becomes inadequate. TheExternal Memory Interface is designed in compliance to the 74AHC series latch. However, most\nlatches can be used as long they comply with the main timing parameters. The main parameters\nfor the address latch are:\n\u0081 D to Q propagation delay (t\nPD)\n\u0081 Data setup time before G low (tSU)\n\u0081 Data (address) hold time after G low (TH)\nThe External Memory Interface is designed to guaranty minimum address hold time after G is\nasserted low of th = 5ns. Refer to tLAXX_LD /tLLAXX_ST  in \u201cExternal Data Memory Timing\u201d  Tables 31-\n11 through Tables 31-18  on pages 379 - 382. The D-to-Q propagation delay (tPD) must be taken\ninto consideration when calculating the access time requirement of the external component. Thedata setup time before G low (t\nSU) must not exceed address valid to ALE low (tAVLLC ) minus PCB\nwiring delay (dependent on the capacitive load).\n\n30\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-2. External SRAM Connected to the AVR\n9.1.3 Pull-up and Bus-keeper\nThe pull-ups on the AD7:0 ports may be activated if the corresponding Port register is written to\none. To reduce power consumption in sleep mode, it is recommended to disable the pull-ups by\nwriting the Port register to zero before entering sleep.\nThe XMEM interface also provides a bus-keeper on the AD7:0 lines. The bus-keeper can be dis-\nabled and enabled in software as described in \u201cXMCRB \u2013 External Memo ry Control Register B\u201d\non page 38 . When enabled, the bus-keeper will keep th e previous value on the AD7:0 bus while\nthese lines are tri-stated by the XMEM interface.\n9.1.4 Timing\nExternal Memory devices have different timing requirements. To meet these requirements, the\nXMEM interface provides four different wait-states as shown in Table 9-3 on page 38 . It is impor-\ntant to consider the timing specification of the External Memory device before selecting the wait-\nstate. The most important parameters are the access time for the external memory compared tothe set-up requirement. The access time for the External Memory is defined to be the time from\nreceiving the chip selec t/address until the data of this address actually is driven on the bus. The\naccess time cannot exceed the time from the ALE pulse must be asserted low until data is stableduring a read sequence (see t\nLLRL+ tRLRH - tDVRH in Tables 31-11  through Tables 31-18  on pages\n379 - 382). The different wait-states are set up in software. As an additional feature, it is possible\nto divide the external memory s pace in two sectors with indivi dual wait-state settings. This\nmakes it possible to connect two different memory devices with different timing requirements to\nthe same XMEM interface. For XMEM interface timing details, please refer to Table 31-11 on\npage 379  to Table 31-18 on page 382  and Figure 31-9 on page 382  to Figure 31-12 on page 384\nin the \u201cExternal Data Memory Timing\u201d on page 379 .\nNote that the XMEM interface is asynchronous and that the waveforms in the following figures\nare related to the internal system clock. T he skew between the internal and external clock\n(XTAL1) is not guarantied (varies between devices temperature, and supply voltage). Conse-\nquently, the XMEM interface is not suited for synchronous operation.D[7:0]\nA[7:0]\nA[15:8]\nRD\nWRSRAM\nDQ\nGAD7:0\nALE\nA15:8\nRD\nWRAVR\n\n31\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-3. External Data Memory Cycles without Wait-state (SR Wn1=0 and SR Wn0=0)(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector). The ALE pulse in period T4  is only present if the next instruction \naccesses the RAM (internal or external).\nFigure 9-4. External Data Memory Cycles with SR Wn1 = 0 and SR Wn0 = 1(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector).\nThe ALE pulse in period T5 is only present if the next instruction accesses the RAM (internal \nor external).ALET1 T2 T3\nWrite\nReadWRT4\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)\nXXXXX XXXXXXXX\nALET1 T2 T3\nWrite\nReadWRT5\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4\n\n32\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-5. External Data Memory Cycles with SR Wn1 = 1 and SR Wn0 = 0(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or\nSRW00 (lower sector).\nThe ALE pulse in period T6 is only present if the next instruction accesses the RAM (internal\nor external).\nFigure 9-6. External Data Memory Cycles with SR Wn1 = 1 and SR Wn0 = 1(1)\nNote: 1. SR Wn1 = SR W11 (upper sector) or SR W01 (lower sector), SR Wn0 = SR W10 (upper sector) or \nSRW00 (lower sector).\nThe ALE pulse in period T7 is only present if the next instruction accesses the RAM (internal \nor external).\n9.1.5 Using all Locations of External Memory Smaller than 64Kbytes\nSince the external memory is mapped after the internal memory as shown in Figure 9-1 on page\n28, the external memory is not addressed when addressing the first 8,704 bytes of data space. It\nmay appear that the first 8,704 bytes of the external memory are inaccessible (external memory\naddresses 0x0000 to 0x21FF). However, when connecting an external memory smaller than64Kbytes, for example 32Kbytes, these locations are easily accessed simply by addressing from\naddress 0x8000 to 0xA1FF. Since the External Me mory Address bit A15 is not connected to the\nexternal memory, addresses 0x 8000 to 0xA1FF will ap pear as addresses 0x 0000 to 0x21FF for\nthe external memory. Addressing above address 0xA1FF is not recommended, since this will\naddress an external memory location that is al ready accessed by another (lower) address. ToALET1 T2 T3\nWrite\nReadWRT6\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4 T5\nALET1 T2 T3\nWrite\nReadWRT7\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data Prev. data Address\nData Prev. data Address DA7:0 (XMBK = 1)System Clock (CLKCPU)T4 T5 T6\n\n33\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe Application software, the external 32Kbytes memory w ill appear as one linear 32Kbytes\naddress space from 0x2200 to 0xA1FF. This is illustrated in Figure 9-7 .\nFigure 9-7. Address Map with 32Kbytes External Memory\n9.1.6 Using all 64Kbytes Locations of External Memory\nSince the External Memory is mapped af ter the Internal Memory as shown in Figure 9-1 on page\n28, only 56Kbytes of External Memory is avail able by default (address  space 0x0000 to 0x21FF\nis reserved for internal memory). However, it is possible to take advantage of the entire External\nMemory by masking the higher address bits to zero. This can be done by using the XMMn bitsand control by software the most significant bits of the address. By setting Port C to output 0x00,and releasing the most si gnificant bits for normal Port Pin operation, the Memory Interface will\naddress 0x0000 - 0x2FFF. See the following code examples.\nCare must be exercised using this option as most of the memory is masked away.0x0000\n0x21FF \n0x2200 \n0x7FFF \n0x8000 \n0x90FF \n0x9100 0x0000\n0x7FFF Internal MemoryAVR Memory Map External 32K SRAM\nExternal \nMemory\n\n34\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\n; OFFSET is defined to 0x4000 to ensure\n; external memory access; Configure Port C (address high byte) to\n; output 0x00 when the pins are released\n; for normal Port Pin operation\nldir16, 0xFF\noutDDRC, r16\nldir16, 0x00\noutPORTC, r16\n; release PC7:6ldir16, (1<<XMM1)\nstsXMCRB, r16\n; write 0xAA to address 0x0001 of external; memory\nldir16, 0xaa\nsts0x0001+OFFSET, r16\n; re-enable PC7:6 for external memory\nldir16, (0<<XMM1)\nstsXMCRB, r16\n; store 0x55 to address (OFFSET + 1) of\n; external memory\nldir16, 0x55\nsts0x0001+OFFSET, r16\nC Code Example(1)\n#define OFFSET 0x4000\nvoid XRAM_example( void)\n{\nunsigned char *p = (unsigned char *) (OFFSET + 1);\nDDRC = 0xFF;\nPORTC = 0x00;\nXMCRB = (1<<XMM1);\n*p = 0xaa;\nXMCRB = 0x00;*p = 0x55;\n}\n\n35\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n9.2 Register Description\n9.2.1 EEPROM registers\n9.2.1.1 EEARH and EEARL \u2013 The EEPROM Address Register\n\u0081 Bits 15:12 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 11:0 \u2013 EEAR8:0: EEPROM Address\nThe EEPROM Address Registers \u2013 EEARH and EEARL specify the EEPROM address in the\n4Kbytes EEPROM space. The EEPROM dat a bytes are addressed linearly between 0 and\n4096. The initial value of EEAR  is undefined. A proper valu e must be written before the\nEEPROM may be accessed.\n9.2.1.2 EEDR \u2013 The EEPROM Data Register\n\u0081 Bits 7:0 \u2013 EEDR7:0: EEPROM Data\nFor the EEPROM write operation, the EEDR Register contains the data to be written to the\nEEPROM in the address given by the EEAR Regi ster. For the EEPROM read operation, the\nEEDR contains the data read out from the EEPROM at the add ress given by EEAR.\n9.2.1.3 EECR \u2013 The EEPROM Control Register\n\u0081 Bits 7:6 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 5, 4 \u2013 EEPM1 and EEPM0: EEPROM Programming Mode Bits\nThe EEPROM Programming mode bit setting define s which programming acti on that will be trig-\ngered when writing EEPE. It is possible to program  data in one atomic operation (erase the old\nvalue and program the new value) or to split the Erase and Write operations in two different\noperations. The Programming times for the different modes are shown in Table 9-1 on page 36 .\nWhile EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be\nreset to 0b00 unless the EEPROM is busy programming.B i t 1 51 41 31 2 1 1 1 0 9 8\n0x22 (0x42) \u2013\u2013\u2013\u2013 E E A R 1 1 E E A R 1 0 E E A R 9 E E A R 8 E E A R H\n0x21 (0x41) EEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 EEARL\n7654 3 2 10\nRead/Wr i t e RRRR R / W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e0000X XXX\nXXXX X X XX\nB i t 765432100x20 (0x40) MSB LSB EEDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1F (0x3F) \u2013 \u2013 EEPM1 EEPM0 EERIE EEMPE EEPE EERE EECR\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 X X 0 0 X 0\n\n36\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 EERIE: EEPROM Ready Interrupt Enable\nWriting EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing\nEERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant inter-\nrupt when EEPE is cleared.\n\u0081 Bit 2 \u2013 EEMPE: EEPROM Master Programming Enable\nThe EEMPE bit determines whether setting EEPE to one causes the EEPROM to be written.\nWhen EEMPE is set, setting EEPE wit hin four clock cycles will writ e data to the EEPROM at the\nselected address If EEMPE is zero , setting EEPE will have no effect. When EEMPE has been\nwritten to one by software, ha rdware clears the bit to zero after four clock cycles. See the\ndescription of the EEPE bit fo r an EEPROM write procedure.\n\u0081 Bit 1 \u2013 EEPE: EEPROM Programming Enable\nThe EEPROM Write Enable Signal EEPE is the write strobe to the EEPROM. When address\nand data are correctly set up, the EEPE bit must be written to one to write the value into the\nEEPROM. The EEMPE bit must be written to one be fore a logical one is written to EEPE, other-\nwise no EEPROM write takes pl ace. The following pr ocedure should be followed when writing\nthe EEPROM (the order of steps  3 and 4 is not essential):\n1.Wait until EEPE becomes zero.\n2.Wait until SPMEN in SPMCSR becomes zero.\n3.Write new EEPROM address to EEAR (optional).\n4.Write new EEPROM data to EEDR (optional).\n5.Write a logical one to the EEMPE bit wh ile writing a zero to EEPE in EECR.\n6.Within four clock cycles after setting EEMPE, write a logical one to EEPE.\nThe EEPROM can not be programmed during a CPU write to the Flash memory. The software\nmust check that the Flash programming is co mpleted before initiating a new EEPROM write.\nStep 2 is only relevant if the software contai ns a Boot Loader allowing the CPU to program the\nFlash. If the Flash is never being updated by the CPU, step 2 can be omitted. See \u201cMemory Pro-\ngramming\u201d on page 335  for details about Boot programming.\nCaution:  An interrupt between step 5 and step 6 will  make the write cycle fail, since the\nEEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is\ninterrupting another EEPROM acce ss, the EEAR or EEDR Register  will be modified, causing the\ninterrupted EEPROM access to fail.  It is recommended to have the Global Interrupt Flag cleared\nduring all the steps to avoid these problems.\nWhen the write access time has elapsed, the EE PE bit is cleared by hardware. The user soft-\nware can poll this bit and wait for a zero before writing the next byte. When EEPE has been set,\nthe CPU is halted for two cycles before the next instruction is executed.Table 9-1. EEPROM Mode Bits\nEEPM1 EEPM0Programming \nTime Operation\n0 0 3.4ms Erase and Write in one operation (Atomic Operation)\n0 1 1.8ms Erase only\n1 0 1.8ms Write only\n1 1 \u2013 Reserved for future use\n\n37\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 EERE: EEPROM Read Enable\nThe EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct\naddress is set up in the EEAR Register, the EERE bit must be written to a logic one to trigger theEEPROM read. The EEPROM read access takes one  instruction, and th e requested data is\navailable immediately. When the EEPROM is read, the CPU is halted for four cycles before the\nnext instruction is executed.\nThe user should poll the EEPE bit before starting the read operation. If a write operation is in\nprogress, it is neither possi ble to read the EEPROM, nor to change the EEAR Register.\n9.3 General Purpose registers\n9.3.1 GPIOR2 \u2013 General Purpose I/O Register 2\n9.3.2 GPIOR1 \u2013 General Purpose I/O Register 1\n9.3.3 GPIOR0 \u2013 General Purpose I/O Register 0\n9.4 External Memory registers\n9.4.1 XMCRA \u2013 External Memory Control Register A\n\u0081 Bit 7 \u2013 SRE: External SRAM/XMEM Enable\nWriting SRE to one enables the External Memory  Interface.The pin functions AD7:0, A15:8,\nALE, WR, and RD  are activated as the alternate pin functions. The SRE bit overrides any pin\ndirection settings in the respective data direction registers. Writing SRE to zero, disables the\nExternal Memory Interface and the normal pin and data direction settings are used.\n\u0081 Bit 6:4 \u2013 SRL2:0: Wait-state Sector Limit\nIt is possible to configure different wait-states for different External Memory addresses. The\nexternal memory address space can be divided in two sectors that have separate wait-state bits.The SRL2, SRL1, and SRL0 bits select the split of the sectors, see Table 9-2 on page 38  andB i t 76543210\n0x2B (0x4B) MSB LSB GPIOR2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x2A (0x4A) MSB LSB GPIOR1\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1E (0x3E) MSB LSB GPIOR0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210\u201c(0x74)\u201d SRE SRL2 SRL1 SRL0 SRW11 SRW10 SRW01 SRW00 XMCRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n38\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 9-1 on page 28 . By default, the SRL2, SRL1, and SRL0 bits are set to zero and the entire\nexternal memory address space is treated as one sector. When the entire SRAM address space\nis configured as one sector, the wait-states are configured by the SR W11 and SR W10 bits.\n\u0081 Bit 3:2 \u2013 SRW11, SRW10: Wait-state Select Bits for Upper Sector\nThe SR W11 and SR W10 bits control the number of wait-states for the upper sector of the exter-\nnal memory address space, see Table 9-3 .\n\u0081 Bit 1:0 \u2013 SRW01, SRW00: Wait-state Select Bits for Lower Sector\nThe SR W01 and SR W00 bits control the number of wait-states for the lower sector of the exter-\nnal memory address space, see Table 9-3 .\nNote: 1. n = 0 or 1 (lower/upper sector).\nFor further details of the timing and wait-states of the External Memory Interface, see Figures \n9-3 through Figures 9-6  for how the setting of the SR W bits affects the timing.\n9.4.2 XMCRB \u2013 External Memory Control Register BTable 9-2. Sector limits with different settings of SRL2:0\nSRL2 SRL1 SRL0 Sector Limits\n00xLower sector = N/A\nUpper sector = 0x2200 - 0xFFFF\n010Lower sector = 0x2200 - 0x3FFF\nUpper sector = 0x4000 - 0xFFFF\n011Lower sector = 0x2200 - 0x5FFF\nUpper sector = 0x6000 - 0xFFFF\n100Lower sector = 0x2200 - 0x7FFF\nUpper sector = 0x8000 - 0xFFFF\n101Lower sector = 0x2200 - 0x9FFF\nUpper sector = 0xA000 - 0xFFFF\n110Lower sector = 0x2200 - 0xBFFF\nUpper sector = 0xC000 - 0xFFFF\n111Lower sector = 0x2200 - 0xDFFF\nUpper sector = 0xE000 - 0xFFFF\nTable 9-3. Wait States(1)\nSRWn1 SRWn0 Wait States\n0 0 No wait-states\n01 Wait one cycle during read/write strobe\n10 Wait two cycles during read/write strobe\n11Wait two cycles during read/write and wait one cycle before driving out new \naddress\nB i t 765 4 3 210\n(0x75) XMBK \u2013 \u2013 \u2013 \u2013 XMM2 XMM1 XMM0 XMCRB\nRead/Write R/ W RR R R R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n39\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7\u2013 XMBK: External Memory Bus-keeper Enable\nWriting XMBK to one enables the bus keeper on the AD7:0 lines. When the bus keeper is\nenabled, AD7:0 will keep the last driven value on the lines even if the XMEM  interface has tri-\nstated the lines. Writing XMBK to zero disables the bus keeper. XMBK is not qualified with SRE,\nso even if the XMEM in terface is disabled, the bus keepers are still activated as long as XMBK is\none.\n\u0081 Bit 6:3 \u2013 Res: Reserved Bits\nThese bits are reserved and will always read as zero. When writing to this address location,\nwrite these bits to zero for compatibility with future devices.\n\u0081 Bit 2:0 \u2013 XMM2, XMM1, XMM0: External Memory High Mask\nWhen the External Memory is enabled, all Port C pi ns are default used for the high address byte.\nIf the full 60Kbytes address space is not required to access the External Memory, some, or all,Port C pins can be released for normal  Port Pin function as described in Table 9-4 . As described\nin \u201cUsing all 64Kbytes Locations of External Memory\u201d on page 33 , it is possible to use the XMMn\nbits to access all 64Kbytes locations of the External Memory.\nTable 9-4. Port C Pins Released as Normal Port Pi ns when the External Memory is Enabled\nXMM2 XMM1 XMM0 # Bits for External Memory Address Released Port Pins\n0 0 0 8 (Full 56Kbytes space) None001 7 P C 7\n010 6 P C 7  -  P C 6\n011 5 P C 7  -  P C 5100 4 P C 7  -  P C 4\n101 3 P C 7  -  P C 3\n110 2 P C 7  -  P C 21 1 1 No Address high bits Full Port C\n\n40\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10. System Clock and Clock Options\nThis section describes the clock options for the AVR microcontroller.\n10.1 Overview\nFigure 10-1  presents the principal clock systems in the AVR and their distribution. All of the\nclocks need not be active at a given time. In order to reduce power consumption, the clocks tomodules not being used can be halted by using different sleep modes, as described in \u201cPower\nManagement and Sleep Modes\u201d on page 52 . The clock systems are detailed below.\nFigure 10-1. Clock Distribution\n10.2 Clock Systems and their Distribution\n10.2.1 CPU Clock \u2013 clkCPU\nThe CPU clock is routed to parts of the system concerned with operation of the AVR core.\nExamples of such modules are the General Pur pose Register File, the Status Register and the\ndata memory holding the Stack Pointer. Halting the CPU clock inhibits the core from performinggeneral operations and calculations.General I/O\nModulesAsynchronous\nTimer/CounterCPU Core RAM\nclkI/O\nclkASYAVR Clock\nControl UnitclkCPUFlash and\nEEPROM\nclkFLASH\nSource clockWatchdog  Timer\nWatchdog\nOscillatorReset  Logic\nClock\nMultiplexerWatchdog clock\nCalibrated RC\nOscillatorTimer/Counter\nOscillatorCrystal\nOscillatorLow-frequency\nCrystal OscillatorExternal ClockADC\nclkADC\nSystem Clock\nPrescaler\n\n41\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.2.2 I/O Clock \u2013 clkI/O\nThe I/O clock is used by the majority of the I/O modules, like Timer/Counters, SPI, and USART.\nThe I/O clock is also used by the External Inte rrupt module, but note that some external inter-\nrupts are detected by asynchronous logic, allowing such interrupts to be detected even if the I/O\nclock is halted. Also note that start condition detection in the USI module is carried out asynchro-\nnously when clkI/O is halted, T WI address recognition in all sleep modes.\n10.2.3 Flash Clock \u2013 clkFLASH\nThe Flash clock controls operation of the Flash in terface. The Flash clock is usually active simul-\ntaneously with the CPU clock.\n10.2.4 Asynchronous Timer Clock \u2013 clkASY\nThe Asynchronous Timer clock al lows the Asynchronous Timer/C ounter to be clocked directly\nfrom an external clock or an external 32kHz clock crystal. The dedicated clock domain allows\nusing this Timer/Counter as a real-time counter even when the device is in sleep mode.\n10.2.5 ADC Clock \u2013 clkADC\nThe ADC is provided with a dedicated clock domain. This allows halting the CPU and I/O clocks\nin order to reduce noise generated by digital circuitry. This gives more accurate ADC conversion\nresults.\n10.3 Clock Sources\nThe device has the following clock source options, selectable by Flash Fuse bits as shown\nbelow. The clock from the selected source is input to the AVR clock generator, and routed to the\nappropriate modules.\nNote: 1. For all fuses \u201c1\u201d means unprogrammed while \u201c0\u201d means programmed.Table 10-1. Device Clocking Options Select(1)\nDevice Clocking Option  CKSEL3:0\nLow Power Crystal Oscillator 1111 - 1000\nFull Swing Crystal Oscillator 0111 - 0110\nLow Frequency Crystal Oscillator 0101 - 0100\nInternal 128kHz RC Oscillator 0011\nCalibrated Internal RC Oscillator 0010\nExternal Clock 0000\nReserved 0001\n\n42\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.3.1 Default Clock Source\nThe device is shipped with inte rnal RC oscillator at 8.0MHz a nd with the fuse CKDIV8 pro-\ngrammed, resulting in 1.0MHz system clock. Th e startup time is set to maximum and time-out\nperiod enabled. (CKSEL = \"0010\", SU T = \"10\", CKDIV8 = \"0\"). Th e default setti ng ensures that\nall users can make their desired clock source se tting using any available programming interface.\n10.3.2 Clock Start-up Sequence\nAny clock source needs a sufficient VCC to start oscillating and a minimum number of oscillating\ncycles before it can be considered stable.\nTo ensure sufficient VCC, the device issues an internal reset with a time-out delay (tTOUT) after\nthe device reset is released by all other reset sources. \u201cOn-chip Debug System\u201d on page 55\ndescribes the start conditions for the internal reset. The delay (tTOUT) is timed from the Watchdog\nOscillator and the number of cycles in the delay is set by the SUTx and CKSELx fuse bits. The\nselectable delays are shown in Table 10-2 . The frequency of the Watchdog Oscillator is voltage\ndependent as shown in \u201cTypical Characteristics\u201d on page 385 .\nMain purpose of the delay is to keep the AVR in reset until it is supplied with minimum VCC. The\ndelay will not monitor t he actual voltage and it w ill be required to select a delay longer than the\nVcc rise time. If this is not possible, an intern al or external Brown-Out Detection circuit should be\nused. A BOD circuit will ensure sufficient VCC before it releases the reset, and the time-out delay\ncan be disabled. Disabling the time-out delay wi thout utilizing a Brown-Out Detection circuit is\nnot recommended.\nThe oscillator is required to oscillate for a minimu m number of cycles befo re the clock is consid-\nered stable. An inte rnal ripple counter monito rs the oscillator output cl ock, and keep s the internal\nreset active for a given number of clock cycl es. The reset is then released and the device will\nstart to execute. The recommend ed oscillator start-up time is  dependent on the clock type, and\nvaries from 6 cycles for an externally applied clock to 32K cycles for a low frequency crystal.\nThe start-up sequence for the clock includes both the time-out delay and the start-up time when\nthe device starts up from reset. When starting up from Power-save or Power-down mode, VCC is\nassumed to be at a sufficient level and only the start-up time is included.\n10.4 Low Power Crystal Oscillator\nPins XTAL1 and XTAL2 are input and output, respec tively, of an invertin g amplifier which can be\nconfigured for use as an On-c hip Oscillator, as shown in Figure 10-2 . Either a quartz crystal or a\nceramic resonator may be used.\nThis Crystal Oscillator is a low power oscillator, with reduced voltage swing on the XTAL2 out-\nput. It gives the lowest power consumption, but is not capable of driving other clock inputs, andmay be more susceptible to noise in noisy environments. In these cases, refer to the \u201cFull Swing\nCrystal Oscillator\u201d on page 44 .Table 10-2. Number of Watchdog Oscillator Cycles\nTyp Time-out (VCC = 5.0V) Typ Time-out (VCC = 3.0V) Number of Cycles\n0ms 0ms 0\n4.1ms 4.3ms 512\n65ms 69ms 8K (8,192)\n\n43\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nC1 and C2 should always be equal for both crystals and resonators. The optimal value of the\ncapacitors depends on the crystal or resonator in use, the amount of stray capacitance, and the\nelectromagnetic noise of the environment. Some initial guidelines for choosing capacitors for\nuse with crystals are given in Table 10-3 . For ceramic resonators, the capacitor values given by\nthe manufacturer should be used.\nFigure 10-2. Crystal Oscillator Connections\nThe Low Power Oscillator c an operate in three diff erent modes, each optimi zed for a specific fre-\nquency range. The operating mode is select ed by the fuses CKSEL3:1 as shown in Table 10-3 .\nNotes: 1. This is the recommended CKSEL settings for the different frequency ranges.\n2. This option should not be used with crystals, only with ceramic resonators.\n3. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8. It must be ensured \nthat the resulting divided clock meets th e frequency specification of the device.\n4. Maximum frequency when using ceramic oscillator is 10MHz.\nThe CKSEL0 Fuse together with the SUT1:0 Fuses select the start-up times as shown in Table\n10-4.Table 10-3. Low Power Crystal Osc illator Operating Modes(3)\n Frequency Range (MHz) CKSEL3:1(1)Recommended Range for Capacitors C1 and C2 (pF)\n0.4 - 0.9 100(2)\u2013\n0.9 - 3.0 101 12 - 22\n3.0 - 8.0 110 12 - 22\n8.0 - 16.0(4)111 12 - 22\nTable 10-4. Start-up Times for the Low Power Cr ystal Oscillator Clock Selection\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nCeramic resonator, fast \nrising power258 CK 14CK + 4.1ms(1)00 0\nCeramic resonator, slowly \nrising power258 CK 14CK + 65ms(1)00 1\nCeramic resonator, BOD \nenabled1K CK 14CK(2)01 0XTAL2\nXTAL1\nGNDC2\nC1\n\n44\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. These options should only be used when not operating close to the maximum frequency of the \ndevice, and only if frequency stability at start- up is not important for the application. These \noptions are not suitable for crystals.\n2. These options are intended for use with cerami c resonators and will ensure frequency stability \nat start-up. They can also be used with crystal s when not operating close to the maximum fre-\nquency of the device, and if frequency stability at  start-up is not important for the application.\n10.5 Full Swing Crystal Oscillator\nPins XTAL1 and XTAL2 are input and output, respec tively, of an invertin g amplifier which can be\nconfigured for use as an On-chip Oscillator, as shown in Figure 10-2 on page 43 . Either a quartz\ncrystal or a ceramic resonator may be used.\nThis Crystal Oscillator is a full s wing oscillator, wit h rail-to-rail swing on th e XTAL2 output. This is\nuseful for driving other clock inputs and in noisy environments. The current consumption ishigher than the \u201cLow Power Crystal Os cillator\u201d on page 42 . Note that the Full Swing Crystal\nOscillator will only operate for V\nCC = 2.7 - 5.5 volts.\nC1 and C2 should always be equal for both crystals and resonators. The optimal value of the\ncapacitors depends on the crystal or resonator in use, the amount of stray capacitance, and theelectromagnetic noise of the environment. Some initial guidelines for choosing capacitors for\nuse with crystals are given in Table 10-6 on page 45 . For ceramic resonato rs, the capacitor val-\nues given by the manufacturer should be used.\nThe operating mode is selected by the fuses CKSEL3:1 as shown in Table 10-5 .\nNote: 1. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8. It must be ensured \nthat the resulting divided clock meets th e frequency specification of the device.Ceramic resonator, fast \nrising power1K CK 14CK + 4.1ms(2)01 1\nCeramic resonator, slowly \nrising power1K CK 14CK + 65ms(2)10 0\nCrystal Oscillator, BOD \nenabled16K CK 14CK101\nCrystal Oscillator, fast \nrising power16K CK 14CK + 4.1ms110\nCrystal Oscillator, slowly \nrising power16K CK 14CK + 65ms111Table 10-4. Start-up Times for the Low Power Crysta l Oscillator Clock Se lection (Continued)\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nTable 10-5. Full Swing Crystal Osc illator operating modes(1)\nFrequency Range (MHz) CKSEL3:1 Recommended Range for Capacitors C1 and C2 (pF)\n0.4 - 16 011 12 - 22\n\n45\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. These options should only be used when not operating close to the maximum frequency of the \ndevice, and only if frequency stability at start- up is not important for the application. These \noptions are not suitable for crystals.\n2. These options are intended for use with cerami c resonators and will ensure frequency stability \nat start-up. They can also be used with crystal s when not operating close to the maximum fre-\nquency of the device, and if frequency stability at  start-up is not important for the application.\n10.6 Low Frequency Crystal Oscillator\nThe device can utilize a 32.768kHz watch crystal as clock source by a dedicated Low Frequency\nCrystal Oscillator.  The crystal should be connected as shown in Figure 10-2 on page 43 . When\nthis Oscillator is selected, start-up times are determined by  the SUT Fuses and CKSEL0 as\nshown in Table 10-8 on page 46 .\nThe Low-Frequency Crystal Oscillator provi des an internal load capacitance, see Table 10-7  at\neach XTAL/TOSC pin.Table 10-6. Start-up Times for the Full Swing Crystal Oscillator Clock Selection\nOscillator Source / \nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nCeramic resonator, fast \nrising power258 CK 14CK + 4.1ms(1)00 0\nCeramic resonator, slowly \nrising power258 CK 14CK + 65ms(1)00 1\nCeramic resonator, BOD \nenabled1K CK 14CK(2)01 0\nCeramic resonator, fast \nrising power1K CK 14CK + 4.1ms(2)01 1\nCeramic resonator, slowly \nrising power1K CK 14CK + 65ms(2)10 0\nCrystal Oscillator, BOD \nenabled16K CK 14CK 1 01\nCrystal Oscillator, fast \nrising power16K CK 14CK + 4.1ms 1 10\nCrystal Oscillator, slowly \nrising power16K CK 14CK + 65ms 1 11\nTable 10-7. Capacitance for Low Frequency Oscillator\nDevice 32kHz oscillator Cap (Xtal1/Tosc1) Cap (Xtal2/Tosc2)\nATmega640/1280/1281/2560/2561 System Osc. 18 pF 8pF\nTimer Osc. 6 pF 6pF\n\n46\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe capacitance (Ce + Ci) needed at each XTAL/TOSC pin can be calculated by using:\nwhere:\nCe - is optional external capacitors as described in Figure 10-2 on page 43 .\nCi - is is the pin capacitance in Table 10-7 on page 45 .\nCL - is the load capacitance for a 32.768kHz crystal specified by the crystal vendor.C\nS - is the total stray capacitance for one XTAL/TOSC pin.\nCrystals specifying load capacitance (CL)  higher than the ones given in the Table 10-7 on page\n45, require external capacitors applied as described in Figure 10-2 on page 43 .\nFigure 10-3. Crystal Oscillator Connections\nTo find suitable load capacitance for a 32.768kHz crysal, please consult the crystal datasheet.\nWhen this oscillator is selected, start-up ti mes are determined by the SUT Fuses and CKSEL0\nas shown in Table 10-8 .\nNote: 1. These options should only be used if frequen cy stability at start-up is not important for the \napplication.\n10.7 Calibrated Internal RC Oscillator\nBy default, the Internal RC Osc illator provides an a pproximate 8MHz clock. Though voltage and\ntemperature dependent, this clock can be very accurately calibrated by the user. See Table 31-1\non page 371  and \u201cInternal Oscillator Sp eed\u201d on page 404  for more details. The device is shipped\nwith the CKDIV8 Fuse programmed. See \u201cSystem Clock Presca ler\u201d on page 49  for more details.Table 10-8. Start-up Times for the Lo w Frequency Crystal Oscillator Clock Selection\nPower ConditionsStart-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset \n(VCC = 5.0V) CKSEL0 SUT1:0\nBOD enabled 1K CK 14CK(1)00 0\nFast rising power 1K CK 14CK + 4.1ms(1)00 1\nSlowly rising power 1K CK 14CK + 65ms(1)01 0\nReserved 0 11\nBOD enabled 32K CK 14CK 1 00\nFast rising power 32K CK 14CK + 4.1ms 1 01\nSlowly rising power 32K CK 14CK + 65ms 1 10\nReserved 1 11Ce Ci+ 2CL\u22c5 Cs\u2013 =\n\n47\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThis clock may be selected as  the system clock by programming the CKSEL Fuses as shown in\nTable 10-9 . If selected, it will operate with no external  components. During re set, hardware loads\nthe pre-programmed calibration value into the OSCCAL Register and thereby automatically  cal-\nibrates the RC Oscillator. The accuracy of this  calibration is shown as Factory calibration in\nTable 31-1 on page 371 .\nBy changing the OSCCAL register from S W, see \u201cOSCCAL \u2013 Oscillator Ca libration Register\u201d on\npage 50 , it is possible to get a higher calibration accuracy than by using the factory calibration.\nThe accuracy of this calibration is  shown as User calibration in Table 31-1 on page 371 .\nWhen this Oscillator is used as the chip clock, the Watchdog Oscillator will still be used for the\nWatchdog Timer and for the Reset Time-out. For more information on the pre-programmed cali-\nbration value, see the section \u201cCalibration Byte\u201d on page 338 .\nNotes: 1. The device is shipped with this option selected.\n2. If 8MHz frequency exceeds the specification of the device (depends on VCC), the CKDIV8 \nFuse can be programmed in order to divide the internal frequency by 8.\nWhen this Oscillator is selected,  start-up times are determined by the SUT Fuses as shown in\nTable 10-10 .\nNote: 1. The device is shipped with this option selected.\n10.8 128 kHz Internal Oscillator\nThe 128kHz internal Oscillator is a low power Oscillator providing a clock of 128kHz. The fre-\nquency is nominal at 3V and 25 \u00b0C. This clock may be select as the system clock by\nprogramming the C KSEL Fuses to \u201c11\u201d as shown in Table 10-11 .\nNote: 1. Note that the 128kHz oscillator is a very low power clock source, and is not designed for high \naccuracy.Table 10-9. Internal Calibrated RC O scillator Operating Modes(1)(2)\nFrequency Range (MHz)  CKSEL3:0\n7.3 - 8.1 0010\nTable 10-10. Start-up times for the internal calib rated RC Oscillator clock selection\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset (VCC = 5.0V) SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4.1ms 01\nSlowly rising power 6CK 14CK + 65ms(1)10\nReserved 11\nTable 10-11. 128kHz Internal Osc illator Operating Modes(1)\nNominal Frequency  CKSEL3:0\n128kHz 0011\n\n48\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen this clock source is selected, start-up ti mes are determined by the SUT Fuses as shown in\nTable 10-12 .\n10.9 External Clock\nTo drive the device from an external clock source, XTAL1 should be driven as shown in Figure\n10-4. To run the device on an external clock, the CKSEL Fuses must be programmed to \u201c0000\u201d.\nFigure 10-4. External Clock Drive Configuration\nWhen this clock source is selected, start-up ti mes are determined by the SUT Fuses as shown in\nTable 10-15 on page 51 .\nWhen applying an external clock, it is required to avoid sudden changes in the applied clock fre-\nquency to ensure stable operation of the MCU. A variation in frequency of more than 2% fromone clock cycle to the next can lead to unpredict able behavior. If changes of more than 2% is\nrequired, ensure that the MCU is kept in Reset during the changes.Table 10-12. Start-up Times for the 128k Hz Internal Oscillator\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4ms 01\nSlowly rising power 6CK 14CK + 64ms 10\nReserved 11\nTable 10-13. Crystal Oscillator Clock Frequency\nNominal Frequency  CKSEL3:0\n0 - 16MHz 0000\nTable 10-14. Start-up Times for the External Clock Selection\nPower ConditionsStart-up Time from Power-\ndown and Power-saveAdditional Delay from \nReset (VCC = 5.0V) SUT1:0\nBOD enabled 6CK 14CK 00\nFast rising power 6CK 14CK + 4.1ms 01\nSlowly rising power 6CK 14CK + 65ms 10\nReserved 11NC\nEXTERNAL\nCLOCK\nSIGNALXTAL2\nXTAL1\nGND\n\n49\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that the System Clock Prescaler can be used to implement run-time changes of the internal\nclock frequency while still ensuring stable operation. Refer to \u201cSystem Clock Prescaler\u201d  for\ndetails.\n10.10 Clock Output Buffer\nThe device can output the system clock on t he CLKO pin. To enable the output, the CKOUT\nFuse has to be programmed. This mode is suitable when the chip clock is used to drive other cir-\ncuits on the system. The clock also will be output during reset, and the normal operation of I/O\npin will be overridden when the fu se is programmed. An y clock source, includi ng the internal RC\nOscillator, can be selected when the clock is out put on CLKO. If the System Clock Prescaler is\nused, it is the divided system clock that is output.\n10.11 Timer/Counter Oscillator\nThe device can operate its Timer/Counter2 from an  external 32.768kHz watch crystal or a exter-\nnal clock source. See Figure 10-2 on page 43  for crystal connection.\nApplying an external clock source to TOSC1 r equires EXCLK in the ASSR Register written to\nlogic one. See \u201cAsynchronous Operation of Timer/Counter2\u201d on page 184  for further description\non selecting external clock as input instead of a 32kHz crystal.\n10.12 System Clock Prescaler\nThe ATmega640/1280/1281/2560/2561 has a system clock prescaler, and the system clock canbe divided by setting the \u201cCLKPR \u2013 Clock Prescale Register\u201d on page 50 . This feature can be\nused to decrease the system clock frequency and the power consumption when the requirement\nfor processing power is low. This  can be used with all clock sour ce options, and it will affect the\nclock frequency of the CPU and all synchronous peripherals. clk\nI/O, clkADC, clkCPU, and clkFLASH\nare divided by a factor as shown in Table 10-15 on page 51 .\nWhen switching between prescaler settings, the System Clock Prescaler ensures that no\nglitches occurs in the clock system. It also ensures that no intermediate frequency is higher thanneither the clock frequency corresponding to the previous setting, nor the clock frequency corre-\nsponding to the new setting.\nThe ripple counter that implements the prescaler runs at the frequency of the undivided clock,\nwhich may be faster than the CPU's clock frequency.  Hence, it is not possible to determine the\nstate of the prescaler - even if it were readable, and the exact time it takes to switch from one\nclock division to the other cann ot be exactly predicted. From th e time the CLKPS values are writ-\nten, it takes between T1 + T2 and T1 + 2 \u00d7 T2 before the new clock frequency is active. In thisinterval, 2 active clock edges are produced. Here, T1 is the previous clock period, and T2 is the\nperiod corresponding to the new prescaler setting.\nTo avoid unintentional changes of clock frequency, a special write procedure must be followed\nto change the CLKPS bits:\nWrite the Clock Prescaler Change Enable (CLKPCE) bit to one and  all other bits in CLKPR to\nzero.\nWithin four cycles, write th e desired value to CLKPS while  writing a zero to CLKPCE.\nInterrupts must be disabled when changing prescaler setting to make sure the write procedure is\nnot interrupted.\n\n50\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.13 Register Description\n10.13.1 OSCCAL \u2013 Oscillato r Calibration Register\n\u0081 Bits 7:0 \u2013 CAL7:0: Oscillator Calibration Value\nThe Oscillator Calibration Register is used to trim the Calibrated Internal RC Oscillator to\nremove process variations from the oscillator frequency. A pre-programmed calibration value is\nautomatically written to this register during chip reset, giving the Factory calibrated frequency as\nspecified in Table 31-1 on page 371 . The application software can write this register to change\nthe oscillator frequency. The os cillator can be calibrated to frequencies as specified in Table 31-\n1 on page 371 . Calibration outside that range is not guaranteed.\nNote that this o scillator is used to time EEPROM and Flash write accesses , and these write\ntimes will be affected accordingly. If the EEPROM or Flash are writ ten, do not calibrate to more\nthan 8.8 MHz. Other wise, the EEPROM or Flash write may fail.\nThe CAL7 bit determines the range of operation for the oscillator. Setting this bit to 0 gives the\nlowest frequency range, setting this bit to 1 gives the highest frequency range. The two fre-\nquency ranges are overlapping, in other words a setting of OSCCAL = 0x7F gives a higher\nfrequency than OSCCAL = 0x80.\nThe CAL6..0 bits are used to tune the frequency within the selected range. A setting of 0x00\ngives the lowest frequency in that range, and a setting of 0x7F gives the highest frequency in the\nrange.\n10.13.2 CLKPR \u2013 Clock Prescale Register\n\u0081 Bit 7 \u2013 CLKPCE: Clock Prescaler Change Enable\nThe CLKPCE bit must be written to logic one to enab le change of the CLKPS bits. The CLKPCE\nbit is only updated when the other bits in CL KPR are simultaneously wr itten to zero. CLKPCE is\ncleared by hardware four cycles af ter it is written or when CLKPS bits are written. Rewriting the\nCLKPCE bit within this time-out period does neither extend the time-out period, nor clear the\nCLKPCE bit.\n\u0081 Bits 3:0 \u2013 CLKPS3:0: Clock Prescaler Select Bits 3 - 0\nThese bits define the division factor between the selected clock source and the internal system\nclock. These bits can be written run-time to vary the clock frequency to suit the application\nrequirements. As the divider divides the master clock input to the MCU, the speed of all synchro-\nnous peripherals is reduced when a division fact or is used. The division factors are given in\nTable 10-15 on page 51 .\nThe CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is unprogrammed,\nthe CLKPS bits will be reset to \u201c0000\u201d. If CKDIV8 is programmed, CLKPS bits are reset to\u201c0011\u201d, giving a division factor of 8 at start up. This feature should be used if the selected clockB i t 76543210\n(0x66) CAL7 CAL6 CAL5 CAL4 CAL3 CAL2 CAL1 CAL0 OSCCAL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value Device Spec ific Calibration Value\nB i t 76543210\n(0x61) CLKPCE \u2013 \u2013 \u2013 CLKPS3 CLKPS2 CLKPS1 CLKPS0 CLKPR\nRead/Write R/ W RRR R / W R/W R/W R/W\nInitial Value 0 0 0 0 See Bit Description\n\n51\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nsource has a higher frequency than the maximum frequency of the device at the present operat-\ning conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8\nFuse setting. The Application software must ensure  that a sufficient division factor is chosen if\nthe selected clock source has a higher frequency than the maximum frequency of the device atthe present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.\nTable 10-15. Clock Prescaler Select\nCLKPS3 CLKPS2 CLKPS1 CLKPS0 Clock Division Factor\n0000 1\n0001 2\n0010 40011 8\n0100 1 6\n0101 3 20110 6 4\n0111 1 2 8\n1000 2 5 61001 R e s e r v e d\n1010 R e s e r v e d\n1011 R e s e r v e d1100 R e s e r v e d\n1101 R e s e r v e d\n1110 R e s e r v e d1111 R e s e r v e d\n\n52\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n11. Power Management and Sleep Modes\nSleep modes enable the application to shut down unused modules in the MCU, thereby saving\npower. The AVR provides various sleep modes allowing the user to tailor the power consump-\ntion to the application\u2019s requirements.\n11.1 Sleep Modes\nFigure 10-1 on page 40  presents the different clock systems in the\nATmega640/1280/1281/2560/2561, and their distribution. The figure is helpful in selecting an\nappropriate sleep mode. Table 11-1  shows the different sleep modes and their wake-up\nsources.\nNotes: 1. Only recommended with external crystal or resonator selected as clock source.\n2. If Timer/Counter2 is running in asynchronous mode.\n3. For INT7:4, only level interrupt.\nTo enter any of the sleep modes, the SE bit in \u201cSMCR \u2013 Sleep Mode Control Register\u201d on page\n56 must be written to logic one and a SLEEP instruction must be executed. The SM2, SM1, and\nSM0 bits in the SMCR Register select which sleep mode will be ac tivated by the SLEEP instruc-\ntion. See Table 11-2 on page 56  for a summary.\nIf an enabled interrupt occurs while the MCU is in a sleep mode, the MCU wakes up. The MCU\nis then halted for four cycles in addition to the st art-up time, executes the interrupt routine, and\nresumes execution from the instruction followi ng SLEEP. The contents of the Register File and\nSRAM are unaltered when the device wakes up from sleep. If a reset occurs during sleep mode,\nthe MCU wakes up and executes from the Reset Vector.\n11.2 Idle Mode\nWhen the SM2:0 bits are written to 000, the SLEEP instruction makes the MCU enter Idle mode,\nstopping the CPU but allowing the SPI, USART, Analog Comparator, ADC, 2-wire Serial Inter-\nface, Timer/Counters, Watchdog, and the interrupt system to continue operating. This sleep\nmode basically halts clkCPU and clkFLASH , while allowing the ot her clocks to run.Table 11-1. Active Clock Domains and Wake-up Sources in the Different Sleep Modes.\nActive Clock Domains Oscillators Wake-up Sources\nSleep Mode\nclkCPU\nclkFLASH\nclkIO\nclkADC\nclkASY\nMain Clock\nSource \nEnabled\nTimer Osc \nEnabled\nINT7:0 and \nPin Change\nTWI Address \nMatch\nTimer2\nSPM/\nEEPROM Ready\nADC\nWDT Interrupt\nOther I/O\nIdle X X X X X(2)XXXXXXX\nADCNRM X X X X(2)X(3)XX(2)XXX\nPower-down X(3)XX\nPower-save X X(2)X(3)XX X\nStandby(1)XX(3)XX\nExtended Standby X(2)XX(2)X(3)XX X\n\n53\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIdle mode enables the MCU to wake up from external triggered interrupts as well as internal\nones like the Timer Overflow and USART Transmit Complete interrupts. If wake-up from the\nAnalog Comparator interrupt is not required, the Analog Comparator can be powered down by\nsetting the ACD bit in the Analog Comparator Control and Status Regist er \u2013 ACSR. This will\nreduce power consumption in Idle mode. If t he ADC is enabled, a conversion starts automati-\ncally when this mode is entered.\n11.3 ADC Noise Reduction Mode\nWhen the SM2:0 bits are written to 001, th e SLEEP instruction makes the MCU enter ADC\nNoise Reduction mode, stopping the CPU but allowi ng the ADC, the external interrupts, 2-wire\nSerial Interface address match, Timer/Counter2 and the Watchdog to continue operating (if\nenabled). This sleep mode basically halts clkI /O, clkCPU, and clkFLASH, while allowing the\nother clocks to run.\nThis improves the noise environment for the AD C, enabling higher resolution measurements. If\nthe ADC is enabled, a conversion starts automatically when this mode is entered. Apart form theADC Conversion Complete interru pt, only an External Reset, a Watchdog System Reset, a\nWatchdog interrupt, a Brown-out Reset, a 2-wire serial interface interrupt, a Timer/Counter2\ninterrupt, an SPM/EEPROM ready interrupt, an external level interrupt on INT7:4 or a pinchange interrupt can wakeup the MCU from ADC Noise Reduction mode.\n11.4 Power-down Mode\nWhen the SM2:0 bits are written to 010, the SLEEP instruction makes the MCU enter Power-\ndown mode. In this mode,  the external Osc illator is stopped, while the external interrupts, the 2-\nwire Serial Interface, and the Watchdog continue operating (if enabled). Only an External Reset,\na Watchdog Reset, a Brown-out Reset, 2-wire Serial Interface address match, an external level\ninterrupt on INT7:4, an external interrupt on INT3:0, or a pin change interrupt can wake up theMCU. This sleep mode basically halts all gener ated clocks, allowing operation of asynchronous\nmodules only.\nNote that if a level triggered interrupt is used for wake-up from Power-down mode, the changed\nlevel must be held for some time to wake up the MCU. Refer to \u201cExternal Interrupts\u201d on page 112\nfor details.\nWhen waking up from Power-down mode, there is a delay from the wake-up condition occurs\nuntil the wake-up becomes effective. This allows the clock to restart and become stable afterhaving been stopped. The wake-up period is defined by the same  CKSEL Fuses that define the\nReset Time-out period, as described in \u201cClock Sources\u201d on page 41 .\n11.5 Power-save Mode\nWhen the SM2:0 bits are written to 011, the SLEEP instruction makes the MCU enter Power-\nsave mode. This mode is identical to Power-down, with one exception:\nIf Timer/Counter2 is e nabled, it will keep running during sleep. The device can wake up from\neither Timer Overflow or Output Compare event from Timer/Counter2 if the correspondingTimer/Counter2 interrupt enable bits are set in  TIMSK2, and the Global Interrupt Enable bit in\nSREG is set. If Timer/Counter2 is not running, Power-down mode is recommended instead of\nPower-save mode.\nThe Timer/Counter2 can be clocked both synchronously and asynchronously in Power-save\nmode. If the Time r/Counter2 is not using t he asynchronous clock, the Timer/Counter Oscillator is\n\n54\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nstopped during sleep. If the Timer/Counter2 is not using the synchronous clock, the clock source\nis stopped during sleep. Note that even if the synchronous clock is running in Power-save, this\nclock is only available for the Timer/Counter2.\n11.6 Standby Mode\nWhen the SM2:0 bits are 110 and an external crystal/resonator clock option is selected, the\nSLEEP instruction makes the MCU enter Standby mode. This mode is identical to Power-down\nwith the exception that the Oscillator is kept running. Fr om Standby mode, the device wakes up\nin six clock cycles.\n11.7 Extended Standby Mode\nWhen the SM2:0 bits are 111 and an external crystal/resonator clock option is selected, the\nSLEEP instruction makes the M CU enter Extended Standby mode . This mode is identical to\nPower-save mode with th e exception that the Oscillator is kept running. From  Extended Standby\nmode, the device wakes up in six clock cycles.\n11.8 Power Reduction Register\nThe Power Reduction Register (PRR), see \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nand \u201cPRR1 \u2013 Power Reduction Register 1\u201d on page 57 , provides a method for stopping the clock\nto individual peripherals to reduce power consumption.\nNote that when the clock for a peripheral is stopped, then:\n\u0081 The current state of the peripheral is frozen\n\u0081 The associated registers can not be read or written\u0081 Resources used by the peripherals (for example I/O pin, etc.) will remain occupied\nThe peripheral should in most cases be disabled before stopping the clock. Waking up a mod-\nule, which is done by cleaning the bit in PRR, puts the module in the same state as before\nshutdown. Module shutdown can be used in Idle mode or Active mode to significantly reduce the\noverall power consumption. See \u201cPower-down Supply Current\u201d on page 392  for examples. In all\nother sleep modes, the clock is already stopped.\n11.9 Minimizing Power Consumption\nThere are several issues to consider when trying to minimize the power consumption in an AVR\ncontrolled system. In general, sleep modes should be used as much as possible, and the sleep\nmode should be selected so that as few as possi ble of the device\u2019s functions are operating. All\nfunctions not needed should be disabled. In particular, the following modules may need special\nconsideration when trying to achieve th e lowest possible power consumption.\n11.9.1 Analog to Digital Converter\nIf enabled, the ADC will be enabled in all sleep  modes. To save power, the ADC should be dis-\nabled before entering any sleep mode. When the ADC is turned off and on again, the next\nconversion will be an extended conversion. Refer to \u201cADC \u2013 Analog to Digital Converter\u201d on\npage 275  for details on ADC operation.\n11.9.2 Analog Comparator\nWhen entering Idle mode, the Analog Comparator should be disabled if not used. When entering\nADC Noise Reduction mode, the Analog Comparator  should be disabled. In other sleep modes,\nthe Analog Comparator is automatically disabled. However, if the Analog Comparator is set up\n\n55\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nto use the Internal Voltage Reference as input, the Analog Comparator should be disabled in all\nsleep modes. Otherwise, the Internal Voltage Reference will be enabled, independent of sleep\nmode. Refer to \u201cAC \u2013 Analog Comparator\u201d on page 271  for details on how to configure the Ana-\nlog Comparator.\n11.9.3 Brown-out Detector\nIf the Brown-out Detector is not needed by the application, this module should be turned off. If\nthe Brown-out Detector is enabled by the BO DLEVEL Fuses, it will be enabled in all sleep\nmodes, and hence, always co nsume power. In the deeper sleep modes, this w ill contribute sig-\nnificantly to the total current consumption. Refer to \u201cBrown-out Detect ion\u201d on page 61  for details\non how to configure the Brown-out Detector.\n11.9.4 Internal Voltage Reference\nThe Internal Voltage Referenc e will be enabled when needed by the Brown-out De tection, the\nAnalog Comparator or the ADC. If these modules are disabled as described in the sections\nabove, the internal voltage re ference will be disabled and it will not be consuming power. When\nturned on again, the user must allow the reference to start up before the output is used. If the\nreference is kept on in sleep mode, the output can be used immediately. Refer to \u201cInternal Volt-\nage Reference\u201d on page 62  for details on the start-up time.\n11.9.5 Watchdog Timer\nIf the Watchdog Timer is not needed in the application, the module should be turned off. If the\nWatchdog Timer is enabled, it will be enabled in all sleep modes, and hence, always consume\npower. In the deeper slee p modes, this will contribute signific antly to the total current consump-\ntion. Refer to \u201cInterrupts\u201d on page 105  for details on how to configure the Watchdog Timer.\n11.9.6 Port Pins\nWhen entering a sleep mode, all port pins should be configured to use minimum power. The\nmost important is then to ensure that no pins drive resistive loads. In sleep modes where both\nthe I/O clock (clkI/O) and the ADC clock (clkADC) are stopped, the input buf fers of the device will\nbe disabled. This ensures that no power is consumed by the input logic when not needed. Insome cases, the input logic is needed for detec ting wake-up conditions, and it will then be\nenabled. Refer to the section \u201cDigital Input Enable and Sleep Modes\u201d on page 74  for details on\nwhich pins are enabled. If the input buffer is enabl ed and the input signal is left floating or have\nan analog signal level close to V\nCC/2, the input buffer will use excessive power.\nFor analog input pins, the digital input buffer should be disabled at all times. An analog signal\nlevel close to VCC/2 on an input pin can cause significant current even in active mode. Digital\ninput buffers can be disabled by writing to the Digital Input Disable Registers (DIDR2, DIDR1and DIDR0). Refer to \u201cDIDR2 \u2013 Digital Input Disable Register 2\u201d on page 295 , \u201cDIDR1 \u2013 Digital\nInput Disable Register 1\u201d on page 274  and \u201cDIDR0 \u2013 Digital Input Disable Register 0\u201d on page\n295 for details.\n11.9.7 On-chip Debug System\nIf the On-chip debug system is enabled by the OCDEN Fuse and the chip enters sleep mode,\nthe main clock source is enabled, and hence , always consumes power. In the deeper sleep\nmodes, this will contribute significantly  to the total cu rrent consumption.\n\n56\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThere are three alte rnative ways to disable the OCD system:\n\u0081 Disable the OCDEN Fuse\n\u0081 Disable the JTAGEN Fuse\u0081Write one to the JTD bit in MCUCR\n11.10 Register Description\n11.10.1 SMCR \u2013 Sleep Mode Control Register\nThe Sleep Mode Control Register contains control bits for power management.\n\u0081 Bits 3, 2, 1 \u2013 SM2:0: Sleep Mode Select Bits 2, 1, and 0\nThese bits select between the five available sleep modes as shown in Table 11-2 .\nNote: 1. Standby modes are only recommended for use with external crystals or resonators.\n\u0081 Bit 1 \u2013 SE: Sleep Enable\nThe SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP\ninstruction is executed. To avoid the MCU enteri ng the sleep mode unless it is the programmer\u2019s\npurpose, it is recommended to write the Sleep Enable (SE) bit to one just before the execution of\nthe SLEEP instruction and to clear it immediately af ter waking up.\n11.10.2 PRR0 \u2013 Power Reduction Register 0\n\u0081 Bit 7 - PRTWI: Power Reduction TWI\nWriting a logic one to this bit shuts down the T WI by stopping the clock to the module. When\nwaking up the T WI again, the T WI should be re initialized to ensure proper operation.B i t 76543210\n0x33 (0x53) \u2013\u2013\u2013\u2013 S M 2 S M 1 S M 0 S E S M C R\nRead/Wr i t e RRRR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 11-2. Sleep Mode Select\nSM2 SM1 SM0 Sleep Mode\n000 I d l e\n0 0 1 ADC Noise Reduction010 P o w e r - d o w n\n011 P o w e r - s a v e\n100 R e s e r v e d101 R e s e r v e d\n1 1 0 Standby\n(1)\n1 1 1 Extended Standby(1)\nB i t 7 6 543 2 1 0\n(0x64) PRTWI PRTIM2 PRTIM0 \u2013 PRTIM1 PRSPI PRUSART0 PRADC PRR0\nRead/Write R/ W R/W R/W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n57\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 - PRTIM2: Power Reduction Timer/Counter2\nWriting a logic one to this bit shuts down the Timer/Counter2 module in synchronous mode (AS2\nis 0). When the Timer/Counter2 is en abled, operation will continue  like before the shutdown.\n\u0081 Bit 5 - PRTIM0: Power Reduction Timer/Counter0\nWriting a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 4 - Res: Reserved bit\nThis bit is reserved bit and will always read as zero.\n\u0081 Bit 3 - PRTIM1: Power Reduction Timer/Counter1\nWriting a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 2 - PRSPI: Power Reduction Serial Peripheral Interface\nWriting a logic one to this bit shuts down the Seri al Peripheral Interface by stopping the clock to\nthe module. When waking up the SPI again, the SPI should be re initialized to ensure proper\noperation.\n\u0081 Bit 1 - PRUSART0: Power Reduction USART0\nWriting a logic one to this bit shuts down the U SART0 by stopping the clock to the module.\nWhen waking up the USART0 again, the USART0 should be re initialized to ensure proper\noperation.\n\u0081 Bit 0 - PRADC: Power Reduction ADC\nWriting a logic one to this bit shuts down the ADC. The ADC must be disabled before shut down.\nThe analog comparator cannot use the ADC input MUX when the ADC is shut down.\n11.10.3 PRR1 \u2013 Power Reduction Register 1\n\u0081 Bit 7:6 - Res: Reserved bits\nThese bits are reserved and will always read as zero.\n\u0081 Bit 5 - PRTIM5: Power Reduction Timer/Counter5\nWriting a logic one to this bit shuts down the Timer/Counter5 module. When the Timer/Counter5\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 4 - PRTIM4: Power Reduction Timer/Counter4\nWriting a logic one to this bit shuts down the Timer/Counter4 module. When the Timer/Counter4\nis enabled, operation will cont inue like before the shutdown.\n\u0081 Bit 3 - PRTIM3: Power Reduction Timer/Counter3\nWriting a logic one to this bit shuts down the Timer/Counter3 module. When the Timer/Counter3\nis enabled, operation will cont inue like before the shutdown.B i t 7 6 543 2 1 0\n(0x65) \u2013 \u2013 PRTIM5 PRTIM4 PRTIM3 PRUSART3 PRUSART2 PRUSART1 PRR1\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n58\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 - PRUSART3: Power Reduction USART3\nWriting a logic one to this bit shuts down the U SART3 by stopping the clock to the module.\nWhen waking up the USART3 again, the USART3 should be re initialized to ensure proper\noperation.\n\u0081 Bit 1 - PRUSART2: Power Reduction USART2\nWriting a logic one to this bit shuts down the U SART2 by stopping the clock to the module.\nWhen waking up the USART2 again, the USART2 should be re initialized to ensure proper\noperation.\n\u0081 Bit 0 - PRUSART1: Power Reduction USART1\nWriting a logic one to this bit shuts down the U SART1 by stopping the clock to the module.\nWhen waking up the USART1 again, the USART1 should be re initialized to ensure proper\noperation.\n\n59\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n12. System Control and Reset\n12.1 Resetting the AVR\nDuring reset, all I/O Registers are set to their initial values, and the program starts execution\nfrom the Reset Vector. The instruction placed at the Reset Vector must be a JMP \u2013 AbsoluteJump \u2013 instruction to the reset handling routine. If the program never enables an interrupt\nsource, the Interrupt Vectors are not used, and regular program code can be placed at these\nlocations. This is also the case if the Reset Vector is in the App lication section while the Interrupt\nVectors are in the Boot section or vice versa. The circuit diagram in Figure 12-1 on page 60\nshows the reset logic. \u201cSystem and Reset Characte ristics\u201d on page 372  defines the electrical\nparameters of the reset circuitry.\nThe I/O ports of the AVR are immediately reset to their initial state when a reset source goes\nactive. This does not require any clock source to be running.\nAfter all reset sources have gone inactive, a delay counter is invoked, stretching the internal\nreset. This allows the power to reach a stable level before normal operation starts. The time-out\nperiod of the delay counter is defined by the user through the SUT and CKSEL Fuses. The dif-\nferent selections for the delay period are presented in \u201cClock Sources\u201d on page 41 .\n12.2 Reset Sources\nThe ATmega640/1280/1281/2560/2561 has five sources of reset:\n\u0081Power-on Reset . The MCU is reset when the supply voltage is below the Power-on Reset \nthreshold (VPOT)\n\u0081External Reset . The MCU is reset when a low level is present on the RESET  pin for longer \nthan the minimum pulse length\n\u0081Watchdog Reset . The MCU is reset when the Watchdog Timer period expires and the \nWatchdog is enabled\n\u0081Brown-out Reset . The MCU is reset when  the supply voltage VCC is below the Brown-out \nReset threshold (VBOT) and the Brown-out Detector is enabled\n\u0081JTAG AVR Reset . The MCU is reset as long as there is a logic one in the Reset Register, \none of the scan chains of the JTAG system. Refer to the section \u201cIEEE 1149.1 (JTAG) \nBoundary-scan\u201d on page 302  for details\n\n60\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-1. Reset Logic\n12.2.1 Power-on Reset\nA Power-on Reset (POR) pulse is generated by an On-chip detection circuit. The detection level\nis defined in \u201cSystem and Reset Characteristics\u201d on page 372 . The POR is activated whenever\nVCC is below the detection level. The POR circuit can be used to trigger the start-up Reset, as\nwell as to detect a fa ilure in supply voltage.\nA Power-on Reset (POR) circuit ensures that the device is reset from Power-on. Reaching the\nPower-on Reset threshold voltage invokes the delay counter, which determines how long the\ndevice is kept in RESET after VCC rise. The RESET signal is acti vated again, without any delay,\nwhen VCC decreases below the detection level.\nFigure 12-2. MCU Start-up, RESET  Tied to VCCMCU Status\nRegister (MCU SR)\nBrown-out\nReset CircuitBODLEVEL [2..0]\nDelay Counters\nCKSEL[3:0]CK\nTIMEOUTWDRFBORF\nEXTRFPORFDATA BU S\nClock\nGeneratorSPIKE\nFILTERPull-up Resistor\nJTRF\nJTAG Reset\nRegister\nWatchdog\nOscillator\nSUT[1:0]Power-on Reset\nCircuit\nV\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTCC\n\n61\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-3. MCU Start-up, RESET  Extended Externally\n12.2.2 External Reset\nAn External Reset is generated by a low level on the RESET  pin. Reset pulses longer than the\nminimum pulse width (see \u201cSystem and Reset Characteristics\u201d on page 372 ) will generate a\nreset, even if the clock is not running. Shorter pulses are not guaranteed to generate a reset.\nWhen the applied signal reaches the Reset Threshold Voltage \u2013 VRST \u2013 on its positive edge, the\ndelay counter starts the MCU after the Time-out period \u2013 tTOUT \u2013 has expired.\nFigure 12-4. External Reset During Operation\n12.2.3 Brown-out Detection\nATmega640/1280/1281/2560/2561 has an On-chip Brown-out Detection (BOD) circuit for moni-\ntoring the VCC level during operation by comparing it to a fixed trigger level. The trigger level for\nthe BOD can be selected by the BODLEVEL Fu ses. The trigger level ha s a hysteresis to ensure\nspike free Brown-out Detection. The hysteresis on the detection level should be interpreted as\nVBOT+ = VBOT + VHYST/2 and VBOT- = VBOT - VHYST/2.\nWhen the BOD is enabled, and VCC decreases to a value below the trigger level (VBOT- in Figure\n12-5 on page 62 ), the Brown-out Reset is immediately activated. When VCC increases above the\ntrigger level (VBOT+ in Figure 12-5 on page 62 ), the delay counter starts the MCU after the Time-\nout period tTOUT has expired.\nThe BOD circuit will only detect a drop in VCC if the voltage stays below the trigger level for lon-\nger than tBOD given in \u201cSystem and Reset Characteristics\u201d on page 372 .RESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTVCC\nCC\n\n62\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 12-5. Brown-out Reset During Operation\n12.2.4 Watchdog Reset\nWhen the Watchdog times out, it will gene rate a short reset pulse of  one CK cycle duration. On\nthe falling edge of this pulse, the delay timer starts counting the Time-out period tTOUT. See\n\u201cWatchdog Timer\u201d on page 55.  for details on operation of the Watchdog Timer.\nFigure 12-6. Watchdog Reset During Operation\n12.3 Internal Voltage Reference\nATmega640/1280/1281/2560/2561 features an internal bandgap reference. This reference is\nused for Brown-out Detection, and it can be used as an input to the Analog Comparator or theADC.\n12.3.1 Voltage Reference Enable Signals and Start-up Time\nThe voltage reference has a start-up time that may influence the way it should be used. The\nstart-up time is given in \u201cSystem and Reset Characteristics\u201d on page 372 . To save power, the\nreference is not always turned on. The reference is on during the following situations:\n1.When the BOD is enabled (by prog ramming the BODLEVEL [2:0] Fuse).\n2.When the bandgap reference is connected to the Analog Comparator (by setting the \nACBG bit in ACSR).\n3.When the ADC is enabled.\nThus, when the BOD is not enabled, after setting the ACBG bit or enabling the ADC, the user\nmust always allow the reference to start up before the output from the Analog Comparator orVCC\nRESET\nTIME-OUT\nINTERNAL\nRESETVBOT -VBOT+\ntTOUT\nCKCC\n\n63\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nADC is used. To reduce power consumption in Power-down mode, the user can avoid the three\nconditions above to ensure that the reference is turned off before entering Power-down mode.\n12.4 Watchdog Timer\n12.4.1 Features\n\u0081Clocked from separate On-chip Oscillator\n\u00813 Operating modes\n\u2013 Interrupt\n\u2013 System Reset\n\u2013 Interrupt and System Reset\n\u0081Selectable Time-out pe riod from 16ms to 8s\n\u0081Possible Hardware fuse Watchdog al ways on (WDTON) for fail-safe mode\nFigure 12-7. Watchdog Timer\n12.4.2 Overview\nATmega640/1280/1281/2560/2561 has an Enhanced Watchdog Timer ( WDT). The WDT is a\ntimer counting cycles of a separate on-chip 128kHz oscillator. The WDT gives an interrupt or a\nsystem reset when the counter reaches a given time -out value. In normal  operation mode, it is\nrequired that the system uses the WDR - Watchdog Timer Reset - instruction to restart the coun-\nter before the time-out value is reached. If the system doesn't restart the counter, an interrupt orsystem reset will be issued.\nIn Interrupt mode, the WDT gives an interrupt when the timer expires. This interrupt can be used\nto wake the device from sleep-modes, and also as a general system timer. One example is to\nlimit the maximum time allowed for certain operations, giving an interrupt when the operation\nhas run longer than expected. In System Reset mode, the WDT gives a reset when the timer\nexpires. This is typically used to prevent sys tem hang-up in case of runaway code. The third\nmode, Interrupt and System Reset mode, combines  the other two modes by first giving an inter-\nrupt and then switch to System Reset mode. This mode will for instance allow a safe shutdown\nby saving critical parameters before a system reset.\nThe Watchdog always on ( WDTON) fuse, if programmed, will force the Watchdog Timer to Sys-\ntem Reset mode. With the fuse programmed the System Reset mode bit ( WDE) and Interrupt\nmode bit ( WDIE) are locked to 1 and 0 respectively. To further ensure program security, altera-128 kHz\nOSCILLATOR\nOSC/2K\nOSC/4K\nOSC/8K\nOSC/16K\nOSC/32KOSC/64K\nOSC/128K\nOSC/256K\nOSC/512K\nOSC/1024K\nWDP0\nWDP1WDP2WDP3WATCHDOG\nRESET\nWDE\nWDIF\nWDIEMCU RESET\nINTERRUPT\n\n64\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ntions to the Watchdog set-up must follow timed sequences. The sequence for clearing WDE and\nchanging time-out configuration is as follows:\n1. In the same operation, write a logic one to the Watchdog change enable bit ( WDCE) and\nWDE. A logic one must be written to WDE regardless of the previous value of the WDE\nbit.\n2.Within the next four clock cycles, write the WDE and Watchdog prescaler bits ( WDP) as\ndesired, but with the WDCE bit cleared. This must be done in one operation.\nThe following code example shows one assembly and one C function for turning off the Watch-\ndog Timer. The example assumes that interrupt s are controlled (for example by disabling\ninterrupts globally) so that no interrupts will occur during the execution of these functions.\n\n65\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. The example code assumes that the pa rt specific header file is included.\n2. If the Watchdog is accidentally enabled, for exampl e by a runaway pointer or brown-out condi-\ntion, the device will be reset and the Watchdog Timer will stay enabled. If the code is not set up \nto handle the Watchdog, this might lead to an eternal lo op of time-out resets . To avoid this sit-\nuation, the application software should always clear the Watchdog System Reset Flag \n(WDRF) and the WDE control bit in the initialisation routine, even if the Watchdog is not in use.\nThe following code example shows one assembly and one C function for changing the time-out\nvalue of the Watchdog Timer.Assembly Code Example(1)\nWDT_off:\n; Turn off global interruptcli\n; Reset Watchdog Timer\nwdr\n; Clear WDRF in MCUSR\nin    r16, MCUSR\nandi  r16, (0xff & (0<<WDRF))\nout   MCUSR, r16\n; Write logical one to WDCE and WDE; Keep old prescaler setting to prevent unintentional time-out\nldi r16, WDTCSR\nori   r16, (1<<WDCE) | (1<<WDE)\nsts WDTCSR, r16\n; Turn off WDT\nldi   r16, (0<<WDE)\nsts WDTCSR, r16\n; Turn on global interrupt\nseiret\nC Code Example(1)\nvoid WDT_off(void){\n__disable_interrupt();\n__watchdog_reset();\n/* Clear WDRF in MCUSR */MCUSR &= ~(1<<WDRF);\n/* Write logical one to WDCE and WDE */\n/* Keep old prescaler setting to prevent unintentional time-out \n*/\nWDTCSR |= (1<<WDCE) | (1<<WDE);\n/* Turn off WDT */WDTCSR = 0x00;\n__enable_interrupt();\n}\n\n66\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. The example code assumes that the part specific header file is included.\n2. The Watchdog Timer should be reset before any change of the WDP bits, since a change in \nthe WDP bits can result in a time-out when switching to a shorter time-out period.Assembly Code Example(1)\nWDT_Prescaler_Change:\n; Turn off global interruptcli\n; Reset Watchdog Timer\nwdr\n; Start timed sequence\nin    r16, WDTCSR\nori   r16, (1<<WDCE) | (1<<WDE)\nout   WDTCSR, r16\n; --  Got four cycles to set the new values from here -; Set new prescaler(time-out) value = 64K cycles (~0.5 s)\nldi   r16, (1<<WDE) | (1<<WDP2) | (1<<WDP0)\nout   WDTCSR, r16\n; --  Finished setting new values, used 2 cycles -\n; Turn on global interrupt\nseiret\nC Code Example(2)\nvoid WDT_Prescaler_Change(void){\n__disable_interrupt();\n__watchdog_reset();\n/* Start timed  equence */WDTCSR |= (1<<WDCE) | (1<<WDE);\n/* Set new prescaler(time-out) value = 64K cycles (~0.5 s) */\nWDTCSR  = (1<<WDE) | (1<<WDP2) | (1<<WDP0);__enable_interrupt();\n}\n\n67\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n12.5 Register Description\n12.5.1 MCUSR \u2013 MCU Status Register\nThe MCU Status Register provides information on which reset source caused an MCU reset.\n\u0081 Bit 4 \u2013 JTRF: JTAG Reset Flag\nThis bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by\nthe JTAG instruction AVR_RESET. This bit is rese t by a Power-on Reset, or by writing a logic\nzero to the flag.\n\u0081 Bit 3 \u2013 WDRF: Watchdog Reset Flag\nThis bit is set if a Watchdog Reset occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 2 \u2013 BORF: Brown-out Reset Flag\nThis bit is set if a Brown-out Reset occurs. The bi t is reset by a Power-on  Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 1 \u2013 EXTRF: External Reset Flag\nThis bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 0 \u2013 PORF: Power-on Reset Flag\nThis bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag.\nTo make use of the Reset Flags to identify a reset condition, the user should read and then\nReset the MCUSR as early as possible in the program. If the register is cleared before another\nreset occurs, the source of the reset can be found by examining the Reset Flags.\n12.5.2 WDTCSR \u2013 Watchdog Timer Control Register\n\u0081 Bit 7 - WDIF: Watchdog Interrupt Flag\nThis bit is set when a time-out occurs in the Watchdog Timer and the Watchdog Timer is config-\nured for interrupt. WDIF is cleared by hardware when executing the corresponding interrupt\nhandling vector. Alternatively, WDIF is cleared by writing a logic one to the flag. When the I-bit in\nSREG and WDIE are set, the Watchdog Time-out Interrupt is executed.B i t 76543210\n0x35 (0x55) \u2013 \u2013 \u2013 JTRF WDRF BORF EXTRF PORF MCUSR\nRead/Write R R R R/ W R/W R/W R/W R/W\nInitial Value 0 0 0 See Bit Description\nB i t 76543210(0x60) WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 WDTCSR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 X 0 0 0\n\n68\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 - WDIE: Watchdog Interrupt Enable\nWhen this bit is written to one and the I-bit in the Status Register is set, the Watchdog Interrupt is\nenabled. If WDE is cleared in combination with this setting, the Watchdog Timer is in Interrupt\nMode, and the corresponding interrupt is executed if time-out in the Watchdog Timer occurs.\nIf WDE is set, the Watchdog Timer is in Interrupt and Syst em Reset Mode. The first time-out in\nthe Watchdog Timer will set WDIF. Executing the corresponding interr upt vector will clear WDIE\nand WDIF automatically by hardware (the Watchdog goes to System Reset Mode). This is use-\nful for keeping the Watchdog Timer security while using the interrupt. To stay in Interrupt and\nSystem Reset Mode, WDIE must be set after each interrupt. This should however not be done\nwithin the interrupt service routine itself, as this might compromise the safety-function of the\nWatchdog System Reset mode. If the interrupt is not executed before the next time-out, a Sys-\ntem Reset will be applied.\nNote: 1. WDTON Fuse set to \u201c0\u201c means programmed and \u201c1\u201d means unprogrammed.\n\u0081 Bit 4 - WDCE: Watchdog Change Enable\nThis bit is used in timed sequences for changing WDE and prescaler bits. To clear the WDE bit,\nand/or change the prescaler bits, WDCE must be set.\nOnce written to one,  hardware will clear WDCE after four clock cycles.\n\u0081 Bit 3 - WDE: Watchdog System Reset Enable\nWDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is\nset. To clear WDE, WDRF must be cleared first. This feature ensures multiple resets during con-\nditions causing failure, and a safe start-up after the failure.\n\u0081 Bit 5, 2:0 - WDP3:0: Watchdog Timer Prescaler 3, 2, 1 and 0\nThe WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is run-\nning. The different prescaling values and thei r corresponding time-out periods are shown in\nTable 12-2 on page 69 .Table 12-1. Watchdog Timer Configuration\nWDTON(1)WDE WDIE Mode Action on Time-out\n1 0 0 Stopped None\n1 0 1 Interrupt Mode Interrupt1 1 0 System Reset Mode Reset\n111Interrupt and System \nReset ModeInterrupt, then go to \nSystem Reset Mode\n0 x x System Reset Mode Reset\n\n69\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n.\nTable 12-2. Watchdog Timer Prescale Select\nWDP3 WDP2 WDP1 WDP0Number of WDT Oscillator \nCyclesTypical Time-out at \nVCC = 5.0V\n0 0 0 0 2K (2048) cycles 16ms\n0 0 0 1 4K (4096) cycles 32ms\n0 0 1 0 8K (8192) cycles 64ms0 0 1 1 16K (16384) cycles 0.125s\n0 1 0 0 32K (32768) cycles 0.25s\n0 1 0 1 64K (65536) cycles 0.5s0 1 1 0 128K (131072) cycles 1.0s\n0 1 1 1 256K (262144) cycles 2.0s\n1 0 0 0 512K (524288) cycles 4.0s1 0 0 1 1024K (1048576) cycles 8.0s\n1010\nReserved1011\n1100\n1101\n11101111\n\n70\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13. I/O-Ports\n13.1 Introduction\nAll AVR ports have true Read-Modify- Write functionality when used as general digital I/O ports.\nThis means that the direction of one port pin can be changed without unintentionally changing\nthe direction of any other pin with the SBI and CBI instructions. The same applies when chang-\ning drive value (if configured as output) or enabling/disabling of pull-up resistors (if configured as\ninput). Each output buffer has symmetrical drive characteristics with both high sink and sourcecapability. The pin driver is stro ng enough to drive LED displays directly. All port pins have indi-\nvidually selectable pull-up resistors with a suppl y-voltage invariant resistance. All I/O pins have\nprotection diodes to both V\nCC and Ground as indicated in Figure 13-1 . Refer to \u201cElectrical Char-\nacteristics\u201d on page 367  for a complete list of parameters.\nFigure 13-1. I/O Pin Equivalent Schematic\nAll registers and bit references in this section are written in general form. A lower case \u201cx\u201d repre-\nsents the numbering letter for the port, and a lower case \u201cn\u201d represents the bit number. However,when using the register or bit defines in a progr am, the precise form must be used. For example,\nPORTB3 for bit no. 3 in Port B, here documented generally as PORTxn. The physical I/O Regis-\nters and bit locations are listed in \u201cTable 13-34 and Table 13-35 relates the alternate functions of\nPort L to the overriding signals shown in Figure 13-5 on page 76.\u201d on page 99 .\nThree I/O memory address locations are allocated for each port, one each for the Data Register\n\u2013 PORTx, Data Direction Register \u2013 DDRx, and the Port Input Pins \u2013 PINx. The Port Input PinsI/O location is read only, while the Data Register and the Data Direction Register are read/write.\nHowever, writing a logic one to a bit in the PINx Register, will result in a toggle in the correspond-\ning bit in the Data Register. In addition, the Pu ll-up Disable \u2013 PUD bit in MCUCR disables the\npull-up function for all pins in all ports when set.\nUsing the I/O port as General Digital I/O is described in \u201cPorts as General Digital I/O\u201d on page\n71. Most port pins are multiplexed with alternate functions for the peripheral features on the\ndevice. How each alternate function interferes with the port pin is described in \u201cAlternate Port\nFunctions\u201d on page 75 . Refer to the individual module sectio ns for a full description of the alter-\nnate functions.CpinLogicRpu\nSee Figure\n\"General Digital I/O\" for\nDetailsPxn\n\n71\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that enabling the alternate function of some of the port pins does not affect the use of the\nother pins in the port as general digital I/O.\n13.2 Ports as Gener al Digital I/O\nThe ports are bi-directional I/O ports  with optional internal pull-ups. Figure 13-2  shows a func-\ntional description of one I/O-port pin, here generically called Pxn.\nFigure 13-2. General Digital I/O(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O,\nSLEEP , and PUD are common to all ports.\n13.2.1 Configuring the Pin\nEach port pin consists of three register bits: DDxn, PORTxn, and PINxn. As shown in \u201cTable 13-\n34 and Table 13-35 relates the alternate function s of Port L to the ov erriding signals shown in\nFigure 13-5 on page 76.\u201d on page 99 , the DDxn bits are accessed at the DDRx I/O address, the\nPORTxn bits at the PORTx I/O address, and the PINxn bits at the PINx I/O address.\nThe DDxn bit in the DDRx Register selects the direct ion of this pin. If DDxn is written logic one,\nPxn is configured as an output pin. If DDxn is written logic zero, Pxn is configured as an input\npin.\nIf PORTxn is written logic one when the pin is c onfigured as an input pin, the pull-up resistor is\nactivated. To switch the pull-up resistor off, PORTxn has to be written logic zero or the pin has to\nbe configured as an output pin. The port pins are tri-stated when reset condition becomes active,even if no clocks are running.clkRPxRRxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWRx: WRITE PORTx\nRRx: READ PORTx REGISTER\nRPx: READ PORTx PINPUD: PULLUP DISABLE\nclkI/O: I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQD\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/OWPx01\nWRx\nWPx: WRITE PINx REGISTER\n\n72\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf PORTxn is written logic one when the pin is conf igured as an output pin, the port pin is driven\nhigh (one). If PORTxn is written logic zero when the pin is configured as an output pin, the port\npin is driven low (zero).\n13.2.2 Toggling the Pin\nWriting a logic one to PINxn toggles the value of PORTxn, independent on the value of DDRxn.\nNote that the SBI instruction can be used to toggle one single bit in a port.\n13.2.3 Switching Between Input and Output\nWhen switching between tri-state ({DDxn, PORTxn} = 0b00) and output high ({DDxn, PORTxn}\n= 0b11), an intermediate state with either pull-up enabled {DDxn, PORTxn} = 0b01) or output\nlow ({DDxn, PORTxn} = 0b10) must occur. Norma lly, the pull-up enabled state is fully accept-\nable, as a high-impedant enviro nment will not notice the differenc e between a strong high driver\nand a pull-up. If this is not the case, the PUD bit in the MCUCR Register can be set to disable all\npull-ups in all ports.\nSwitching between input with pull-up and output low generates the same problem. The user\nmust use either the tri-state ({DDxn, PORTxn} = 0b00) or the output high state ({DDxn, PORTxn}\n= 0b11) as an intermediate step.\nTable 13-1  summarizes the control signals for the pin value.\n13.2.4 Reading the Pin Value\nIndependent of the setting of Data Direction bit DDxn, the port pin can be read through the\nPINxn Register bit. As shown in Figure 13-2 on page 71 , the PINxn Register bit and the preced-\ning latch constitute a synchronizer. This is needed to avoid metastability if the physical pinchanges value near the edge of the internal clock, but it also introduces a delay. Figure 13-3 on\npage 73  shows a timing diagram of the synchroni zation when reading an externally applied pin\nvalue. The maximum and minimum propagation delays are denoted t\npd,max  and tpd,min\nrespectively.Table 13-1. Port Pin ConfigurationsDDxn\nPORTxn\nPUD\n(in MCUCR) I/O Pull-up Comment\n0 0 X Input No Tri-state (Hi-Z)0 1 0 Input Y es Pxn will source current if ext. pulled low\n0 1 1 Input No Tri-state (Hi-Z)\n1 0 X Output No Output Low (Sink)1 1 X Output No Output High (Source)\n\n73\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 13-3. Synchronization when Reading an Externally Applied Pin value\nConsider the clock period starting shortly after the first falling edge of the system cl ock. The latch\nis closed when the clock is low, and goes transpa rent when the clock is high, as indicated by the\nshaded region of the \u201cSYNC LATCH\u201d signal. The signal value is latched when the system clock\ngoes low. It is clocked into the PINxn Register  at the succeeding positive clock edge. As indi-\ncated by the two arrows tpd,max and tpd,min, a single signal tr ansition on the pin will be delayed\nbetween \u00bd and 1\u00bd system clock period depending upon the time of assertion.\nWhen reading back a software assigned pin value, a nop instruction must be inserted as indi-\ncated in Figure 13-4 . The out instruction sets the \u201cSYNC LATCH\u201d signal at the positive edge of\nthe clock. In this case, the delay tpd through  the synchronizer is one system clock period.\nFigure 13-4. Synchronization when Reading a Software Assigned Pin ValueXXX in r17, PINx\n0x00 0xFFINSTRUCTION S\nSYNC LATCH\nPINxn\nr17XXXSYSTEM CLK\ntpd, max\ntpd, min\nout PORTx, r16 nop in r17, PINx0xFF\n0x00 0xFFSYSTEM CLK\nr16\nINSTRUCTIONS\nSYNC LATCH\nPINxn\nr17\ntpd\n\n74\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code example shows how to set por t B pins 0 and 1 high, pins 2 and 3 low, and\ndefine the port pins from 4 to 7 as input with pull-ups assigned to port pins 6 and 7. The resulting\npin values are read back again, but as previously discussed, a nop instruction is included to be\nable to read back the value recently assigned to some of the pins.\nNote: 1. For the assembly program, two temporary registers are used to minimize the time from pull-\nups are set on pins 0, 1, 6, and 7, until the di rection bits are correctly  set, defining bit 2 and 3\nas low and redefining bits 0 and 1 as strong high drivers.\n13.2.5 Digital Input Enable and Sleep Modes\nAs shown in Figure 13-2 on page 71 , the digital input signal can be clamped to ground at the\ninput of the schmitt-trigger. Th e signal denoted SLEEP in the fi gure, is set by the MCU Sleep\nController in Power-down mode, Power-save mode, and Standby mode to avoid high power\nconsumption if some input signals are left floating, or have an analog signal level close to VCC/2.\nSLEEP is overridden for port pins enabled as ex ternal interrupt pins. If the external interrupt\nrequest is not e nabled, SLEEP is active also  for these pins. SL EEP is also overri dden by various\nother alternate functions as described in \u201cAlternate Port Functions\u201d on page 75 .\nIf a logic high level (\u201cone\u201d) is present on an asynchronous external interrupt pin configured as\n\u201cInterrupt on Rising Edge, Falling Edge, or Any Logic Change on Pin\u201d while the external interrupt\nis not enabled, the corresponding External Interrupt Flag will be set when resuming from theAssembly Code Example(1)\n...\n; Define pull-ups and set outputs high\n; Define directions for port pins\nldir16,(1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0)\nldir17,(1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0)\noutPORTB,r16\noutDDRB,r17\n; Insert nop for synchronization\nnop; Read port pins\ninr16,PINB\n...\nC Code Example\nunsigned char i;\n...\n/* Define pull-ups and set outputs high */\n/* Define directions for port pins */\nPORTB = (1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0);\nDDRB = (1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0);/* Insert nop for synchronization */\n__no_operation();\n/* Read port pins */\ni = PINB;\n...\n\n75\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nabove mentioned Sleep mode, as the clamping in these sleep mode produces the requested\nlogic change.\n13.2.6 Unconnected Pins\nIf some pins are unused, it is recommended to ens ure that these pins have a defined level. Even\nthough most of the digital inputs are disabled in  the deep sleep modes as described above, float-\ning inputs should be avoided to reduce current consumption in all other modes where the digitalinputs are enabled (Reset, Active mode and Idle mode).\nThe simplest method to ensure a defined level of an unused pin, is to enable the internal pull-up.\nIn this case, the pull-up will be  disabled during reset. If low po wer consumption during reset is\nimportant, it is recommended to use an external pull-up or pull-down. Connecting unused pins\ndirectly to V\nCC or GND is not recommended, since this ma y cause excessive curr ents if the pin is\naccidentally configured as an output.\n13.3 Alternate Port Functions\nMost port pins have alternate functions in addition to being general digital I/Os. Figure 13-5 on\npage 76  shows how the port pin control signals from the simplified Figure 13-2 on page 71  can\nbe overridden by alternate functions . The overriding signals may not be present in all port pins,\nbut the figure serves as a generic description applicable to all port pins in the AVR microcon-\ntroller family.\n\n76\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 13-5. Alternate Port Functions(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O,\nSLEEP , and PUD are common to all ports. All other signals are unique for each pin.clkRPxRRxWRxRDxWDxPUD\nSYNCHRONIZER\nWDx:     WRITE DDRx\nWRx:     WRITE PORTxRRx:     READ PORTx REGISTER\nRPx:     READ PORTx PINPUD:     PULLUP DISABLE\nclkI/O:     I/O CLOCKRDx:     READ DDRxD\nLQ\nQSET\nCLR01\n0101\nDIxn\nAIOxnDIEOExnPVOVxnPVOExnDDOVxnDDOExnPUOExn\nPUOVxn\nPUOExn: Pxn PULL-UP OVERRIDE ENABLE\nPUOVxn: Pxn PULL-UP OVERRIDE VALUE\nDDOExn: Pxn DATA DIRECTION OVERRIDE ENABLE\nDDOVxn: Pxn DATA DIRECTION OVERRIDE VALUE\nPVOExn: Pxn PORT VALUE OVERRIDE ENABLE\nPVOVxn: Pxn PORT VALUE OVERRIDE VALUE\nDIxn:     DIGITAL INPUT PIN n ON PORTx\nAIOxn:     ANALOG INPUT/OUTPUT PIN n ON PORTxRESETRESETQQ D\nCLR\nQQ D\nCLR\nQQD\nCLRPINxnPORTxnDDxn\nDATA BUS\n01DIEOVxn\nSLEEP\nDIEOExn: Pxn DIGITAL INPUT -ENABLE OVERRIDE ENABLE\nDIEOVxn: Pxn DIGITAL INPUT -ENABLE OVERRIDE VALUESLEEP: SLEEP CONTROLPxn\nI/O01\nPTOExn\nPTOExn: Pxn, PORT TOGGLE OVERRIDE ENABLEWPx: WRITE PINxWPx\n\n77\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 13-2  summarizes the function of the overriding signals. The pin and port indexes from Fig-\nure 13-5 on page 76  are not shown in the succeeding tables. The overriding signals are\ngenerated internally in the modules having the alternate function.\nThe following subsections shortly describe the alternate functions for each port, and relate the\noverriding signals to the alternate function. Refer to the alternate function description for further\ndetails.Table 13-2. Generic Description of Overriding  Signals for Alternate Functions\nSignal Name Full Name Description\nPUOEPull-up Override \nEnableIf this signal is set, the pull-up enable is controlled by the PUOV \nsignal. If this signal is cleared, the pull-up is enabled when \n{DDxn, PORTxn, PUD} = 0b010. \nPUOVPull-up Override \nValueIf PUOE is set, the pull-up is enabled/disabled when PUOV is \nset/cleared, regardless of the setting of the DDxn, PORTxn, \nand PUD Register bits.\nDDOEData Direction \nOverride EnableIf this signal is set, the Output Driver Enable is controlled by the \nDDOV signal. If this signal is cleared, the Output driver is \nenabled by the DDxn Register bit.\nDDOVData Direction \nOverride ValueIf DDOE is set, the Output Driver is enabled/disabled when \nDDOV is set/cleared, regardle ss of the setting of the DDxn \nRegister bit.\nPVOEPort Value \nOverride EnableIf this signal is set and the Output Driver is enabled, the port \nvalue is controlled by the PVOV si gnal. If PVOE is cleared, and \nthe Output Driver is enabled, the port Value is controlled by the \nPORTxn Register bit.\nPVOVPort Value \nOverride ValueIf PVOE is set, the port value is  set to PVOV, regardless of the \nsetting of the PORTxn Register bit.\nPTOEPort Toggle \nOverride EnableIf PTOE is set, the PORTxn Register bit is inverted.\nDIEOEDigital Input \nEnable Override \nEnableIf this bit is set, the Digital Input Enable is controlled by the \nDIEOV signal. If this signal is cleared, the Digital Input Enable is \ndetermined by MCU state (Normal mode, sleep mode).\nDIEOVDigital Input \nEnable Override \nValueIf DIEOE is set, the Digital Input is enabled/disabled when \nDIEOV is set/cleared, regardl ess of the MCU state (Normal \nmode, sleep mode).\nDI Digital InputThis is the Digital Input to alternate functions. In the figure, the \nsignal is connected to the output of the schmitt trigger but \nbefore the synchronizer. Unless the Digital Input is used as a \nclock source, the module with the alternate function will use its \nown synchronizer.\nAIOAnalog \nInput/OutputThis is the Analog I nput/output to/from alte rnate functions. The \nsignal is connected directly to the pad, and can be used bi-\ndirectionally.\n\n78\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.1 Alternate Functions of Port A\nThe Port A has an alternate function as the address low byte and data lines for the External\nMemory Interface.\nTable 13-4  and Table 13-5 on page 79  relates the alternate functions of Port A to the overriding\nsignals shown in Figure 13-5 on page 76 .\nNote: 1. ADA is short for ADdress Active and r epresents the time when address is output. See \u201cExter-\nnal Memory Interface\u201d on page 28  for details.Table 13-3. Port A Pins Alternate Functions\nPort Pin Alternate Function\nPA7 AD7 (External memory interface address and data bit 7)\nPA6 AD6 (External memory interface address and data bit 6)\nPA5 AD5 (External memory interface address and data bit 5)\nPA4 AD4 (External memory interface address and data bit 4)PA3 AD3 (External memory interface address and data bit 3)\nPA2 AD2 (External memory interface address and data bit 2)\nPA1 AD1 (External memory interface address and data bit 1)PA0 AD0 (External memory interface address and data bit 0)\nTable 13-4. Overriding Signals for Alternate Functions in PA7:PA4\nSignal\nName PA7/AD7 PA6/AD6 PA5/AD5 PA4/AD4\nPUOE SRE SRE SRE SRE\nPUOV~(WR | ADA(1)) \u0081 \nPORTA7 \u0081 PUD~(WR | ADA) \u0081 \nPORTA6 \u0081 PUD~(WR | ADA) \u0081 \nPORTA5 \u0081 PUD~(WR | ADA) \u0081 \nPORTA4 \u0081 PUD\nDDOE SRE SRE SRE SRE\nDDOV WR | ADA WR | ADA WR | ADA WR | ADA\nPVOE SRE SRE SRE SRE\nPVOVA7 \u0081 ADA | D7 \nOUTPUT \u0081 WRA6 \u0081 ADA | D6 \nOUTPUT \u0081 WRA5 \u0081 ADA | D5 \nOUTPUT \u0081 WRA4 \u0081 ADA | D4 \nOUTPUT \u0081 WR\nD I E O E 0000\nD I E O V 0000\nDI D7 INPUT D6 INPUT D5 INPUT D4 INPUT\nA I O \u2013\u2013\u2013\u2013\n\n79\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.2 Alternate Functions of Port B\nThe Port B pins with alternate functions are shown in Table 13-6 .\nThe alternate pin configuration is as follows:\n\u0081 OC0A/OC1C/PCINT7, Bit 7\nOC0A, Output Compare Match A output: The PB7 pin can serve as an external output for the\nTimer/Counter0 Output Compare. The pin has to be configured as an output (DDB7 set \u201cone\u201d) to\nserve this function. The OC0A pin is also the output pin for the P WM mode timer function.\nOC1C, Output Compare Match C output: The PB7 pi n can serve as an external output for the\nTimer/Counter1 Output Compare C. The pin has to be configured as an output (DDB7 set (one))\nto serve this function. The OC1C pin is also the output pin for the P WM mode timer function.Table 13-5. Overriding Signals for Alternate Functions in PA3:PA0\nSignal \nName PA3/AD3 PA2/AD2 PA1/AD1 PA0/AD0\nPUOE SRE SRE SRE SRE\nPUOV~(WR | ADA) \u0081 \nPORTA3 \u0081 PUD~(WR | ADA) \u0081 \nPORTA2 \u0081 PUD~(WR | ADA) \u0081 \nPORTA1 \u0081 PUD~(WR | ADA) \u0081 \nPORTA0 \u0081 PUD\nDDOE SRE SRE SRE SRE\nDDOV WR | ADA WR | ADA WR | ADA WR | ADA\nPVOE SRE SRE SRE SRE\nPVOVA3 \u0081 ADA | D3 \nOUTPUT \u0081 WRA2\u0081 ADA | D2 \nOUTPUT \u0081 WRA1 \u0081 ADA | D1 \nOUTPUT \u0081 WRA0 \u0081 ADA | D0 \nOUTPUT \u0081 WR\nD I E O E 0000\nD I E O V 0000\nD I D 3  I N P U TD 2  I N P U TD 1  I N P U TD 0  I N P U T\nA I O \u2013\u2013\u2013\u2013\nTable 13-6. Port B Pins Alternate Functions\nPort Pin Alternate Functions\nPB7OC0A/OC1C/PCINT7 (Output Compare and P WM Output A for Timer/Counter0, Output \nCompare and P WM Output C for Timer/Counter1 or Pin Change Interrupt 7)\nPB6OC1B/PCINT6 (Output Compare and P WM Output B for Timer/Counter1 or Pin Change \nInterrupt 6)\nPB5OC1A/PCINT5 (Output Compare and P WM Output A for Timer/Counter1 or Pin Change \nInterrupt 5)\nPB4OC2A/PCINT4 (Output Compare and P WM Output A for Timer/Counter2 or Pin Change \nInterrupt 4)\nPB3 MISO/PCINT3 (SPI Bus Master Input/Sla ve Output or Pin Change Interrupt 3)\nPB2 MOSI/PCINT2 (SPI Bus Ma ster Output/Slave Input or Pin Change Interrupt 2)\nPB1 SCK/PCINT1 (SPI Bus Serial Clock or Pin Change Interrupt 1)\nPB0 SS /PCINT0 (SPI Slave Select input or Pin Change Interrupt 0)\n\n80\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nPCINT7, Pin Change Interrupt source 7: The PB7 pin can serve as an external interrupt source.\n\u0081 OC1B/PCINT6, Bit 6\nOC1B, Output Compare Match B output: The PB6 pin can serve as an external output for the\nTimer/Counter1 Output Compare B. The pin has to be configured as an output (DDB6 set (one))\nto serve this function. The OC1B pin is also the output pin for the P WM mode timer function.\nPCINT6, Pin Change Interrupt source 6: The PB6 pin can serve as an external interrupt source.\n\u0081 OC1A/PCINT5, Bit 5\nOC1A, Output Compare Match A output: The PB5 pin can serve as an external output for the\nTimer/Counter1 Output Compare A. The pin has to be configured as an output (DDB5 set (one))to serve this function. The OC1A pin is also the output pin for the P WM mode timer function.\nPCINT5, Pin Change Interrupt source 5: The PB5 pin can serve as an external interrupt source.\n\u0081 OC2A/PCINT4, Bit 4\nOC2A, Output Compare Match output: The PB4 pin can serve as an external output for the\nTimer/Counter2 Output Compare. The pin has to be configured as an output (DDB4 set (one)) toserve this function. The OC2A pin is also the output pin for the P WM mode timer function.\nPCINT4, Pin Change Interrupt source 4: The PB4 pin can serve as an external interrupt source.\n\u0081 MISO/PCINT3 \u2013 Port B, Bit 3\nMISO: Master Data input, Slave Data output pin for SPI channel. When the SPI is enabled as a\nmaster, this pin is configured as an in put regardless of the setting of DDB3. When the SPI is\nenabled as a slave, the data direction of this pin is controlled by DDB3. When the pin is forced to\nbe an input, the pull- up can still be controlled by the PORTB3 bit.\nPCINT3, Pin Change Interrupt source 3: The PB3 pin can serve as an external interrupt source.\n\u0081 MOSI/PCINT2 \u2013 Port B, Bit 2\nMOSI: SPI Master Data output, Slave Data input for SPI channel. When the SPI is enabled as a\nslave, this pin is configured as an input regardless of the setting of DDB2. When the SPI is\nenabled as a master, the data direction of this pin is controlled by DDB2. When the pin is forced\nto be an input, the pull-up can st ill be controlled by the PORTB2 bit.\nPCINT2, Pin Change Interrupt source 2: The PB2 pin can serve as an external interrupt source.\n\u0081 SCK/PCINT1 \u2013 Port B, Bit 1\nSCK: Master Clock output, Slave Clock input pin for SPI channel. When the SPI is enabled as a\nslave, this pin is configured as an input regardless of the setting of DDB1. When the SPI0 is\nenabled as a master, the data direction of this pin is controlled by DDB1. When the pin is forced\nto be an input, the pull-up can st ill be controlled by the PORTB1 bit.\nPCINT1, Pin Change Interrupt source 1: The PB1 pin can serve as an external interrupt source.\n\u0081S S\n/PCINT0 \u2013 Port B, Bit 0\nSS: Slave Port Select input. When the SPI is enabled as a slave,  this pin is configured as an\ninput regardless of the setting of DDB0. As a slav e, the SPI is activated when this pin is driven\nlow. When the SPI is enabled as a master, the data direct ion of this pin is controlled by DDB0.\nWhen the pin is forced to be an input, the pu ll-up can still be controlled by the PORTB0 bit.\n\n81\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 13-7  and Table 13-8  relate the alternate functions of Port B to the overriding signals\nshown in Figure 13-5 on page 76 . SPI MSTR INPUT and SPI SL AVE OUTPUT constitute the\nMISO signal, while MOSI is divided in to SPI MSTR OUTPUT and SPI SLAVE INPUT.\nPCINT0, Pin Change Interrupt source 0: The PB0 pin can serve as an external interrupt source.\n Table 13-7. Overriding Signals for Alternate Functions in PB7:PB4\nSignal \nName PB7/OC0A/OC1C PB6/OC1B PB5/OC1A PB4/OC2A\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nPVOE OC0/OC1C ENABLE OC1B EN ABLE OC1A ENABLE OC2A ENABLE\nPVOV OC0/OC1C OC1B OC1A OC2A\nDIEOE PCINT7 \u0081 PCIE0 PCINT6 \u0081 PCIE0 PCINT5 \u0081 PCIE0 PCINT4 \u0081 PCIE0\nDIEOV 1 1 1 1\nDI PCINT7 INPUT PCINT6 INPUT PCINT5 INPUT PCINT4 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-8. Overriding Signals for Alternate Functions in PB3:PB0\nSignal \nName PB3/MISO PB2/MO SI PB1/SCK PB0/SS\nPUOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR\nPUOV PORTB3 \u0081 PUD PORTB2 \u0081 PUD PORTB1 \u0081 PUD PORTB0 \u0081 PUD\nDDOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR\nDDOV 0 0 0 0\nPVOE SPE \u0081 MSTR SPE \u0081 MSTR SPE \u0081 MSTR 0\nPVOV SPI SLAVE OUTPUT SPI MSTR OUTPUT SCK OUTPUT 0\nDIEOE PCINT3 \u0081 PCIE0 PCI NT2 \u0081 PCIE0 PCINT1 \u0081 PCIE0 PCINT0 \u0081 PCIE0\nDIEOV 1 1 1 1\nDISPI MSTR INPUT\nPCINT3 INPUTSPI SLAVE INPUT\nPCINT2 INPUTSCK INPUT\nPCINT1 INPUTSPI SS\nPCINT0 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\n\n82\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.3 Alternate Functions of Port C\nThe Port C alternate function is as follows:\nTable 13-10  and Table 13-11 on page 83  relate the alternate functions of Port C to the overriding\nsignals shown in Figure 13-5 on page 76 .Table 13-9. Port C Pins Alternate Functions\nPort Pin Alternate Function\nPC7 A15 (External Memory interface address bit 15)\nPC6 A14 (External Memory interface address bit 14)\nPC5 A13 (External Memory interface address bit 13)PC4 A12 (External Memory interface address bit 12)\nPC3 A11 (External Memory interface address bit 11)\nPC2 A10 (External Memory interface address bit 10)PC1 A9 (External Memory interface address bit 9)\nPC0 A8 (External Memory interface address bit 8)\nTable 13-10. Overriding Signals for Alte rnate Functions in PC7:PC4\nSignal \nName PC7/A15 PC6/A14 PC5/A13 PC4/A12\nPUOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nPUOV 0 0 0 0\nDDOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nDDOV 1 1 1 1\nPVOE SRE \u0081 (XMM<1) SRE \u0081 (XMM<2) SRE \u0081 (XMM<3) SRE \u0081 (XMM<4)\nPVOV A15 A14 A13 A12\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nDI \u2013 \u2013 \u2013 \u2013\nAIO \u2013 \u2013 \u2013 \u2013\n\n83\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.4 Alternate Functions of Port D\nThe Port D pins with alternate functions are shown in Table 13-12 .\nThe alternate pin configuration is as follows:\n\u0081 T0 \u2013 Port D, Bit 7\nT0, Timer/Counter0 counter source.\n\u0081 T1 \u2013 Port D, Bit 6\nT1, Timer/Counter1 counter source.\n\u0081 XCK1 \u2013 Port D, Bit 5\nXCK1, USART1 External clock. Th e Data Direction Register (DDD5) controls whether the clock\nis output (DDD5 set) or input (DDD5 cleared).  The XCK1 pin is active only when the USART1\noperates in Synchronous mode.\n\u0081 ICP1 \u2013 Port D, Bit 4\nICP1 \u2013 Input Capture Pin 1: The PD4 pin can ac t as an input capture pin for Timer/Counter1.Table 13-11. Overriding Signals for Alte rnate Functions in PC3:PC0\nSignal \nName PC3/A11 PC2/A10 PC1/A9 PC0/A8\nPUOE SRE \u0081 (XMM<5) SRE \u0081 (XMM< 6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nP U O V 0000\nDDOE SRE \u0081 (XMM<5) SRE \u0081 (XMM<6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nDDOV 1 1 1 1\nPVOE SRE \u0081 (XMM<5) SRE \u0081 (XMM< 6) SRE \u0081 (XMM<7) SRE \u0081 (XMM<7)\nPVOV A11 A10 A9 A8\nD I E O E 0000\nD I E O V 0000\nD I \u2013\u2013\u2013\u2013\nA I O \u2013\u2013\u2013\u2013\nTable 13-12. Port D Pins Alternate Functions\nPort Pin Alternate Function\nPD7 T0 (Timer/Counter0 Clock Input)PD6 T1 (Timer/Counter1 Clock Input)\nPD5 XCK1 (USART1 External Clock Input/Output)\nPD4 ICP1 (Timer/Counter1 Input Capture Trigger)\nPD3 INT3/TXD1 (External Interrupt3 Input or USART1 Transmit Pin)\nPD2 INT2/RXD1 (External Interrupt2 Input or USART1 Receive Pin)\nPD1 INT1/SDA (External Interrupt1 Input or T WI Serial DAta)\nPD0 INT0/SCL (External Interrupt0 Input or T WI Serial CLock)\n\n84\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 INT3/TXD1 \u2013 Port D, Bit 3\nINT3, External Interrupt source 3: The PD3 pin c an serve as an external interrupt source to the\nMCU.\nTXD1, Transmit Data (Data output pin for the USART1). When the USART1 Transmitter is\nenabled, this pin is configured as an output regardless of the value of DDD3.\n\u0081 INT2/RXD1 \u2013 Port D, Bit 2\nINT2, External Interrupt source 2. The PD2 pin can serve as an External Interrupt source to the\nMCU.\nRXD1, Receive Data (Data input pin for the USART1). When the USART1 receiver is enabled\nthis pin is configured as an input regardless of the value of DDD2. When the USART forces this\npin to be an input, the pull-up can still be controlled by the PORTD2 bit.\n\u0081 INT1/SDA \u2013 Port D, Bit 1\nINT1, External Interrupt source 1. The PD1 pin c an serve as an external interrupt source to the\nMCU.\nSDA, 2-wire Serial Interface Data: When the T WEN bit in T WCR is set (one) to enable the 2-wire\nSerial Interface, pin PD1 is disconnected from t he port and becomes the Serial Data I/O pin for\nthe 2-wire Serial Interface. In this mode, ther e is a spike filter on the pin to suppress spikes\nshorter than 50ns on the input signal, and the pin is  driven by an open drain driver with slew-rate\nlimitation.\n\u0081I N T 0 / S C L  \u2013  P o r t  D ,  B i t  0\nINT0, External Interrupt source 0. The PD0 pin c an serve as an external interrupt source to the\nMCU.\nSCL, 2-wire Serial Interface Clock: When the T WEN bit in T WCR is set (one) to enable the 2-\nwire Serial Interface, pin PD0 is disconnect ed from the port and becomes the Serial Clock I/O\npin for the 2-wire Serial Interface. In this mode, there is a spike filter on the pin to suppress\nspikes shorter than 50ns on the input signal, and the pin is driven by an open drain driver with\nslew-rate limitation.\nTable 13-13 on page 85  and Table 13-14 on page 85  relates the alternate functions of Port D to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n85\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \nNote: 1. When enabled, the 2-wire Serial Interface enable s Slew-Rate controls on the output pins PD0 \nand PD1. This is not shown in this table. In addition, spike filters are connected between the \nAIO outputs shown in the port figure and the digital logic of the T WI module.Table 13-13. Overriding Signals for Alternate Functions PD7:PD4\nSignal Name PD7/T0 PD 6/T1 PD5/XCK1 PD4/ICP1\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 XCK1 OUTPUT ENABLE 0\nDDOV 0 0 1 0\nPVOE 0 0 XCK1 OUTPUT ENABLE 0\nPVOV 0 0 XCK1 OUTPUT 0\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nDI T0 INPUT T1 INPUT XCK1 INPUT ICP1 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-14. Overriding Signals for Alte rnate Functions in PD3:PD0(1)\nSignal Name PD3/INT3/T XD1 PD2/INT2/RXD1 PD1/INT1/SDA PD0/INT0/SCL\nPUOE TXEN1 RXEN1 T WEN T WEN\nPUOV 0 PORTD2 \u0081 PUD PORTD1 \u0081 PUD PORTD0 \u0081 PUD\nDDOE TXEN1 RXEN1 T WEN T WEN\nDDOV 1 0 SDA_OUT SCL_OUT\nPVOE TXEN1 0 T WEN T WEN\nPVOV TXD1 0 0 0\nDIEOE INT3 ENABLE INT2 EN ABLE INT1 ENABLE INT0 ENABLE\nDIEOV 1 1 1 1\nDI INT3 INPUT INT2 INPUT/RX D1 INT1 INPUT INT0 INPUT\nAIO \u2013 \u2013 SDA INPUT SCL INPUT\n\n86\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.5 Alternate Functions of Port E\nThe Port E pins with alternate functions are shown in Table 13-15 .\nNote: 1. Only for ATmega1281/2561. For ATmega640/ 1280/2560 these functions are placed on \nMISO/MOSI pins.\n\u0081 INT7/ICP3/CLKO \u2013 Port E, Bit 7\nINT7, External Interrupt source 7: The PE7 pin can serve as an external interrupt source.\nICP3, Input Capture Pin 3: The PE7 pin can act as an input capture pin for Timer/Counter3.\nCLKO - Divided System Clock: The divided system clock can be output on the PE7 pin. The\ndivided system clock will be output if the CK OUT Fuse is programmed, regardless of the\nPORTE7 and DDE7 settings. It will also be output during reset.\n\u0081 INT6/T3 \u2013 Port E, Bit 6\nINT6, External Interrupt source 6: The PE6 pin can serve as an external interrupt source.\nT3, Timer/Counter3 counter source.\n\u0081 INT5/OC3C \u2013 Port E, Bit 5\nINT5, External Interrupt source 5: The PE5 pin can serve as an External Interrupt source.\nOC3C, Output Compare Match C output: The PE5 pin can serve as an External output for the\nTimer/Counter3 Output Compare C. The pin has to be configured as an output (DDE5 set \u201cone\u201d)to serve this function. The OC3C pin is also the output pin for the P WM mode timer function.Table 13-15. Port E Pins Alternate Functions\nPort Pin Alternate Function\nPE7INT7/ICP3/CLK0\n(External Interrupt 7 Input, Timer/Counter3 Inpu t Capture Trigger or Divided System Clock)\nPE6INT6/ T3\n(External Interrupt 6 Input or Timer/Counter3 Clock Input)\nPE5INT5/OC3C\n(External Interrupt 5 Input or Output Compare and P WM Output C for Timer/Counter3)\nPE4INT4/OC3B\n(External Interrupt4 Input or Output Compare and P WM Output B for Timer/Counter3)\nPE3AIN1/OC3A\n(Analog Comparator Negative In put or Output Compare and P WM Output A for \nTimer/Counter3)\nPE2AIN0/XCK0\n(Analog Comparator Positive Input or USART0 external clock input/output)\nPE1PDO(1)/TXD0\n(Programming Data Output or USART0 Transmit Pin)\nPE0PDI(1)/RXD0/PCINT8\n(Programming Data Input, USART0 Receive Pin or Pin Change Interrupt 8)\n\n87\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 INT4/OC3B \u2013 Port E, Bit 4\nINT4, External Interrupt source 4: The PE4 pin can serve as an External Interrupt source.\nOC3B, Output Compare Match B output: The PE4 pin can serve as an External output for the\nTimer/Counter3 Output Compare B. The pin has to be configured as an output (DDE4 set (one))\nto serve this function. The OC3B pin is also the output pin for the P WM mode timer function.\n\u0081 AIN1/OC3A \u2013 Port E, Bit 3\nAIN1 \u2013 Analog Comparator Negative input. This pi n is directly connected to the negative input of\nthe Analog Comparator.\nOC3A, Output Compare Match A output: The PE3 pin can serve as an External output for the\nTimer/Counter3 Output Compare A. The pin has to be configured as an output (DDE3 set \u201cone\u201d)to serve this function. The OC3A pin is also the output pin for the P WM mode timer function.\n\u0081 AIN0/XCK0 \u2013 Port E, Bit 2\nAIN0 \u2013 Analog Comparator Positive input. This pin is directly connected to the positive input of\nthe Analog Comparator.\nXCK0, USART0 External clock. Th e Data Direction Register (DDE2) controls whether the clock\nis output (DDE2 set) or input (DDE2 cleared) . The XCK0 pin is active only when the USART0\noperates in Synchronous mode.\n\u0081 PDO/TXD0 \u2013 Port E, Bit 1\nPDO, SPI Serial Programming Data Output. Duri ng Serial Program Downloading, this pin is\nused as data output line for the ATmega1281/2561. For ATmega640/1280/2560 this function isplaced on MISO.\nTXD0, USART0 Transmit pin.\n\u0081 PDI/RXD0/PCINT8 \u2013 Port E, Bit 0\nPDI, SPI Serial Programming Data Input. During Serial Program Downloading, this pin is used\nas data input line for the ATmega1281/2561. Fo r ATmega640/1280/2560 this function is placed\non MOSI.\nRXD0, USART0 Receive Pin. Receive Da ta (Data input pin for the USART0). When the\nUSART0 receiver is enabled this pin is configur ed as an input regardless of the value of DDRE0.\nWhen the USART0 forces this pin to be an input, a logical one in  PORTE0 will turn on the inter-\nnal pull-up.\nPCINT8, Pin Change Interrupt source 8: The PE0 pin can serve as an external interrupt source.\nTable 13-16 on page 88  and Table 13-17 on page 88  relates the alternate functions of Port E to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n88\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \n \nNote: 1. PDO/PDI only available at PE1/PE0 for ATmega1281/2561.Table 13-16. Overriding Signals for Alternate Functions PE7:PE4\nSignal \nName PE7/INT7/ICP3 PE6/INT6/T3 PE5/INT5/OC3C PE4/INT4/OC3B\nPUOE 0 0 0 0\nPUOV 0 0 0 0\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nPVOE 0 0 OC3C ENABLE OC3B ENABLE\nPVOV 0 0 OC3C OC3B\nDIEOE INT7 ENABLE INT6 ENABL E INT5 ENABLE INT4 ENABLE\nDIEOV 1 1 1 1\nDIINT7 INPUT/ICP3 \nINPUTINT7 INPUT/T3 \nINPUTINT5 INPUT INT4 INPUT\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-17. Overriding Signals for Alternate Functions in PE3:PE0\nSignal \nName PE3/AIN1/OC3A PE2/AIN0/XCK0PE1/PDO(1)/\nTXD0PE0/PDI(1)/\nRXD0/PCINT8\nPUOE 0 0 TXEN0 RXEN0\nPUOV 0 0 0 PORTE0 \u0081 PUD\nDDOE 0XCK0 OUTPUT \nENABLETXEN0 RXEN0\nDDOV 0 1 1 0\nPVOE OC3B ENABLEXCK0 OUTPUT \nENABLETXEN0 0\nPVOV OC3B XCK0 OUTPUT TXD0 0\nDIEOE 0 0 0 PCINT8 \u0081 PCIE1\nDIEOV 0 0 0 1\nDI 0 XCK0 INPUT \u2013 RXD0\nPE0 0 0 0 PCINT8 INPUT\nAIO AIN1 INPUT AIN0 INPUT \u2013 \u2013\n\n89\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.6 Alternate Functions of Port F\nThe Port F has an alternate function as analog input for the ADC as shown in Table 13-18 . If\nsome Port F pins are configured as outputs, it is essential that these do not switch when a con-version is in progress. This might corrupt the re sult of the conversion. If the JTAG interface is\nenabled, the pull-up resistors on pins PF7(TDI), PF5(TMS), an d PF4(TCK) will be activated even\nif a Reset occurs.\n\u0081 TDI, ADC7 \u2013 Port F, Bit 7\nADC7, Analog to Digital Converter, Channel 7.\nTDI, JTAG Test Data In: Serial input data to be shifted in to the Instruction Register or Data Reg-\nister (scan chains). When the JTAG interface is enabled, th is pin can not be used as an I/O pin.\n\u0081 TDO, ADC6 \u2013 Port F, Bit 6\nADC6, Analog to Digital Converter, Channel 6.\nTDO, JTAG Test Data Out: Serial output data from Instruction Register or Data Register. When\nthe JTAG interface is enabled, this pin can not be used as an I/O pin.\nThe TDO pin is tri-stated unless TAP states that shift out data are entered.\n\u0081 TMS, ADC5 \u2013 Port F, Bit 5\nADC5, Analog to Digital Converter, Channel 5.\nTMS, JTAG Test Mode Select: This pin is used fo r navigating through the TAP-controller state\nmachine. When the JTAG interface is enabled, this pin can not be used as an I/O pin.\n\u0081 TCK, ADC4 \u2013 Port F, Bit 4\nADC4, Analog to Digital Converter, Channel 4.\nTCK, JTAG Test Clock: JTAG oper ation is synchronous to TCK. When the JTAG interface is\nenabled, this pin can not be used as an I/O pin.\n\u0081 ADC3 \u2013 ADC0 \u2013 Port F, Bit 3:0\nAnalog to Digital Converter, Channel 3:0.Table 13-18. Port F Pins Alternate Functions\nPort Pin Alternate Function\nPF7 ADC7/TDI (ADC input channel 7 or JTAG Test Data Input)\nPF6 ADC6/TDO (ADC input channel 6 or JTAG Test Data Output)PF5 ADC5/TMS (ADC input channel 5 or JTAG Test Mode Select)\nPF4 ADC4/TCK (ADC input channel 4 or JTAG Test ClocK)\nPF3 ADC3 (ADC input channel 3)PF2 ADC2 (ADC input channel 2)\nPF1 ADC1 (ADC input channel 1)\nPF0 ADC0 (ADC input channel 0)\n\n90\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n \n13.3.7 Alternate Functions of Port G\nThe Port G alternate pin configuration is as follows:Table 13-19. Overriding Signals for Alternate Functions in PF7:PF4\nSignal \nName PF7/ADC7/TDI PF6/ADC6/TDO PF5/ADC5/TMS PF4/ADC4/TCK\nPUOE JTAGEN JTAGEN JTAGEN JTAGEN\nPUOV 1 0 1 1\nDDOE JTAGEN JTAGEN JTAGEN JTAGEN\nDDOV 0SHIFT_IR + \nSHIFT_DR00\nPVOE 0 JTAGEN 0 0\nPVOV 0 TDO 0 0\nDIEOE JTAGEN JTAGEN JTAGEN JTAGEN\nDIEOV 0 0 0 0\nDI \u2013 \u2013 \u2013 \u2013\nAIO TDI/ADC7 INPUT ADC6 INPUT TMS/ADC5 INPUT TCK/ADC4 INPUT\nTable 13-20. Overriding Signals for Alternate Functions in PF3:PF0\nSignal Name PF3/ADC3 PF2/ADC2 PF1/ ADC1 PF0/ADC0\nP U O E 0000\nP U O V 0000\nD D O E 0000\nD D O V 0000\nP V O E 0000\nP V O V 0000\nD I E O E 0000\nD I E O V 0000\nD I \u2013\u2013\u2013\u2013\nAIO ADC3 INPUT ADC2 INPU TA D C 1  I N P U TA D C 0  I N P U T\nTable 13-21. Port G Pins Alternate Functions\nPort Pin Alternate Function\nPG5 OC0B (Output Compare and P WM Output B for Timer/Counter0)\nPG4 TOSC1 (RTC Oscillator Timer/Counter2)\nPG3 TOSC2 (RTC Oscillator Timer/Counter2)\nPG2 ALE (Address Latch Enable to external memory)PG1 RD\n (Read strobe to external memory)\nPG0 WR (Write strobe to external memory)\n\n91\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 OC0B \u2013 Port G, Bit 5\nOC0B, Output Compare match B output: The PG5 pin can serve as an external output for the\nTImer/Counter0 Output Compare. The pin has to be configured as an output (DDG5 set) toserve this function. The OC0B pin is also the output pin for the P WM mode timer function.\n\u0081 TOSC1 \u2013 Port G, Bit 4\nTOSC2, Timer Oscillator pin 1: When the AS2 bit in ASSR is se t (one) to enabl e asynchronous\nclocking of Timer/Counter2, pin PG4 is disconnected from the port, and becomes the input of the\ninverting Oscillator amplifier. In this mode, a Cr ystal Oscillator is connected to this pin, and the\npin can not be used as an I/O pin.\n\u0081 TOSC2 \u2013 Port G, Bit 3\nTOSC2, Timer Oscillator pin 2: When the AS2 bit in ASSR is se t (one) to enabl e asynchronous\nclocking of Timer/Counter2, pin PG3 is disconnected from the port, and becomes the inverting\noutput of the Oscillator amplifier. In this mode , a Crystal Oscillator is connected to this pin, and\nthe pin can not be used as an I/O pin.\n\u0081 ALE \u2013 Port G, Bit 2\nALE is the external data memory Address Latch Enable signal.\n\u0081R D\n \u2013 Port G, Bit 1\nRD is the external data memory read control strobe.\n\u0081W R  \u2013 Port G, Bit 0\nWR is the external data memory write control strobe.\nTable 13-22 on page 91  and Table 13-23 on page 92  relates the alternate functions of Port G to\nthe overriding signals shown in Figure 13-5 on page 76 .\nTable 13-22. Overriding Signals for Alternate Functions in PG5:PG4\nSignal Name \u2014 \u2014 PG5/ OC0B PG4/TOSC1\nPUOE \u2013 \u2013 \u2013 AS2\nP U O V \u2013\u2013\u2013 0\nDDOE \u2013 \u2013 \u2013 AS2\nDDOV \u2013 \u2013 \u2013 0\nPVOE \u2013 \u2013 OC0B Enable 0\nPVOV \u2013 \u2013 OC0B 0\nP T O E \u2013\u2013\u2013 \u2013\nDIEOE \u2013 \u2013 \u2013 AS2\nDIEOV \u2013 \u2013 \u2013 EXCLK\nD I \u2013\u2013\u2013 \u2013\nAIO \u2013 \u2013 \u2013 T/C2 OSC INPUT\n\n92\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.8 Alternate Functions of Port H\nThe Port H alternate pin configuration is as follows:\n\u0081 T4 \u2013 Port H, Bit 7\nT4, Timer/Counter4 counter source.\n\u0081 OC2B \u2013 Port H, Bit 6\nOC2B, Output Compare Match B output: The PH6 pin can serve as an external output for the\nTimer/Counter2 Output Compare B. The pin has to be configured as an output (DDH6 set) to\nserve this function. The OC2B pin is also the output pin for the P WM mode timer function.\n\u0081 OC4C \u2013 Port H, Bit 5\nOC4C, Output Compare Match C output: The PH5 pin can serve as an external output for the\nTimer/Counter4 Output Compare C. The pin has to be configured  as an output (DDH5 set) to\nserve this function. The OC4C pin is also the output pin for the P WM mode timer function.Table 13-23. Overriding Signals for Alternate Functions in PG3:PG0\nSignal Name PG3/TOSC2 PG2/ALE/A7 PG1/RD PG0/WR\nPUOE AS2 \u0081 EXCLK SRE SRE SRE\nP U O V 0 000\nDDOE AS2 \u0081 EXCLK SRE SRE SRE\nDDOV 0 1 1 1\nPVOE 0 SRE SRE SRE\nPVOV 0 ALE RD WR\nP T O E \u2013 \u2013\u2013\u2013\nDIEOE AS2 \u0081 EXCLK 000\nD I E O V 0 000\nD I \u2013 \u2013\u2013\u2013\nAIO T/C2 OSC OUTPUT \u2013 \u2013 \u2013\nTable 13-24. Port H Pins Alternate Functions\nPort Pin Alternate Function\nPH7 T4 (Timer/Counter4 Clock Input)\nPH6 OC2B (Output Compare and P WM Output B for Timer/Counter2)\nPH5 OC4C (Output Compare and P WM Output C for Timer/Counter4)\nPH4 OC4B (Output Compare and P WM Output B for Timer/Counter4)\nPH3 OC4A (Output Compare and P WM Output A for Timer/Counter4)\nPH2 XCK2 (USART2 External Clock)PH1 TXD2 (USART2 Transmit Pin)\nPH0 RXD2 (USART2 Receive Pin)\n\n93\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 OC4B \u2013 Port H, Bit 4\nOC4B, Output Compare Match B output: The PH4 pin can serve as an external output for the\nTimer/Counter2 Output Compare B. The pin has to be configured as an output (DDH4 set) toserve this function. The OC4B pin is also the output pin for the P WM mode timer function.\n\u0081 OC4A \u2013 Port H, Bit 3\nOC4C, Output Compare Match A output: The PH3 pi n can serve as an external output for the\nTimer/Counter4 Output Compare A. The pin has to be configured as an output (DDH3 set) to\nserve this function. The OC4A pin is also the output pin for the P WM mode timer function.\n\u0081 XCK2 \u2013 Port H, Bit 2\nXCK2, USART2 External Clock: The Data Direction Register (DDH2) controls whether the clock\nis output (DDH2 set) or input (DDH2 cleared).  The XC2K pin is active only when the USART2\noperates in synchronous mode.\n\u0081 TXD2 \u2013 Port H, Bit 1\nTXD2, USART2 Transmit Pin.\n\u0081 RXD2 \u2013 Port H, Bit 0\nRXD2, USART2 Receive pin: Receive Da ta (Data input pin for the USART2). When the\nUSART2 Receiver is enabled, this  pin is configured as an inpu t regardless of the value of DDH0.\nWhen the USART2 forces this pin to be an input,  a logical on in PORTH0  will turn on the internal\npull-up. \nTable 13-25. Overriding Signals for Alte rnate Functions in PH7:PH4\nSignal Name PH7/T4 PH6/OC2B PH5/OC4C PH4/OC4B\nP U O E 0 000\nP U O V 0 000\nDDOE 0 0 0 0\nD D O V 0 000\nPVOE 0 OC2B ENABLE OC4C ENABLE OC4B ENABLE\nPVOV 0 OC2B OC4C OC4BP T O E \u2013 \u2013\u2013\u2013\nD I E O E 0 000\nD I E O V 0 000\nDI T4 INPUT 0 0 0\nA I O \u2013 \u2013\u2013\u2013\n\n94\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.9 Alternate Functions of Port J\nThe Port J alternate pin configuration is as follows:\n\u0081 PCINT15:12 - Port J, Bit 6:3\nPCINT15:12, Pin Change Interrupt Source 15:12. Th e PJ6:3 pins can serve as External Interrupt\nSources.\n\u0081 XCK2/PCINT11 - Port J, Bit 2\nXCK2, USART 2 External Clock. The Data Directi on Register (DDJ2) controls whether the clock\nis output (DDJ2 set) or input (DDJ2 cleared). The XCK2 pin is active only when the USART2\noperates in synchronous mode.\nPCINT11, Pin Change Interrupt Source 11. The PJ2 pin can serve as External Interrupt\nSources.Table 13-26. Overriding Signals for Alte rnate Functions in PH3:PH0\nSignal Name PH3/OC4A PH 2/XCK2 PH1/TXD2 PH0/RXD2\nPUOE 0 0 TXEN2 RXEN2\nPUOV 0 0 0 PORTH0 \u0081 PUD\nDDOE 0XCK2 OUTPUT \nENABLETXEN2 RXEN2\nD D O V 0 110\nPVOE OC4A ENABLEXCK2 OUTPUT \nENABLETXEN2 0\nPVOV OC4A XCK2 TXD2 0\nP T O E \u2013 \u2013\u2013\u2013\nD I E O E 0 000\nD I E O V 0 000\nDI 0 XC2K INPUT 0 RXD2\nA I O \u2013 \u2013\u2013\u2013\nTable 13-27. Port J Pins Alternate Functions\nPort Pin Alternate Function\nPJ7 \u2013\nPJ6 PCINT15 (Pin Change Interrupt 15)\nPJ5 PCINT14 (Pin Change Interrupt 14)PJ4 PCINT13 (Pin Change Interrupt 13)\nPJ3 PCINT12 (Pin Change Interrupt 12)\nPJ2 XCK3/PCINT11 (USART3 External Clock or Pin Change Interrupt 11)PJ1 TXD3/PCINT10 (USART3 Transmit Pin or Pin Change Interrupt 10)\nPJ0 RXD3/PCINT9 (USART3 Receive Pin or Pin Change Interrupt 9)\n\n95\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 TXD3/PCINT10 - Port J, Bit 1\nTXD3, USART3 Transmit pin.\nPCINT10, Pin Change Interrupt Source 10. The PJ1 pin can serve as External Interrupt\nSources.\n\u0081 RXD3/PCINT9 - Port J, Bit 0\nRXD3, USART3 Receive pin. Receive Da ta (Data input pin for the USART3). When the\nUSART3 Receiver is enabled, this pin is config ured as an input regardless of the value of DDJ0.\nWhen the USART3 forces th is pin to be an input, a logical on e in PORTJ0 will tu rn on the inter-\nnal pull-up.\nPCINT9, Pin Change Interrupt Source 9. The PJ 0 pin can serve as External Interrupt Sources.\nTable 13-28 on page 96  and Table 13-29 on page 96  relates the alternate functions of Port J to\nthe overriding signals shown in Figure 13-5 on page 76 .\n\n96\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.10 Alternate Functions of Port K\nThe Port K alternate pin configuration is as follows:Table 13-28. Overriding Signals for Alternate Functions in PJ7:PJ4\nSignal Name PJ7 PJ6/ PCINT1 5 PJ5/ PCINT14 PJ4/ PCINT13\nP U O E 0000\nP U O V 0000\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nP V O E 0000P V O V 0000\nP T O E ----\nDIEOE 0 PCINT15\u00b7PCIE1 PCI NT14\u00b7PCIE1 PCINT13\u00b7PCIE1\nDIEOV 0 1 1 1\nDI 0 PCINT15 INPUT PCINT14 INPUT PCINT13 INPUT\nAIO - - - -\nTable 13-29. Overriding Signals for Alternate Functions in PJ3:PJ0\nSignal Name PJ3/PCINT12PJ2/XCK3/PCINT\n11PJ1/TXD3/PCINT\n10PJ0/RXD3/PCINT\n9\nPUOE 0 0 TXEN3 RXEN3P U O V 000P O R T J 0 \u00b7 P U D\nDDOE 0 XCK3 OUTPUT \nENABLETXEN3 RXEN3\nD D O V 0110\nPVOE 0 XCK3 OUTPUT \nENABLETXEN3 0\nPVOV 0 XCK3 TXD3 0\nP T O E ----\nDIEOE PCINT12\u00b7PCIE1 PCINT11\u00b7PCIE 1 PCINT10\u00b7PCIE1 P CINT9\u00b7PCIE1\nD I E O V 1111\nDI PCINT12 INPUT PCINT11 INPUT\nXCK3 INPUTPCINT10 INPUT PCINT9 INPUT \nRXD3\nA I O ----\nTable 13-30. Port K Pins Alternate Functions\nPort Pin Alternate Function\nPK7 ADC15/PCINT23 (ADC Input Channel 15 or Pin Change Interrupt 23)\nPK6 ADC14/PCINT22 (ADC Input Channel 14 or Pin Change Interrupt 22)PK5 ADC13/PCINT21 (ADC Input Channel 13 or Pin Change Interrupt 21)\n\n97\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 ADC15:8/PCINT23:16 \u2013 Port K, Bit 7:0\nADC15:8, Analog to Digital Converter, Channel 15 - 8.\nPCINT23:16, Pin Change Interrupt Source 23:16. The PK7:0 pins can serve as External Inter-\nrupt Sources.PK4 ADC12/PCINT20 (ADC Input Channel 12 or Pin Change Interrupt 20)\nPK3 ADC11/PCINT19 (ADC Input Channel 11 or Pin Change Interrupt 19)\nPK2 ADC10/PCINT18 (ADC Input Channel 10 or Pin Change Interrupt 18)\nPK1 ADC9/PCINT17 (ADC Input Channel 9 or Pin Change Interrupt 17)\nPK0 ADC8 /PCINT16 (ADC Input Channel 8 or Pin Change Interrupt 16)\nTable 13-31. Overriding Signals for Alternate Functions in PK7:PK4\nSignal NamePK7/ADC15/\nPCINT23PK6/ADC14/\nPCINT22PK5/ADC13/\nPCINT21PK4/ADC12/\nPCINT20\nP U O E 0000\nP U O V 0000\nDDOE 0 0 0 0\nDDOV 0 0 0 0\nP V O E 0000\nP V O V 0000\nP T O E \u2013\u2013\u2013\u2013\nDIEOE PCINT23 \u0081 PCIE2 PCINT22 \u0081 PCIE 2 PCINT21 \u0081 PCIE2 PCINT20 \u0081 PCIE2\nDIEOV 1 1 1 1\nDI PCINT23 INPUT PCINT22 INPUT PCINT21 INPUT PCINT20 INPUT\nAIO ADC15 INPUT ADC14 INPUT ADC13 INPUT ADC12 INPUTTable 13-30. Port K Pins Alternate Functions (Continued)\nPort Pin Alternate Function\n\n98\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.3.11 Alternate Functions of Port L\nThe Port L alternate pin configuration is as follows:\n\u0081 OC5C \u2013 Port L, Bit 5\nOC5C, Output Compare Match C output: The PL5 pin can serve as an external output for the\nTimer/Counter5 Output Compare C. The pin has to  be configured as an output (DDL5 set) to\nserve this function. The OC5C pin is also the output pin for the P WM mode timer function.\n\u0081 OC5B \u2013 Port L, Bit 4\nOC5B, Output Compare Match B output: The PL4 pin can serve as an external output for the\nTimer/Counter 5 Output Compare B. The pin has to be configured as an output (DDL4 set) to\nserve this function. The OC5B pin is also the output pin for the P WM mode timer function.\n\u0081 OC5A \u2013 Port L, Bit 3\nOC5A, Output Compare Match A output: The PL3 pin can serve as an external output for the\nTimer/Counter 5 Output Compare A. The pin has to be configured as an output (DDL3 set) to\nserve this function. The OC5A pin is also the output pin for the P WM mode timer function.Table 13-32. Overriding Signals for Alternate Functions in PK3:PK0\nSignal NamePK3/ADC11/\nPCINT19PK2/ADC10/\nPCINT18PK1/ADC9/\nPCINT17PK0/ADC8/\nPCINT16\nP U O E 0000\nP U O V 0000\nD D O E 0000\nDDOV 0 0 0 0\nP V O E 0000\nP V O V 0000\nP T O E \u2013\u2013\u2013\u2013\nDIEOE PCINT19 \u0081 PCIE2 PCI NT18 \u0081 PCIE2 PCINT17 \u0081 PCIE2 PCINT16 \u0081 PCIE2\nDIEOV 1 1 1 1\nDI PCINT19 INPUT PCINT18 INPUT PCINT17 INPUT PCINT16 INPUT\nAIO ADC11 INPUT ADC10INPUT ADC9 INPUT ADC8 INPUT\nTable 13-33. Port L Pins Alternate Functions\nPort Pin Alternate Function\nPL7 \u2013PL6 \u2013\nPL5 OC5C (Output Compare and P WM Output C for Timer/Counter5)\nPL4 OC5B (Output Compare and P WM Output B for Timer/Counter5)\nPL3 OC5A (Output Compare and P WM Output A for Timer/Counter5)\nPL2 T5 (Timer/Counter5 Clock Input)\nPL1 ICP5 (Timer/Counter5 Input Capture Trigger)PL0 ICP4 (Timer/Counter4 Input Capture Trigger)\n\n99\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 T5 \u2013 Port L, Bit 2\nT5, Timer/Counter5 counter source.\n\u0081 ICP5 \u2013 Port L, Bit 1\nICP5, Input Capture Pin 5: The PL1 pin can serve as an Input Capture pin for Timer/Counter5.\n\u0081 ICP4 \u2013 Port L, Bit 0\nICP4, Input Capture Pin 4: The PL0 pin can serve as an Input Capture pin for Timer/Counter4.\nTable 13-34  and Table 13-35  relates the alternate functions of Port L to the overriding signals\nshown in Figure 13-5 on page 76 .\nTable 13-34. Overriding Signals for Alternate Functions in PL7:PL4\nSignal Name PL7 PL6 PL5/OC5C PL4/OC5B\nP U O E 0000\nP U O V 0000\nDDOE \u2013 \u2013 0 0\nDDOV \u2013 \u2013 0 0\nPVOE \u2013 \u2013 OC5C ENABLE OC5B ENABLE\nPVOV \u2013 \u2013 OC5C OC5B\nP T O E \u2013\u2013\u2013\u2013\nDIEOE 0 0 0 0\nDIEOV 0 0 0 0\nD I 0000\nAIO \u2013 \u2013 \u2013 \u2013\nTable 13-35. Overriding Signals for Alternate Functions in PL3:PL0\nSignal Name PL 3/OC5A PL2/T5 PL 1/ICP5 PL0/ICP4\nP U O E 0000\nP U O V 0000\nD D O E 0000\nD D O V 0000\nPVOE OC5A ENABLE 0 0 0\nP V O V O C 5 A 000\nP T O E \u2013\u2013\u2013\u2013\nD I E O E 0000\nD I E O V 0000\nDI 0 T5 INPUT ICP5 INPUT ICP4 INPUT\nA I O \u2013\u2013\u2013\u2013\n\n100\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4 Register Descrip tion for I/O-Ports\n13.4.1 MCUCR \u2013 MCU Control Register\n\u0081 Bit 4 \u2013 PUD: Pull-up Disable\nWhen this bit is written to one, the I/O ports pull-up resistors are disabled even if the DDxn and\nPORTxn Registers are configured to enable the pull-up resistor ({DDxn, PORTxn} = 0b01). See\u201cConfiguring the Pin\u201d on page 71  for more details about this feature.\n13.4.2 PORTA \u2013 Port A Data Register\n13.4.3 DDRA \u2013 Port A Data Direction Register13.4.4 PINA \u2013 Port A Input Pins Address\n13.4.5 PORTB \u2013 Port B Data Register\n13.4.6 DDRB \u2013 Port B Data Direction Register13.4.7 PINB \u2013 Port B Input Pins AddressBit 7 6 5 4 3 2 1 0\n0x35 (0x55) JTD \u2013 \u2013P U D \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RRR / W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x02 (0x22)\nPORTA7 PORTA6 PORTA5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 PORTA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x01 (0x21) DDA7 DDA6 DDA5 DDA4 DDA3 DDA2 DDA1 DDA0 DDRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x00 (0x20) PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 PINA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210\n0x05 (0x25) PORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 PORTB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x04 (0x24) DDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 DDRB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x03 (0x23) PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 PINB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n101\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.8 PORTC \u2013 Port C Data Register\n13.4.9 DDRC \u2013 Port C Data Direction Register\n13.4.10 PINC\u2013 Port C Input Pins Address\n13.4.11 PORTD \u2013 Port D Data Register13.4.12 DDRD \u2013 Port D Data Direction Register\n13.4.13 PIND \u2013 Port D Input Pins Address\n13.4.14 PORTE \u2013 Port E Data Register13.4.15 DDRE \u2013 Port E Data Direction RegisterB i t 76543210\n0x08 (0x28) PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 PORTC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x07 (0x27) DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 DDRC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x06 (0x26) PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 PINC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x0B (0x2B)\nPORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 PORTD\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0A (0x2A) DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 DDRD\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x09 (0x29) PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 PIND\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x0E (0x2E)\nPORTE7 PORTE6 PORTE5 PORTE4 PORTE3 PORTE2 PORTE1 PORTE0 PORTE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0D (0x2D) DDE7 DDE6 DDE5 DDE4 DDE3 DDE2 DDE1 DDE0 DDRE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n102\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.16 PINE \u2013 Port E Input Pins Address\n13.4.17 PORTF \u2013 Port F Data Register\n13.4.18 DDRF \u2013 Port F Data Direction Register\n13.4.19 PINF \u2013 Port F Input Pins Address13.4.20 PORTG \u2013 Port G Data Register\n13.4.21 DDRG \u2013 Port G Data Direction Register\n13.4.22 PING \u2013 Port G Input Pins Address13.4.23 PORTH \u2013 Port H Data RegisterB i t 76543210\n0x0C (0x2C) PINE7 PINE6 PINE5 PINE4 PINE3 PINE2 PINE1 PINE0 PINE\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x11 (0x31)\nPORTF7 PORTF6 PORTF5 PORTF4 PORTF3 PORTF2 PORTF1 PORTF0 PORTF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x10 (0x30) DDF7 DDF6 DDF5 DDF4 DDF3 DDF2 DDF1 DDF0 DDRF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x0F (0x2F) PINF7 PINF6 PINF5 PINF4 PINF3 PINF2 PINF1 PINF0 PINF\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 765432100x14 (0x34) \u2013\u2013\nPORTG5 PORTG4 PORTG3 PORTG2 PORTG1 PORTG0 PORTG\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x13 (0x33) \u2013 \u2013 DDG5 DDG4 DDG3 DDG2 DDG1 DDG0 DDRG\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x12 (0x32) \u2013 \u2013 PING5 PING4 PING3 PING2 PING1 PING0 PING\nRead/Write R R R/ W R/W R/W R/W R/W R/W\nInitial Value 0 0 N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x102)\nPORTH7 PORTH6 PORTH5 PORTH4 PORTH3 PORTH2 PORTH1 PORTH0 PORTH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n103\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.24 DDRH \u2013 Port H Data Direction Register\n13.4.25 PINH \u2013 Port H Input Pins Address\n13.4.26 PORTJ \u2013 Port J Data Register\n13.4.27 DDRJ \u2013 Port J Data Direction Register13.4.28 PINJ \u2013 Port J Input Pins Address\n13.4.29 PORTK \u2013 Port K Data Register\n13.4.30 DDRK \u2013 Port K Data Direction Register13.4.31 PINK \u2013 Port K Input Pins AddressB i t 76543210\n(0x101) DDH7 DDH6 DDH5 DDH4 DDH3 DDH2 DDH1 DDH0 DDRH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x100) PINH5 PINH5 PINH5 PINH4 PI NH3 PINGH PINH1 PINH0 PINH\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x105)\nPORTJ7 PORTJ6 PORTJ5 PORTJ4 PORTJ3 PORTJ2 PORTJ1 PORTJ0 PORTJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x104) DDJ7 DDJ6 DDJ5 DDJ4 DDJ3 DDJ2 DDJ1 DDJ0 DDRJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x103) PINJ5 PINJ5 PINJ5 PINJ4 PINJ3 PINGJ PINJ1 PINJ0 PINJ\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210(0x108)\nPORTK7 PORTK6 PORTK5 PORTK4 PORTK3 PORTK2 PORTK1 PORTK0 PORTK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x107) DDK7 DDK6 DDK5 DDK4 DDK3 DDK2 DDK1 DDK0 DDRK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x106) PINK5 PINK5 PINK5 PINK4 PI NK3 PINGK PINK1 PINK0 PINK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n104\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n13.4.32 PORTL \u2013 Port L Data Register\n13.4.33 DDRL \u2013 Port L Data Direction Register\n13.4.34 PINL \u2013 Port L Input Pins AddressB i t 76543210\n(0x10B) PORTL7 PORTL6 PORTL5 PORTL4 PORTL3 PORTL2 PORTL1 PORTL0 PORTL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x10A) DDL7 DDL6 DDL5 DDL4 DDL3 DDL2 DDL1 DDL0 DDRL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x109) PINL5 PINL5 PINL5 PINL4 PINL3 PINGL PINL1 PINL0 PINL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n105\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14. Interrupts\nThis section describes the specifics of the interrupt handling as performed in\nATmega640/1280/1281/2560/2561. For a general explanation of the AVR interrupt handling,\nrefer to \u201cReset and Interrupt Handling\u201d on page 18 .\n14.1 Interrupt Vectors in  ATmega640/1280/ 1281/2560/2561\nTable 14-1. Reset and Interrupt Vectors\nVector\nNo.Program\nAddress(2)Source Interrupt Definition\n1 $0000(1)RESETExternal Pin, Power-on Reset, Brown-out Reset, \nWatchdog Reset, and JTAG AVR Reset\n2 $0002 INT0 External Interrupt Request 03 $0004 INT1 External Interrupt Request 1\n4 $0006 INT2 External Interrupt Request 2\n5 $0008 INT3 External Interrupt Request 36 $000A INT4 External Interrupt Request 4\n7 $000C INT5 External Interrupt Request 5\n8 $000E INT6 External Interrupt Request 69 $0010 INT7 External Interrupt Request 7\n10 $0012 PCINT0 Pin Change Interrupt Request 0\n11 $0014 PCINT1 Pin Change Interrupt Request 112 $0016\n(3)PCINT2 Pin Change Interrupt Request 2\n13 $0018 WDT Watchdog Time-out Interrupt\n14 $001A TIMER2 COMPA Timer /Counter2 Compare Match A\n15 $001C TIMER2 COMPB Timer /Counter2 Compare Match B\n16 $001E TIMER2 OVF Timer/Counter2 Overflow\n17 $0020 TIMER1 CAPT Timer/Counter1 Capture Event18 $0022 TIMER1 COMPA Timer /Counter1 Compare Match A\n19 $0024 TIMER1 COMPB Timer /Counter1 Compare Match B\n20 $0026 TIMER1 COMPC Timer/Counter1 Compare Match C21 $0028 TIMER1 OVF Timer/Counter1 Overflow\n22 $002A TIMER0 COMPA Timer /Counter0 Compare Match A\n23 $002C TIMER0 COMPB Timer /Counter0 Compare match B\n24 $002E TIMER0 OVF Timer/Counter0 Overflow\n25 $0030 SPI, STC SPI Serial Transfer Complete\n26 $0032 USART0 RX USART0 Rx Complete\n27 $0034 USART0 UDRE USART0 Data Register Empty\n28 $0036 USART0 TX USART0 Tx Complete29 $0038 ANALOG COMP Analog Comparator\n\n106\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. When the BOOTRST Fuse is programmed, the device will jump to the Boot Loader address at \nreset, see \u201cMemory Programming\u201d on page 335 .\n2.When the IVSEL bit in MCUCR is set, Interrupt Ve ctors will be moved to the start of the Boot \nFlash Section. The address of each Interrupt Vector will then be the address in this table \nadded to the start address of the Boot Flash Section.\n3. Only available in ATmega640/1280/2560.30 $003A ADC ADC Conversion Complete\n31 $003C EE READY EEPROM Ready\n32 $003E TIMER3 CAPT Timer/Counter3 Capture Event\n33 $0040 TIMER3 COMPA Timer/Counter3 Compare Match A\n34 $0042 TIMER3 COMPB Timer/Counter3 Compare Match B35 $0044 TIMER3 COMPC Timer/Counter3 Compare Match C\n36 $0046 TIMER3 OVF Timer/Counter3 Overflow\n37 $0048 USART1 RX USART1 Rx Complete38 $004A USART1 UDRE USART1 Data Register Empty\n39 $004C USART1 TX USART1 Tx Complete\n40 $004E T WI 2-wire Serial Interface\n41 $0050 SPM READY Store Program Memory Ready\n42 $0052\n(3)TIMER4 CAPT Timer/Counter4 Capture Event\n43 $0054 TIMER4 COMPA Timer/Counter4 Compare Match A44 $0056 TIMER4 COMPB Timer/Counter4 Compare Match B\n45 $0058 TIMER4 COMPC Timer/Counter4 Compare Match C\n46 $005A TIMER4 OVF Timer/Counter4 Overflow47 $005C\n(3)TIMER5 CAPT Timer/Counter5 Capture Event\n48 $005E TIMER5 COMPA Timer/Counter5 Compare Match A\n49 $0060 TIMER5 COMPB Timer/Counter5 Compare Match B50 $0062 TIMER5 COMPC Timer/Counter5 Compare Match C\n51 $0064 TIMER5 OVF Timer/Counter5 Overflow\n52 $0066\n(3)USART2 RX USART2 Rx Complete\n53 $0068(3)USART2 UDRE USART2 Data Register Empty\n54 $006A(3)USART2 TX USART2 Tx Complete\n55 $006C(3)USART3 RX USART3 Rx Complete\n56 $006E(3))USART3 UDRE USART3 Data Register Empty\n57 $0070(3)USART3 TX USART3 Tx CompleteTable 14-1. Reset and Interrupt Vectors (Continued)\nVector\nNo.Program\nAddress(2)Source Interrupt Definition\n\n107\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.2 Reset and Interr upt Vector placement\nTable 14-2  shows Reset and Interrupt Vectors placement for the various combinations of\nBOOTRST and IVSEL settings. If the program never enables an in terrupt source, the Interrupt\nVectors are not used, and regular program code can be placed at these locations. This is alsothe case if the Reset Vector is in the Application section while the Interrupt Vectors are in the\nBoot section or vice versa.\nNote: 1. The Boot Reset Address is shown in Table 29-7 on page 328  through Table 29-15 on page \n332. For the BOOTRST Fuse \u201c1\u201d means unprogrammed while \u201c0\u201d means programmed.\nThe most typical and general program setup for the Reset and Interrupt Vector Addresses in\nATmega640/1280/1281/2560/2561 is:Table 14-2. Reset and Interrupt Vectors Placement(1)\nBOOTRST IVSEL Reset Address Interrupt Vectors Start Address\n1 0 0x0000 0x0002\n1 1 0x0000 Boot Reset Address + 0x0002\n0 0 Boot Reset Address 0x00020 1 Boot Reset Address Boot Reset Address + 0x0002\nAddress Labels Code Comments\n0x0000 jmp RESET ; Reset Handler0x0002 jmp INT0 ; IRQ0 Handler0x0004 jmp INT1 ; IRQ1 Handler0x0006 jmp INT2 ; IRQ2 Handler0x0008 jmp INT3 ; IRQ3 Handler0x000A jmp INT4 ; IRQ4 Handler0x000C jmp INT5 ; IRQ5 Handler0x000E jmp INT6 ; IRQ6 Handler0x0010 jmp INT7 ; IRQ7 Handler0x0012 jmp PCINT0 ; PCINT0 Handler0x0014 jmp PCINT1 ; PCINT1 Handler0x0016 jmp PCINT2 ; PCINT2 Handler0X0018 jmp WDT ; Watchdog Timeout Handler0x001A jmp TIM2_COMPA ; Timer2 CompareA Handler0x001C jmp TIM2_COMPB ; Timer2 CompareB Handler0x001E jmp TIM2_OVF ; Timer2 Overflow Handler0x0020 jmp TIM1_CAPT ; Timer1 Capture Handler0x0022 jmp TIM1_COMPA ; Timer1 CompareA Handler0x0024 jmp TIM1_COMPB ; Timer1 CompareB Handler0x0026 jmp TIM1_COMPC ; Timer1 CompareC Handler0x0028 jmp TIM1_OVF ; Timer1 Overflow Handler0x002A jmp TIM0_COMPA ; Timer0 CompareA Handler0x002C jmp TIM0_COMPB ; Timer0 CompareB Handler0x002E jmp TIM0_OVF ; Timer0 Overflow Handler0x0030 jmp SPI_STC ; SPI Transfer Complete Handler0x0032 jmp USART0_RXC ; USART0 RX Complete Handler0x0034 jmp USART0_UDRE ; USART0,UDR Empty Handler0x0036 jmp USART0_TXC ; USART0 TX Complete Handler0x0038 jmp ANA_COMP ; Analog Comparator Handler0x003A jmp ADC ; ADC Conversion Complete Handler0x003C jmp EE_RDY ; EEPROM Ready Handler0x003E jmp TIM3_CAPT ; Timer3 Capture Handler\n\n108\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the BOOTRST Fuse is unprogrammed, the Boot section size set to 8Kbytes and the\nIVSEL bit in the MCUCR Register is set before an y interrupts are enabled, the most typical and\ngeneral program setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n0x00000 RESET: ldi r16,high(RAMEND); Main program start\n0x00001 out SPH,r16 ; Set Stack Pointer to top of RAM0x00002 ldi r16,low(RAMEND)\n0x00003 out SPL,r16\n0x00004 sei ; Enable interrupts\n0x00005 <instr>  xxx\n;\n.org 0x1F0020x1F002 jmp EXT_INT0 ; IRQ0 Handler\n0x1F004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; \n0x1FO70 jmp USART3_TXC ; USART3 TX Complete Handler0x0040 jmp TIM3_COMPA ; Timer3 CompareA Handler\n0x0042 jmp TIM3_COMPB ; Timer3 CompareB Handler0x0044 jmp TIM3_COMPC ; Timer3 CompareC Handler0x0046 jmp TIM3_OVF ; Timer3 Overflow Handler0x0048 jmp USART1_RXC ; USART1 RX Complete Handler0x004A jmp USART1_UDRE ; USART1,UDR Empty Handler0x004C jmp USART1_TXC ; USART1 TX Complete Handler0x004E jmp TWI ; 2-wire Serial Handler0x0050 jmp SPM_RDY ; SPM Ready Handler0x0052 jmp TIM4_CAPT ; Timer4 Capture Handler0x0054 jmp TIM4_COMPA ; Timer4 CompareA Handler0x0056 jmp TIM4_COMPB ; Timer4 CompareB Handler0x0058 jmp TIM4_COMPC ; Timer4 CompareC Handler0x005A jmp TIM4_OVF ; Timer4 Overflow Handler0x005C jmp TIM5_CAPT ; Timer5 Capture Handler0x005E jmp TIM5_COMPA ; Timer5 CompareA Handler0x0060 jmp TIM5_COMPB ; Timer5 CompareB Handler0x0062 jmp TIM5_COMPC ; Timer5 CompareC Handler0x0064 jmp TIM5_OVF ; Timer5 Overflow Handler0x0066 jmp USART2_RXC ; USART2 RX Complete Handler0x0068 jmp USART2_UDRE ; USART2,UDR Empty Handler\n0x006A jmp USART2_TXC ; USART2 TX Complete Handler\n0x006C jmp USART3_RXC ; USART3 RX Complete Handler0x006E jmp USART3_UDRE ; USART3,UDR Empty Handler0x0070 jmp USART3_TXC ; USART3 TX Complete Handler;0x0072 RESET: ldi r16, high(RAMEND) ; Main program start0x0073 out SPH,r16 ; Set Stack Pointer to top of RAM0x0074 ldi r16, low(RAMEND)0x0075 out SPL,r160x0076 sei ; Enable interrupts0x0077 <instr> xxx\n... ... ... ...\n\n109\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the BOOTRST Fuse is programmed and the Boot section size set to 8Kbytes, the most\ntypical and general program setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n.org 0x0002\n0x00002 jmp EXT_INT0 ; IRQ0 Handler\n0x00004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; \n0x00070 jmp USART3_TXC ; USART3 TX Complete Handler;\n.org 0x1F000\n0x1F000 RESET: ldi r16,high(RAMEND); Main program start\n0x1F001 out SPH,r16 ; Set Stack Pointer to top of RAM\n0x1F002 ldi r16,low(RAMEND)\n0x1F003 out SPL,r16\n0x1F004 sei ; Enable interrupts\n0x1F005 <instr>  xxx\nWhen the BOOTRST Fuse is programmed, the Boot section size set to 8Kbytes and the IVSEL\nbit in the MCUCR Register is set before any interr upts are enabled, the mo st typical and general\nprogram setup for the Reset and Interrupt Vector Addresses is:\nAddress Labels Code Comments\n;\n.org 0x1F000\n0x1F000 jmp RESET ; Reset handler0x1F002 jmp EXT_INT0 ; IRQ0 Handler\n0x1F004 jmp EXT_INT1 ; IRQ1 Handler\n... ... ... ; 0x1F070 jmp USART3_TXC ; USART3 TX Complete Handler\n;\n0x1F072 RESET: ldi r16,high(RAMEND) ; Main program start\n0x1F073 out SPH,r16 ; Set Stack Pointer to top of RAM\n0x1F074 ldi r16,low(RAMEND)0x1F075 out SPL,r16\n0x1F076 sei ; Enable interrupts\n0x1FO77 <instr>  xxx\n14.3 Moving Interrupts Between A pplication and Boot Section\nThe MCU Control Register controls the placement of the Interrupt Vector table, see Code Exam-\nple below. For more details, see \u201cReset and Interrupt Handling\u201d on page 18 .\n\n110\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.4 Register Description\n14.4.1 MCUCR \u2013 MCU Control Register\n\u0081 Bit 1 \u2013 IVSEL: Interrupt Vector Select\nWhen the IVSEL bit is clea red (zero), the Interrupt Vectors ar e placed at the st art of the Flash\nmemory. When this bit is set (one), the Interrupt Vectors are moved to the beginning of the Boot\nLoader section of the Flash. The actual address of the start of the Boot Flash Section is deter-\nmined by the BOOTSZ Fuses. Refer to the section \u201cMemory Programming\u201d on page 335  for\ndetails. To avoid unintentional changes of Interrupt  Vector tables, a special write procedure must\nbe followed to change  the IVSEL bit (see \u201cMoving Interrupts Between Application and Boot Sec-\ntion\u201d on page 109 ):\n1.Write the Interrupt Vector Change Enable (IVCE) bit to one.\n2.Within four cycles, write the desired value to IVSEL while writing a zero to IVCE.Assembly Code Example\nMove_interrupts:\n; Get MCUCR\nin r16, MCUCR\nmov r17, r16\n; Enable change of Interrupt Vectors\nori r16, (1<<IVCE)\nout MCUCR, r16\n; Move interrupts to Boot Flash sectionori r16, (1<<IVSEL)\nout MCUCR, r17\nret\nC Code Example\nvoid Move_interrupts( void)\n{\nuchar temp;\n/* Get MCUCR */\ntemp = MCUCR;\n/* Enable change of Interrupt Vectors */\nMCUCR = temp|(1<<IVCE);\n/* Move interrupts to Boot Flash section */\nMCUCR = temp|(1<<IVSEL); \n}\nB i t 76543210\n0x35 (0x55) JTD \u2013 \u2013 PUD \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RR R / W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n111\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nInterrupts will automatically be di sabled while this sequence is executed. Interrupts are disabled\nin the cycle IVCE is set, and they remain disabl ed until after the instru ction following the write to\nIVSEL. If IVSEL is not written, interrupts remain disabled for four cycles. The I-bit in the Status\nRegister is unaffected by the automatic disabling.\nNote: If Interrupt Vectors are placed in the Boot Loader section and Boot Lock bit BLB02 is programmed, \ninterrupts are disabled while executing from the A pplication section. If Interrupt Vectors are placed \nin the Application section and Boot Lock bit BLB 12 is programed, interrupts are disabled while \nexecuting from the Boot Loader section. Refer to the section \u201cMemory Programmi ng\u201d on page 335  \nfor details on Boot Lock bits.\n\u0081 Bit 0 \u2013 IVCE: Interrupt Vector Change Enable\nThe IVCE bit must be written to  logic one to enable change of the IVSEL bit. IVCE is cleared by\nhardware four cyc les after it is written or when IVSEL is written. Sett ing the IVCE bit will disable\ninterrupts, as explained in the IVSEL description.\n\n112\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n15. External Interrupts\nThe External Interrupts are triggered by the INT7:0 pin or any of the PCINT23:0 pins. Observe\nthat, if enabled, the interrupts w ill trigger even if the INT7:0 or PCINT23:0 pins are configured as\noutputs. This feature provides a way of generating a software interrupt.\nThe Pin change interrupt PCI2 will trigger if any enabled PC INT23:16 pin toggles, Pin change\ninterrupt PCI1 if any enabled PCINT15:8 toggles and Pin change interrupts PCI0 will trigger if\nany enabled PCINT7:0 pin toggles. PCMSK2, PCMSK1 and PCMSK0 Re gisters control which\npins contribute to the pin change interrupts. Pin change interrupts on PCINT23 :0 are detected\nasynchronously. This implies that these interrupts can be used for waking the part also from\nsleep modes other than Idle mode.\nThe External Interrupts can be triggered by a falli ng or rising edge or a low level. This is set up\nas indicated in the specification for the External Interrupt Control Registers \u2013 EICRA (INT3:0)\nand EICRB (INT7:4). When the external interrupt is enabled and is configured as level triggered,\nthe interrupt will trigger as long as the pin is held  low. Note that recognition of falling or rising\nedge interrupts on INT7:4 requires the presence of an I/O clock, described in \u201cOverview\u201d on\npage 40 . Low level interrupts and the edge interrupt on INT3:0 are detected asynchronously.\nThis implies that these interrupts can be used for waking the part also from sleep modes other\nthan Idle mode. The I/O clock is halted in all sleep modes except Idle mode.\nNote that if a level triggered interrupt is used for wake-up from Power-down, the required level\nmust be held long enough for the MCU to complete the wake-up to trigger the level interrupt. If\nthe level disappears before the end of the Start-up Ti me, the MCU will still wake  up, but no inter-\nrupt will be generated. The start- up time is defined by the SU T and CKSEL Fuses as described\nin \u201cSystem Clock and Clock Options\u201d on page 40 .\n15.1 Pin Change Interrupt Timing\nAn example of timing of a pin change interrupt is shown in Figure 15-1 on page 113 .\n\n113\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 15-1. Normal pin change interrupt.\n15.2 Register Description\n15.2.1 EICRA \u2013 External Interrupt Control Register A\nThe External Interrupt Control Register A contains control bits for interrupt sense control.\n\u0081 Bits 7:0 \u2013 ISC31, ISC30 \u2013 ISC00, ISC00: External Interrupt 3 - 0 Sense Control Bits\nThe External Interrupts 3 - 0 are activated by the external pins INT3:0 if the SREG I-flag and the\ncorresponding interrupt mask in the EIMSK is set. The level and edges on the external pins thatactivate the interrupts are defined in Table 15-1 on page 114 . Edges on INT3:0 are registered\nasynchronously. Pulses on INT3:0 pins wider than the minimum pulse width given in Table 15-2\non page 114  will generate an interrupt. Shorter pulses  are not guaranteed to generate an inter-\nrupt. If low level interrupt is se lected, the low level must be held until the completion of the\ncurrently executing instru ction to generate an interrupt. If e nabled, a level trig gered inte rrupt will\ngenerate an interrupt request as long as the pin is held low. When changing the ISCn bit, an\ninterrupt can occur. Therefore, it is recommended to first disable INTn by clearing its Interrupt\nEnable bit in the EIMSK Register. Then, the ISCn bit can be changed. Finally, the INTn interrupt\nflag should be cleared by writing a logical one to its Interrupt Flag bit (INTFn) in the EIFR Regis-\nter before the interrupt is re-enabled.clk\nPCINT(n)\npin_lat\npin_sync\npcint_in_(n)\npcint_syn\npcint_setflag\nPCIFPCINT(0)\npin_syncpcint_synpin_lat\nD     Q\nLEpcint_setflag\nPCIF\nclk\nclk PCINT(0) in PCM SK(x)pcint_in_(0)\n0\nx\nB i t 76543210\n(0x69) I S C 3 1I S C 3 0I S C 2 1I S C 2 0I S C 1 1I S C 1 0I S C 0 1I S C 0 0 E I C R A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n114\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. n = 3, 2, 1or 0.\nWhen changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt \nEnable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.\n15.2.2 EICRB \u2013 External Interrupt Control Register B\n\u0081 Bits 7:0 \u2013 ISC71, ISC70 - ISC41, ISC40: External Interrupt 7 - 4 Sense Control Bits\nThe External Interrupts 7 - 4 are activated by the external pins INT7:4 if the SREG I-flag and the\ncorresponding interrupt mask in the EIMSK is set. The level and edges on the external pins thatactivate the interrupts are defined in Table 15-3 . The value on the INT7:4 pins are sampled\nbefore detecting edges. If edge or toggle interrupt is selected, pulses that last longer than one\nclock period will generate an interrupt. Shorter pulses are not guaranteed to generate an inter-rupt. Observe that CPU clock frequency can be lower than the XTAL frequency if the XTALdivider is enabled. If low level interrupt is se lected, the low level must be held until the comple-\ntion of the currently executing instruction to generate an interrupt. If enabled, a level triggered\ninterrupt will generate an interrupt request as long as the pin is held low.\nNote: 1. n = 7, 6, 5 or 4.\nWhen changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt \nEnable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.Table 15-1.  Interrupt Sense Control(1)\nISCn1 ISCn0 Description\n0 0 The low level of INTn generates an interrupt request\n0 1 Any edge of INTn generates asynchronously an interrupt request\n1 0 The falling edge of INTn generates asynchronously an interrupt request\n1 1 The rising edge of INTn generates asynchronously an interrupt request\nTable 15-2. Asynchronous External Interrupt Characteristics\nSymbol Parameter Condition Min Typ Max Units\ntINTMinimum pulse width for asynchronous \nexternal interrupt50 ns\nB i t 76543210\n(0x6A) ISC71 ISC70 ISC61 ISC60 ISC51 ISC50 ISC41 ISC40 EICRB\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 15-3.  Interrupt Sense Control(1)\nISCn1 ISCn0 Description\n0 0 The low level of INTn generates an interrupt request\n0 1 Any logical change on INTn generates an interrupt request1 0 The falling edge between two samples of INTn generates an interrupt request\n1 1 The rising edge between two samples of INTn generates an interrupt request\n\n115\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n15.2.3 EIMSK \u2013 External Interrupt Mask Register\n\u0081 Bits 7:0 \u2013 INT7:0: External Interrupt Request 7 - 0 Enable\nWhen an INT7:0 bit is written to one and the I-bit in the Status Register (SREG) is set (one), the\ncorresponding external pin interrupt is enabled. The Interrupt Sense Control bits in the External\nInterrupt Control Registers \u2013 EICRA and EICRB \u2013 defines whether the external interrupt is acti-\nvated on rising or fal ling edge or level sensed. Activity on  any of these pins will trigger an\ninterrupt request even if the pin is enabled as an output. This provides a way of generating a\nsoftware interrupt.\n15.2.4 EIFR \u2013 External Interrupt Flag Register\n\u0081 Bits 7:0 \u2013 INTF7:0: External Interrupt Flags 7 - 0\nWhen an edge or logic change on the INT7:0 pin triggers an interrupt request, INTF7:0 becomes\nset (one). If the I-bit in SREG and the corresponding interrupt enable bit, INT7:0 in EIMSK, are\nset (one), the MCU will jump  to the interrupt vector . The flag is cleared wh en the interr upt routine\nis executed. Alternatively, the flag can be cleared by writing a logical one to it. These flags arealways cleared when INT7:0 are configured as level interrupt. Note that when entering sleep\nmode with the INT3:0 inte rrupts disabled, the input buffers on these pins will be disabled. This\nmay cause a logic change in internal si gnals which will set the INTF3:0 flags. See \u201cDigital Input\nEnable and Sleep Modes\u201d on page 74  for more information.\n15.2.5 PCICR \u2013 Pin Change Interrupt Control Register\n\u0081 Bit 2 \u2013 PCIE2: Pin Change Interrupt Enable 1\nWhen the PCIE2 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 2 is enabled. Any change on any enabled PCINT23:16 pin will cause an inter-\nrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI2Interrupt Vector. PCINT23:16 pins are enabled individually by the PCMSK2 Register.\n\u0081 Bit 1 \u2013 PCIE1: Pin Change Interrupt Enable 1\nWhen the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 1 is enabled. Any change on any enabled PCINT15:8 pin will cause an inter-\nrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1Interrupt Vector. PCINT15:8 pins are enabled individually by the PCMSK1 Register.B i t 76543210\n0x1D (0x3D) INT7 INT6 INT5 INT4 INT3 INT2 INT1 INT0 EIMSK\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x1C (0x3C) INTF7 INTF6 INTF5 INTF4 INTF3 INTF2 INTF1 IINTF0 EIFR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210\n(0x68) \u2013 \u2013 \u2013 \u2013 \u2013 PCIE2 PCIE1 PCIE0 PCICR\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\n\n116\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 PCIE0: Pin Change Interrupt Enable 0\nWhen the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin\nchange interrupt 0 is enabled. Any change on any enabled PCINT7 :0 pin will cause an interrupt.\nThe corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt\nVector. PCINT7:0 pins are enabled individually by the PCMSK0 Register.\n15.2.6 PCIFR \u2013 Pin Change Interrupt Flag Register\n\u0081 Bit 2 \u2013 PCIF2: Pin Change Interrupt Flag 1\nWhen a logic change on any PCINT23:16 pin triggers an interrupt request, PCIF2 becomes set\n(one). If the I-bit in SREG and the PCIE2 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n\u0081 Bit 1 \u2013 PCIF1: Pin Change Interrupt Flag 1\nWhen a logic change on any PCINT15:8 pin trigge rs an interrupt request, PCIF1 becomes set\n(one). If the I-bit in SREG and the PCIE1 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n\u0081 Bit 0 \u2013 PCIF0: Pin Change Interrupt Flag 0\nWhen a logic change on any PCINT7:0 pin triggers an interrupt request, PCIF0 becomes set\n(one). If the I-bit in SREG and the PCIE0 bit in PCICR are set (one), the MCU will jump to the\ncorresponding Interrupt Vector. The flag is cleared  when the interrupt routine is executed. Alter-\nnatively, the flag can be cleared by writing a logical one to it.\n15.2.7 PCMSK2 \u2013 Pin Change Mask Register 2\n\u0081 Bit 7:0 \u2013 PCINT23:16: Pin Change Enable Mask 23:16\nEach PCINT23:16-bit selects whether pin change interrupt is enabled on the corresponding I/O\npin. If PCINT23:16 is set and the PCIE2 bit in PCICR is set, pin change interrupt is enabled on\nthe corresponding I/O pin. If PCINT23:16 is cleared, pin change interrupt on the corresponding\nI/O pin is disabled.\n15.2.8 PCMSK1 \u2013 Pin Change Mask Register 1B i t 76543210\n0x1B (0x3B) \u2013 \u2013 \u2013 \u2013 \u2013 PCIF2 PCIF1 PCIF0 PCIFR\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x6D)\nPCINT23 PCINT22 PCINT21 PCINT20 PCINT19 PCINT18 PCINT17 PCINT16 PCMSK2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x6C)\nPCINT15 PCINT14 PCINT13 PCINT12 PCINT11 PCINT10 PCINT9 PCINT8 PCMSK1\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n117\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7:0 \u2013 PCINT15:8: Pin Change Enable Mask 15:8\nEach PCINT15:8-bit selects whether pin change interrupt is enabled on the corresponding I/O\npin. If PCINT15:8 is set and the PCIE1 bit in EIMSK is set, pin change interrupt is enabled on the\ncorresponding I/O pin. If PCINT15:8 is cleared, pin change interrupt on the corresponding I/O\npin is disabled.\n15.2.9 PCMSK0 \u2013 Pin Change Mask Register 0\n\u0081 Bit 7:0 \u2013 PCINT7:0: Pin Change Enable Mask 7:0\nEach PCINT7:0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin.\nIf PCINT7:0 is set and the PCIE0 bit in PCICR is set, pin change interrupt is enabled on the cor-\nresponding I/O pin. If PCINT7:0 is cleared, pi n change interrupt on the corresponding I/O pin is\ndisabled.B i t 76543210\n(0x6B) PCINT7 PCINT6 PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 PCMSK0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n118\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16. 8-bit Timer/Counter0 with PWM\n16.1 Features\n\u0081Two Independent Output Compare Units\n\u0081Double Buffered Outp ut Compare Registers\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch Free, Phase Correct Pulse Width Modulator (PWM)\n\u0081Variable PWM Period\n\u0081Frequency Generator\n\u0081Three Independent Interrupt Sources (TOV0, OCF0A, and OCF0B)\n16.2 Overview\nTimer/Counter0 is a general purpose 8-bit Time r/Counter module, with two independent Output\nCompare Units, and with P WM support. It allows accurate program execution timing (event man-\nagement) and wave generation.\nA simplified block diagram of the 8-bit Timer/Counter is shown in Figure 16-1 . For the actual\nplacement of I/O pins, refer to \u201cTQFP-pinout ATmega640/1280/2560\u201d on page 2 . CPU accessi-\nble I/O Registers, including I/O bits and I/O pi ns, are shown in bold. The device-specific I/O\nRegister and bit locations are listed in the \u201cRegister Description\u201d on page 129 .\nFigure 16-1. 8-bit Timer/Counter Block Diagram \n16.2.1 Registers\nThe Timer/Counter (TCNT0) and Output Compare Registers (OCR0A and OCR0B) are 8-bit\nregisters. Interrupt request (abbreviated to Int.Req . in the figure) signals are all visible in the\nTimer Interrupt Flag Register (T IFR0). All interrupts are individually masked with the Timer Inter-\nrupt Mask Register (TIMSK0). TIFR0 and TIMSK0 are not shown in the figure.\nThe Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on\nthe T0 pin. The Clock Select logic block controls which clock source and edge the Timer/CounterClock Select\nTimer/Counter\nDATA BUSOCRnA\nOCRnB=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB=\nFixed\nTOP\nValueControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int.Req.)\nOCnA(Int.Req.)\nOCnB\n(Int.Req.)\nTCCRnA TCCRnBTnEdge\nDetector\n( From Prescaler )clkTn\n\n119\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nuses to increment (or decrement) its value. The Timer/Counter is inactive when no clock source\nis selected. The output from the Clock Select logic is referred to as the timer clock (clkT0).\nThe double buffered Output Compare Registers (OCR0A and OCR0B) are compared with the\nTimer/Counter value at all times. The result of the compare can be used by the Waveform Gen-\nerator to generate a P WM or variable frequency output on the Output Compare pins (OC0A and\nOC0B). See \u201cOutput Compare Unit\u201d on page 120.  for details. The Compare Match event will also\nset the Compare Flag (OCF0A or OCF0B) which can be used to generate an Output Compareinterrupt request.\n16.2.2 Definitions\nMany register and bit references in this section are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case 0. A lower case \u201cx\u201d replaces the Output Com-\npare Unit, in this case Compare Unit A or Compare Unit B. Howe ver, when using the register or\nbit defines in a program, the precise form must be used, that is, TCNT0 for accessing\nTimer/Counter0 counter value and so on.\nThe definitions in Table 16-1  are also used extensively throughout the document.\n16.3 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the Clock Select  logic which is controlled by the Clock Select (CS02:0) bits\nlocated in the Timer/Counter Control Register (TCCR0B). For details on clock sources and pres-\ncaler, see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169 .\n16.4 Counter Unit\nThe main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure\n16-2 shows a block diagram of the counter and its surroundings.\nFigure 16-2. Counter Unit Block DiagramTable 16-1. Definitions\nBOTTOM The counter reaches the BOTTOM when it becomes 0x00.\nMAX The counter reaches its MAXimum when it becomes 0xFF (decimal 255).TOP The counter reaches the TOP when it becomes equal to the highest value in the\ncount sequence. The TOP value can be assigned to be the fixed value 0xFF(MAX) or the value stored in the OCR0A Register. The assignment is depen-\ndent on the mode of operation.\nDATA BU S\nTCNTn Control LogiccountTOVn\n(Int.Req.)\nClock Select\ntopTnEdge\nDetector\n( From Prescaler )clkTn\nbottomdirectionclear\n\n120\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSignal description (internal signals):\ncount Increment or decrement TCNT0 by 1.\ndirection Select between increment and decrement.\nclear Clear TCNT0 (set all bits to zero).\nclkTn Timer/Counter clock, referred to as clkT0 in the following.\ntop Signalize that TCNT0 has  reached maximum value.\nbottom Signalize that TCNT0 has re ached minimum value (zero).\nDepending of the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock (clkT0). clkT0 can be generated from an external or internal clock source,\nselected by the Clock Select bits (CS02:0). When no clock source is selected (CS02:0 = 0) the\ntimer is stopped. However, the TCNT0 value can be accessed by the CPU, regardless of\nwhether clkT0 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the WGM01 and WGM00 bits located in\nthe Timer/Counter Control Register (TCCR0A) and the WGM02 bit located in the Timer/Counter\nControl Register B (TCCR0B). There are clos e connections between how the counter behaves\n(counts) and how waveforms are generated on the Output Compare outputs OC0A and OC0B.\nFor more details about advanced counting sequences and waveform generation, see \u201cModes of\nOperation\u201d on page 123 .\nThe Timer/Counter Overflow Flag (TOV0) is set according to the mode of operation selected by\nthe WGM02:0 bits. TOV0 can be used for generating a CPU interrupt.\n16.5 Output Compare Unit\nThe 8-bit comparator continuously compares TCNT0 with the Output Compare Registers\n(OCR0A and OCR0B). Whenever TCNT0 equals OCR0A or OCR0B, the comparator signals a\nmatch. A match will set the Output  Compare Flag (OCF0A or OCF0 B) at the next timer clock\ncycle. If the corresponding interrupt is enabled, the Output Compare Flag generates an OutputCompare interrupt. The Output Compare Flag is automatically cleared when the interrupt is exe-cuted. Alternatively, the flag can be cleared by software by writing a logical one to its I/O bit\nlocation. The Waveform Generator uses the match signal  to generate an output according to\noperating mode set by the WGM02:0 bits and Compare Output mode (COM0x1:0) bits. The\nmaximum and bottom signals are used by the Waveform Generator for handling the special\ncases of the extreme values in some modes of operation ( \u201cModes of Operation\u201d on page 123 ).\nFigure 16-3 on page 121  shows a block diagram of the Output Compare unit.\n\n121\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-3. Output Compare Unit, Block Diagram\nThe OCR0x Registers are double buffered when using any of the Pulse Width Modulation\n(PWM) modes. For the normal and Clear Timer on Compare (CTC) modes of operation, the dou-\nble buffering is disabled. The double buffering synchronizes the update of the OCR0x Compare\nRegisters to either top or bottom of the counting sequence. The synchronization prevents the\noccurrence of odd-length, non-symmetrical P WM pulses, thereby making the output glitch-free.\nThe OCR0x Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR0x Buffer Register, and if double buffering is dis-\nabled the CPU will access  the OCR0x directly.\n16.5.1 Force Output Compare\nIn non-P WM waveform generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Outp ut Compare (FOC0x) bit. Forcin g Compare Match will not set the\nOCF0x Flag or reload/clear the timer, but the OC0x pin will be updated as if a real Compare\nMatch had occurred (the COM0x1:0 bits settings de fine whether the OC0x pin is set, cleared or\ntoggled).\n16.5.2 Compare Match Bloc king by TCNT0 Write\nAll CPU write operations to the TCNT0 Register  will block any Compare Ma tch that occur in the\nnext timer clock cycle, even when the timer is stopped. This feature allows OCR0x to be initial-\nized to the same value as TCNT0 without triggering an interrupt when the Timer/Counter clock isenabled.\n16.5.3 Using the Output Compare Unit\nSince writing TCNT0 in any mo de of operation will block all Compare Matches for one timer\nclock cycle, there are risks involved when ch anging TCNT0 when using the Output Compare\nUnit, independently of whether the Timer/Counter is running or not. If the value written to TCNT0equals the OCR0x value, the Compare Match will be missed, resulting in incorrect waveformOCFn x (Int.Req.)= (8-bit Comparator )OCRnx\nOCnxDATA BU S\nTCNTn\nWGMn1:0Waveform Generatortop\nFOCn\nCOMnX1:0bottom\n\n122\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ngeneration. Similarly, do not write the TCNT0 value equal to BOTTOM when the counter is\ndown-counting.\nThe setup of the OC0x should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OC0x value is to use the Force Output Com-pare (FOC0x) strobe bits in Normal mode. The OC0x Registers keep their values even when\nchanging between Waveform Generation modes.\nBe aware that the COM0x1:0 bits are not doubl e buffered together with the compare value.\nChanging the COM0x1:0 bits will take effect immediately.\n16.6 Compare Match Output Unit\nThe Compare Output mode (COM0x1:0) bits have two functions. The Waveform Generator uses\nthe COM0x1:0 bits for defining the Output Compare (OC0x) state at the next Compare Match.Also, the COM0x1:0 bits control the OC0x pin output source. Figure 16-4  shows a simplified\nschematic of the logic affected by the COM0x1:0 bit setting. The I/O Registers, I/O bits, and I/O\npins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers(DDR and PORT) that are affected by the COM0x1:0 bits are shown. When referring to the\nOC0x state, the reference is for the internal OC0x  Register, not the OC0x pin. If a system reset\noccur, the OC0x Register is reset to \u201c0\u201d.\nFigure 16-4. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC0x) from the Waveform\nGenerator if either of the COM0x1:0 bits are set. However, the OC0x pin direction (input or out-put) is still controlled by the Da ta Direction Register (DDR) for th e port pin. The Data Direction\nRegister bit for the OC0x pin (DDR_OC0x) must be set as output before the OC0x value is visi-\nble on the pin. The port override  function is independent of the Waveform Generation mode.\nThe design of the Output Compare pin logic allows initialization of the OC0x state before the out-\nput is enabled. Note that some COM0x1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 129 .PORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCn\nclkI/O\n\n123\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.6.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COM0x1:0 bits differently in Normal, CTC, and P WM modes.\nFor all modes, setting the COM0x1:0 = 0 tells the Waveform Generator that no action on the\nOC0x Register is to be performed on the next Compare Match. For compare output actions in\nthe non-P WM modes refer to Table 16-2 on page 129 . For fast P WM mode, refer to Table 16-3\non page 129 , and for phase correct P WM refer to Table 16-4 on page 130 .\nA change of the COM0x1:0 bits state will have effe ct at the first Compare Match after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOC0x strobe bits.\n16.7 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode ( WGM02:0) and Compare Out-\nput mode (COM0x1:0) bits. The Compare Output mode bits do not affect the counting sequence,while the Waveform Generation mode bits do. The COM0x1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COM0x1:0 bits control whether the output should be set, cleared, or toggled at a CompareMatch. See \u201cCompare Match Output Unit\u201d on page 147.\nFor detailed timing information see \u201cTimer/Counter Timing Diagrams\u201d on page 127 .\n16.7.1 Normal Mode\nThe simplest mode of operation is the Normal mode ( WGM02:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 8-bit value (TOP = 0xFF) and then restarts from the bot-\ntom (0x00). In normal o peration the Timer/Counter Overflow Flag (TOV0) will be set in the same\ntimer clock cycle as the TCNT0 becomes zero. The TOV0 Flag in this case behaves like a ninth\nbit, except that it is only set, not cleared. However, combined with the timer overflow interrupt\nthat automatically clears the TOV0 Flag, the timer resolution can be increased by software.\nThere are no special cases to consider in the Normal mode, a new counter value can be writtenanytime.\nThe Output Compare Unit can be used to generate interrupts at some given time. Using the Out-\nput Compare to generate waveforms in Normal mode is not recommended, since this will\noccupy too much of the CPU time.\n16.7.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare or CTC mode ( WGM02:0 = 2), the OCR0A Register is used to\nmanipulate the counter resolution. In CTC mode the counter is cleared to zero when the counter\nvalue (TCNT0) matches the OCR0A. The OCR0A defines the top value for the counter, hence\nalso its resolution. This mode allows greater control of the Compare Match output frequency. Italso simplifies the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 16-5 on page 124 . The counter value\n(TCNT0) increases until a Compare Match occurs between TCNT0 and OCR0A, and then coun-ter (TCNT0) is cleared.\n\n124\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-5. CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter value reaches the TOP value by using the\nOCF0A Flag. If the interrupt is enabled, the interrupt handler routine can be used for updating\nthe TOP value. However, changing TOP to a va lue close to BOTTOM when the counter is run-\nning with none or a low prescaler value must be done with care since the CTC mode does nothave the double buffering feature. If the new value written to OCR0A is lower than the current\nvalue of TCNT0, the counter will miss the Compar e Match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starting at 0x00 before the Compare Match canoccur.\nFor generating a waveform output in CTC mode, the OC0A output can be set to toggle its logical\nlevel on each Compare Match by setting the Compare Output mode bits to toggle mode(COM0A1:0 = 1). The OC0A value will not be visible on the port pin unless the data direction for\nthe pin is set to output. The waveform ge nerated will have a ma ximum frequency of f\nOC0 =\nfclk_I/O /2 when OCR0A is set to zero (0x00). The waveform frequency is defined by the following\nequation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOV0 Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x00.\n16.7.3 Fast PWM Mode\nThe fast Pulse Width Modulation or fast P WM mode ( WGM02:0 = 3 or 7) provides a high fre-\nquency P WM waveform generation option. The fast P WM differs from the other P WM option by\nits single-slope operation. The counter counts from BOTTOM to TOP then restarts from BOT-\nTOM. TOP is defined as 0xFF when WGM2:0 = 3, and OCR0A when WGM2:0 = 7. In non-\ninverting Compare Output mode, the Output Compare (OC0x) is cleared on the Compare Match\nbetween TCNT0 and OCR0x, and set at BOTTOM. In inverting Compare Output mode, the out-\nput is set on Compare Match and cleared at BOTTOM. Due to the single-slope operation, theoperating frequency of the fast P WM mode can be twice as high as the phase correct P WM\nmode that use dual-slope operation. This high frequency makes the fast P WM mode well suited\nfor power regulation, rectification, and DAC app lications. High frequency a llows physically small\nsized external components (coils, capacitors), and therefore reduces total system cost.\nIn fast P WM mode, the counter is incremented until the counter value matches the TOP value.\nThe counter is then cleared at the following timer clock cycle. The timing diagram for the fastPWM mode is shown in Figure 16-6 . The TCNT0 value is in the timing diagram shown as a his-TCNTn\nOCn\n(Toggle)OCnx Interrupt Flag Set\n1 4 Period 2 3(COMnx1:0 = 1)\nfOCnxfclk_I/O\n2N1OCRnx+() \u22c5\u22c5------------------------------------------------- - =\n\n125\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ntogram for illustrating the single-slope operation. The diagram includes non-inverted and\ninverted P WM outputs. The small horizontal line marks on the TCNT0 slopes represent Com-\npare Matches between OCR0x and TCNT0.\nFigure 16-6. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each time the counter reaches TOP. If the inter-\nrupt is enabled, the interrupt handler routine can be used for updating the compare value.\nIn fast P WM mode, the compare unit allows generation of P WM waveforms on the OC0x pins.\nSetting the COM0x1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COM0x1:0 to three: Setting the COM0A1:0 bits to one allows\nthe OC0A pin to toggle on Compare Matches if the WGM02 bit is set. This option is not available\nfor the OC0B pin (see Table 16-3 on page 129 ). The actual OC0x value will only be visible on\nthe port pin if the data direction for the port pin is set as output. The P WM waveform is gener-\nated by setting (or clearing) the OC0x Register at the Compare Match between OCR0x and\nTCNT0, and clearing (or setting) the OC0x Regist er at the timer clock cycle the counter is\ncleared (changes from TOP to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Register represents special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCR0A is set equal to BOTTOM, the output will\nbe a narrow spike for each MAX+1 timer clock cycle. Setting the OCR0A equal to MAX will resultin a constantly high or low output (depending on the polarity of the output set by the COM0A1:0\nbits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OC0x to toggle its logical level on each Compare Match (COM0x1:0 = 1). The waveformgenerated will have a maximum frequency of f\nOC0 = fclk_I/O /2 when OCR0A is set to zero. This\nfeature is similar to the OC0A toggle in CTC mode, except the double buffer feature of the Out-\nput Compare unit is enabled in the fast P WM mode.TCNTnOCRnx Update and\nTOVn Interrupt Flag Set\n1 Period 2 3OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Interrupt Flag Set\n4 5 6 7\nfOCnxPWMfclk_I/O\nN256\u22c5------------------=\n\n126\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.7.4 Phase Correct PWM Mode\nThe phase correct P WM mode ( WGM02:0 = 1 or 5) provides a high resolution phase correct\nPWM waveform generation option. The phase correct P WM mode is based on a dual-slope\noperation. The counter counts repeatedly from BOTTOM to TOP and then from TOP to BOT-\nTOM. TOP is defined as 0xFF when WGM2:0 = 1, and OCR0A when WGM2:0 = 5. In non-\ninverting Compare Output mode, the Output Compare (OC0x) is cleared on the Compare Matchbetween TCNT0 and OCR0x while upcounting, and set on the Compare Match while down-\ncounting. In inverting Output Compare mode, the operation is inverted. The dual-slope operation\nhas lower maximum operation frequency than single slope operation. However, due to the sym-metric feature of the dual-slope P WM modes, these modes are preferred for motor control\napplications.\nIn phase correct P WM mode the counter is incremented until the counter value matches TOP.\nWhen the counter reaches TOP, it changes the count direction. The TCNT0 value will be equal\nto TOP for one timer clock cycle. The timing diagram for the phase correct P WM mode is shown\non Figure 16-7 . The TCNT0 value is in the timing diagram shown as a histogram for illustrating\nthe dual-slope operation. The diagram includes non-inverted and inverted P WM outputs. The\nsmall horizontal line marks on the TCNT0 slop es represent Compare Matches between OCR0x\nand TCNT0.\nFigure 16-7. Phase Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each time the counter reaches BOTTOM. The\nInterrupt Flag can be used to generate an interrupt each time the counter reaches the BOTTOM\nvalue.\nIn phase correct P WM mode, the compare unit allows generation of P WM waveforms on the\nOC0x pins. Setting the COM0x1:0 bits to two will produce a non-inverted P WM. An inverted\nPWM output can be generated by setting the COM0x1:0 to three: Setting the COM0A0 bits to\none allows the OC0A pin to toggle on Compare Matches if the WGM02 bit is set. This option is\nnot available for the OC0B pin (see Table 16-4 on page 130 ). The actual OC0x value will only be\nvisible on the port pin if the data direction for the port pin is set as output. The P WM waveform isTOVn Interrupt Flag SetOCnx Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Update\n\n127\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ngenerated by clearing (or setting) the OC0x Register at the Compare Match between OCR0x\nand TCNT0 when the counter increments, and setti ng (or clearing) the OC0x Register at Com-\npare Match between OCR0x and TCNT0 when the counter decrements. The P WM frequency for\nthe output when using phase correct P WM can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCR0A is set equal to BOTTOM, the\noutput will be continuously low an d if set equal to MAX the output  will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have th e opposite logic values.\nAt the very start of period 2 in Figure 16-7 on page 126  OCnx has a transition from high to low\neven though there is no Compare Match. The poin t of this transition is to guarantee symmetry\naround BOTTOM. There are two cases that give a transition without Compare Match.\n\u0081 OCR0A changes its value from MAX, like in Figure 16-7 on page 126 . When the OCR0A \nvalue is MAX the OCn pin value is the same as the result of a down-counting Compare Match. To ensure symmetry around BOTTOM the OCn value at MAX must correspond to the result of an up-counting Compare Match.\n\u0081 The timer starts counting from a value higher than the one in OCR0A, and for that reason \nmisses the Compare Match and hence the OCn change that would have happened on the way up.\n16.8 Timer/Counter Timing Diagrams\nThe Timer/Counter is a synchronous design and the timer clock (clkT0) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when Interrupt\nFlags are set. Figure 16-8  contains timing data for basic Timer/Counter operation. The figure\nshows the count sequence close to the MAX va lue in all modes other than phase correct P WM\nmode.\nFigure 16-8. Timer/Counter Timing Diagram, no Prescaling\nFigure 16-9 on page 128  shows the same timing data, but with the prescaler enabled.fOCnxPCPWMfclk_I/O\nN510\u22c5------------------=\nclkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\n\n128\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 16-9. Timer/Counter Timing Dia gram, with Prescaler (fclk_I/O /8)\nFigure 16-10  shows the setting of OCF0B in all modes and OCF0A in all modes except CTC\nmode and P WM mode, where OCR0A is TOP.\nFigure 16-10. Timer/Counter Timing Diagram, Setting of OCF0x, with Prescaler (fclk_I/O /8)\nFigure 16-11  shows the setting of OCF0A and the clearing of TCNT0 in CTC mode and fast\nPWM mode where OCR0A is TOP.\nFigure 16-11. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Pres-\ncaler (fclk_I/O /8)TOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n129\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9 Register Description\n16.9.1 TCCR0A \u2013 Timer/Counter Control Register A\n\u0081 Bits 7:6 \u2013 COM0A1:0: Compare Match Output A Mode\nThese bits control the Output Compare pin (OC0A) behavior. If one or both of the COM0A1:0\nbits are set, the OC0A output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction R egister (DDR) bit corresponding to the OC0A pin\nmust be set in order to enable the output driver.\nWhen OC0A is connected to the pin, the f unction of the COM0A1:0 bits depends on the\nWGM02:0 bit setting. Table 16-2  shows the COM0A1:0 bit functionality when the WGM02:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 16-3  shows the COM0A1:0 bit functionality when the WGM01:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 124  for more details.\nTable 16-4 on page 130  shows the COM0A1:0 bit functionality when the WGM02:0 bits are set\nto phase correct P WM mode.Bit 7 6 5 4 3 2 1 0\n0x24 (0x44) COM0A1 COM0A0 COM0B1 COM0B0 \u2013 \u2013 WGM01 WGM00 TCCR0A\nRead/Write R/ W R/W R/W R/W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 16-2. Compare Output Mode, non-P WM Mode\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n0 1 Toggle OC0A on Compare Match\n1 0 Clear OC0A on Compare Match1 1 Set OC0A on Compare Match\nTable 16-3. Compare Output Mode, Fast P WM Mode(1)\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n01WGM02 = 0: Normal Port Operation, OC0A Disconnected\nWGM02 = 1: Toggle OC0A on Compare Match\n10Clear OC0A on Compare Match, set OC0A at BOTTOM\n(non-inverting mode)\n11Set OC0A on Compare Match, clear OC0A at BOTTOM\n(inverting mode)\n\n130\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. A special case occurs when OCR0A equals TOP and COM0A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 126  for more details.\n\u0081 Bits 5:4 \u2013 COM0B1:0: Compare Match Output B Mode\nThese bits control the Output Compare pin (OC0B) behavior. If one or both of the COM0B1:0\nbits are set, the OC0B output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction R egister (DDR) bit corresponding to the OC0B pin\nmust be set in order to enable the output driver.\nWhen OC0B is connected to the pin, the function of the COM0B1:0 bits depends on the\nWGM02:0 bit setting. Table 16-5  shows the COM0B1:0 bit functionality when the WGM02:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 16-6  shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 124  for more details.Table 16-4. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM0A1 COM0A0 Description\n0 0 Normal port operation, OC0A disconnected\n01WGM02 = 0: Normal Port Operation, OC0A Disconnected\nWGM02 = 1: Toggle OC0A on Compare Match\n10Clear OC0A on Compare Match when up-counting. Set OC0A on \nCompare Match when down-counting\n11Set OC0A on Compare Match when up-counting. Clear OC0A on \nCompare Match when down-counting\nTable 16-5. Compare Output Mode, non-P WM Mode\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected\n0 1 Toggle OC0B on Compare Match1 0 Clear OC0B on Compare Match\n1 1 Set OC0B on Compare Match\nTable 16-6. Compare Output Mode, Fast P WM Mode(1)\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected01 R e s e r v e d\n10Clear OC0B on Compare Match, set OC0B at BOTTOM\n(non-inverting mode)\n11Set OC0B on Compare Match, clear OC0B at BOTTOM\n(inverting mode)\n\n131\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 16-7  shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to phase cor-\nrect PWM mode.\nNote: 1. A special case occurs when OCR0B equals TOP and COM0B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 126  for more details.\n\u0081 Bits 3, 2 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 1:0 \u2013 WGM01:0: Waveform Generation Mode\nCombined with the WGM02 bit found in the TCCR0B Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 16-8 . Modes of operation supported by the Timer/Counter\nunit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types ofPulse Width Modulation (P WM) modes (see \u201cModes of Operation\u201d on page 148 ).\nNote: 1. MAX        = 0xFF \n2. BOTTOM = 0x00Table 16-7. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM0B1 COM0B0 Description\n0 0 Normal port operation, OC0B disconnected\n01 R e s e r v e d\n10Clear OC0B on Compare Match when up-counting. Set OC0B on \nCompare Match when down-counting\n11Set OC0B on Compare Match when up-counting. Clear OC0B on \nCompare Match when down-counting\nTable 16-8. Waveform Generation Mode Bit Description\nMode WGM2 WGM1 WGM0Timer/Counter \nMode of \nOperation TOPUpdate of\nOCRx atTOV Flag\nSet on(1)(2)\n0 0 0 0 Normal 0xFF Immediate MAX\n1 001PWM, Phase \nCorrect0xFF TOP BOTTOM\n2 010 C T C O C R A I m m e d i a t e M A X\n3 011 F a s t  P WM 0xFF TOP MAX\n4 100 R e s e r v e d \u2013 \u2013 \u2013\n5 101PWM, Phase \nCorrectOCRA TOP BOTTOM\n6 110 R e s e r v e d \u2013 \u2013 \u2013\n7 111 F a s t  P WM OCRA BOTTOM TOP\n\n132\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9.2 TCCR0B \u2013 Timer/Counter Control Register B\n\u0081 Bit 7 \u2013 FOC0A: Force Output Compare A\nThe FOC0A bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR0B is written when operating in P WM mode. When writing a logical one to the FOC0A bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC0A output is\nchanged according to its COM0A1:0 bits setting. Note that the FOC0A bit is implemented as a\nstrobe. Therefore it is the value present in the COM0A1:0 bits that determines the effect of theforced compare.\nA FOC0A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR0A as TOP.\nThe FOC0A bit is always read as zero.\n\u0081 Bit 6 \u2013 FOC0B: Force Output Compare B\nThe FOC0B bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR0B is written when operating in P WM mode. When writing a logical one to the FOC0B bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC0B output is\nchanged according to its COM0B1:0 bits setting. Note that the FOC0B bit is implemented as a\nstrobe. Therefore it is the value present in the COM0B1:0 bits that determines the effect of theforced compare.\nA FOC0B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR0B as TOP.\nThe FOC0B bit is always read as zero.\n\u0081 Bits 5:4 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 3 \u2013 WGM02: Waveform Generation Mode\nSee the description in the \u201cTCCR0A \u2013 Timer/Counter Control Register A\u201d on page 129 .\n\u0081 Bits 2:0 \u2013 CS02:0: Clock Select\nThe three Clock Select bits select the clock source to be used by the Timer/Counter, see Table\n16-9 on page 133 .Bit 7 6 5 4 3 2 1 0\n0x25 (0x45) FOC0A FOC0B \u2013 \u2013 WGM02 CS02 CS01 CS00 TCCR0B\nRead/Write WW RR R / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n133\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n16.9.3 TCNT0 \u2013 Timer/Counter Register\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter. Writing to the TCNT0 Register blocks (removes) the Compare\nMatch on the following timer clock. Modifying the counter (TCNT0) while the counter is running,introduces a risk of missing a Compare Match between TCNT0 and the OCR0x Registers.\n16.9.4 OCR0A \u2013 Output Compare Register A\nThe Output Compare Register A contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT0). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OC0A pin.\n16.9.5 OCR0B \u2013 Output Compare Register B\nThe Output Compare Register B contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT0). A match can be used to generate an Output Compare interrupt, or to\ngenerate a waveform output on the OC0B pin.Table 16-9. Clock Select Bit Description \nCS02 CS01 CS00 Description\n0 0 0 No clock source (Timer/Counter stopped)\n001 c l kI/O/(No prescaling)\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on T0 pin. Clock on falling edge1 1 1 External clock source on T0 pin. Clock on rising edge\nB i t 76543210\n0x26 (0x46) TCNT0[7:0] TCNT0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x27 (0x47) OCR0A[7:0] OCR0A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x28 (0x48) OCR0B[7:0] OCR0B\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n134\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n16.9.6 TIMSK0 \u2013 Timer/Counter Interrupt Mask Register\n\u0081 Bits 7:3, 0 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 2 \u2013 OCIE0B: Timer/Counter Output Compare Match B Interrupt Enable\nWhen the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter Compare Match B interrupt is enab led. The corresponding interrupt is executed if\na Compare Match in Timer/Counter occurs, that is, when the OCF0B bit is set in the\nTimer/Counter Interrupt Flag Register \u2013 TIFR0.\n\u0081 Bit 1 \u2013 OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable\nWhen the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter0 Compare Match A interrupt is enabled. The corresponding interrupt is executed\nif a Compare Match in Timer/Counter0 occurs, that is, when the OCF0A bit is set in the\nTimer/Counter 0 Interrupt Flag Register \u2013 TIFR0.\n\u0081 Bit 0 \u2013 TOIE0: Timer/Counter0 Overflow Interrupt Enable\nWhen the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the\nTimer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter0 occurs, that is, when the TOV0 bit is set in the Timer/Counter 0 Inter-\nrupt Flag Register \u2013 TIFR0.\n16.9.7 TIFR0 \u2013 Timer/Counter 0 Interrupt Flag Register\n\u0081 Bits 7:3, 0 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 2 \u2013 OCF0B: Timer/Counter 0 Output Compare B Match Flag\nThe OCF0B bit is set when a Compare Match occurs between the Timer/Counter and the data in\nOCR0B \u2013 Output Compare Register0 B. OCF0B is cleared by hardware when executing the cor-\nresponding interrupt handling vector. Alternatively, OCF0B is cleared by writing a logic one to\nthe flag. When the I-bit in SREG, OCIE0B (Timer/Counter Compare B Match Interrupt Enable),\nand OCF0B are set, the Timer/Counter Compare Match Interrupt is executed.\n\u0081 Bit 1 \u2013 OCF0A: Timer/Counter 0 Output Compare A Match Flag\nThe OCF0A bit is set when a Compare Match occurs between the Timer/Counter0 and the data\nin OCR0A \u2013 Output Compare Register0. OCF0A is cleared by hardware when executing the cor-\nresponding interrupt handling vector. Alternativel y, OCF0A is cleared by writing a logic one to\nthe flag. When the I-bit in SREG, OCIE0A (Timer/Counter0 Compare Match Interrupt Enable),\nand OCF0A are set, the Timer/Counter0 Compare Match Interrupt is executed.B i t 76543210\n(0x6E) \u2013 \u2013 \u2013 \u2013 \u2013 OCIE0B OCIE0A TOIE0 TIMSK0\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x15 (0x35) \u2013\u2013\u2013\u2013\u2013 O C F 0 B O C F 0 A\nTOV0 TIFR0\nRead/Wr i t e RRRRR R / W R/W R/W\nI n i t i a l  V a l u e00000000\n\n135\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TOV0: Timer/Counter0 Overflow Flag\nThe bit TOV0 is set when an overflow occurs in  Timer/Counter0. TOV0 is cleared by hardware\nwhen executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by\nwriting a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt\nEnable), and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed.\nThe setting of this flag is dependent of the WGM02:0 bit setting. Refer to Table 16-8 , \u201cWaveform\nGeneration Mode Bit Description\u201d on page 131 .\n\n136\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17. 16-bit Timer/Counter (Timer/Counter 1, 3, 4, and 5)\n17.1 Features\n\u0081True 16-bit Design (that is, allows 16-bit PWM)\n\u0081Three independent Output Compare Units\n\u0081Double Buffered Outp ut Compare Registers\n\u0081One Input Capture Unit\n\u0081Input Capture Noise Canceler\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch-free, Phase Correct Pu lse Width Modulator (PWM)\n\u0081Variable PWM Period\n\u0081Frequency Generator\n\u0081External Event Counter\n\u0081Twenty independent interrupt sources (TOV1, OCF1A, OCF1B, OCF1C,  ICF1, TOV3, OCF3A, \nOCF3B, OCF3C, ICF3, TOV4, OCF4A, OCF4B, OCF4C, ICF4, TOV5, OCF5A, OCF5B, OCF5C and ICF5)\n17.2 Overview\nThe 16-bit Timer/Counter unit allows accurate program execution timing (event management),\nwave generation, and signal timing measurement.\nMost register and bit references in this sect ion are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, and a lower case \u201cx\u201d replaces the Output Compare unit\nchannel. However, when using the register or bit defines in a program, the precise form must beused, that is, TCNT1 for accessing Timer/Counter1 counter value and so on.\nA simplified block diagram of the 16-bit Timer/Counter is shown in Figure 17-1 on page 137 . For\nthe actual placement of I/O pins, see \u201cTQFP-pinout ATmega640/1280/2560\u201d on page 2  and\n\u201cPinout ATmega1281/2561\u201d on page 4 . CPU accessible I/O Registers,  including I/O bits and I/O\npins, are shown in bold. The device-specific I /O Register and bit locations are listed in the \u201cReg-\nister Description\u201d on page 158 .\nThe Power Reduction Timer/Counter1 bit, PRTIM1, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be written to zero to enable Timer/Counter1 module.\nThe Power Reduction Timer/Counter3 bit, PRTIM3, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter3 module.\nThe Power Reduction Timer/Counter4 bit, PRTIM4, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter4 module.\nThe Power Reduction Timer/Counter5 bit, PRTIM5, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be written to zero to enable Timer/Counter5 module.\nTimer/Counter4 and Timer/Counter5 only have full functionality in the ATmega640/1280/2560.\nInput capture and output compare are not available in the ATmega1281/2561.\n\n137\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-1. 16-bit Timer/Counter Block Diagram(1)\nNote: 1. Refer to Figure 1-1 on page 2 , Table 13-5 on page 79 , and Table 13-11 on page 83  for\nTimer/Counter1 and 3 and 3 pin placement and description.\n17.2.1 Registers\nThe Timer/Counter (TCNTn), Output Compare Registers (OCRnA/B/C), and Input Capture Reg-\nister (ICRn) are all 16-bit registers. Special procedures must be followed when accessing the 16-bit registers. These procedures are described in the section \u201cAccessing 16-bit Registers\u201d on\npage 138 . The Timer/Counter Control Registers (T CCRnA/B/C) are 8-bit registers and have no\nCPU access restrictions. Interrupt requests (short en as Int.Req.) signals are all visible in the\nTimer Interrupt Flag Register (T IFRn). All interrupts are individually masked with the Timer Inter-\nrupt Mask Register (TIMSKn). TIFRn and TIMSKn are not shown in the figure since these\nregisters are shared by other timer units.\nThe Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on\nthe Tn pin. The Clock Select logic block controls which clock source and edge the Timer/Counter\nuses to increment (or decrement) its value. The Timer/Counter is inactive when no clock sourceis selected. The output from the clock select logic is referred to as the timer clock (clk\nTn).\nThe double buffered Output Compare Registers (OCRnA/B/C) are compared with the\nTimer/Counter value at all time. The result of the compare can be used by the Waveform Gener-\nator to generate a P WM or variable frequency output on the Output Compare pin (OCnA/B/C).ICFn  (Int.Req.)TOVn\n(Int.Req.)\nClock Select\nTimer/CounterDATABUS\nICRn=\n==TCNTn\nWaveform\nGeneration\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB\nOCnC\nNoise\nCanceler\nICPn=\nFixed\nTOP\nValues\nEdge\nDetectorControl Logic\n= 0TOP BOTTOMCount\nClear\nDirection\nOCFnA\n(Int.Req.)\nOCFnB(Int.Req.)\nOCFnC\n(Int.Req.)\nTCCRnA TCCRnB TCCRnC( From Analog\nComparator Ouput )TnEdge\nDetector\n( From Prescaler )TCLK\nOCRnCOCRnBOCRnA\n\n138\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSee \u201cOutput Compare Units\u201d on page 145.  The compare match event will also set the Compare\nMatch Flag (OCFnA/B/C) which can be used to generate an Output Compare interrupt request.\nThe Input Capture Register can capture the Timer/ Counter value at a given external (edge trig-\ngered) event on either the Input Capture pin (ICPn) or on the Analog Comparator pins (see \u201cAC\n\u2013 Analog Comparator\u201d on page 271 ). The Input Capture unit incl udes a digital filtering unit\n(Noise Canceler) for reducing the chance of capturing noise spikes.\nThe TOP value, or maximum Timer/Counter value, can in some modes of operation be defined\nby either the OCRnA Register, the ICRn Register, or by a set of fixed values. When using\nOCRnA as TOP value in a P WM mode, the OCRnA Register can not be used for generating a\nPWM output. However, the TOP va lue will in this case be doub le buffered allowing the TOP\nvalue to be changed in run time. If a fixed TOP value is required, the ICRn Register can be used\nas an alternative, freeing the OCRnA to be used as P WM output.\n17.2.2 Definitions\nThe following definitions are used extensively throughout the document:\n17.3 Accessing 16-bit Registers\nThe TCNTn, OCRnA/B/C, and ICRn are 16-bit registers that can be accessed by the AVR CPU\nvia the 8-bit data bus. The 16-bit register must be byte accessed using two read or write opera-tions. Each 16-bit timer has a single 8-bit register for temporary storing of the high byte of the 16-\nbit access. The same Temporary Register is shared between all 16-bit registers within each 16-\nbit timer. Accessing the low byte triggers the 16-bit read or write operation. When the low byte of\na 16-bit register is written by the CPU, the high byte stored in the Temporary Register, and thelow byte written are both copied into the 16-bit register in the same clock cycle. When the low\nbyte of a 16-bit register is read by the CPU, the high byte of the 16-bit register is copied into the\nTemporary Register in the same clock cycle as the low byte is read.\nNot all 16-bit accesses uses the Temporary Regi ster for the high byte. Reading the OCRnA/B/C\n16-bit registers does not involve using the Temporary Register.\nTo do a 16-bit write, the high byte must be written before the low byte. For a 16-bit read, the low\nbyte must be read before the high byte.\nThe following code examples show how to access the 16-bit timer registers assuming that no\ninterrupts updates the temporary register. The same principle can be used directly for accessingthe OCRnA/B/C and ICRn Registers. Note that when using \u201cC\u201d, the compiler handles the 16-bit\naccess.Table 17-1. Definitions\nBOTTOM The counter reaches the BOTTOM  when it becomes 0x0000.\nMAX The counter reaches its MAX imum when it becomes 0xFFFF (decimal 65535).\nTOP The counter reaches the TOP when it becomes equal to the highest value in the\ncount sequence. The TOP value can be assigned to be one of the fixed values:\n0x00FF, 0x01FF, or 0x03FF, or to the value stored in the OCRnA or ICRn Reg-ister. The assignment is dependent of the mode of operation.\n\n139\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example returns the TCNTn value in the r17:r16 register pair.\nIt is important to notice that accessing 16-bit registers are atomic operations. If an interrupt\noccurs between the two instructions accessing the 16-bit register, and the interrupt codeupdates the temporary register by accessing the same or any other of the 16-bit Timer Regis-\nters, then the result of the a ccess outside the interrupt will be corrupted. Theref ore, when both\nthe main code and the interrupt code update the temporary register, the main code must disablethe interrupts during the 16-bit access.\nThe following code examples show how to do an atomic read of the TCNTn Register contents.\nReading any of the OCRnA/B/C or ICRn Registers can be done by using the same principle.Assembly Code Examples\n(1)\n...\n; Set TCNTn to 0x01FF\nldir17,0x01\nldir16,0xFF\noutTCNTnH,r17\noutTCNTnL,r16\n; Read TCNTn into r17:r16\ninr16,TCNTnL\ninr17,TCNTnH\n...\nC Code Examples(1)\nunsigned int  i;\n...\n/* Set TCNTn to 0x01FF */\nTCNTn = 0x1FF;/* Read TCNTn into i */\ni = TCNTn;\n...\n\n140\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example returns the TCNTn value in the r17:r16 register pair.Assembly Code Example(1)\nTIM16_ReadTCNTn:\n; Save global interrupt flag\ninr18,SREG\n; Disable interrupts\ncli\n; Read TCNTn into r17:r16inr16,TCNTnL\ninr17,TCNTnH\n; Restore global interrupt flagoutSREG,r18\nret\nC Code Example(1)\nunsigned  int TIM16_ReadTCNTn( void )\n{\nunsigned  char sreg;\nunsigned  int i;\n/* Save global interrupt flag */\nsreg = SREG;\n/* Disable interrupts */__disable_interrupt();\n/* Read TCNTn into i */\ni = TCNTn;/* Restore global interrupt flag */\nSREG = sreg;\nreturn i;\n}\n\n141\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code examples show how to do an atomic write of the TCNTn Register contents.\nWriting any of the OCRnA/B/C or ICRn Registers can be done by using the same principle.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe assembly code example requires that the r17:r16 register pair contains the value to be writ-\nten to TCNTn.\n17.3.1 Reusing the Temporary High Byte Register\nIf writing to more than one 16-bit register where the high byte is the same for all registers written,\nthen the high byte only needs to be written once. However, note that the same rule of atomicoperation described previously also applies in this case.\n17.4 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the Clock Select logic which is controlled by the Clock Select  (CSn2:0) bits\nlocated in the Timer/Counter control Register B  (TCCRnB). For details on clock sources and\nprescaler, see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169 .Assembly Code Example(1)\nTIM16_WriteTCNTn:\n; Save global interrupt flag\ninr18,SREG\n; Disable interruptscli\n; Set TCNTn to r17:r16\noutTCNTnH,r17\noutTCNTnL,r16\n; Restore global interrupt flag\noutSREG,r18\nret\nC Code Example(1)\nvoid TIM16_WriteTCNTn( unsigned  int i )\n{\nunsigned  char sreg;\nunsigned  int i;\n/* Save global interrupt flag */sreg = SREG;\n/* Disable interrupts */\n__disable_interrupt();/* Set TCNTn to i */\nTCNTn = i;\n/* Restore global interrupt flag */SREG = sreg;\n}\n\n142\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.5 Counter Unit\nThe main part of the 16-bit Timer/Counter is th e programmable 16-bit bi-directional counter unit.\nFigure 17-2  shows a block diagram of the counter and its surroundings.\nFigure 17-2. Counter Unit Block Diagram\nSignal description (internal signals):\nCount Increment or decrement TCNTn by 1.\nDirection Select between increment and decrement.\nClear Clear TCNTn (set all bits to zero).\nclkTn Timer/Counter clock.\nTOP Signalize that TCNTn has  reached maximum value.\nBOTTOM Signalize that TCNTn has re ached minimum value (zero).\nThe 16-bit counter is mapped into two 8-bit I/O memory locations: Counter High  (TCNTnH) con-\ntaining the upper eight bits of the counter, and Counter Low  (TCNTnL) containing the lower eight\nbits. The TCNTnH Register can only be  indirectly accessed by the CPU. When the CPU does an\naccess to the TCNTnH I/O location, the CPU accesses the high byte temporary register (TEMP).\nThe temporary register is updated with the TCNTnH value when the TCNTnL is read, andTCNTnH is updated with the temporary register va lue when TCNTnL is written. This allows the\nCPU to read or write the entire  16-bit counter value within one clock cycle via the 8-bit data bus.\nIt is important to notice that there are special cases of writing to the TCNTn Register when thecounter is counting that will gi ve unpredictable results. The s pecial cases are described in the\nsections where they are of importance.\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock  (clk\nTn). The clkTn can be generated from an external or internal clock source,\nselected by the Clock Select  bits (CSn2:0). When no clock source is selected (CSn2:0 = 0) the\ntimer is stopped. However, the TCNTn value can be accessed by the CPU, independent of\nwhether clkTn is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the Waveform Generation mode  bits\n(WGMn3:0) located in the Timer/Counter Control Registers  A and B (TCCRnA and TCCRnB).\nThere are close connections between how the counter behaves (counts) and how waveforms\nare generated on the Output Compare outputs OCnx. For more details about advanced counting\nsequences and waveform generation, see \u201cModes of Operation\u201d on page 148 .\nThe Timer/Counter Overflow Flag (TOVn) is set according to the mode of operation selected by\nthe WGMn3:0 bits. TOVn can be used for generating a CPU interrupt.TEMP  (8-bit)DATA BU S (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nControl LogicCount\nClear\nDirectionTOVn\n(Int.Req.)\nClock Select\nTOP BOTTOMTnEdge\nDetector\n( From Prescaler )clkTn\n\n143\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.6 Input Capture Unit\nThe Timer/Counter incorporates an input capture un it that can capture external events and give\nthem a time-stamp indicating time of occurrence. The external signal indicating an event, or mul-\ntiple events, can be applied via the ICPn pin or al ternatively, for the Timer/Counter1 only, via the\nAnalog Comparator unit. The time-stamps can then be used to calculate frequency, duty-cycle,\nand other features of the signal applied. Alternatively the time-stamps can be used for creating a\nlog of the events.\nThe Input Capture unit is illustrated by the block diagram shown in Figure 17-3 . The elements of\nthe block diagram that are not directly a part of the input capture unit are gray shaded. The small\n\u201cn\u201d in register and bit names indicates the Timer/Counter number.\nFigure 17-3. Input Capture Unit Block Diagram\nNote: The Analog Comparator Output (ACO) ca n only trigger the Timer/Counter1 ICP \u2013 not \nTimer/Counter3, 4 or 5.\nWhen a change of the logic level (an event) occurs on the Input Capture Pin  (ICPn), alternatively\non the analog Comparator output  (ACO), and this change confirms to the setting of the edge\ndetector, a capture will be triggered. When a capture is triggered, the 16-bit value of the counter\n(TCNTn) is written to the Input Capture Register  (ICRn). The Input Capture Flag  (ICFn) is set at\nthe same system clock as the TCNTn value is c opied into ICRn Register. If enabled (TICIEn =\n1), the input capture flag generates an input capt ure interrupt. The ICFn flag is automatically\ncleared when the interrupt is executed. Alternativ ely the ICFn flag can be cleared by software by\nwriting a logical one to  its I/O bit location.\nReading the 16-bit value in the Input Capture Register  (ICRn) is done by first reading the low\nbyte (ICRnL) and then the high byte (ICRnH). When the low byte is read the high byte is copied\ninto the high byte Temporary Register (TEMP). When the CPU reads the ICRnH I/O location it\nwill access the TEMP Register.ICFn  (Int.Req.)Analog\nComparatorWRITE ICRn (16-bit Register)ICRnH (8-bit)\nNoise\nCanceler\nICPnEdge\nDetectorTEMP  (8-bit)DATA BU S (8-bit)\nICRnL (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nACIC* ICNC ICES ACO*\n\n144\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe ICRn Register can only be written when using a Waveform Generation mode that utilizes\nthe ICRn Register for defining the counter\u2019s TOP value. In these cases the Waveform Genera-\ntion mode  (WGMn3:0) bits must be set before the TOP value can be written to the ICRn\nRegister. When writing the ICRn Register the high byte  must be written to the ICRnH I/O location\nbefore the low byte is written to ICRnL.\nFor more information on how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 138 .\n17.6.1 Input Capture Trigger Source\nThe main trigger source for the input capture unit is the Input Capture Pin  (ICPn).\nTimer/Counter1 can alternatively use the analog comparator output as trigger source for the\ninput capture unit. The Analog Comparator is selected as trigger source by setting the analog\nComparator Input Capture  (ACIC) bit in the Analog Comparator Control and Status Register\n(ACSR). Be aware that changing trigger source can trigger a capture. The input capture flag\nmust therefore be cleared after the change.\nBoth the Input Capture Pin  (ICPn) and the Analog Comparator output  (ACO) inputs are sampled\nusing the same technique as for the Tn pin ( Figure 18-1 on page 169 ). The edge detector is also\nidentical. However, when the noise canceler is enabled, additional logic is inserted before the\nedge detector, which increases t he delay by four system clock cycles. Note that the input of the\nnoise canceler and edge detector is always enabled unless the Timer/Counter is set in a Wave-\nform Generation mode that uses ICRn to define TOP.\nAn input capture can be tri ggered by software by controllin g the port of the ICPn pin.\n17.6.2 Noise Canceler\nThe noise canceler improves noise immunity by  using a simple digital filtering scheme. The\nnoise canceler input is monitored over four samples, and all four must be equal for changing the\noutput that in turn is used by the edge detector.\nThe noise canceler is enabled by setting the Input Capture Noise Canceler  (ICNCn) bit in\nTimer/Counter Control Register B  (TCCRnB). When enabled the noise canceler introduces addi-\ntional four system clock cycles of delay from a change applied to the input, to the update of the\nICRn Register. The noise canceler uses the sy stem clock and is therefore not affected by the\nprescaler.\n17.6.3 Using the Input Capture Unit\nThe main challenge when using the Input Capture unit is to assign enough processor capacity\nfor handling the incoming events. The time between two events is critical. If the processor has\nnot read the captured value in th e ICRn Register before the nex t event occurs, the ICRn will be\noverwritten with a new value. In this case the result of the ca pture will be incorrect.\nWhen using the Input Capture interrupt, the ICRn Register should be read as early in the inter-\nrupt handler routine as possible. Even though the Input Capture interrupt has relatively high\npriority, the maximum interrupt response time is dependent on the maximum number of clockcycles it takes to handle any of the other interrupt requests.\nUsing the Input Capture unit in any mode of  operation when the TOP value (resolution) is\nactively changed during operation, is not recommended.\nMeasurement of an external signal\u2019s duty cycle requires that the trigger edge is changed after\neach capture. Changing the edge sensing must be done as early as possible after the ICRn\n\n145\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nRegister has been read. After a change of the edge, the Input Capture Flag (ICFn) must be\ncleared by software (writing a logical one to the I/O bit location). For measuring frequency only,\nthe clearing of the ICFn Flag is not required (if an interrupt handler is used).\n17.7 Output Compare Units\nThe 16-bit comparator continuously compares TCNTn with the Output Compare Register\n(OCRnx). If TCNT equals OCRnx the comparator signals a match. A match will set the Output\nCompare Flag  (OCFnx) at the next timer clock cycle. If enabled (OCIEnx = 1), the Output Com-\npare Flag generates an Output Compare interrupt. The OCFnx Flag is automatically clearedwhen the interrupt is executed. Alternatively the OCFnx Flag can be cleared by software by writ-\ning a logical one to its I/O bit location. The Waveform Generator uses the match signal to\ngenerate an output according to operating mode set by the Waveform Generation mode\n(WGMn3:0) bits and Compare Output mode  (COMnx1:0) bits. The TOP and BOTTOM signals\nare used by the Waveform Generator for handling the special cases of the extreme values in\nsome modes of operation. See \u201cModes of Operation\u201d on page 148.\nA special feature of Output Compare unit A allows it to define the Timer/Counter TOP value (that\nis, counter resolution). In addition to the counter resolution, the TOP value defines the period\ntime for waveforms generated by the Waveform Generator.\nFigure 17-4  shows a block diagram of the Output Compare unit. The small \u201cn\u201d in the register and\nbit names indicates the device number (n = n\n for Timer/Counter n), and the \u201cx\u201d indicates Output\nCompare unit (A/B/C). The elements of the block diagram that are not directly a part of the Out-put Compare unit are gray shaded.\nFigure 17-4. Output Compare Unit, Block Diagram\nOCFnx  (Int.Req.)= (16-bit Comparator )OCRnx  Buffer (16-bit Register)OCRnxH Buf. ( 8-bit)\nOCnxTEMP  (8-bit)DATA BU S (8-bit)\nOCRnxL Buf. ( 8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nCOMnx1:0 WGMn3:0OCRnx (16-bit Register)OCRnxH (8-bit) OCRnxL (8-bit)\nWaveform GeneratorTOP\nBOTTOM\n\n146\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe OCRnx Register is double buffered when using any of the twelve Pulse Width Modulation\n(PWM) modes. For the Normal and Clear Timer on Compare  (CTC) modes of operation, the\ndouble buffering is disabled. The double buffering synchronizes the update of the OCRnx Com-\npare Register to either TOP or BOTTOM of  the counting sequence. The synchronization\nprevents the occurrence of odd-length, non-symmetrical P WM pulses, thereby making the out-\nput glitch-free.\nThe OCRnx Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCRnx Buffer Register, and if double buffering is dis-\nabled the CPU will access the OCRnx directly. The content of the OCR1x (Buffer or Compare)\nRegister is only changed by a write operation (the Timer/Counter does not update this registerautomatically as the TCNT1 and ICR1 Register). Therefore OCR1x is not read via the high byte\ntemporary register (TEMP). However, it is a good practice to read the low byte first as when\naccessing other 16-bit registers. Writing the OCRnx Registers must be done via the TEMP Reg-\nister since the compare of all 16 bits is done continuously. The high byte (OCRnxH) has to be\nwritten first. When the high byte I/O location is written by the CPU, the TEMP Register will be\nupdated by the value written. Then when the low by te (OCRnxL) is written to the lower eight bits,\nthe high byte will be copied into the upper 8-bits  of either the OCRnx bu ffer or OCRnx Compare\nRegister in the same system clock cycle.\nFor more information of how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 138 .\n17.7.1 Force Output Compare\nIn non-P WM Waveform Generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Output Compare  (FOCnx) bit. Forcing compare match will not set the\nOCFnx Flag or reload/clear the timer, but the OCnx pin will be updated as if a real compare\nmatch had occurred (the COMn1:0 bits settings define whether the OCnx pin is set, cleared or\ntoggled).\n17.7.2 Compare Match Bloc king by TCNTn Write\nAll CPU writes to the TCNTn Register will block any compare match that o ccurs in the next timer\nclock cycle, even when the timer is stopped. This  feature allows OCRnx to  be initialized to the\nsame value as TCNTn without triggering an inte rrupt when the Timer/Counter clock is enabled.\n17.7.3 Using the Output Compare Unit\nSince writing TCNTn in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNTn when using any of the Output Compare\nchannels, independent of whether the Timer/Counter is running or not. If the value written to\nTCNTn equals the OCRnx value, the compare matc h will be missed, resulting in incorrect wave-\nform generation. Do not write the TCNTn equal to TOP in P WM modes with variable TOP\nvalues. The compare match for the TOP will be ignored and the counte r will continue to 0xFFFF.\nSimilarly, do not write the TCNTn value equal to BOTTOM when the counter is downcounting.\nThe setup of the OCnx should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OCnx value is to use the Force Output Com-\npare (FOCnx) strobe bits in Normal mode. The OCnx Register keeps its value even whenchanging between Waveform Generation modes.\nBe aware that the COMnx1:0 bits are not doubl e buffered together with the compare value.\nChanging the COMnx1:0 bits will take effect immediately.\n\n147\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.8 Compare Match Output Unit\nThe Compare Output mode (COMnx1:0) bits have two functions. The Waveform Generator uses\nthe COMnx1:0 bits for defining the Output Compare (OCnx) state at the next compare match.\nSecondly the COMnx1:0 bits control the OCnx pin output source. Figure 17-5  shows a simplified\nschematic of the logic affected by the COMnx1:0 bit setting. The I/O Registers, I/O bits, and I/O\npins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers\n(DDR and PORT) that are affected by the COMnx1:0 bits are shown. When referring to the\nOCnx state, the reference is for the internal OCnx  Register, not the OCnx pin. If a system reset\noccur, the OCnx Register is reset to \u201c0\u201d.\nFigure 17-5. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OCnx) from the Waveform\nGenerator if either of the COMnx1:0 bits are set. However, the OCnx pin direction (input or out-\nput) is still controlled by the Data Direction Register  (DDR) for the port pin. The Data Direction\nRegister bit for the OCnx pin (DDR_OCnx) must be set as output before the OCnx value is visi-\nble on the pin. The port override func tion is generally independent of the Waveform Generation\nmode, but there are some exceptions. Refer to Table 17-3 on page 159 , Table 17-4 on page 159\nand Table 17-5 on page 160  for details.\nThe design of the Output Compare pin logic allows initialization of the OCnx state before the out-\nput is enabled. Note that some COMnx1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 158.\nThe COMnx1:0 bits have no effect on the Input Capture unit.\n17.8.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COMnx1:0 bits differently in normal, CTC, and P WM modes.\nFor all modes, setting the COMnx1:0 = 0 tells the Waveform Generator that no action on the\nOCnx Register is to be performed on the next compare match. For compare output actions in thePORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCnx\nclkI/O\n\n148\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nnon-PWM modes refer to Table 17-3 on page 159 . For fast P WM mode refer to Table 17-4 on\npage 159 , and for phase correct and phase and frequency correct P WM refer to Table 17-5 on\npage 160 .\nA change of the COMnx1:0 bits st ate will have effect at the first compare matc h after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOCnx strobe bits.\n17.9 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode  (WGMn3:0) and Compare Out-\nput mode  (COMnx1:0) bits. The Compare Output mode bits do not affect the counting sequence,\nwhile the Waveform Generation mode bits do. The COMnx1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COMnx1:0 bits control whether the output should be set, cleared or toggle at a compare\nmatch. See \u201cCompare Match Output Unit\u201d on page 147.\nNote: 1. The CTCn and P WMn1:0 bit definition names are obsolete. Use the WGMn2:0 definitions. \nHowever, the functionality and location of these bits are compatible with previous versions of \nthe timer.\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 156 .Table 17-2. Waveform Generation Mode Bit Description(1)\nMode WGMn3WGMn2\n(CTCn)WGMn1\n(PWMn1)WGMn0\n(PWMn0)Timer/Counter\nMode of Operation TOPUpdate of \nOCRn x atTOVn Flag \nSet on\n0 0 0 0 0 Normal 0xFFFF Immediate MAX\n10 0 0 1 P WM, Phase Correct, 8-bit 0x00FF TOP BOTTOM\n20 0 1 0 P WM, Phase Correct, 9-bit 0x01FF TOP BOTTOM\n30 0 1 1 P WM, Phase Correct, 10-bit 0x03FF TOP BOTTOM\n4 0 1 0 0 CTC OCRnA Immediate MAX\n50 1 0 1 F a s t  P WM, 8-bit 0x00FF BOTTOM TOP\n60 1 1 0 F a s t  P WM, 9-bit 0x01FF BOTTOM TOP\n70 1 1 1 F a s t  P WM, 10-bit 0x03FF BOTTOM TOP\n81 0 0 0PWM, Phase and Frequency \nCorrectICRn BOTTOM BOTTOM\n91 0 0 1PWM,Phase and Frequency \nCorrectOCRnA BOTTOM BOTTOM\n1 0 1010P WM, Phase Correct ICRn TOP BOTTOM\n1 1 1011P WM, Phase Correct OCRnA TOP BOTTOM\n12 1 1 0 0 CTC ICRn Immediate MAX1 3 1101 ( R e s e r v e d ) \u2013 \u2013 \u2013\n1 4 1110 F a s t  P WMI C R n B O T T O M T O P\n1 5 1111 F a s t  P WM OCRnA BOTTOM TOP\n\n149\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.9.1 Normal Mode\nThe simplest mode of operation is the Normal mode  (WGMn3:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 16-bit value (MAX = 0xFFFF) and then restarts from the\nBOTTOM (0x0000). In normal operation the Timer/Counter Overflow Flag  (TOVn) will be set in\nthe same timer clock cycle as the TCNTn become s zero. The TOVn Flag in this case behaves\nlike a 17th bit, except that it is only set, not cleared. However, combined with the timer overflow\ninterrupt that automatically clears the TOVn Flag, the timer resolution can be increased by soft-\nware. There are no special cases to consider in the Normal mode, a new counter value can bewritten anytime.\nThe Input Capture unit is easy to use in Normal mode. However, observe that the maximum\ninterval between the external events must not exceed the resolution of the counter. If the intervalbetween events are too long, the timer overflow interrupt or the prescaler must be used to\nextend the resolution for the capture unit.\nThe Output Compare units can be used to generat e interrupts at some given time. Using the\nOutput Compare to gene rate waveforms in Norm al mode is not recommended, since this will\noccupy too much of the CPU time.\n17.9.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare  or CTC mode ( WGMn3:0 = 4 or 12), the OCRnA or ICRn Register\nare used to manipulate the counter resolution. In CTC mode the counter is cleared to zero when\nthe counter value (TCNTn) matches either the OCRnA ( WGMn3:0 = 4) or the ICRn ( WGMn3:0 =\n12). The OCRnA or ICRn define the top value for the counter, hence also its resolution. This\nmode allows greater control of the compare match output frequency. It also simplifies the opera-tion of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 17-6 . The counter value (TCNTn)\nincreases until a compare match occurs with either OCRnA or ICRn, and then counter (TCNTn)is cleared.\nFigure 17-6. CTC Mode, Timing Diagram\nAn interrupt can be generated at each time the counter value reaches the TOP value by either\nusing the OCFnA or ICFn Flag according to the register used to define the TOP value. If theinterrupt is enabled, the interrupt handler routine can be used for updating the TOP value. How-\never, changing the TOP to a value close to BOTTOM when the counter is running with none or a\nlow prescaler value must be done with care since the CTC mode does not have the double buff-ering feature. If the new value written to OCRnA or ICRn is lower than the current value ofTCNTn\nOCnA\n(Toggle)OCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 4 Period 2 3(COMnA1:0 = 1)\n\n150\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTCNTn, the counter will miss the co mpare match. The counter will then  have to count to its max-\nimum value (0xFFFF) and wrap around starting at 0x0000 before the compare match can occur.\nIn many cases this feature is not desirable. An al ternative will then be to use the fast P WM mode\nusing OCRnA for defining TOP ( WGMn3:0 = 15) since the OCRnA then will be doub le buffered.\nFor generating a waveform output in CTC mode, the OCnA output can be set to toggle its logical\nlevel on each compare match by setting the Compare Output mode bits to toggle mode\n(COMnA1:0 = 1). The OCnA value will not be visible on the port pin unless the data direction for\nthe pin is set to output (DDR_OCnA = 1). Th e waveform generated will have a maximum fre-\nquency of fOCnA = fclk_I/O /2 when OCRnA is set to zero (0x0000). The waveform frequency is\ndefined by the following equation:\nThe N variable represents the prescaler factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOVn Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x0000.\n17.9.3 Fast PWM Mode\nThe fast Pulse Width Modulation or fast P WM mode ( WGMn3:0 = 5, 6, 7, 14, or 15) provides a\nhigh frequency P WM waveform generation option. The fast P WM differs from the other P WM\noptions by its single-slope operation. The counter counts from BOTTOM to TOP then restarts\nfrom BOTTOM. In non-inverting Compare Output mode, the Output Compare (OCnx) is cleared\non the compare match between TCNTn and OCRnx, and set at BOTTOM. In inverting CompareOutput mode output is set on compare match and cleared at BOTTOM. Due to the single-slope\noperation, the operating frequency of the fast P WM mode can be twice as high as the phase cor-\nrect and phase and frequency correct P WM modes that use dual-slope operation. This high\nfrequency makes the fast P WM mode well suited for power regu lation, rectification, and DAC\napplications. High frequency allows physically sm all sized external com ponents (coils, capaci-\ntors), hence reduces total system cost.\nThe PWM resolution for fast P WM can be fixed to 8-bit, 9-bit, or 10-bit, or defined by either ICRn\nor OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA set to 0x0003), and the\nmaximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM resolution in bits can be\ncalculated by using the following equation:\nIn fast P WM mode the counter is incremented until the counter value matches either one of the\nfixed values 0x00FF, 0x01FF, or 0x03FF ( WGMn3:0 = 5, 6, or 7), the value in ICRn ( WGMn3:0 =\n14), or the value in OCRnA ( WGMn3:0 = 15). The counter is then cleared at the following timer\nclock cycle. The timing diagram for the fast P WM mode is shown in Figure 17-7 on page 151 .\nThe figure shows fast P WM mode when OCRnA or ICRn is used to define TOP. The TCNTn\nvalue is in the timing diagram shown as a hist ogram for illustrating the single-slope operation.\nThe diagram includes non-inverted and inverted P WM outputs. The small horizontal line marks\non the TCNTn slopes represent compare ma tches between OCRnx and TCNTn. The OCnx\nInterrupt Flag will be set when a compare match occurs.fOCnAfclk_I/O\n2N1OCRnA+() \u22c5\u22c5-------------------------------------------------- - =\nRFPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n151\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-7. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set each time the counter reaches TOP. In addition\nthe OCnA or ICFn Flag is set at the same time r clock cycle as TOVn is set when either OCRnA\nor ICRn is used for defining the TOP value. If one of the interrupts are enabled, the interrupt han-dler routine can be used for updating the TOP and compare values.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will never occur between the TCNTn and the OCRnx.\nNote that when using fixed TOP values the unused bits are masked to zero when any of the\nOCRnx Registers are written.\nThe procedure for updating ICRn differs from updating OCRnA when used for defining the TOP\nvalue. The ICRn Register is not double buffered. This means that if ICRn is changed to a low\nvalue when the counter is running with none or a low prescaler value, there is a risk that the newICRn value written is lower than the current va lue of TCNTn. The result will then be that the\ncounter will miss the compare matc h at the TOP value. The counter will then have to count to the\nMAX value (0xFFFF) and wrap around starting at 0x0000 before the compare match can occur.The OCRnA Register however, is double buffered. This feature allows the OCRnA I/O location\nto be written anytime. When the OCRnA I/O location is written the value written will be put into\nthe OCRnA Buffer Register. Th e OCRnA Compare Register will th en be updated with the value\nin the Buffer Register at the next timer clo ck cycle the TCNTn matches TOP. The update is done\nat the same timer clock cycle as the TCNT n is cleared and the TOVn Flag is set.\nUsing the ICRn Register for defining TOP work s well when using fixed TOP values. By using\nICRn, the OCRnA Register is free to be used for generating a P WM output on OCnA. However,\nif the base P WM frequency is actively changed (by ch anging the TOP value), using the OCRnA\nas TOP is clearly a better choice due to its double buffer feature.\nIn fast P WM mode, the compare units allow generation of P WM waveforms on the OCnx pins.\nSetting the COMnx1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COMnx1:0 to three (see Table  on page 159 ). The actual OCnx\nvalue will only be visible on the port pin if the data direction for the port pin is set as output\n(DDR_OCnx). The P WM waveform is generated by setting (or clearing) the OCnx Register at\nthe compare match between OCRnx and TCNTn, and clearing (or setting) the OCnx Register at\nthe timer clock cycle the counter is cleared (changes from TOP to BOTTOM).TCNTnOCRnx / TOP Update \nand TOVn Interrupt Flag Set and OCnA Interrupt Flag Set or ICFn Interrupt Flag Set (Interrupt on TOP)\n1 7 Period 2 3 4 56 8OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n152\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCRnx Register represents special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCRnx is set equal to BOTTOM (0x0000) the out-\nput will be a narrow spike for eac h TOP+1 timer clock cycle. Se tting the OCRnx equal to TOP\nwill result in a const ant high or low output (depending on the polarity of the output set by the\nCOMnx1:0 bits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OCnA to toggle its logical level on each compare match (COMnA1:0 = 1). This applies onlyif OCR1A is used to define the TOP value ( WGM13:0 = 15). The wave form generated will have\na maximum frequency of f\nOCnA = fclk_I/O /2 when OCRnA is set to zero (0x0000). This feature is\nsimilar to the OCnA toggle in CTC mode, except the double buffer feature of the Output Com-pare unit is enabled in the fast P WM mode.\n17.9.4 Phase Correct PWM Mode\nThe phase correct Pulse Width Modulation or phase correct P WM mode ( WGMn3:0 = 1, 2, 3,\n10, or 11) provides a high resolution phase correct P WM waveform generation option. The\nphase correct P WM mode is, like the phase and frequency correct P WM mode, based on a dual-\nslope operation. The counter counts repeatedly from BOTTOM (0x0000) to TOP and then from\nTOP to BOTTOM. In non-inverting Compare Output mode, the Output Compare (OCnx) is\ncleared on the compare match between TCNTn and OCRnx while upcounting, and set on thecompare match while downcounting. In inverting Output Compare mode, the operation is\ninverted. The dual-slope operation has lower maximum operation frequency than single slope\noperation. However, due to the symmetric feature of the dual-slope P WM modes, these modes\nare preferred for motor control applications.\nThe P WM resolution for the phase correct P WM mode can be fixed to 8-bit, 9-bit, or 10-bit, or\ndefined by either ICRn or OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA setto 0x0003), and the maximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM reso-\nlution in bits can be calculated by using the following equation:\nIn phase correct P WM mode the counter is incremented until the counter value matches either\none of the fixed values 0x00FF, 0x01FF, or 0x03FF ( WGMn3:0 = 1, 2, or 3), the value in ICRn\n(WGMn3:0 = 10), or the value in OCRnA ( WGMn3:0 = 11). The counter has then reached the\nTOP and changes the count direct ion. The TCNTn value will be equa l to TOP for one timer clock\ncycle. The timing diagram for the phase correct P WM mode is shown on Figure 17-8 on page\n153. The figure shows phase correct P WM mode when OCRnA or ICRn is used to define TOP.\nThe TCNTn value is in the timing diagram shown as a histogram for illustrating the dual-slope\noperation. The diagram includes non-inverted and inverted P WM outputs. The small horizontal\nline marks on the TCNTn slopes represent compare matches between OCRnx and TCNTn. TheOCnx Interrupt Flag will be set when a compare match occurs.fOCnxPWMfclk_I/O\nN1TOP+()\u22c5---------------------------------- - =\nRPCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n153\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-8. Phase Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set each time the counter reaches BOTTOM. When\neither OCRnA or ICRn is used for defining the TOP value, the OCnA or ICFn Flag is set accord-\ningly at the same timer clock cycle as the OCRnx Registers are updated with the double buffer\nvalue (at TOP). The Interrupt Flags can be used to  generate an interrupt each time the counter\nreaches the TOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will never occur between the TCNTn and the OCRnx.\nNote that when using fixed TOP values, the unus ed bits are masked to zero when any of the\nOCRnx Registers are written. As the third period shown in Figure 17-8  illustrates, changing the\nTOP actively while the Timer/Counter is running in the phase correct mode can result in an\nunsymmetrical output. The reason for this can be found in the time of update of the OCRnx Reg-\nister. Since the OCRnx update occurs at TOP, the P WM period starts and ends at TOP. This\nimplies that the length of the falling slope is determined by the previous TOP value, while thelength of the rising slope is determined by the new TOP value. When these two values differ the\ntwo slopes of the period will differ in length. The difference in length gives the unsymmetrical\nresult on the output.\nIt is recommended to use the phase and frequency correct mode instead of the phase correct\nmode when changing the TOP value while the Timer/Counter is running. When using a static\nTOP value there are practically no differences between the two modes of operation.\nIn phase correct P WM mode, the compare units allow generation of P WM waveforms on the\nOCnx pins. Setting the COMnx1:0 bits  to two will produce a non-inverted P WM and an inverted\nPWM output can be generated by setting the COMnx1:0 to three (see Table 17-5 on page 160 ).\nThe actual OCnx value will only be visible on the port pin if the data direction for the port pin is\nset as output (DDR_OCnx). The P WM waveform is generated by setting (or clearing) the OCnx\nRegister at the compare match between OCRnx and TCNTn when the counter increments, andclearing (or setting) the OCnx Register at compare match between OCRnx and TCNTn whenOCRnx/TOP Update and\nOCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 2 3 4TOVn Interrupt Flag Set\n(Interrupt on Bottom)\nTCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n154\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe counter decrements. The P WM frequency for the output when using phase correct P WM can\nbe calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCRnx Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCRnx is set equal to BOTTOM the\noutput will be continuously low and if set equal to TOP the output will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have the opposite logic values. If\nOCR1A is used to define the TOP value ( WGM13:0 = 11) and COM1A1:0 = 1, the OC1A output\nwill toggle with a 50% duty cycle.\n17.9.5 Phase and Frequency Correct PWM Mode\nThe phase and frequency correct Pulse Width Modulation, or phase and frequency correct P WM\nmode ( WGMn3:0 = 8 or 9) provides a high resolution phase and frequency correct P WM wave-\nform generation option. The phase and frequency correct P WM mode is, like the phase correct\nPWM mode, based on a dual-slope operation. The counter counts repeatedly from BOTTOM\n(0x0000) to TOP and then from TOP to BOTTOM. In non-inverting Compare Output mode, the\nOutput Compare (OCnx) is cleared on the compare match between TCNTn and OCRnx while\nupcounting, and set on the compare match while downcounting. In inverting Compare Outputmode, the operation is inverted. The dual-slope operation gives a lower maximum operation fre-\nquency compared to the single-slope operation. Howe ver, due to the symmetric feature of the\ndual-slope P WM modes, these modes are preferred for motor control applications.\nThe main difference between the phase correct, and the phase and frequency correct P WM\nmode is the time the OCRnx Register is updated by the OCRnx Buffer Register, see Figure 17-8\non page 153  and Figure 17-9 on page 155 .\nThe P WM resolution for the phase and frequency correct P WM mode can be defined by either\nICRn or OCRnA. The minimum resolution allowed is 2-bit (ICRn or OCRnA set to 0x0003), and\nthe maximum resolution is 16-bit (ICRn or OCRnA set to MAX). The P WM resolution in bits can\nbe calculated using the following equation:\nIn phase and frequency correct P WM mode the counter is incremented until the counter value\nmatches either the value in ICRn ( WGMn3:0 = 8), or the value in OCRnA ( WGMn3:0 = 9). The\ncounter has then reac hed the TOP and ch anges the count di rection. The TCNTn value will be\nequal to TOP for one timer clock cycle. The timing diagram for the phase correct and frequency\ncorrect P WM mode is shown on Figure 17-9 on page 155 . The figure shows phase and fre-\nquency correct P WM mode when OCRnA or ICRn is used to define TOP. The TCNTn value is in\nthe timing diagram shown as a histogram for il lustrating the dual-slope operation. The diagram\nincludes non-inverted and inverted P WM outputs. The small horizontal line marks on the TCNTn\nslopes represent compare matches between OCRnx and TCNTn. The OCnx Interrupt Flag will\nbe set when a compare match occurs.fOCnxPCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\nRPFCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n155\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-9. Phase and Frequency Correct P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOVn) is set at the same timer clock cycle as the OCRnx\nRegisters are updated with the double buffer value (at BOTTOM). When either OCRnA or ICRn\nis used for defining the TOP value, the OCnA or ICFn Flag set when TCNTn has reached TOP.\nThe Interrupt Flags can then be used to generate an interrupt each time the counter reaches the\nTOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a compare match will neve r occur between the TCNTn and the OCRnx.\nAs Figure 17-9  shows the output generated is, in contrast to the phase correct mode, symmetri-\ncal in all periods. Since the OCRnx Registers are updated at BOTTOM, the length of the rising\nand the falling slopes will always be  equal. This gives symmetrical output pulses and is therefore\nfrequency correct.\nUsing the ICRn Register for defining TOP work s well when using fixed TOP values. By using\nICRn, the OCRnA Register is free to be used for generating a P WM output on OCnA. However,\nif the base P WM frequency is actively changed by changing the TOP value, using the OCRnA as\nTOP is clearly a better choice due to its double buffer feature.\nIn phase and frequency correct P WM mode, the compare units allow generation of P WM wave-\nforms on the OCnx pins. Setting the COMnx1:0  bits to two will produce a non-inverted P WM and\nan inverted P WM output can be generated by setting the COMnx1:0 to three (see Table 17-5 on\npage 160 ). The actual OCnx value will only be visible on the port pin if the data direction for the\nport pin is set as output (DDR_OCnx). The P WM waveform is generated by setting (or clearing)\nthe OCnx Register at the compare match between OCRnx and TCNTn when the counter incre-\nments, and clearing (or setting) the OCnx Register at compare match between OCRnx andTCNTn when the counter decrements. The P WM frequency for the output when using phase\nand frequency correct P WM can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).OCRnx/TOP Updateand\nTOVn Interrupt Flag Set\n(Interrupt on Bottom)OCnA Interrupt Flag Set\nor ICFn Interrupt Flag Set\n(Interrupt on TOP)\n1 2 3 4TCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\nfOCnxPFCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\n\n156\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe extreme values for the OCRnx Register represents special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCRnx is set equal to BOTTOM the\noutput will be continuously low and if set equal to TOP the output will be set to high for non-\ninverted P WM mode. For inverted P WM the output will have the opposite logic values. If OCR1A\nis used to define the TOP value ( WGM13:0 = 9) and COM1A1:0 = 1, the OC1A output will toggle\nwith a 50% duty cycle.\n17.10 Timer/Counte r Timing Diagrams\nThe Timer/Counter is a synchronous design and the timer clock (clkTn) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when Interrupt\nFlags are set, and when the OCRnx Register is updated with the OCRnx buffer value (only for\nmodes utilizing double buffering). Figure 17-10  shows a timing diagram for the setting of OCFnx. \nFigure 17-10. Timer/Counter Timing Diagram, Setting of OCFnx, no Prescaling\nFigure 17-11  shows the same timing data, but with the prescaler enabled.\nFigure 17-11. Timer/Counter Timing Diagram, Setting of OCFnx, with Prescaler (fclk_I/O /8)clkTn\n(clkI/O/1)\nOCFnxclkI/O\nOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2\nOCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\n\n157\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 17-12  shows the count sequence clos e to TOP in various modes. When using phase and\nfrequency correct P WM mode the OCRnx Register is updated at BOTTOM. The timing diagrams\nwill be the same, but TOP should be replaced by BOTTOM, TOP-1 by BOTTOM+1 and so on.\nThe same renaming applies for modes that set the TOVn Flag at BOTTOM.\nFigure 17-12. Timer/Counter Timing Diagram, no Prescaling\nFigure 17-13  shows the same timing data, but with the prescaler enabled.\nFigure 17-13. Timer/Counter Timing Dia gram, with Prescaler (fclk_I/O /8) TOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkTn\n(clkI/O/1)clkI/O\nTOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n158\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11 Register Description\n17.11.1 TCCR1A \u2013 Timer/Counter 1 Control Register A\n17.11.2 TCCR3A \u2013 Timer/Counter 3 Control Register A\n17.11.3 TCCR4A \u2013 Timer/Counter 4 Control Register A\n17.11.4 TCCR5A \u2013 Timer/Counter 5 Control Register A\n\u0081\nBit 7:6 \u2013 COMnA1:0: Compare Output Mode for Channel A\n\u0081Bit 5:4 \u2013 COMnB1:0: Compare Output Mode for Channel B\n\u0081Bit 3:2 \u2013 COMnC1:0: Compare Output Mode for Channel C\nThe COMnA1:0, COMnB1:0, and COMnC1:0 control the output compare pins (OCnA, OCnB,\nand OCnC respectively) behavior. If one or both of the COMnA1:0 bits are written to one, the\nOCnA output overrides the normal port functionality of the I/O pin it is connected to. If one or\nboth of the COMnB1:0 bits are written to one, the OCnB output overrides the normal port func-tionality of the I/O pin it is connected to. If one or both of the COMnC1:0 bits are written to one,\nthe OCnC output overrides the normal port functionality of the I/O pin it is connected to. How-\never, note that the Data Direction Register (DDR) bit corresponding to the OCnA, OCnB or\nOCnC pin must be set in order to enable the output driver.\nWhen the OCnA, OCnB or OCnC is connected to the pin, the function of the COMnx1:0 bits is\ndependent of the WGMn3:0 bits setting. Table 17-3 on page 159  shows the COMnx1:0 bit func-\ntionality when the WGMn3:0 bits are set to a normal or a CTC mode (non-P WM).B i t 765432 1 0\n(0x80) COM1A1 COM1A0 COM1B1 COM1B0 COM1C1 COM1C0 WGM11 WGM10 TCCR1A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0x90)\nCOM3A1 COM3A0 COM3B1 COM3B0 COM3C1 COM3C0 WGM31 WGM30 TCCR3A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0xA0)\nCOM4A1 COM4A0 COM4B1 COM4B0 COM4C1 COM4C0 WGM41 WGM40 TCCR4A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\nB i t 765432 1 0(0x120)\nCOM5A1 COM5A0 COM5B1 COM5B0 COM5C1 COM5C0 WGM51 WGM50 TCCR5A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 000000 0 0\n\n159\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1:0 \u2013 WGMn1:0: Waveform Generation Mode\nCombined with the WGMn3:2 bits found in the TCCRnB Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 17-2 on page 148 . Modes of operation supported by the\nTimer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode,and three types of Pulse Width Modulation (P WM) modes. For more information on the different\nmodes, see \u201cModes of Operation\u201d on page 148 .\nTable 17-4  shows the COMnx1:0 bit functionality when the WGMn3:0 bits are set to the fast\nPWM mode.\nNote: A special case occurs when  OCRnA/OCRnB/OCRnC equals TOP and \nCOMnA1/COMnB1/COMnC1 is set. In this case t he compare match is ignored, but the set or clear \nis done at BOTTOM. See \u201cFast P WM Mode\u201d on page 150.  for more details.Table 17-3. Compare Output Mode, non-P WM\nCOMnA1\nCOMnB1\nCOMnC1COMnA0\nCOMnB0\nCOMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected0 1 Toggle OCnA/OCnB/OCnC on compare match\n1 0 Clear OCnA/OCnB/OCnC on compare match (set output to low level)\n1 1 Set OCnA/OCnB/OCnC on compare match (set output to high level)\nTable 17-4. Compare Output Mode, Fast P WM\nCOMnA1\nCOMnB1COMnC1COMnA0\nCOMnB0COMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected\n01WGM13:0 = 14 or 15: Toggle OC1A on Compare Match, OC1B and OC1C \ndisconnected (normal port operation). For all other WGM1 settings, normal \nport operation, OC1A/OC1B/OC1C disconnected\n10Clear OCnA/OCnB/OCnC on compare match, set OCnA/OCnB/OCnC at \nBOTTOM (non-inverting mode)\n11Set OCnA/OCnB/OCnC on compare match, clear OCnA/OCnB/OCnC at \nBOTTOM (inverting mode)\n\n160\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 17-5  shows the COMnx1:0 bit functionality when the WGMn3:0 bits are set to the phase\ncorrect and frequency correct P WM mode.\nNote: A special case occurs when  OCRnA/OCRnB/OCRnC equals TOP and \nCOMnA1/COMnB1//COMnC1 is set. See \u201cPhase Correct P WM Mode\u201d on page 152.  for more \ndetails.\n17.11.5 TCCR1B \u2013 Timer/Counter 1 Control Register B\n17.11.6 TCCR3B \u2013 Timer/Counter 3 Control Register B\n17.11.7 TCCR4B \u2013 Timer/Counter 4 Control Register B\n17.11.8 TCCR5B \u2013 Timer/Counter 5 Control Register B\n\u0081 Bit 7 \u2013 ICNCn: Input Capture Noise Canceler\nSetting this bit (to one) activates the Input Capture Noise Canceler. When the Noise Canceler is\nactivated, the input from the Input Capture Pin (ICPn) is filtered. The filter function requires foursuccessive equal valued samples of the ICPn pin for changing its output. The input capture is\ntherefore delayed by four Oscillator cycles when the noise canceler is enabled.Table 17-5. Compare Output Mode, Phase Correct and Phase and Frequency Correct P WM\nCOMnA1\nCOMnB1\nCOMnC1COMnA0\nCOMnB0\nCOMnC0 Description\n0 0 Normal port operation, OCnA/OCnB/OCnC disconnected\n01WGM13:0 =9 or 11: Toggle OC1A on Compare Match, OC1B and OC1C \ndisconnected (normal port operation). For all other WGM1 settings, normal \nport operation, OC1A/OC1B/OC1C disconnected\n10Clear OCnA/OCnB/OCnC on compare match when up-counting\nSet OCnA/OCnB/OCnC on compare match when downcounting\n11Set OCnA/OCnB/OCnC on compare match when up-counting\nClear OCnA/OCnB/OCnC on compare match when downcounting\nB i t 76543210\n(0x81) ICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 TCCR1B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nBit 7 6 5 4 3 2 1 0(0x91) ICNC3 ICES3 \u2013 WGM33 WGM32 CS32 CS31 CS30 TCCR3B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA1) ICNC4 ICES4 \u2013 WGM43 WGM42 CS42 CS41 CS40 TCCR4B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x121) ICNC5 ICES5 \u2013 WGM53 WGM52 CS52 CS51 CS50 TCCR5B\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n161\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ICESn: Input Capture Edge Select\nThis bit selects which edge on the Input Capture Pin (ICPn) that is used to trigger a capture\nevent. When the ICESn bit is written to zero, a fa lling (negative) edge is  used as trigger, and\nwhen the ICESn bit is written to one, a risi ng (positive) edge w ill trigger the capture.\nWhen a capture is triggered according to the ICESn setting, the counter value is copied into the\nInput Capture Register (ICRn). The event will also set the Input Capture Flag (ICFn), and this\ncan be used to cause an Input Capture Interrupt, if this interrupt is enabled.\nWhen the ICRn is used as TOP value (see description of the WGMn3:0 bits located in the\nTCCRnA and the TCCRnB Register), the ICPn is disconnected and consequently the input cap-ture function is disabled.\n\u0081 Bit 5 \u2013 Reserved Bit\nThis bit is reserved for future use. For ensuring  compatibility with future de vices, this bit must be\nwritten to zero when TCCRnB is written.\n\u0081 Bit 4:3 \u2013 WGMn3:2: Waveform Generation Mode\nSee TCCRnA Register description.\n\u0081 Bit 2:0 \u2013 CSn2:0: Clock Select\nThe three clock select bits select the clock source to be used by the Timer/Counter, see Figure\n17-10 on page 156  and Figure 17-11 on page 156 .\nIf external pin modes are used for the Timer/Countern, transitions on the Tn pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n17.11.9 TCCR1C \u2013 Timer/Counter 1 Control Register CTable 17-6. Clock Select Bit Description\nCSn2 CSn1 CSn0 Description\n0 0 0 No clock source. (Timer/Counter stopped)001 c l k\nI/O/1 (No prescaling\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on Tn pin. Clock on falling edge1 1 1 External clock source on Tn pin. Clock on rising edge\nB i t 7654 3210\n(0x82) FOC1A FOC1B FOC1C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR1C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\n\n162\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.10 TCCR3C \u2013 Timer/Counter 3 Control Register C\n17.11.11 TCCR4C \u2013 Timer/Counter 4 Control Register C\n17.11.12 TCCR5C \u2013 Timer/Counter 5 Control Register C\n\u0081Bit 7 \u2013 FOCnA: Force Output Compare for Channel A\n\u0081Bit 6 \u2013 FOCnB: Force Output Compare for Channel B\n\u0081Bit 5 \u2013 FOCnC: Force Output Compare for Channel C\nThe FOCnA/FOCnB/FOCnC bits are only active when the WGMn3:0 bits specifies a non-P WM\nmode. When writing a logical one to the FOCnA/FOCnB/FOCnC bit, an immediate compare\nmatch is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed\naccording to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are imple-\nmented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine theeffect of the forced compare.\nA FOCnA/FOCnB/FOCnC strobe will no t generate any interrupt nor w ill it clear the timer in Clear\nTimer on Compare Match (CTC) mode using OCRnA as TOP.\nThe FOCnA/FOCnB/FOCnB bits are always read as zero.\n\u0081 Bit 4:0 \u2013 Reserved Bits\nThese bits are reserved for future  use. For ensuring compatibility with future devices, these bits\nmust be written to zero when TCCRnC is written.\n17.11.13 TCNT1H and TCNT1L \u2013 Timer/Counter 1\n17.11.14 TCNT3H and TCNT3L \u2013 Timer/Counter 3B i t 7654 3210\n(0x92) FOC3A FOC3B FOC3C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR3C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 7654 3210(0xA2) FOC4A FOC4B FOC4C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR4C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 7654 3210(0x122) FOC5A FOC5B FOC3C \u2013 \u2013 \u2013 \u2013 \u2013 TCCR5C\nRead/Write WWW R RRRR\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x85) TCNT1[15:8] TCNT1H\n(0x84) TCNT1[7:0] TCNT1L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x95) TCNT3[15:8] TCNT3H\n(0x94) TCNT3[7:0] TCNT3L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n163\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.15 TCNT4H and TCNT4L \u2013Timer/Counter 4\n17.11.16 TCNT5H and TCNT5L \u2013Timer/Counter 5\nThe two Timer/Counter  I/O locations (TCNTnH and TCNTnL , combined TCNTn) give direct\naccess, both for read and for write operations, to the Timer/Counter unit 16-bit counter. Toensure that both the high and low bytes are read and written simultaneously when the CPU\naccesses these registers, the access is perfo rmed using an 8-bit temporary High Byte Register\n(TEMP). This temporary register is shared by all the other 16-bit registers. See \u201cAccessing 16-bit\nRegisters\u201d on page 138.\nModifying the counter (TCNTn) while the counte r is running introduces a risk of missing a com-\npare match between TCNTn and one of the OCRnx Registers.\nWriting to the TCNTn Register blocks (removes) the compare match on the following timer clock\nfor all compare units.\n17.11.17 OCR1AH and OCR1AL \u2013 Ou tput Compare Register 1 A\n17.11.18 OCR1BH and OCR1BL \u2013 Ou tput Compare Register 1 B\n17.11.19 OCR1CH and OCR1CL \u2013 Ou tput Compare Register 1 CB i t 76543210\n(0xA5) TCNT4[15:8] TCNT4H\n(0xA4) TCNT4[7:0] TCNT4L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x125) TCNT5[15:8] TCNT5H\n(0x124) TCNT5[7:0] TCNT5L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x89) OCR1A[15:8] OCR1AH\n(0x88) OCR1A[7:0] OCR1AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x8B) OCR1B[15:8] OCR1BH\n(0x8A) OCR1B[7:0] OCR1BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x8D) OCR1C[15:8] OCR1CH\n(0x8C) OCR1C[7:0] OCR1CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n164\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.20 OCR3AH and OCR3AL \u2013 Ou tput Compare Register 3 A\n17.11.21 OCR3BH and OCR3BL \u2013 Ou tput Compare Register 3 B\n17.11.22 OCR3CH and OCR3CL \u2013 Ou tput Compare Register 3 C\n17.11.23 OCR4AH and OCR4AL \u2013 Ou tput Compare Register 4 A\n17.11.24 OCR4BH and OCR4BL \u2013 Ou tput Compare Register 4 B\n17.11.25 OCR4CH and OCR4CL \u2013Output Compare Register 4 C\n17.11.26 OCR5AH and OCR5AL \u2013 Ou tput Compare Register 5 AB i t 76543210\n(0x99) OCR3A[15:8] OCR3AH\n(0x98) OCR3A[7:0] OCR3AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x9B) OCR3B[15:8] OCR3BH\n(0x9A) OCR3B[7:0] OCR3BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x9D) OCR3C[15:8] OCR3CH\n(0x9C) OCR3C[7:0] OCR3CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA9) OCR4A[15:8] OCR4AH\n(0xA8) OCR4A[7:0] OCR4AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xAA) OCR4B[15:8] OCR4BH\n(0xAB) OCR4B[7:0] OCR4BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xAD) OCR4C[15:8] OCR4CH\n(0xAC) OCR4C[7:0] OCR4CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x129) OCR5A[15:8] OCR5AH\n(0x128) OCR5A[7:0] OCR5AL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n165\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n17.11.27 OCR5BH and OCR5BL \u2013 Ou tput Compare Register 5 B\n17.11.28 OCR5CH and OCR5CL \u2013Output Compare Register 5 C\nThe Output Compare Registers contain a 16-bit value that is continuously compared with the\ncounter value (TCNTn). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OCnx pin.\nThe Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are\nwritten simultaneously when the CP U writes to these registers, the access is performed using an\n8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other\n16-bit registers. See \u201cAccessing 16-bit Registers\u201d on page 138.\n17.11.29 ICR1H and ICR1L \u2013 Input Capture Register 1\n17.11.30 ICR3H and ICR3L \u2013 Input Capture Register 3\n17.11.31 ICR4H and ICR4L \u2013 Input Capture Register 4\n17.11.32 ICR5H and ICR5L \u2013 Input Capture Register 5B i t 76543210\n(0x12B) OCR5B[15:8] OCR5BH\n(0x12A) OCR5B[7:0] OCR5BL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x12D) OCR5C[15:8] OCR5CH\n(0x12C) OCR5C[7:0] OCR5CL\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x87) ICR1[15:8] ICR1H\n(0x86) ICR1[7:0] ICR1L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x97) ICR3[15:8] ICR3H\n(0x96) ICR3[7:0] ICR3L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xA7) ICR4[15:8] ICR4H\n(0xA6) ICR4[7:0] ICR4L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0x127) ICR5[15:8] ICR5H\n(0x126) ICR5[7:0] ICR5L\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n166\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Input Capture is updated with the counter (TCNTn) value each time an event occurs on the\nICPn pin (or optionally on the Analog Comparator output for Timer/Counter1). The Input Capture\ncan be used for defining the counter TOP value.\nThe Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read\nsimultaneously when the CPU accesses these regi sters, the access is performed using an 8-bit\ntemporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit\nregisters. See \u201cAccessing 16-bit Registers\u201d on page 138.\n17.11.33 TIMSK1 \u2013 Ti mer/Counter 1 Interrupt Mask Register\n17.11.34 TIMSK3 \u2013 Ti mer/Counter 3 Interrupt Mask Register\n17.11.35 TIMSK4 \u2013 Ti mer/Counter 4 Interrupt Mask Register\n17.11.36 TIMSK5 \u2013 Ti mer/Counter 5 Interrupt Mask Register\n\u0081 Bit 5 \u2013 ICIEn: Timer/Countern, Input Capture Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Input Capture interrupt is enabled. The corresponding Interrupt\nVector (see \u201cInterrupts\u201d on page 105 ) is executed when the ICFn Flag, located in TIFRn, is set.\n\u0081 Bit 3 \u2013 OCIEnC: Timer/Countern, Output Compare C Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare C Match interrupt is enabled. The corresponding\nInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnC Flag, located in\nTIFRn, is set.\n\u0081 Bit 2 \u2013 OCIEnB: Timer/Countern, Output Compare B Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare B Match interrupt is enabled. The corresponding\nInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnB Flag, located in\nTIFRn, is set.B i t 76543210\n(0x6F) \u2013 \u2013I C I E 1 \u2013 OCIE1C OCIE1B OCIE1A TOIE1 TIMSK1\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x71)\n\u2013 \u2013I C I E 3 \u2013 OCIE3C OCIE3B OCIE3A TOIE3 TIMSK3\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x72)\n\u2013 \u2013I C I E 4 \u2013 OCIE4C OCIE4B OCIE4A TOIE4 TIMSK4\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nB i t 76543210(0x73)\n\u2013 \u2013I C I E 5 \u2013 OCIE5C OCIE5B OCIE5A TOIE5 TIMSK5\nRead/Write R R R/ W RR / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n167\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 1 \u2013 OCIEnA: Timer/Countern, Output Compare A Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Output Compare A Match interrupt is enabled. The correspondingInterrupt Vector (see \u201cInterrupts\u201d on page 105 ) is executed when the OCFnA Flag, located in\nTIFRn, is set.\n\u0081 Bit 0 \u2013 TOIEn: Timer/Countern, Overflow Interrupt Enable\nWhen this bit is written to one, and the I-flag in t he Status Register is set (interrupts globally\nenabled), the Timer/Countern Overflow interrupt is enabled. The corresponding Interrupt Vector(see \u201cInterrupts\u201d on page 105 ) is executed when the TOVn Flag, located in TIFRn, is set.\n17.11.37 TIFR1 \u2013 Timer/Counte r1 Interrupt Flag Register\n17.11.38 TIFR3 \u2013 Timer/Counte r3 Interrupt Flag Register\n17.11.39 TIFR4 \u2013 Timer/Counte r4 Interrupt Flag Register\n17.11.40 TIFR5 \u2013 Timer/Counte r5 Interrupt Flag Register\n\u0081 Bit 5 \u2013 ICFn: Timer/Count ern, Input Capture Flag\nThis flag is set when a capture event occurs on the ICPn pin. When the Input Capture Register\n(ICRn) is set by the WGMn3:0 to be used as the TOP value, the ICFn Flag is set when the coun-\nter reaches the TOP value.\nICFn is automatically cleared when the Input Capt ure Interrupt Vector is executed. Alternatively,\nICFn can be cleared by writing a logic one to its bit location.\n\u0081 Bit 3\u2013 OCFnC: Timer/Countern, Output Compare C Match Flag\nThis flag is set in the timer clock cycle af ter the counter (TCNTn) value matches the Output\nCompare Register C (OCRnC).\nNote that a Forced Output Compare (FOC nC) strobe will not set the OCFnC Flag.\nOCFnC is automatically cleared when the Output Compare Match C Interrupt Vector is exe-\ncuted. Alternatively, OCFnC can be cleared by writing a logic one to its bit location.B i t 76543210\n0x16 (0x36) \u2013 \u2013I C F 1 \u2013 OCF1C OCF1B OCF1A TOV1 TIFR1\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x18 (0x38)\n\u2013 \u2013I C F 3 \u2013 OCF3C OCF3B OCF3A TOV3 TIFR3\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x19 (0x39)\n\u2013 \u2013I C F 4 \u2013 OCF4C OCF4B OCF4A TOV4 TIFR4\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x1A (0x3A)\n\u2013 \u2013I C F 5 \u2013 OCF5C OCF5B OCF5A TOV5 TIFR5\nRead/Write R R R/ W RR / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n168\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 \u2013 OCFnB: Timer/Counter1, Output Compare B Match Flag\nThis flag is set in the timer clock cycle af ter the counter (TCNTn) value matches the Output\nCompare Register B (OCRnB).\nNote that a Forced Output Compare (FOC nB) strobe will not set the OCFnB Flag.\nOCFnB is automatically cleared when the Output  Compare Match B Interrupt Vector is exe-\ncuted. Alternatively, OCFnB can be cleared by writing a logic one to its bit location.\n\u0081 Bit 1 \u2013 OCF1A: Timer/Counter1, Output Compare A Match Flag\nThis flag is set in the timer clock cycle after the counter (TCNTn value matches the Output Com-\npare Register A (OCRnA).\nNote that a Forced Output Compare (FOC nA) strobe will not set the OCFnA Flag.\nOCFnA is automatically cleared when the Output  Compare Match A Interrupt Vector is exe-\ncuted. Alternatively, OCFnA can be cleared by writing a logic one to its bit location.\n\u0081 Bit 0 \u2013 TOVn: Timer/Countern, Overflow Flag\nThe setting of this flag is dependent of the WGMn3:0 bits setting. In Normal and CTC modes,\nthe TOVn Flag is set when the timer overflows. Refer to Table 17-2 on page 148  for the TOVn\nFlag behavior when using another WGMn3:0 bit setting.\nTOVn is automatically cleared when the Timer/C ountern Overflow Interrupt Vector is executed.\nAlternatively, TOVn can be cleared by writing a logic one to its bit location.\n\n169\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n18. Timer/Counter 0, 1, 3, 4, and 5 Prescaler\nTimer/Counter 0, 1, 3, 4, and 5 share the same prescaler module, but the Timer/Counters can\nhave different prescaler settings. The description below applies to all Timer/Counters. Tn is used\nas a general name, n = 0, 1, 3, 4, or 5.\n18.1 Internal Clock Source\nThe Timer/Counter can be clocked directly by the system clock (by setting the CSn2:0 = 1). This\nprovides the fastest operation, with a maximum Timer/Counter clock frequency equal to system\nclock frequency (fCLK_I/O ). Alternatively, one of four taps from the prescaler can be used as a\nclock source. The prescaled clock has a frequency of either fCLK_I/O /8, fCLK_I/O /64, fCLK_I/O /256, or\nfCLK_I/O /1024.\n18.2 Prescaler Reset\nThe prescaler is free running, that is, operates  independently of the Clock Select logic of the\nTimer/Counter, and it is shared by the Timer/Counter Tn. Since the prescaler is not affected by\nthe Timer/Counter\u2019s clock select, the state of the prescaler will ha ve implications  for situations\nwhere a prescaled clock is used. One example of prescaling artifacts occurs when the timer isenabled and clocked by the prescaler (6 > CSn2:0  > 1). The number of system clock cycles from\nwhen the timer is enabled to the first count occurs can be from 1 to N+1 system clock cycles,\nwhere N equals the prescaler divisor (8, 64, 256, or 1024).\nIt is possible to use the prescaler reset for synchronizing the Timer/Counter to program execu-\ntion. However, care must be taken if the other Timer/Counter that shares the same prescaler\nalso uses prescaling. A prescaler reset will affect the prescaler period for all Timer/Coun ters it is\nconnected to.\n18.3 External Clock Source\nAn external clock source applied to the Tn  pin can be used as Timer/Counter clock (clkTn). The\nTn pin is sampled once every system clock cycle by the pin synchronization logic. The synchro-nized (sampled) signal is then passed through the edge detector. Figure 18-1  shows a functional\nequivalent block diagram of the Tn synchronizati on and edge detector logic. The registers are\nclocked at the positive edge of the internal system clock (\nclkI/O). The latch is transparent in the\nhigh period of the internal system clock.\nThe edge detector generates one clkTn pulse for each positive (CSn2:0 = 7) or negative (CSn2:0\n= 6) edge it detects.\nFigure 18-1. Tn/T0 Pin Sampling\nTn_sync\n(To ClockSelect Logic)\nEdge Detector SynchronizationDQ DQ\nLEDQ Tn\nclkI/O\n\n170\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe synchronization and e dge detector logic introduces a de lay of 2.5 to 3.5 system clock cycles\nfrom an edge has been applied to the Tn pin to the counter is updated.\nEnabling and disabling of the clock input must be done when Tn has been stable for at least one\nsystem clock cycle, otherwise it is a risk that a false Timer/Counter clock pulse is generated.\nEach half period of the external clock applie d must be longer than one system clock cycle to\nensure correct sampling. The external clock must be guaranteed to have less than half the sys-\ntem clock frequency (fExtClk < fclk_I/O /2) given a 50/50% duty cycle. Since the edge detector uses\nsampling, the maximum frequency of an external clock it can detect is half the sampling fre-\nquency (Nyquist sampling theorem). However, due to variation of the system clock frequency\nand duty cycle caused by Oscillator source (crystal, resonator, and capacitors) tolerances, it isrecommended that maximum frequency of an external clock source is less than f\nclk_I/O /2.5.\nAn external clock source  can not be prescaled.\nFigure 18-2. Prescaler for synchronous Timer/Counters\n18.4 Register Description\n18.4.1 GTCCR \u2013 General Timer/Counter Control Register\n\u0081 Bit 7 \u2013 TSM: Timer/Counter Synchronization Mode\nWriting the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode, the\nvalue that is written to the PSRASY and PSRSYN C bits is kept, hence keeping the correspond-\ning prescaler reset signals asserted. This ensures that the corresponding Timer/Counters arehalted and can be configured to the same value without the risk of one of them advancing during\nconfiguration. When the TSM bit is writ ten to zero, the PSRASY and PSRSYNC bits are cleared\nby hardware, and the Timer/Counte rs start counting simultaneously.PSR10Clear\nTnTnclkI/O\nSynchronizationSynchronization\nTIMER/COUNTERn CLOCK SOURCE\nclkTnTIMER/COUNTERn CLOCK SOURCE\nclkTnCSn0\nCSn1\nCSn2CSn0\nCSn1\nCSn2\nBit 7 6 5 4 3 2 1 0\n0x23 (0x43) TSM \u2013 \u2013 \u2013 \u2013 \u2013 PSRASY PSRSYNC GTCCR\nRead/Write R/ W RRR R R R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n171\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 PSRSYNC: Prescaler Reset for Synchronous Timer/Counters\nWhen this bit is one, Timer/Counter0, Timer/C ounter1, Timer/Counter3, Timer/Counter4 and\nTimer/Counter5 prescaler will be Re set. This bit is normally cl eared immediatel y by hardware,\nexcept if the TSM bit is set. Note that Timer/Counter0, Timer/Counter1, Timer/Counter3,\nTimer/Counter4 and Timer/Counte r5 share the same prescaler and  a reset of this prescaler will\naffect all timers.\n\n172\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n19. Output Compare Modulator (OCM1C0A)\n19.1 Overview\nThe Output Compare Modulator (OCM) allows generation of waveforms modulated with a carrier\nfrequency. The modulator uses the outputs from the Output Compare Unit C of the 16-bitTimer/Counter1 and the Output Compare Unit of the 8-bit Timer/Counter0. For more details\nabout these Timer/Counters see \u201cTimer/Counter 0, 1, 3, 4, and 5 Prescaler\u201d on page 169  and \u201c8-\nbit Timer/Counter2 with P WM and Asynchronous Operation\u201d on page 174 .\nFigure 19-1. Output Compare Modulator, Block Diagram\nWhen the modulator is enabled, the two output compare channels are modulated together as\nshown in the block diagram (see Figure 19-1 ).\n19.2 Description\nThe Output Compare unit 1C and Output Compare unit 2 shares the PB7 port pin for output. The\noutputs of the Output Compare units (OC1C and OC0A) overrides the normal PORTB7 Register\nwhen one of them is enabled (that is, when COMnx1:0 is not equal to zero). When both OC1C\nand OC0A are enabled at the same time, the modulator is automatically enabled.\nThe functional equivalent schematic of the modulator is shown on Figure 19-2 . The schematic\nincludes part of the Timer/Counter units and the port B pin 7 output driver circuit.\nFigure 19-2. Output Compare Modulator, SchematicOC1C\nPin\nOC1C /\nOC0A / PB7Timer/Counter 1\nTimer/Counter 0 OC0A\nPORTB7 DDRB7DQ DQPinCOMA01\nCOMA00\nDATABUSOC1C /\nOC0A/ PB7COM1C1\nCOM1C0Modulator\n10\nOC1CDQ\nOC0ADQ( From Waveform Generator )\n( From Waveform Generator )01Vcc\n\n173\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the modulator is enabled the type of modulation (logical AND or OR) can be selected by\nthe PORTB7 Register. Note that the DDRB7 controls the direction of the port independent of the\nCOMnx1:0 bit setting.\n19.2.1 Timing example\nFigure 19-3 illustrates the modulator in ac tion. In this example the Ti mer/Counter1 is  set to oper-\nate in fast P WM mode (non-inverted) and Timer/Counter0 uses CTC waveform mode with toggle\nCompare Output mode (COMnx1:0 = 1).\nFigure 19-3. Output Compare Modulator, Timing Diagram\nIn this example, Timer/Counter2 provides the carrier, while the modulating signal is generated\nby the Output Compare unit C of the Timer/Counter1.\nThe resolution of the P WM signal (OC1C) is reduced by the modulation. The reduction factor is\nequal to the number of system clock cycles of one period of the carrier (OC0A). In this example\nthe resolution is reduced by a factor of two. The reason for the reduction is illustrated in Figure\n19-3 at the second and third period of the PB7 output when PORTB7 equals zero. The period 2\nhigh time is one cycle longer than the period 3 high time, but the result on the PB7 output is\nequal in both periods.1 2OC0A\n(CTC Mode)OC1C\n(FPWM Mode)\nPB7\n(PORTB7 = 0)\nPB7\n(PORTB7 = 1)\n(Period)3clkI/O\n\n174\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20. 8-bit Timer/Counter2 with PWM and Asynchronous Operation\nTimer/Counter2 is a general purpose, single channel, 8-bit Timer/Counter module. The main\nfeatures are:\n\u0081Single Channel Counter\n\u0081Clear Timer on Compare Match (Auto Reload)\n\u0081Glitch-free, Phase Correct Pu lse Width Modulator (PWM)\n\u0081Frequency Generator\n\u008110-bit Clock Prescaler\n\u0081Overflow and Compare Ma tch Interrupt Sources (TOV2, OCF2A and OCF2B)\n\u0081Allows Clocking from External 32kHz Watch Crystal Independent of the I/O Clock\n20.1 Overview\nA simplified block diagram of the 8-bit Timer/Counter is shown in Figure 17-12.  For the actual\nplacement of I/O pins, see \u201cPin Configurations\u201d on page 2 . CPU accessible I/O Registers, includ-\ning I/O bits and I/O pins, are shown in bold. T he device-specific I/O Register and bit locations\nare listed in the \u201cRegister Description\u201d on page 187 .\nThe Power Reduction Timer/Counter2 bit, PRTIM2, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be written to zero to enable Timer/Counter2 module.\nFigure 20-1. 8-bit Timer/Counter Block Diagram\nTimer/Counter\nDATA BUSOCRnA\nOCRnB=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB=\nFixed\nTOP\nValueControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int.Req.)\nOCnA\n(Int.Req.)\nOCnB(Int.Req.)\nTCCRnA TCCRnBclkTn\nASSRnSynchronization UnitPrescalerT/C\nOscillator\nclkI/O\nclkASY\nasynchronous mode\n      select (ASn)Synchronized Status flagsTOSC1\nTOSC2\nStatus flagsclkI/O\n\n175\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.1.1 Registers\nThe Timer/Counter (TCNT2) and Output Compare Register (OCR2A and OCR2B) are 8-bit reg-\nisters. Interrupt request (abbreviated to Int.Req.) signals are all visible in the Timer Interrupt Flag\nRegister (TIFR2). All interrupts are individua lly masked with the Timer Interrupt Mask Register\n(TIMSK2). TIFR2 and TIMSK2 are not shown in the figure.\nThe Timer/Counter can be clocked internally, via the prescaler, or asynchronously clocked from\nthe TOSC1/2 pins, as detailed later in this section. The asynchronous operation is controlled by\nthe Asynchronous Status Regist er (ASSR). The Clock Select lo gic block controls which clock\nsource the Timer/Counter uses to increment (or de crement) its value. The Timer/Counter is inac-\ntive when no clock source is selected. The output from the Clock Select logic is referred to as the\ntimer clock (clkT2).\nThe double buffered Output Compare Register (OCR2A and OCR2B) are compared with the\nTimer/Counter value at all times. The result of the compare can be used by the Waveform Gen-\nerator to generate a P WM or variable frequency output on the Output Compare pins (OC2A and\nOC2B). See \u201cOutput Compare Unit\u201d on page 180  for details. The comp are match event will also\nset the Compare Flag (OCF2A or OCF2B) which can be used to generate an Output Compare\ninterrupt request.\n20.1.2 Definitions\nMany register and bit references in this document are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case  2. However, when using the register or bit\ndefines in a program, the precise form must be used, that is, TCNT2 for accessing\nTimer/Counter2 counter value and so on.\nThe definitions in Table 20-1  are also used extensively throughout the section.\n20.2 Timer/Counter Clock Sources\nThe Timer/Counter can be clocked by an internal synchronous or an external asynchronous\nclock source. The clock source clkT2 is by default equal to the MCU clock, clkI/O. When the AS2\nbit in the ASSR Register is written to logic one, the clock source is taken from the Timer/Counter\nOscillator connecte d to TOSC1 and TOSC2. For details on asynchronous operation, see \u201cAsyn-\nchronous Operation of Timer/Counter2\u201d on page 184 . For details on clock sources and\nprescaler, see \u201cTimer/Counter Prescaler\u201d on page 186 .\n20.3 Counter Unit\nThe main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure\n20-2 on page 176  shows a block diagram of the counter and its surrounding environment.Table 20-1. Definitions\nBOTTOM The counter reaches the BOTTOM when it becomes zero (0x00)\nMAX The counter reaches its MAXimum when it becomes 0xFF (decimal 255)\nTOP The counter reaches the TOP when it becomes equal to the highest value in the count\nsequence. The TOP value can be assigned to be the fixed value 0xFF (MAX) or the\nvalue stored in the OCR2A Register. The assignment is dependent on the mode of\noperation\n\n176\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-2. Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment or decrement TCNT2 by 1.\ndirection Selects between increment and decrement.\nclear Clear TCNT2 (set all bits to zero).\nclkTn Timer/Counter clock, referred to as clkT2 in the following.\ntop Signalizes that TCNT2 has reached maximum value.\nbottom Signalizes that TCNT2 has reached minimum value (zero).\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock (clkT2). clkT2 can be generated from an external or internal clock source,\nselected by the Clock Select bits (CS22:0). When no clock source is selected (CS22:0 = 0) the\ntimer is stopped. However, the TCNT2 value can be accessed by the CPU, regardless of\nwhether clkT2 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the WGM21 and WGM20 bits located in\nthe Timer/Counter Control Register (TCCR2A) and the WGM22 located in the Timer/Counter\nControl Register B (TCCR2B). There are clos e connections between how the counter behaves\n(counts) and how waveforms are generated on the Output Compare outputs OC2A and OC2B.\nFor more details about advanced counting sequences and waveform generation, see \u201cModes of\nOperation\u201d on page 176 .\nThe Timer/Counter Overflow Flag (TOV2) is set according to the mode of operation selected by\nthe WGM22:0 bits. TOV2 can be used for generating a CPU interrupt.\n20.4 Modes of Operation\nThe mode of operation, that is, the behavior of the Timer/Counter and the Output Compare pins,\nis defined by the combination of the Waveform Generation mode ( WGM22:0) and Compare Out-\nput mode (COM2x1:0) bits. The Compare Output mode bits do not affect the counting sequence,while the Waveform Generation mode bits do. The COM2x1:0 bits control whether the P WM out-\nput generated should be inverted or not (inverted or non-inverted P WM). For non-P WM modes\nthe COM2x1:0 bits control whether the output should be set, cleared, or toggled at a comparematch. See \u201cCompare Match Output Unit\u201d on page 182.\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 183 .DATA BU S\nTCNTn Control LogiccountTOVn\n(Int.Req.)\ntop bottomdirectionclearTOSC1\nT/C\nOscillator\nTOSC2Prescaler\nclkI/OclkTn\n\n177\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.4.1 Normal Mode\nThe simplest mode of operation is the Normal mode ( WGM22:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 8-bit value (TOP = 0xFF) and then restarts from the bot-\ntom (0x00). In normal o peration the Timer/Counter Overflow Flag (TOV2) will be set in the same\ntimer clock cycle as the TCNT2 becomes zero. The TOV2 Flag in this case behaves like a ninth\nbit, except that it is only set, not cleared. However, combined with the timer overflow interrupt\nthat automatically clears the TOV2 Flag, the timer resolution can be increased by software.\nThere are no special cases to consider in the Normal mode, a new counter value can be writtenanytime.\nThe Output Compare unit can be used to generate interrupts at some given time. Using the Out-\nput Compare to generate waveforms in Normal mode is not recommended, since this willoccupy too much of the CPU time.\n20.4.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare or CTC mode ( WGM22:0 = 2), the OCR2A Register is used to\nmanipulate the counter resolution. In CTC mode the counter is cleared to zero when the counter\nvalue (TCNT2) matches the OCR2A. The OCR2A defines the top value for the counter, hencealso its resolution. This mode allows greater control of the compare match output frequency. It\nalso simplifies the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 20-3 . The counter value (TCNT2)\nincreases until a compare match occurs between TCNT2 and OCR2A, and then counter\n(TCNT2) is cleared.\nFigure 20-3. CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter value reaches the TOP value by using the\nOCF2A Flag. If the interrupt is enabled, the interrupt handler routine can be used for updatingthe TOP value. However, changing TOP to a va lue close to BOTTOM when the counter is run-\nning with none or a low prescaler value must be done with care since the CTC mode does not\nhave the double buffering feature. If the new value written to OCR2A is lower than the currentvalue of TCNT2, the counter will miss the compar e match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starting at 0x00 before the compare match can\noccur.\nFor generating a waveform output in CTC mode, the OC2A output can be set to toggle its logical\nlevel on each compare match by setting the Compare Output mode bits to toggle mode\n(COM2A1:0 = 1). The OC2A value will not be visible on the port pin unless the data direction forTCNTn\nOCnx\n(Toggle)OCnx Interrupt Flag Set\n1 4 Period 2 3(COMnx1:0 = 1)\n\n178\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nthe pin is set to output. The wavefo rm generated will have a maximum frequency of fOC2A =\nfclk_I/O /2 when OCR2A is set to zero (0x00). The waveform frequency is defined by the following\nequation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nAs for the Normal mode of operation, the TOV2  Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x00.\n20.4.3 Fast PWM Mode\nFigure 20-4. Fast P WM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches TOP. If the inter-\nrupt is enabled, the interrupt handler routine can be used for updating the compare value.\nIn fast P WM mode, the compare unit allows generation of P WM waveforms on the OC2x pin.\nSetting the COM2x1:0 bits to tw o will produce a non-inverted P WM and an inverted P WM output\ncan be generated by setting the COM2x1:0 to three. TOP is defined as 0xFF when WGM2:0 = 3,\nand OCR2A when WGM2:0 = 7 (see Table 20-3 on page 187 ). The actual OC2x value will only\nbe visible on the port pin if the data direction for the port pin is set as output. The P WM wave-\nform is generated by setting (or clearing) the OC2x Register at the compare match betweenOCR2x and TCNT2, and clearing (or setting) the OC2x Register  at the timer clock cycle the\ncounter is cleared (changes from TOP to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nThe extreme values for the OCR2A Register represent special cases when generating a P WM\nwaveform output in the fast P WM mode. If the OCR2A is set equal to BOTTOM, the output will\nbe a narrow spike for each MAX+1 timer clock cycle. Setting the OCR2A equal to MAX will resultfOCnxfclk_I/O\n2N1OCRnx+() \u22c5\u22c5------------------------------------------------- - =\nTCNTnOCRnx Update and\nTOVn Interrupt Flag Set\n1 Period 2 3OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Interrupt Flag Set\n4 5 6 7\nfOCnxPWMfclk_I/O\nN256\u22c5------------------=\n\n179\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nin a constantly high or low output (depending on the polarity of the output set by the COM2A1:0\nbits).\nA frequency (with 50% duty cycle) waveform output in fast P WM mode can be achieved by set-\nting OC2x to toggle its logical level on each compare match (COM2x1:0 = 1). The waveformgenerated will have a ma ximum frequency of f\noc2 = fclk_I/O /2 when OCR2A is set to zero. This fea-\nture is similar to the OC2A toggle in CTC mode, except the double buffer feature of the Output\nCompare unit is enabled in the fast P WM mode.\n20.4.4 Phase Correct PWM Mode\nThe phase correct P WM mode ( WGM22:0 = 1 or 5) provides a high resolution phase correct\nPWM waveform generation option. The phase correct P WM mode is based on a dual-slope\noperation. The counter counts repeatedly from BOTTOM to TOP and then from TOP to BOT-\nTOM. TOP is defined as 0xFF when WGM22:0 = 1, and OCR2A when MGM22:0 = 5. In non-\ninverting Compare Output mode, the Output Compare (OC2x) is cleared on the compare match\nbetween TCNT2 and OCR2x while upcounting, and set on the compare match while downcount-\ning. In inverting Output Compare mode, the operation is inverted. The dual-slope operation haslower maximum operation frequency than single slope operation. However, due to the symmet-\nric feature of the dual-slope P WM modes, these modes are preferred for motor control\napplications.\nIn phase correct P WM mode the counter is incremented until the counter value matches TOP.\nWhen the counter reaches TOP, it changes the count direction. The TCNT2 value will be equal\nto TOP for one timer clock cycle. The timing diagram for the phase correct P WM mode is shown\non Figure 20-5 . The TCNT2 value is in the timing diagram shown as a histogram for illustrating\nthe dual-slope operation. The diagram includes non-inverted and inverted P WM outputs. The\nsmall horizontal line marks on the TCNT2 sl opes represent compare matches between OCR2x\nand TCNT2.\nFigure 20-5. Phase Correct P WM Mode, Timing Diagram\nTOVn Interrupt Flag SetOCnx Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCnx\nOCnx (COMnx1:0 = 2)\n(COMnx1:0 = 3)OCRnx Update\n\n180\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches BOTTOM. The\nInterrupt Flag can be used to generate an interrupt each time the counter reaches the BOTTOM\nvalue.\nIn phase correct P WM mode, the compare unit allows generation of P WM waveforms on the\nOC2x pin. Setting the COM2x1:0 bits  to two will produce a non-inverted P WM. An inverted P WM\noutput can be generated by setting the COM2x1:0 to three. TOP is defined as 0xFF when\nWGM2:0 = 3, and OCR2A when MGM2:0 = 7 (see Table 20-4 on page 188 ). The actual OC2x\nvalue will only be visible on the port  pin if the data direction for the port pin is set as output. The\nPWM waveform is generated by clearing (or setting) the OC2x Register at the compare match\nbetween OCR2x and TCNT2 when the counter increments, and setting (or clearing) the OC2xRegister at compare match between OCR2x and TCNT2 when the counter decrements. The\nPWM frequency for the output when using phase correct P WM can be calculated by the follow-\ning equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nThe extreme values for the OCR2A Register represent special cases when generating a P WM\nwaveform output in the phase correct P WM mode. If the OCR2A is set equal to BOTTOM, the\noutput will be continuously low an d if set equal to MAX the output  will be continuously high for\nnon-inverted P WM mode. For inverted P WM the output will have th e opposite logic values.\nAt the very start of period 2 in Figure 20-5 on page 179  OCnx has a transition from high to low\neven though there is no Compare Match. The poin t of this transition is to guarantee symmetry\naround BOTTOM. There are two cases that give a transition without Compare Match.\n\u0081 OCR2A changes its value from MAX, like in Figure 20-5 on page 179 . When the OCR2A \nvalue is MAX the OCn pin value is the same as the result of a down-counting compare match. To ensure symmetry around BOTTOM the OCn value at MAX must correspond to the result of an up-counting Compare Match.\n\u0081 The timer starts counting from a value higher than the one in OCR2A, and for that reason \nmisses the Compare Match and hence the OCn change that would have happened on the way up.\n20.5 Output Compare Unit\nThe 8-bit comparator continuously compares TCNT2 with the Output Compare Register\n(OCR2A and OCR2B). Whenever TCNT2 equals OCR2A or OCR2B, the comparator signals a\nmatch. A match will set the Output Compare Flag (OCF2A or OCF2B) at the next timer clock\ncycle. If the corresponding interrupt is enabled, the Output Compare Flag generates an Output\nCompare interrupt. The Output Compare Flag is automatically cleared when the interrupt is exe-cuted. Alternatively, the Output Compare Flag can be cleared by software by writing a logical\none to its I/O bit location. The Waveform Generator uses the match signal to generate an output\naccording to operating mode set by the WGM22:0 bits and Compare Output mode (COM2x1:0)\nbits. The max and bottom signals are used by the Waveform Generator for handling the special\ncases of the extreme values in some modes of operation (see \u201cModes of Operation\u201d on page\n176).\nFigure 20-6 on page 181  shows a block diagram of the Output Compare unit.fOCnxPCPWMfclk_I/O\nN510\u22c5------------------=\n\n181\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-6. Output Compare Unit, Block Diagram\nThe OCR2x Register is double buffered when using any of the Pulse Width Modulation (P WM)\nmodes. For the Normal and Clear Timer on Compare (CTC) modes of operation, the doublebuffering is disabled. The double buffering synchronizes the update of the OCR2x Compare\nRegister to either top or bottom of the counting sequence. The synchronization prevents the\noccurrence of odd-length, non-symmetrical P WM pulses, thereby making the output glitch-free.\nThe OCR2x Register access may seem  complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR2x Buffer Register, and if double buffering is dis-\nabled the CPU will access  the OCR2x directly.\n20.5.1 Force Output Compare\nIn non-P WM waveform generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Outp ut Compare (FOC2x) bit. Forci ng compare match will not set the\nOCF2x Flag or reload/clear the timer, but the OC2x pin will be updated as if a real compare\nmatch had occurred (the COM2x1:0 bits settings de fine whether the OC2x pin is set, cleared or\ntoggled).\n20.5.2 Compare Match Bloc king by TCNT2 Write\nAll CPU write operations to the TCNT2 Register will block any compare matc h that occurs in the\nnext timer clock cycle, even when the timer is stopped. This feature allows OCR2x to be initial-\nized to the same value as TCNT2 without triggering an interrupt when the Timer/Counter clock isenabled.\n20.5.3 Using the Output Compare Unit\nSince writing TCNT2 in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNT2 when using the Output Compare channel,\nindependently of whether the Timer/Counter is running or not. If the value written to TCNT2equals the OCR2x value, the compare match will be missed, resulting in incorrect waveform\ngeneration. Similarly, do not write the TCNT2 value equal to BOTTOM when the counter is\ndowncounting.OCFn x (Int.Req.)= (8-bit Comparator )OCRnx\nOCnxDATA BU S\nTCNTn\nWGMn1:0Waveform Generatortop\nFOCn\nCOMnX1:0bottom\n\n182\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe setup of the OC2x should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OC2x value is to use the Force Output Com-\npare (FOC2x) strobe bit in Normal mode. The OC2x Register keeps its value even when\nchanging between Waveform Generation modes.\nBe aware that the COM2x1:0 bits are not doubl e buffered together with the compare value.\nChanging the COM2x1:0 bits will take effect immediately.\n20.6 Compare Match Output Unit\nThe Compare Output mode (COM2x1:0) bits have two functions. The Waveform Generator uses\nthe COM2x1:0 bits for defining the Output Compare (OC2x) state at the next compare match.\nAlso, the COM2x1:0 bits control the OC2x pin output source. Figure 20-7  shows a simplified\nschematic of the logic affected by the COM2x1:0 bit setting. The I/O Registers, I/O bits, and I/Opins in the figure are shown in bold. Only the parts of the general I/O Port Control Registers\n(DDR and PORT) that are affected by the COM2x1:0 bits are shown. When referring to the\nOC2x state, the reference is for the internal OC2x Register, not the OC2x pin.\nFigure 20-7. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC2x) from the Waveform\nGenerator if either of the COM2x1:0 bits are set. However, the OC2x pin direction (input or out-\nput) is still controlled by the Da ta Direction Register (DDR) for th e port pin. The Data Direction\nRegister bit for the OC2x pin (DDR_OC2x) must be set as output before the OC2x value is visi-\nble on the pin. The port override  function is independent of the Waveform Generation mode.\nThe design of the Output Compare pin logic allows initialization of the OC2x state before the out-\nput is enabled. Note that some COM2x1:0 bi t settings are reserved for certain modes of\noperation. See \u201cRegister Description\u201d on page 187.PORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATA BUSFOCnx\nclkI/O\n\n183\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.6.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COM2x1:0 bits differently in normal, CTC, and P WM modes.\nFor all modes, setting the COM2x1:0 = 0 tells the Waveform Generator that no action on the\nOC2x Register is to be performed on the next compare match. For compare output actions in the\nnon-PWM modes refer to Table 20-5 on page 188 . For fast P WM mode, refer to Table 20-6 on\npage 188 , and for phase correct P WM refer to Table 20-7 on page 189 .\nA change of the COM2x1:0 bits st ate will have effect at the first compare matc h after the bits are\nwritten. For non-P WM modes, the action can be forced to have immediate effect by using the\nFOC2x strobe bits.\n20.7 Timer/Counter Timing Diagrams\nThe following figures show the Timer/Counter  in synchronous mode, and the timer clock (clkT2)\nis therefore shown as a clock enable  signal. In asynchronous mode, clkI/O should be replaced by\nthe Timer/Counter Oscillator clock. The figures include information on when Interrupt Flags areset. Figure 20-8  contains timing data for basic Timer/ Counter operation. The figure shows the\ncount sequence close to the MAX value in all modes other than phase correct P WM mode.\nFigure 20-8. Timer/Counter Timing Diagram, no Prescaling\nFigure 20-9  shows the same timing data, but with the prescaler enabled.\nFigure 20-9. Timer/Counter Timing Dia gram, with Prescaler (f\nclk_I/O /8)clkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\nTOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n184\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 20-10  shows the setting of OCF2A in all modes except CTC mode.\nFigure 20-10. Timer/Counter Timing Diagram, Setting of OCF2A, with Prescaler (fclk_I/O /8)\nFigure 20-11  shows the setting of OCF2A and the clearing of TCNT2 in CTC mode.\nFigure 20-11. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Pres-\ncaler (fclk_I/O /8)\n20.8 Asynchronous Operati on of Timer/Counter2\nWhen Timer/Counter2 operates asynchronously, some considerations must be taken.\n\u0081Warning: When switching between asynchronous and synchronous clocking of \nTimer/Counter2, the Timer Registers TCNT2, OCR2x, and TCCR2x might be corrupted. A safe procedure for switching clock source is:\n1. Disable the Timer/Counter2 interrupts by clearing OCIE2x and TOIE2.2. Select clock source by setting AS2 as appropriate.3.Write new values to TCNT2, OCR2x, and TCCR2x.\n4. To switch to asynchronous operation: Wait for TCN2UB, OCR2xUB, and TCR2xUB.\n5. Clear the Timer/Counter2 Interrupt Flags.6. Enable interrupts, if needed.OCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n185\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 The CPU main clock frequenc y must be more than four times the Oscillator frequency.\n\u0081When writing to one of the regi sters TCNT2, O CR2x, or TCCR2x, the va lue is transferred to \na temporary register, and latched after two positive edges on TOSC1. The user should not write a new value before the contents of the temporary register have been transferred to its destination. Each of the five mentioned registers have their individual temporary register, which means that, for example, writing to TCNT2 does not disturb an OCR2x write in progress. To detect that a transfer to the destination register has taken place, the Asynchronous Status  Register \u2013 ASSR has been implemented.\n\u0081When entering Power-save or ADC Noise Reduction mode after having written to TCNT2, \nOCR2x, or TCCR2x, the user must wait until the written register has been updated if Timer/Counter2 is used to wake up the device. Other wise, the MCU will enter sleep mode \nbefore the changes are effective. This is particularly important if any of the Output Compare2 interrupt is used to wake up the device, since the Output Compare function is disabled during writing to OCR2x or TCNT2. If the write cycle is not finished, and the MCU enters sleep mode befo re the corresponding OCR2xUB bit returns to zero, the device will \nnever receive a compare match interr upt, and the MCU will not wake up.\n\u0081 If Timer/Counter2 is used to wake the device up from Power-save or ADC Noise Reduction \nmode, precautions must be taken if the user wants to re-enter one of these modes: The interrupt logic needs one TOSC1 cycle to be reset. If the time between wake-up and re-entering sleep mode is less than one TOSC1 cycle, the interrupt will not occur, and the device will fail to wake up. If the user is in doubt whether the time be fore re-entering Power-\nsave or ADC Noise Reduction mode is suffic ient, the following algorithm can be used to \nensure that one TOSC1 cycle has elapsed:\n1.Write a value to TCCR2x, TCNT2, or OCR2x.\n2.Wait until the corresponding Update Busy Flag in ASSR returns to zero.\n3. Enter Power-save or ADC Noise Reduction mode.\n\u0081When the asynchronous ope ration is selected, the 32.768kH z Oscillator for Timer/Counter2 \nis always running, except in Power-down and Standby modes. After a Power-up Reset or wake-up from Power-down or Standby mode, the user should be aware of the fact that this Oscillator might take as long as  one second to stabilize. The us er is advised to wait for at \nleast one second before using Timer/Counter2 after power-up or wake-up from Power-down or Standby mode. The contents of all Timer/Counter2 Registers must be considered lost after a wake-up from Power-down or Standby mode due to unstable clock signal upon start-up, no matter whether the Oscillator is in use or a clock signal is applied to the TOSC1 pin.\n\u0081 Description of wake up from Power-save or  ADC Noise Reduction mode when the timer is \nclocked asynchronously: When the interrupt condition is met, the wake up process is started \non the following cycle of the timer clock, that is, the timer is always advanced by at least one before the processor can read the counter value. After wake-up, the MCU is halted for four cycles, it executes the interrupt routine, and resumes execution from the instruction \nfollowing SLEEP.\n\u0081 Reading of the TCNT2 Register shortly after wake-up from Power-save may give an \nincorrect result. Since TCNT2 is clocked on the asynchronous TOSC clock, reading TCNT2 must be done through a register synchronized to the internal I/O clock domain. Synchronization takes place for every rising TOSC1 edge. When waking up from Power-\nsave mode, and the I/O clock (clk\nI/O) again becomes active, TCNT2 will read as the previous \nvalue (before entering sleep) until the next rising TOSC1 edge. The phase of the TOSC clock after waking up from Power-save mode is essentially unpredictable, as it depends on the wake-up time. The recommended procedure for reading TCNT2 is thus as follows:\n1.Write any value to either of the registers OCR2x or TCCR2x.\n2.Wait for the corresponding Update Busy Flag to be cleared.\n3. Read TCNT2.\n\n186\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 During asynchronous operation, the synchronization of the Interrupt Flags for the \nasynchronous timer takes three p rocessor cycles plus one timer cycle. The timer is therefore \nadvanced by at least one before the processo r can read the timer value causing the setting \nof the Interrupt Flag. The Output Compare pi n is changed on the timer clock and is not \nsynchronized to the processor clock.\n20.9 Timer/Counter Prescaler\nFigure 20-12. Prescaler for Timer/Counter2\nThe clock source for Timer/Counter2 is named clkT2S. clkT2S is by default connected to the main\nsystem I/O clock clkIO. By setting the AS2 bit in ASSR, Timer/Counter2 is asynchronously\nclocked from the TOSC1 pin. This enables us e of Timer/Counter2 as a Real Time Counter\n(RTC). When AS2 is set, pins TOSC1 and TOSC2 are disconnected from Port C. A crystal can\nthen be connected between the TOSC1 and TOSC2 pins to serve as an independent clocksource for Timer/Counter2. The Oscillator is optimized for use with a 32.768kHz crystal. By set-\nting the EXCLK bit in the ASSR, a 32kHz  external clock can be applied. See \u201cASSR \u2013\nAsynchronous Status Register\u201d on page 192  for details.\nFor Timer/Counter2, the possible prescaled selections are: clk\nT2S/8, clkT2S/32, clkT2S/64,\nclkT2S/128, clkT2S/256, and clkT2S/1024. Additionally, clkT2S as well as 0 (stop) may be selected.\nSetting the PSRASY bit in GTCCR resets the prescale r. This allows the user to operate with a\npredictable prescaler.10-BIT T/C PRE SCALER\nTIMER/COUNTER2 CLOCK SOURCEclkI/O clkT2S\nTOSC1\nAS2\nCS20\nCS21\nCS22clkT2S/8\nclkT2S/64\nclkT2S/128\nclkT2S/1024\nclkT2S/256\nclkT2S/32\n0PSRASYClear\nclkT2\n\n187\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10 Register Description\n20.10.1 TCCR2A \u2013Timer/Counter Control Register A\n\u0081 Bits 7:6 \u2013 COM2A1:0: Compare Match Output A Mode\nThese bits control the Output Compare pin (OC2A) behavior. If one or both of the COM2A1:0\nbits are set, the OC2A output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction Re gister (DDR) bit corresponding to the OC2A pin\nmust be set in order to enable the output driver.\nWhen OC2A is connected to the pin, the function of the COM2A1:0 bits depends on the\nWGM22:0 bit setting. Table 20-2  shows the COM2A1:0 bit functionality when the WGM22:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 20-3  shows the COM2A1:0 bit functionality when the WGM21:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 178  for more details.\nTable 20-4 on page 188  shows the COM2A1:0 bi t functionality when the WGM22:0 bits are set\nto phase correct P WM mode.Bit 7 6 5 4 3 2 1 0\n(0xB0) COM2A1 COM2A0 COM2B1 COM2B0 \u2013 \u2013 WGM21 WGM20 TCCR2A\nRead/Write R/ W R/W R/W R/W RR R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 20-2. Compare Output Mode, non-P WM Mode\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n0 1 Toggle OC2A on Compare Match\n1 0 Clear OC2A on Compare Match1 1 Set OC2A on Compare Match\nTable 20-3. Compare Output Mode, Fast P WM Mode(1)\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n01WGM22 = 0: Normal Port O peration, OC2A Disconnected\nWGM22 = 1: Toggle OC2A on Compare Match\n10Clear OC2A on Compare Match, set OC2A at BOTTOM\n(non-inverting mode)\n11Set OC2A on Compare Match, clear OC2A at BOTTOM\n(inverting mode)\n\n188\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. A special case occurs when OCR2A equals TOP and COM2A1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 179  for more details.\n\u0081 Bits 5:4 \u2013 COM2B1:0: Compare Match Output B Mode\nThese bits control the Output Compare pin (OC2B) behavior. If one or both of the COM2B1:0\nbits are set, the OC2B output overrides the normal po rt functionality of the I/O pin it is connected\nto. However, note that the Data Direction Re gister (DDR) bit corresponding to the OC2B pin\nmust be set in order to enable the output driver.\nWhen OC2B is connected to the pin, the function of the COM2B1:0 bits depends on the\nWGM22:0 bit setting. Table 20-5  shows the COM2B1:0 bit functionality when the WGM22:0 bits\nare set to a normal or CTC mode (non-P WM).\nTable 20-6  shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to fast P WM\nmode.\nNote: 1. A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at BOTTOM. See \u201cFast P WM Mode\u201d on \npage 178  for more details.Table 20-4. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM2A1 COM2A0 Description\n0 0 Normal port operation, OC2A disconnected\n01WGM22 = 0: Normal Port O peration, OC2A Disconnected\nWGM22 = 1: Toggle OC2A on Compare Match\n10Clear OC2A on Compare Match when up-counting\nSet OC2A on Compare Match when down-counting\n11Set OC2A on Compare Match when up-counting\nClear OC2A on Compare Match when down-counting\nTable 20-5. Compare Output Mode, non-P WM Mode\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected0 1 Toggle OC2B on Compare Match\n1 0 Clear OC2B on Compare Match\n1 1 Set OC2B on Compare Match\nTable 20-6. Compare Output Mode, Fast P WM Mode(1)\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected\n01 R e s e r v e d\n10Clear OC2B on Compare Match, set OC2B at BOTTOM\n(non-inverting mode)\n11Set OC2B on Compare Match, clear OC2B at BOTTOM\n(inverting mode)\n\n189\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 20-7  shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to phase cor-\nrect PWM mode.\nNote: 1. A special case occurs when OCR2B equals TOP and COM2B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP . See \u201cPhase Correct P WM Mode\u201d on \npage 179  for more details.\n\u0081 Bits 3, 2 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bits 1:0 \u2013 WGM21:0: Waveform Generation Mode\nCombined with the WGM22 bit found in the TCCR2B Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-\nform generation to be used, see Table 20-8 . Modes of operation supported by the Timer/Counter\nunit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types ofPulse Width Modulation (P WM) modes (see \u201cModes of Operation\u201d on page 176 ).\nNotes: 1. MAX  = 0xFF .\n2. BOTTOM = 0x00.Table 20-7. Compare Output Mode, Phase Correct P WM Mode(1)\nCOM2B1 COM2B0 Description\n0 0 Normal port operation, OC2B disconnected\n01 R e s e r v e d\n10Clear OC2B on Compare Match when up-counting\nSet OC2B on Compare Match when down-counting\n11Set OC2B on Compare Match when up-counting\nClear OC2B on Compare Match when down-counting\nTable 20-8. Waveform Generation Mode Bit Description\nMode WGM2 WGM1 WGM0Timer/Counter \nMode of \nOperation TOPUpdate of\nOCRx atTOV Flag\nSet on(1)(2)\n0 0 0 0 Normal 0xFF Immediate MAX\n1 001PWM, Phase \nCorrect0xFF TOP BOTTOM\n2 0 1 0 CTC OCRA Immediate MAX\n3 011 F a s t  P WM0 x F F B O T T O MM A X\n4 100 R e s e r v e d \u2013 \u2013 \u2013\n5 101PWM, Phase \nCorrectOCRA TOP BOTTOM\n6 110 R e s e r v e d \u2013 \u2013 \u2013\n7 111 F a s t  P WM OCRA BOTTOM TOP\n\n190\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10.2 TCCR2B \u2013 Timer/Counter Control Register B\n\u0081 Bit 7 \u2013 FOC2A: Force Output Compare A\nThe FOC2A bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR2B is written when operating in P WM mode. When writing a logical one to the FOC2A bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC2A output is\nchanged according to its COM2A1:0 bits setting. Note that the FOC2A bit is implemented as a\nstrobe. Therefore it is the value present in the COM2A1:0 bits that determines the effect of theforced compare.\nA FOC2A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR2A as TOP.\nThe FOC2A bit is always read as zero.\n\u0081 Bit 6 \u2013 FOC2B: Force Output Compare B\nThe FOC2B bit is only active when the WGM bits specify a non-P WM mode.\nHowever, for ensuring compatibility with future devices, this bit must be set to zero when\nTCCR2B is written when operating in P WM mode. When writing a logical one to the FOC2B bit,\nan immediate Compare Match is forced on the Waveform Generation unit. The OC2B output is\nchanged according to its COM2B1:0 bits setting. Note that the FOC2B bit is implemented as a\nstrobe. Therefore it is the value present in the COM2B1:0 bits that determines the effect of theforced compare.\nA FOC2B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR2B as TOP.\nThe FOC2B bit is always read as zero.\n\u0081 Bits 5:4 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 3 \u2013 WGM22: Waveform Generation Mode\nSee the description in the \u201cTCCR2A \u2013Timer/Counter Control Register A\u201d on page 187 .\n\u0081 Bit 2:0 \u2013 CS22:0: Clock Select\nThe three Clock Select bits select the clock source to be used by the Timer/Counter, see Table\n20-9 on page 191 .Bit 7 6 5 4 3 2 1 0\n(0xB1) FOC2A FOC2B \u2013 \u2013 WGM22 CS22 CS21 CS20 TCCR2B\nRead/Write WW RR R / W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n191\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of the\ncounting.\n20.10.3 TCNT2 \u2013 Timer/Counter Register\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter. Writing to the TCNT2 Register blocks (removes) the Compare\nMatch on the following timer clock. Modifying the counter (TCNT2) while the counter is running,introduces a risk of missing a Compare Match between TCNT2 and the OCR2x Registers.\n20.10.4 OCR2A \u2013 Output Compare Register A\nThe Output Compare Register A contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT2). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OC2A pin.\n20.10.5 OCR2B \u2013 Output Compare Register B\nThe Output Compare Register B contains an 8-bi t value that is continuously compared with the\ncounter value (TCNT2). A match can be used to generate an Output Compare interrupt, or to\ngenerate a waveform output on the OC2B pin.Table 20-9. Clock Select Bit Description\nCS22 CS21 CS20 Description\n0 0 0 No clock source (Timer/Counter stopped)001 c l k\nT2S/(No prescaling)\n010 c l kT2S/8 (From prescaler)\n011 c l kT2S/32 (From prescaler)\n100 c l kT2S/64 (From prescaler)\n101 c l kT2S/128 (From prescaler)\n110 c l kT2S/256 (From prescaler)\n111 c l kT2S/1024 (From prescaler)\nB i t 76543210\n(0xB2) TCNT2[7:0] TCNT2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xB3) OCR2A[7:0] OCR2A\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xB4) OCR2B[7:0] OCR2B\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n192\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n20.10.6 ASSR \u2013 Asynchronous Status Register\n\u0081 Bit 6 \u2013 EXCLK: Enable External Clock Input\nWhen EXCLK is written to one, and asynchronous clock is selected, the external clock input buf-\nfer is enabled and an external cl ock can be input on Timer Oscilla tor 1 (TOSC1) pin instead of a\n32kHz crystal. Writing to EXCLK should be done before asynchronous operation is selected.\nNote that the crystal Oscillator will only run when this bit is zero.\n\u0081 Bit 5 \u2013 AS2: Asynchronous Timer/Counter2\nWhen AS2 is written to zero, Timer/Counter2 is clocked from the I/O clock, clkI/O. When AS2 is\nwritten to one, Timer/Counter2 is clocked from a crystal Oscilla tor connected to the Timer Oscil-\nlator 1 (TOSC1) pin. When the value of AS2 is changed, the contents of TCNT2, OCR2A,\nOCR2B, TCCR2A and TCCR2B might be corrupted.\n\u0081 Bit 4 \u2013 TCN2UB: Timer/Counter2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set.\nWhen TCNT2 has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that TCNT2 is ready to be updated with a new value.\n\u0081 Bit 3 \u2013 OCR2AUB: Output Co mpare Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and OCR2A is written, this bit becomes set.\nWhen OCR2A has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that OCR2A is ready to be updated with a new value.\n\u0081 Bit 2 \u2013 OCR2BUB: Output Compare Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and OCR2B is written, this bit becomes set.\nWhen OCR2B has been updated from the temporary storage register, this bit is cleared by hard-\nware. A logical zero in this bit indicates that OCR2B is ready to be updated with a new value.\n\u0081 Bit 1 \u2013 TCR2AUB: Timer/Counter Control Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCCR2A is written, this bit becomes set.\nWhen TCCR2A has been updated from  the temporary storage regi ster, this bit is cleared by\nhardware. A logical zero in this bit indicates that TCCR2A is ready to be updated with a new\nvalue.\n\u0081 Bit 0 \u2013 TCR2BUB: Timer/Counter  Control Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCCR2B is written, this bit becomes set.\nWhen TCCR2B has been updated from  the temporary storage regi ster, this bit is cleared by\nhardware. A logical zero in this bit indicates that TCCR2B is ready to be updated with a new\nvalue.\nIf a write is performed to any of the five Timer/Counter2 Registers while its update busy flag is\nset, the updated value might get corrupted and cause an unintentional interrupt to occur.Bit 7 6 5 4 3 2 1 0\n(0xB6) \u2013 EXCLK AS2 TCN2UB OCR2AUB OCR2BUB TCR2AUB TCR2BUB ASSR\nRead/Write R R/ W R/W RR R R R\nInitial Value 0 0 0 0 0 0 0 0\n\n193\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe mechanisms for reading TCNT2, OCR2A,  OCR2B, TCCR2A and TCCR2B are different.\nWhen reading TCNT2, the actual timer value is read. When reading OCR2A, OCR2B, TCCR2A\nand TCCR2B the value in the temporary storage register is read.\n20.10.7 TIMSK2 \u2013 Timer/Counter2  Interrupt Mask Register\n\u0081 Bit 2 \u2013 OCIE2B: Timer/Counter2 Output Compare Match B Interrupt Enable\nWhen the OCIE2B bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Compare Match B interrupt is enabled. The corresponding interrupt is executed\nif a compare match in Timer/Counter2 occurs, that is, when the OCF2B bit is set in the\nTimer/Counter 2 Interrupt Flag Register \u2013 TIFR2.\n\u0081 Bit 1 \u2013 OCIE2A: Timer/Counter2 Output Compare Match A Interrupt Enable\nWhen the OCIE2A bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Compare Match A interrupt is enabled. The corresponding interrupt is executed\nif a compare match in Timer/Counter2 occurs, that is, when the OCF2A bit is set in the\nTimer/Counter 2 Interrupt Flag Register \u2013 TIFR2.\n\u0081 Bit 0 \u2013 TOIE2: Timer/Counter2 Overflow Interrupt Enable\nWhen the TOIE2 bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter2 occurs, that is, when  the TOV2 bit is set in the Timer/Counter2 Inter-\nrupt Flag Register \u2013 TIFR2.\n20.10.8 TIFR2 \u2013 Timer/Counter2 Interrupt Flag Register\n\u0081 Bit 2 \u2013 OCF2B: Output Compare Flag 2 B\nThe OCF2B bit is set (one) when a compare match occurs between the Timer/Counter2 and the\ndata in OCR2B \u2013 Output Compare Register2. OCF2B is cleared by hardware when executing\nthe corresponding interrupt handling vector. Alter natively, OCF2B is cleared by writing a logic\none to the flag. When the I-bit in SREG, OCIE2B (Timer/Counter2 Compare match Interrupt\nEnable), and OCF2B are set (one), the Timer/Counter2 Compare match Interrupt is executed.\n\u0081 Bit 1 \u2013 OCF2A: Output Compare Flag 2 A\nThe OCF2A bit is set (one) when a compare match occurs between the Timer/Counter2 and the\ndata in OCR2A \u2013 Output Compare Register2. OCF2A is cleared by hardware when executing\nthe corresponding interrupt handling vector. Alter natively, OCF2A is cleared by writing a logic\none to the flag. When the I-bit in SREG, OCIE2A (Timer/Counter2 Compare match Interrupt\nEnable), and OCF2A are set (one), the Timer/Counter2 Compare match Interrupt is executed.B i t 76543 2 1 0\n(0x70) \u2013 \u2013 \u2013 \u2013 \u2013 OCIE2B OCIE2A TOIE2 TIMSK2\nRead/Wr i t e RRRRR R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x17 (0x37) \u2013 \u2013 \u2013 \u2013 \u2013 OCF2B OCF2A TOV2 TIFR2\nRead/Wr i t e RRRRR R / W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n194\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TOV2: Timer/Counter2 Overflow Flag\nThe TOV2 bit is set (one) when an overflow occu rs in Timer/Counter2. TOV2 is cleared by hard-\nware when executing the corresponding interrupt handling vector. Alternatively, TOV2 is cleared\nby writing a logic one to the flag. When the SREG I-bit, TOIE2A (Timer/Counter2 Overflow Inter-\nrupt Enable), and TOV2 are set (one), the Timer/ Counter2 Overflow interrupt is executed. In\nPWM mode, this bit is set when Timer/Counter2 changes counting direction at 0x00.\n20.10.9 GTCCR \u2013 General Time r/Counter Control Register\n\u0081 Bit 1 \u2013 PSRASY: Prescaler Reset Timer/Counter2\nWhen this bit is one, the Time r/Counter2 prescaler will be rese t. This bit is normally cleared\nimmediately by hardware. If the bit is written wh en Timer/Counter2 is operating in asynchronous\nmode, the bit will remain one until the presca ler has been reset. The bit will not be cleared by\nhardware if the TSM bit is set. Refer to the description of the \u201cBit 7 \u2013 TSM: Timer/Counter Syn-\nchronization Mode\u201d on page 170  for a description of the Timer/Counter Synchronization mode.Bit 7 6 5 4 3 2 1 0\n0x23 (0x43) TSM \u2013 \u2013 \u2013 \u2013 \u2013 PSRASY PSRSYNC GTCCR\nRead/Write R/ W RRR R R R / W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n195\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21. SPI \u2013 Serial Peripheral Interface\nThe Serial Peripheral Interface (SPI) allows hi gh-speed synchronous data transfer between the\nATmega640/1280/1281/2560/2561 and peripheral devices or between several AVR devices.\nThe ATmega640/1280/1281/2560/2561 SPI includes the following features:\n\u0081Full-duplex, Three-wire Synchronous Data Transfer\n\u0081Master or Slave Operation\n\u0081LSB First or MSB First Data Transfer\n\u0081Seven Programmable Bit Rates\n\u0081End of Transmission Interrupt Flag\n\u0081Write Collision Flag Protection\n\u0081Wake-up from Idle Mode\n\u0081Double Speed (CK/2) Master SPI Mode\nUSART can also be used in Master SPI mode, see \u201cUSART in SPI Mode\u201d on page 232 .\nThe Power Reduction SPI bit, PRSPI, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56  on\npage 50 must be written to zero to enable SPI module.\nFigure 21-1. SPI Block Diagram(1)\nNote: 1. Refer to Figure 1-1 on page 2 , and Table 13-6 on page 79  for SPI pin placement.\nThe interconnection between Master and Slave CPUs with SPI is shown in Figure 21-2 on page\n196. The system consists of two shift Registers, and a Master clock generator. The SPI Master\ninitiates the communication cycle wh en pulling low the Slave Select SS  pin of the desired Slave.SPI2XSPI2XDIVIDER\n/2/4/8/16/32/64/12 8\n\n196\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nMaster and Slave prepare the data to be sent in their respective shift Registers, and the Master\ngenerates the required clock pulses on the SCK line to interchange data. Data is always shifted\nfrom Master to Slave on the Master Out \u2013 Slave In, MOSI, line, and from Slave to Master on the\nMaster In \u2013 Slave Out, MISO, line. After each data packet, the Master will synchronize the Slave\nby pulling high the Slave Select, SS , line.\nWhen configured as a Master, the SPI interface has no automatic control of the SS  line. This\nmust be handled by user software before communication can start. When this is do ne, writing a\nbyte to the SPI Data Register starts the SPI clock generator, and the hardware shifts the eight\nbits into the Slave. After shifting one byte , the SPI clock generator stops, setting the end of\nTransmission Flag (SPIF). If the SPI Interrupt Enable bit (SPIE) in the SPCR Register is set, aninterrupt is requested. The Master may continue to shift the next byte by writing it into SPDR, or\nsignal the end of packet by pulling high the Slave Select, SS\n line. The last incoming byte will be\nkept in the Buffer Register for later use.\nWhen configured as a Slave, the SPI interface will remain  sleeping with MISO tri-stated as long\nas the SS  pin is driven high. In this state, software may update the contents of the SPI Data\nRegister, SPDR, but the data will not be shifted out by incoming clock pulses on the SCK pinuntil the SS\n pin is driven low. As one byte has been completely shifted, the end of Transmission\nFlag, SPIF is set. If the SPI Interrupt Enable bit, SPIE, in the SPCR Register is set, an interrupt\nis requested. The Slave may continue to place new data to be sent into SPDR before readingthe incoming data. The last incoming byte will be kept in the Buffer Register for later use.\nFigure 21-2. SPI Master-slave Interconnection\nThe system is single buffered in the transmit di rection and double buffered in the receive direc-\ntion. This means that bytes to be transmitted cannot be written to the SPI Data Register before\nthe entire shift cycle is completed. When receiving data, however, a received character must be\nread from the SPI Data Register before the next character has been completely shifted in. Oth-erwise, the first byte is lost.\nIn SPI Slave mode, the control logic will sample  the incoming signal of the SCK pin. To ensure\ncorrect sampling of the clock signal, the minimum low and high periods should be:\nLow period: longer than 2 CPU clock cycles.\nHigh period: longer than 2 CPU clock cycles.SHIFT\nENABLE\n\n197\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the SPI is enabled, the data direction of the MOSI, MISO, SCK, and SS  pins is overridden\naccording to Table 21-1 . For more details on automatic port overrides, refer to \u201cAlternate Port\nFunctions\u201d on page 75 .\nNote: 1. See \u201cAlternate Functions of Port B\u201d on page 79  for a detailed description of how to define the \ndirection of the user defined SPI pins.\nThe following code examples show how to initialize the SPI as a Master and how to perform a\nsimple transmission. DDR_SPI in the examples mu st be replaced by the actual Data Direction\nRegister controlling the SPI pins. DD_MOSI, DD_MISO and DD_SCK must be replaced by the\nactual data direction bits for these pins. For example, if MOSI is placed on pin PB5, replace\nDD_MOSI with DDB5 and DDR_SPI with DDRB.Table 21-1. SPI Pin Overrides(1)\nPin Direction, Master SPI Direction, Slave SPI\nMOSI User Defined Input\nMISO Input User Defined\nSCK User Defined Input\nSS User Defined Input\n\n198\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nSPI_MasterInit:\n; Set MOSI and SCK output, all others inputldir17,(1<<DD_MOSI)|(1<<DD_SCK)\noutDDR_SPI,r17\n; Enable SPI, Master, set clock rate fck/16\nldir17,(1<<SPE)|(1<<MSTR)|(1<<SPR0)\noutSPCR,r17\nret\nSPI_MasterTransmit:\n; Start transmission of data (r16)\noutSPDR,r16\nWait_Transmit:\n; Wait for transmission complete\nsbisSPSR,SPIF\nrjmpWait_Transmit\nret\nC Code Example(1)\nvoid SPI_MasterInit( void)\n{\n/* Set MOSI and SCK output, all others input */\nDDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);\n/* Enable SPI, Master, set clock rate fck/16 */SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);\n}\nvoid SPI_MasterTransmit( char cData)\n{\n/* Start transmission */SPDR = cData;\n/* Wait for transmission complete */\nwhile(!(SPSR & (1<<SPIF)))\n;\n}\n\n199\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following code examples show how to initialize the SPI as a Slave and how to perform a\nsimple reception.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nSPI_SlaveInit:\n; Set MISO output, all others input\nldir17,(1<<DD_MISO)\noutDDR_SPI,r17\n; Enable SPI\nldir17,(1<<SPE)\noutSPCR,r17\nret\nSPI_SlaveReceive:\n; Wait for reception complete\nsbisSPSR,SPIF\nrjmpSPI_SlaveReceive\n; Read received data and return\ninr16,SPDR\nret\nC Code Example(1)\nvoid SPI_SlaveInit( void)\n{\n/* Set MISO output, all others input */\nDDR_SPI = (1<<DD_MISO);\n/* Enable SPI */SPCR = (1<<SPE);\n}\nchar SPI_SlaveReceive( void)\n{\n/* Wait for reception complete */while(!(SPSR & (1<<SPIF)))\n;\n/* Return Data Register */return SPDR;\n}\n\n200\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.1 SS  Pin Functionality\n21.1.1 Slave Mode\nWhen the SPI is configured as a Slave, the Slave Select (SS ) pin is always input. When SS  is\nheld low, the SPI is activated, and MISO becomes  an output if configured so by the user. All\nother pins are inputs. When SS  is driven high, all pins are inputs, and the SPI is passive, which\nmeans that it will not receive incoming data. No te that the SPI logic will be reset once the SS  pin\nis driven high.\nThe SS  pin is useful for packet/byte synchroniza tion to keep the slave bit counter synchronous\nwith the master clock generator. When the SS  pin is driven high, the SPI slave will immediately\nreset the send and receive logic, and drop any partially received data in the Shift Register.\n21.1.2 Master Mode\nWhen the SPI is configured as a Master (MSTR in  SPCR is set), the user can determine the\ndirection of the SS  pin.\nIf SS  is configured as an output, the pin is a general output pin which does not affect the SPI\nsystem. Typically, the pin will be driving the SS  pin of the SPI Slave.\nIf SS  is configured as an input, it must be held high to ensure Master SPI operation. If the SS  pin\nis driven low by peripheral circuitry when the SPI is configured as a Master with the SS  pin\ndefined as an input, the SPI syst em interprets this as another master selecting the SPI as a\nslave and starting to send data to it. To avoid bus contention, the SPI system takes the followingactions:\n1. The MSTR bit in SPCR is cleared and the SPI system becomes a Slave. As a result of\nthe SPI becoming a Slave, the MOSI and SCK pins become inputs.\n2. The SPIF Flag in SPSR is set, and if the SPI interrupt is enabled, an d the I-bit in SREG is\nset, the interrupt routine will be executed.\nThus, when interrupt-driven SPI transmission is used in Master mode, and there exists a possi-\nbility that SS\n is driven low, the interrup t should always check that the MSTR bit is still set. If the\nMSTR bit has been cleared by a slave select, it must be set by the user to re-enable SPI Master\nmode.\n21.1.3 Data Modes\nThere are four combinations of SCK phase and polarity with respect to serial data, which are\ndetermined by control bits CPHA and CPOL. The SPI data transfer formats are shown in Figure\n21-3 on page 201  and Figure 21-4 on page 201 . Data bits are shifted out and latched in on\nopposite edges of the SCK signal, ensuring sufficient time for data signals to stabilize. This is\nclearly seen by summarizing Table 21-3 on page 202  and Table 21-4 on page 202  in Table 21-2 .\nTable 21-2. CPOL Functionality\nLeading Edge Trailing eDge SPI Mode\nCPOL=0, CPHA=0 Sample (Rising) Setup (Falling) 0\nCPOL=0, CPHA=1 Setup (Rising) Sample (Falling) 1\nCPOL=1, CPHA=0 Sample (Falling) Setup (Rising) 2\nCPOL=1, CPHA=1 Setup (Falling) Sample (Rising) 3\n\n201\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 21-3. SPI Transfer Format with CPHA = 0\nFigure 21-4. SPI Transfer Format with CPHA = 1Bit 1\nBit 6LSB\nMSBSCK (CPOL = 0)\nmode 0\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 2\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5MSB first (DORD = 0)\nLSB first (DORD = 1)\nSCK (CPOL = 0)\nmode 1\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 3\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5Bit 1\nBit 6LSB\nMSBMSB first (DORD = 0)\nLSB first (DORD = 1)\n\n202\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.2 Register Description\n21.2.1 SPCR \u2013 SPI Control Register\n\u0081 Bit 7 \u2013 SPIE: SPI  Interrupt Enable\nThis bit causes the SPI in terrupt to be executed if SPIF bit in the SPSR Register is set and the if\nthe Global Interrupt Enable bit in SREG is set.\n\u0081 Bit 6 \u2013 SPE: SPI Enable\nWhen the SPE bit is written to one, the SPI is enabled. This  bit must be set to enable any SPI\noperations.\n\u0081 Bit 5 \u2013 DORD: Data Order\nWhen the DORD bit is written to one, the LSB of the data word is transmitted first.\nWhen the DORD bit is written to zero, the MSB of the data word is transmitted first.\n\u0081 Bit 4 \u2013 MSTR: Master/Slave Select\nThis bit selects Master SPI mode when written to one, and Slave SPI mode when written logic\nzero. If SS  is configured as an input and is driven low while MSTR is set, MSTR will be cleared,\nand SPIF in SPSR will become set. The user will th en have to set MSTR to re-enable SPI Mas-\nter mode.\n\u0081 Bit 3 \u2013 CPOL: Clock Polarity\nWhen this bit is written to one, SCK is high when idle. When CPOL is written to zero, SCK is low\nwhen idle. Refer to Figure 21-3 on page 201  and Figure 21-4 on page 201  for an example. The\nCPOL functionality is summarized in Table 21-3 .\n\u0081 Bit 2 \u2013 CPHA: Clock Phase\nThe settings of the Clock Phase bit (CPHA) determine if data is sampled on the leading (first) or\ntrailing (last) edge of SCK. Refer to Figure 21-3 on page 201  and Figure 21-4 on page 201  for an\nexample. The CPOL functionality is summarized in Table 21-4 .B i t 76543210\n0x2C (0x4C) SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 SPCR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 21-3. CPOL Functionality\nCPOL Leading Edge Trailing Edge\n0 Rising Falling\n1 Falling Rising\nTable 21-4. CPHA Functionality\nCPHA Leading Edge Trailing Edge\n0 Sample Setup\n1 Setup Sample\n\n203\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bits 1, 0 \u2013 SPR1, SPR0: SPI Clock Rate Select 1 and 0\nThese two bits control the SCK rate of the dev ice configured as a Master. SPR1 and SPR0 have\nno effect on the Slave. The relationship between SCK and the Oscillator Clock frequency fosc is\nshown in Table 21-5 .\n21.2.2 SPSR \u2013 SPI Status Register\n\u0081 Bit 7 \u2013 SPIF: SPI Interrupt Flag\nWhen a serial transfer is complete, the SPIF Flag is set. An interrupt is generated if SPIE in\nSPCR is set and global interrupts are enabled. If SS  is an input and is dr iven low when the SPI is\nin Master mode, this will also set the SPIF Flag. SPIF is cleared by hardwa re when executing the\ncorresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the\nSPI Status Register with SPIF set, then accessing the SPI Data Register (SPDR).\n\u0081 Bit 6 \u2013 WCOL: Write COLlision Flag\nThe WCOL bit is set if the SPI Data Register (S PDR) is written during a data transfer. The\nWCOL bit (and the SPIF bit) are cleared by first reading the SPI Status Register with WCOL set,\nand then accessing the SPI Data Register.\n\u0081 Bit 5:1 \u2013 Res: Reserved Bits\nThese bits are reserved bits  and will always read as zero.\n\u0081 Bit 0 \u2013 SPI2X: Double SPI Speed Bit\nWhen this bit is written logic one the SPI s peed (SCK Frequency) will be doubled when the SPI\nis in Master mode (see Table 21-5 ). This means that the mini mum SCK period will be two CPU\nclock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at fosc/4\nor lower.\nThe SPI interface on the ATmega640/1280/1281/2560/2561 is also used for program memory\nand EEPROM downloading or uploading. See \u201cSerial Downloading\u201d on page 349  for serial pro-\ngramming and verification.Table 21-5. Relationship Between SCK and  the Oscillator Frequency \nSPI2X SPR1 SPR0 SCK Frequency\n00 0 fosc/4\n00 1 fosc/16\n01 0 fosc/64\n01 1 fosc/128\n10 0 fosc/2\n10 1 fosc/8\n11 0 fosc/32\n11 1 fosc/64\nB i t 76543210\n0x2D (0x4D) S P I F W C O L \u2013\u2013\u2013\u2013\u2013 S P I 2 X S P S R\nRead/Wr i t e RRRRRRR R / W\nI n i t i a l  V a l u e00000000\n\n204\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n21.2.3 SPDR \u2013 SPI Data Register\nThe SPI Data Register is a read/write register used for data transfer between the Register File\nand the SPI Shift Register. Writing to the register initiates data transmission. Reading the regis-\nter causes the Shift Register Receive buffer to be read.B i t 76543210\n0x2E (0x4E) MSB LSB SPDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u eXXXXXXXX U n d e f i n e d\n\n205\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22. USART\n22.1 Features\n\u0081Full Duplex Operation (Independent Se rial Receive and Transmit Registers)\n\u0081Asynchronous or Synchronous Operation\n\u0081Master or Slave Clocked Synchronous Operation\n\u0081High Resolution Baud Rate Generator\n\u0081Supports Serial Frames with 5, 6, 7, 8, or 9 Data Bits and 1 or 2 Stop Bits\n\u0081Odd or Even Parity Generation and Parity Check Supported by Hardware\n\u0081Data OverRun Detection\n\u0081Framing Error Detection\n\u0081Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter\n\u0081Three Separate Interrupts on  TX Complete, TX Data Register Empty and RX Complete\n\u0081Multi-processor Communication Mode\n\u0081Double Speed Asynchronous Communication Mode\nOverview The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a\nhighly flexible serial communication device.\nThe ATmega640/1280/2560 has four USART\u2019s,  USART0, USART1, USART2, and USART3.\nThe functionality for all four USART\u2019s is de scribed below. USART0, USART1, USART2, and\nUSART3 have different I/O registers as shown in \u201cRegister Summary\u201d on page 411 .\nA simplified block diagram of the USART Transmitter is shown in Figure 22-1 on page 206 . CPU\naccessible I/O Registers and I/O pins are shown in bold.\nThe Power Reducion USART0 bit, PRUSART0, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on\npage 56  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART1 bit, PRUSART1, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART2 bit, PRUSART2, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\nThe Power Reducion USART3 bit, PRUSART3, in \u201cPRR1 \u2013 Power Reduction Register 1\u201d on\npage 57  must be disabled by writ ing a logical zero to it.\n\n206\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-1. USART Block Diagram(1)\nNote: 1. See Figure 1-1 on page 2 , Figure 1-3 on page 4 , Table 13-12 on page 83 , Table 13-15 on \npage 86 , Table 13-24 on page 92  and Table 13-27 on page 94  for USART pin placement.\nThe dashed boxes in the block diagram separate the three main parts of the USART (listed from\nthe top): Clock Generator, Transmitter and Receiver. Control Registers are shared by all units.The Clock Generation logic consis ts of synchronization logic fo r external clock input used by\nsynchronous slave operation, and the baud rate  generator. The XCKn (Transfer Clock) pin is\nonly used by synchronous transfer mode. The Transmi tter consists of a single write buffer, a\nserial Shift Register, Parity Generator and Cont rol logic for handling different serial frame for-\nmats. The write buffer allows a continuous transfer of data without any delay between frames.\nThe Receiver is the most complex part of the USART module due to its clock and data recoveryunits. The recovery units are used for asynchronous data reception. In addition to the recovery\nunits, the Receiver includes a Parity Checker, Control logic, a Shift Register and a two level\nreceive buffer (UDRn). The Receiver supports the same frame formats as the Transmitter, andcan detect Frame Error, Data OverRun and Parity Errors.\n22.2 Clock Generation\nThe Clock Generation logic generates the base clock for the Transmitter and Receiver. TheUSARTn supports four modes of clock opera tion: Normal asynchronous, Double Speed asyn-\nchronous, Master synchronous and Slave synchronous mode. The UMSELn bit in USART\nControl and Status Register C (UCSRnC) selects between asynchronous and synchronous\noperation. Double Speed (asynchronous mode only) is controlled by the U2Xn found in thePARITY\nGENERATORUBRR[H:L]\nUDR  (Transmit)\nUCSRA UCSRB UCSRCBAUD RATE GENERATOR\nTRANSMIT SHIFT REGISTER\nRECEIVE SHIFT REGISTER RxDTxDPIN\nCONTROL\nUDR (Receive)PIN\nCONTROLXCK\nDATA\nRECOVERYCLOCK\nRECOVERYPIN\nCONTROL\nTX\nCONTROL\nRX\nCONTROL\nPARITY\nCHECKERDATA BUSOSC\nSYNC LOGICClock Generator\nTransmitter\nReceiver\n\n207\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nUCSRnA Register. When using synchronous mode (UMSELn = 1), the Data Direction Register\nfor the XCKn pin (DDR_XCKn) controls whether the clock source is internal (Master mode) or\nexternal (Slave mode). The XCKn pin is only active when using synchronous mode.\nFigure 22-2  shows a block diagram of the clock generation logic.\nFigure 22-2. Clock Generation Logic, Block Diagram\nSignal description:\ntxclk Transmitter clock (Internal Signal).\nrxclk Receiver base clock (Internal Signal).\nxcki Input from XCK pin (internal Signal). Used for synchronous slave\noperation.\nxcko Clock output to XCK pin (Internal Signal). Used for synchronous master\noperation.\nfOSC XTAL pin frequency (System Clock).\n22.2.1 Internal Clock Generation \u2013 The Baud Rate Generator\nInternal clock generation is used for the as ynchronous and the synchronous master modes of\noperation. The description in this section refers to Figure 22-2 .\nThe USART Baud Rate Register (UBRRn) and the down-counter connected to it function as a\nprogrammable prescaler or baud rate generator. The down-counter, running at system clock(f\nosc), is loaded with the UBRRn value each time  the counter has counted down to zero or when\nthe UBRRLn Register is written. A clock is gene rated each time the counter reaches zero. This\nclock is the baud rate generator clock output (= fosc/(UBRRn+1)). The Transmitter divides the\nbaud rate generator clock output by 2, 8 or 16 depending on mode. The baud rate generator out-\nput is used directly by the Receiver\u2019s clock an d data recovery units. However, the recovery units\nuse a state machine that uses 2, 8 or 16 states depending on mode set by the state of theUMSELn, U2Xn and DDR_XCKn bits.\nTable 22-1 on page 208  contains equations for calculating th e baud rate (in bits per second) and\nfor calculating the UBRRn value for each mode of operation using an internally generated clocksource.Prescaling\nDown-Counter/2UBRR\n/4 /2fosc\nUBRR+1\nSync\nRegisterOSC\nXCK\nPintxclkU2X\nUMSELDDR_XCK0\n1\n01\nxcki\nxcko\nDDR_XCK\nrxclk\n0110Edge\nDetector\nUCPOL\n\n208\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. The baud rate is defined to be the transfer rate in bit per second (bps).\nBAUD Baud rate (in bits per second, bps).\nfOSC System Oscillator clock frequency.\nUBRRn Contents of the UBRRHn and UBRRLn Registers, (0-4095).\nSome examples of UBRRn values for some system clock frequencies are found in Table 22-9 on\npage 227 .\n22.2.2 Double Speed Operation (U2Xn)\nThe transfer rate can be doubled by setting the U2Xn bit in UCSRnA. Setting this bit only has\neffect for the asynchronous operation. Set this bit to zero when using synchronous operation.\nSetting this bit will reduce the divisor of the baud rate divider from 16 to 8, effectively doubling\nthe transfer rate for asynchronous communication. Note however that the Receiver will in thiscase only use half the number of samples (reduced from 16 to 8) for data sampling and clock\nrecovery, and therefore a more accurate baud rate setting and system clock are required when\nthis mode is used. For the Transmitter, there are no downsides.\n22.2.3 External Clock\nExternal clocking is used by the synchronous sl ave modes of operation. The description in this\nsection refers to Figure 22-2 on page 207  for details.\nExternal clock input from the XCKn pin is sample d by a synchronization register to minimize the\nchance of meta-stability. The output from the synchronization register must then pass through\nan edge detector before it can be used by the Transmitter and Receiver. This process intro-Table 22-1. Equations for Calculating Baud Rate Register Setting\nOperating ModeEquation for Calculating \nBaud Rate(1)Equation for Calculating \nUBRR Value\nAsynchronous Normal \nmode (U2Xn = 0)\nAsynchronous Double \nSpeed mode (U2Xn = \n1)\nSynchronous Master \nmodeBAUDfOSC\n16UBRR n1+ ()----------------------------------------- - = UBRR nfOSC\n16BAUD----------------------- -1\u2013 =\nBAUDfOSC\n8UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n8BAUD-------------------- 1\u2013 =\nBAUDfOSC\n2UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n2BAUD-------------------- 1\u2013 =\n\n209\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nduces a two CPU clock period delay and therefore the maximum external XCKn clock frequency\nis limited by the following equation:\nNote that fosc depends on the stability of the system clock source. It is therefore recommended to\nadd some margin to avoid possible loss of data due to frequency variations.\n22.2.4 Synchronous Clock Operation\nWhen synchronous mode is  used (UMSELn = 1), the XCKn pin will be used as either clock input\n(Slave) or clock output (Master). The dependency between the clock edges and data sampling\nor data change is the same. The basic principle is  that data input (on RxDn) is sampled at the\nopposite XCKn clock edge of the edge the data output (TxDn) is changed.\nFigure 22-3. Synchronous Mode XCKn Timing.\nThe UCPOLn bit UCRSC selects which XCKn cloc k edge is used for data sampling and which is\nused for data change. As Figure 22-3  shows, when UCPOLn is zero  the data will be changed at\nrising XCKn edge and sampled at falling XCKn edge. If UCPOLn is set, the data will be changed\nat falling XCKn edge and samp led at rising XCKn edge.\n22.3 Frame Formats\nA serial frame is defined to be one character of da ta bits with synchronizat ion bits (start and stop\nbits), and optionally a parity bi t for error checking. The USART accepts all 30 combinations of\nthe following as valid frame formats:\n\u0081 1 start bit\n\u0081 5, 6, 7, 8, or 9 data bits\u0081 no, even or odd parity bit\u0081 1 or 2 stop bitsA frame starts with the start bit followed by the least significant data bit. Then the next data bits,\nup to a total of nine, are succeeding, ending with t he most significant bit. If enabled, the parity bit\nis inserted after the data bits, before the stop bits. When a complete frame is transmitted, it can\nbe directly followed by a new frame, or the communication line can be set to an idle (high) state.\nFigure 22-4 on page 210  illustrates the possible combinations of the frame formats. Bits inside\nbrackets are optional.fXCKfOSC\n4-----------<\nRxD / TxDXCK\nRxD / TxDXCK UCPOL = 0UCPOL = 1\nSample\nSample\n\n210\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-4. Frame Formats\nSt Start bit, always low.\n(n) Data bits (0 to 8).\nP Parity bit. Can be odd or even.\nSp Stop bit, always high.\nIDLE No transfers on the communication line (RxDn or TxDn). An IDLE line\nmust be high.\nThe frame format used by th e USART is set by the UCSZn2:0, UPMn1:0 and USBSn bits in\nUCSRnB and UCSRnC. The Receiver  and Transmitter use the same setting. Note that changing\nthe setting of any of these bits will corrupt a ll ongoing communication for both the Receiver and\nTransmitter.\nThe USART Character SiZe (UCSZn2:0) bits select  the number of data bits in the frame. The\nUSART Parity mode (UPMn1:0) bits enable and set the type of parity bit. The selection between\none or two stop bits is done by the USART Stop Bit Select (USBSn) bit. The Re ceiver ignores\nthe second stop bit. An FE (F rame Error) will theref ore only be detected in the cases where the\nfirst stop bit is zero.\n22.3.1 Parity Bit Calculation\nThe parity bit is calculated by do ing an exclusive-or of all the data bits. If odd parity is used, the\nresult of the exclusive or is inverted. The parity bit is located between the last data bit and firststop bit of a serial frame. The relation betwee n the parity bit and data bits is as follows:\nP\neven Parity bit using even parity.\nPodd Parity bit using odd parity.\ndn Data bit n of the character.\n22.4 USART Initialization\nThe USART has to be initialized before any communication can take place. The initialization pro-\ncess normally consists of setting the baud rate, setting frame format and enabling the\nTransmitter or the Receiver depending on the usage. For interrupt driven USART operation, the\nGlobal Interrupt Flag should be cleared (and interrupts globally disabled) when doing the\ninitialization.\nBefore doing a re-initialization with changed baud rate or frame format, be sure that there are no\nongoing transmissions during the period the registers are changed. The TXCn Flag can be usedto check that the Transmitter has completed all transfers, and the RXC Flag can be used to1 0 2 3 4 [5] [6] [7] [8] [P] St Sp1 [Sp2] (St / IDLE) (IDLE)FRAME\nPevendn1\u2013\u2026 d3d2d1d00\nPodd\u2295\u2295\u2295\u2295\u2295\u2295\ndn1\u2013\u2026 d3d2d1d01 \u2295\u2295\u2295\u2295\u2295\u2295=\n=\n\n211\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ncheck that there are no unread data in the receive buffer. Note that the TXCn Flag must be\ncleared before each transmission (before UDRn is  written) if it is used for this purpose.\nThe following simple USART initialization code examples show one assembly and one C func-\ntion that are equal in functionality. The exampl es assume asynchronous  operation using polling\n(no interrupts enabled) and a fixed frame format. The baud rate is given as a function parameter.\nFor the assembly code, the baud rate parameter is assumed to be stored in the r17:r16\nRegisters.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nMore advanced initialization routines can be made that include frame format as parameters, dis-\nable interrupts and so on. However, many appl ications use a fixed setting of the baud and\ncontrol registers, and for these types of applicati ons the initialization code can be placed directly\nin the main routine, or be combined with initialization code for other I/O modules.Assembly Code Example(1)\nUSART_Init:\n; Set baud rate\nstsUBRRnH, r17\nstsUBRRnL, r16\nldir16, (1<<U2Xn)\nstsUCRnA, r16\n; Enable receiver and transmitter\nldir16, (1<<RXENn)|(1<<TXENn)\nstsUCSRnB,r16\n; Set frame format: 8data, 1stop bit\nldir16, (2<<UMSELn)|(3<<UCSZn0)\nstsUCSRnC,r16\nret\nC Code Example(1)\n#define FOSC 1843200// Clock Speed\n#define BAUD 9600#define (MYUBRR FOSC/16/BAUD-1)void main( void ){...USART_Init ( MYUBRR );...} // mainvoid USART_Init( unsigned int ubrr){/* Set baud rate */UBRRH = (unsigned char)(ubrr>>8);UBRRL = (unsigned char)ubrr;/* Enable receiver and transmitter */UCSRB = (1<<RXEN)|(1<<TXEN);/* Set frame format: 8data, 2stop bit */UCSRC = (1<<USBS)|(3<<UCSZ0);} // USART_Init\n\n212\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.5 Data Transmission \u2013 The USART Transmitter\nThe USART Transmitter is enabled by setting the Transmit Enable  (TXEN) bit in the UCSRnB\nRegister. When the Transmitter is enabled, the normal port operation of the TxDn pin is overrid-\nden by the USART and given the function as t he Transmitter\u2019s serial output. The baud rate,\nmode of operation and frame format must be set up once before doing any transmissions. If syn-\nchronous operation is used, the clock on the XCKn pi n will be overridden and used as\ntransmission clock.\n22.5.1 Sending Frames with 5 to 8 Data Bit\nA data transmission is initiated by loading the transmit buffer with the data to be transmitted. The\nCPU can load the transmit buffer by writing to the UDRn I/O location. The buffered data in the\ntransmit buffer will be moved to the Shift Register wh en the Shift Register is ready to send a new\nframe. The Shift Register is loaded with new data if it is in idle state (no ongoing transmission) orimmediately after the last stop bit of the previous frame is transmitted. When the Shift Register is\nloaded with new data, it will transf er one complete frame at the ra te given by the Baud Register,\nU2Xn bit or by XCKn depending on mode of operation.\nThe following code examples show a simple USART transmit function based on polling of the\nData Register Empty  (UDREn) Flag. When using frames with less than eight bits, the most sig-\nnificant bits written to the UDRn  are ignored. The USART has to be initialized before the function\ncan be used. For the assembly code, the data to be sent is assumed to be stored in Register\nR16.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe function simply waits for the transmit buffer to be em pty by checking the UDREn Flag,\nbefore loading it wit h new data to be transmitted. If the Da ta Register Empty in terrupt is utilized,\nthe interrupt routine writes the data into the buffer.Assembly Code Example(1)\nUSART_Transmit:\n; Wait for empty transmit buffer\nldsr17, UCSRnA\nsbrs r17, UDREn\nrjmpUSART_Transmit\n; Put data (r16) into buffer, sends the data\nstsUDRn,r16\nret\nC Code Example(1)\nvoid USART_Transmit( unsigned char  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRnA & (1<<UDREn)) )\n;\n/* Put data into buffer, sends the data  */\nUDRn = data;\n}\n\n213\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.5.2 Sending Frames with 9 Data Bit\nIf 9-bit characters are used (UCSZn = 7), the ninth bit must be written to the TXB8 bit in\nUCSRnB before the low byte of the character is  written to UDRn. The following code examples\nshow a transmit function that handles 9-bit characters. For the assembly code, the data to be\nsent is assumed to be stored in registers R17:R16.\nNotes: 1. These transmit functions are written to be general functions. They can be optimized if the con-\ntents of the UCSRnB is static. For example, only the TXB8 bit of the UCSRnB Register is used \nafter initialization.\n2.See \u201cAbout Code Examples\u201d on page 11.\nThe ninth bit can be used for indicating an address frame when using multi processor communi-\ncation mode or for other protocol handling as for example synchronization.\n22.5.3 Transmitter Flags and Interrupts\nThe USART Transmitter has two flags that indi cate its state: USART Data Register Empty\n(UDREn) and Transmit Complete (TXCn). Both flags can be used for generating interrupts.\nThe Data Register Empty (UDREn) Flag indicates whether the transmit buffer is ready to receive\nnew data. This bit is set when the transmit buffer is empty, and cleared when the transmit buffer\ncontains data to be transmitted that has not yet be en moved into the Shift Register. For compat-\nibility with future devices, alwa ys write this bit to zero when  writing the UCSRnA Register.Assembly Code Example(1)(2)\nUSART_Transmit:\n; Wait for empty transmit buffer\nsbisUCSRnA,UDREn\nrjmpUSART_Transmit\n; Copy 9th bit from r17 to TXB8\ncbiUCSRnB,TXB8\nsbrcr17,0\nsbiUCSRnB,TXB8\n; Put LSB data (r16) into buffer, sends the data\nstsUDRn,r16\nret\nC Code Example(1)(2)\nvoid USART_Transmit( unsigned int  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRnA & (1<<UDREn))) )\n;\n/* Copy 9th bit to TXB8 */\nUCSRnB &= ~(1<<TXB8);\nif ( data & 0x0100 )\nUCSRnB |= (1<<TXB8);\n/* Put data into buffer, sends the data  */\nUDRn = data;\n}\n\n214\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWhen the Data Register Empty Interrupt Enable ( UDRIEn) bit in UCSRnB is written to one, the\nUSART Data Register Empty Inte rrupt will be executed as long as UDREn is set (provided that\nglobal interrupts are enabled). UD REn is cleared by writing UDRn. When interrupt-driven data\ntransmission is used, the Data Register Empty interrupt routine must either write new data toUDRn in order to clear UDREn or disable the Data Register Empty interrupt, otherwise a new\ninterrupt will occur once the in terrupt routin e terminates.\nThe Transmit Complete (TXCn) Flag bit is set one when the entire frame in the Transmit Shift\nRegister has been shifted out and there are no new data currently present in the transmit buffer.\nThe TXCn Flag bit is automatically cleared when a transmit complete interrupt is executed, or it\ncan be cleared by writing a one to its bit location . The TXCn Flag is usef ul in half-duplex commu-\nnication interfaces (like the RS-485 standard) , where a transmitting application must enter\nreceive mode and free the communication bus immediately after completing the transmission.\nWhen the Transmit Compete Interrupt Enable (TXCIEn) bit in UCSRnB is set, the USART\nTransmit Complete Interrupt will  be executed when the TXCn Flag becomes set (provided that\nglobal interrupts are enabled). When the transmit complete interrupt is used, the interrupt han-\ndling routine does not have to clear the TXCn Fl ag, this is done automatically when the interrupt\nis executed.\n22.5.4 Parity Generator\nThe Parity Generator calculates the parity bit for the serial frame data. When parity bit is enabled\n(UPMn1 = 1), the transmitter control logic inserts the parity bit between the last data bit and the\nfirst stop bit of the frame that is sent.\n22.5.5 Disabling the Transmitter\nThe disabling of the Tran smitter (setting the TXEN to zero ) will not become effective until ongo-\ning and pending transmissions are completed, that is, when the Transmit Shift Register and\nTransmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter\nwill no longer override the TxDn pin.\n22.6 Data Reception \u2013 The USART Receiver\nThe USART Receiver is enabled by writi ng the Receive Enable (RXENn) bit in the\nUCSRnB Register to one. When the Receiver is enabled, the normal pin operation of the RxDn\npin is overridden by the USART and given the func tion as the Receiver\u2019s serial input. The baud\nrate, mode of operation and frame format must be set up once before any serial reception canbe done. If synchronous operation is used, the cloc k on the XCKn pin will be used as transfer\nclock.\n22.6.1 Receiving Frames with 5 to 8 Data Bits\nThe Receiver starts data reception when it detects a valid start bit. Each bit that follows the start\nbit will be sampled at the baud rate or XCKn cl ock, and shifted into the Receive Shift Register\nuntil the first stop bit of  a frame is received. A second stop  bit will be ignored by the Receiver.\nWhen the first stop bit is received, that is, a complete serial frame is present in the Receive Shift\nRegister, the contents of the Shift Register will be moved into the rece ive buffer. The receive\nbuffer can then be read by reading the UDRn I/O location.\nThe following code example shows a simple US ART receive function based on polling of the\nReceive Complete (RXCn) Flag. When using frames with less than eight bits the most significant\nbits of the data read from the UDRn will be masked to zero. Th e USART has to be initialized\nbefore the function can be used.\n\n215\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe function simply waits for data to be present in the receive buffer by checking the RXCn Flag,\nbefore reading the buffer and returning the value.\n22.6.2 Receiving Frames with 9 Data Bits\nIf 9-bit characters are used (UCSZn=7) the ninth bit must be read from the RXB8n bit in\nUCSRnB before  reading the low bits from the UDRn. This rule applies to the FEn, DORn and\nUPEn Status Flags as well. Read status fr om UCSRnA, then data from UDRn. Reading the\nUDRn I/O location will change the state of the re ceive buffer FIFO and consequently the TXB8n,\nFEn, DORn and UPEn bits, which a ll are stored in the FIFO, will change.\nThe following code example shows a simple USART receive function that handles both nine bit\ncharacters and the status bits.Assembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nldsr17, UCSRnA\nsbrsr17, RXCn\nrjmpUSART_Receive\n; Get and return received data from buffer\nldsr16, UDRn\nret\nC Code Example(1)\nunsigned char  USART_Receive( void )\n{\n/* Wait for data to be received  */\nwhile ( !(UCSRnA & (1<<RXCn)) )\n;\n/* Get and return received data from buffer  */\nreturn UDRn;\n}\n\n216\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\nThe receive function example reads all the I/O R egisters into the Register File before any com-\nputation is done. This gives an optimal receive buffer utilization since the bu ffer location read will\nbe free to accept new data as early as possible.\n22.6.3 Receive Compete Flag and Interrupt\nThe USART Receiver has one flag that indicates the Receiver state.\nThe Receive Complete (RXCn) Flag indicates if there are unread data present in the receive buf-\nfer. This flag is one when unread data exist in the receive buffer, and zero when the receiveAssembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nldsr17, UCSRnA\nsbrsr17, RXCn\nrjmpUSART_Receive\n; Get status and 9th bit, then data from buffer\nldsr18, UCSRnA\nldsr17, UCSRnB\nldsr16, UDRn\n; If error, return -1\nandir18,(1<<FEn)|(1<<DORn)|(1<<UPEn)\nbreqUSART_ReceiveNoError\nldir17, HIGH(-1)\nldir16, LOW(-1)\nUSART_ReceiveNoError:\n; Filter the 9th bit, then return\nlsrr17\nandir17, 0x01\nret\nC Code Example(1)\nunsigned int  USART_Receive( void )\n{\nunsigned char  status, resh, resl;\n/* Wait for data to be received  */\nwhile ( !(UCSRnA & (1<<RXCn)) )\n;\n/* Get status and 9th bit, then data  */\n/* from buffer  */\nstatus = UCSRnA;resh = UCSRnB;resl = UDRn;/* If error, return -1  */\nif ( status & (1<<FEn)|(1<<DORn)|(1<<UPEn) )\nreturn -1;\n/* Filter the 9th bit, then return  */\nresh = (resh >> 1) & 0x01;return ((resh << 8) | resl);\n}\n\n217\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nbuffer is empty (that is, does not contain any un read data). If the Receiver is disabled (RXENn =\n0), the receive bu ffer will be flushed and consequently  the RXCn bit will become zero.\nWhen the Receive Complete Interrupt Enable (RXCIEn) in UCSRnB is set, the USART Receive\nComplete interrupt will be executed as long as the RXCn Flag is se t (provided that  global inter-\nrupts are enabled). When interrupt-driven data reception is used, the receive complete routine\nmust read the received data from UDRn in order to clear the RXCn Flag, otherwise a new inter-\nrupt will occur once the inte rrupt routine terminates.\n22.6.4 Receiver Error Flags\nThe USART Receiver has three Error Flags: Frame Error (FEn), Data OverRun (DORn) and\nParity Error (UPEn). All can be accessed by reading UCSRnA. Common for the Error Flags is\nthat they are located in the receive buffer together with the frame for which they indicate the\nerror status. Due to the buffering of the Error Flags, the UCSRnA must be read before thereceive buffer (UDRn), since reading the UDRn I/O location change s the buffer read location.\nAnother equality for the Error Flags is that they can not be altered by software doing a write to\nthe flag location. However, all flags must be set to zero when the UCSRnA is written for upwardcompatibility of future USART impl ementations. None of the Error Flags can genera te interrupts.\nThe Frame Error (FEn) Flag indicates the state of the first stop bit of the next readable frame\nstored in the receive buffer. The FEn Flag is zero when the stop bit was correctly read (as one),and the FEn Flag will be one when the stop bit was incorrect (zero). This flag can be used for\ndetecting out-of-sync conditions, detecting break conditions and protocol handling. The FEn\nFlag is not affected by the setting of the U SBSn bit in UCSRnC since the Receiver ignores all,\nexcept for the first, stop bits. For compatibility with future devices, always set this bit to zero\nwhen writing to UCSRnA.\nThe Data OverRun (DORn) Flag indicates data loss due to a receiver buffer full condition. A\nData OverRun occurs when the receive buffer is full (two characters), it is a new character wait-\ning in the Receive Shift Register, and a new start bit is detected. If the DORn Flag is set there\nwas one or more serial frame lost between the frame last read from UDRn, and the next frameread from UDRn. For compatibility wi th future devices, always write this bit to zero when writing\nto UCSRnA. The DORn Flag is cleared when t he frame received was successfully moved from\nthe Shift Register to the receive buffer.\nThe Parity Error (UPEn) Flag indicates that the next frame in the receive buffer had a Parity\nError when received. If Parity Check is not enabled the UPEn bit will always be read zero. For\ncompatibility with future devices, always set this  bit to zero when writing to UCSRnA. For more\ndetails see \u201cParity Bit Calculation\u201d on page 210  and \u201cParity Checker\u201d on page 217 .\n22.6.5 Parity Checker\nThe Parity Checker is active when the high USART Parity mode (UPMn1) bit is set. Type of Par-\nity Check to be performed (odd or even) is selected by the UPMn0 bit. When enabled, the Parity\nChecker calculates the parity of the data bits in incoming frames and compares the result with\nthe parity bit from the serial frame. The result of the check is stored in the receive buffer togetherwith the received data and stop bits. The Parity Error (UPEn) Flag can then be read by software\nto check if the frame had a Parity Error.\nThe UPEn bit is set if the next character that can be read from the receive buffer had a Parity\nError when received and the Parity Checking was enabled at that point (UPMn1 = 1). This bit is\nvalid until the receive buffer (UDRn) is read.\n\n218\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.6.6 Disabling the Receiver\nIn contrast to the Transmitter, disabling of the Receiver will be immediate. Data from ongoing\nreceptions will ther efore be lost. When disabled (that is, the RXENn is set to zero) the Receiver\nwill no longer override th e normal function of the RxDn port pi n. The Receiver buffer FIFO will be\nflushed when the Receiver is disabled. Remaining data in th e buffer will be lost.\n22.6.7 Flushing the Receive Buffer\nThe receiver buffer FIFO will be flushed when th e Receiver is disabled, that is, the buffer will be\nemptied of its contents. Unread data will be lost. If the buffer has to be flushed during normaloperation, due to for in stance an error conditi on, read the UDRn I/O location until the RXCn Flag\nis cleared. The following code example shows how to flush the receive buffer.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n22.7 Asynchronous Data Reception\nThe USART includes a clock recovery and a data  recovery unit for handling asynchronous data\nreception. The clock recovery logic is used fo r synchronizing the internally generated baud rate\nclock to the incoming asynchronous serial frames at the RxDn pin. The data recovery logic sam-ples and low pass filters each incoming bit, ther eby improving the noise immunity of the\nReceiver. The asynchronous reception operational range depends on the accuracy of the inter-\nnal baud rate clock, the rate of the incoming frames, and the frame size in number of bits.\n22.7.1 Asynchronous Clock Recovery\nThe clock recovery logic synchronizes internal clock to the incoming serial frames. Figure 22-5\non page 219  illustrates the sampling process of the start bit of an incoming frame. The sample\nrate is 16 times the baud rate for Normal mode, and eight times the baud rate for Double Speed\nmode. The horizontal arrows illustrate the sy nchronization variation due to the sampling pro-\ncess. Note the larger time variation when using the Double Speed mode (U2Xn = 1) of\noperation. Samples denoted zero are samples done when the RxDn line is idle (that is, no com-\nmunication activity).Assembly Code Example\n(1)\nUSART_Flush:\nsbisUCSRnA, RXCn\nretinr16, UDRn\nrjmpUSART_Flush\nC Code Example(1)\nvoid USART_Flush( void )\n{\nunsigned char  dummy;\nwhile ( UCSRnA & (1<<RXCn) ) dummy = UDRn;\n}\n\n219\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-5. Start Bit Sampling\nWhen the clock recovery logic detects a high (idle) to low (start) transition on the RxDn line, the\nstart bit detection sequence is initiated. Let sample 1 denote the first zero-sample as shown inthe figure. The clock recovery logic then uses samples 8, 9, and 10 for Normal mode, and sam-\nples 4, 5, and 6 for Double Speed mode (indicated with sample numbers inside boxes on the\nfigure), to decide if a valid start bit is received. If two or more of these three samples have logicalhigh levels (the majority wins), the start bit is rejected as a noise spike and the Receiver starts\nlooking for the next high to low-transition. If however, a valid start bit is detected, the clock recov-\nery logic is synchronized and the data recove ry can begin. The sy nchronization process is\nrepeated for each start bit.\n22.7.2 Asynchronous Data Recovery\nWhen the receiver clock is synchronized to the start bit, the data recovery can begin. The data\nrecovery unit uses a state machine that has  16 states for each bit in Normal mode and eight\nstates for each bit in Double Speed mode. Figure 22-6  shows the sampling of the data bits and\nthe parity bit. Each of the samples is given a number that is equal to the state of the recovery\nunit.\nFigure 22-6. Sampling of Data and Parity Bit\nThe decision of the logic level of the received bit is taken by doing a majori ty voting of the logic\nvalue to the three samples in the center of the received bit. The center samples are emphasized\non the figure by having the sample number inside boxes. The majority voting process is done as\nfollows: If two or all three samples have high levels, the received bit is registered to be a logic 1.If two or all three samples have low levels, the received bit is registered to be a logic 0. Thismajority voting process acts as a low pass filter for the incoming signal on the RxDn pin. The\nrecovery process is then repeated until a complete frame is received. Including the first stop bit.\nNote that the Receiver only uses the first stop bit of a frame.\nFigure 22-7 on page 220  shows the sampling of the stop bit and the earliest possible beginning\nof the start bit of the next frame.1234567 8 9 10 11 12 13 14 15 16 12START IDLE\n0 0BIT 0\n3\n123 4 5 678 12 0RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n1234567 8 9 10 11 12 13 14 15 16 1BIT n\n123 4 5 678 1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n\n220\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 22-7. Stop Bit Sampling and Ne xt Start Bit Sampling\nThe same majority voting is done to the stop bit as done for the other bits in the frame. If the stop\nbit is registered to have a logic 0 va lue, the Frame Error (FEn) Flag will be set.\nA new high to low transition indicating the start bit of a new frame can come right after the last of\nthe bits used for majority voting. For Normal Speed mode, the first low level sample can be at\npoint marked (A) in Figure 22-7 . For Double Speed mode the first low level must be delayed to\n(B). (C) marks a stop bit of full length. The ear ly start bit detection influences the operational\nrange of the Receiver.\n22.7.3 Asynchronous Operational Range\nThe operational range of the Receiver is dependent on the mismatch between the received bit\nrate and the internally generated baud rate. If the Transmitter is sending frames at too fast or tooslow bit rates, or the internally generated baud rate of the Receiver does not have a similar (see\nTable 22-2 on page 221 ) base frequency, the Receiver will not be able to synchronize the\nframes to the start bit.\nThe following equations can be used to calculate the ratio of the incoming data rate and internal\nreceiver baud rate.\nD Sum of character size and parity size (D = 5 to 10 bit).\nS Samples per bit. S = 16 for Normal Speed mode and S = 8 for Double Speed\nmode.\nS\nF First sample number used for majority voting. SF = 8 for normal speed and SF = 4\nfor Double Speed mode.\nSM Middle sample number used for majority voting. SM = 9 for normal speed and\nSM= 5 for Double Speed mode.\nRslow is the ratio of the slowest incoming data rate that can be accepted in relation to the\nreceiver baud rate. Rfast is the ratio of the fastest incoming data rate that can be\naccepted in relation to the receiver baud rate.1234567 8 9 10 0/1 0/1 0/1STOP 1\n123 4 5 6 0/1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)(A) (B) (C)\nRslowD1+() S\nS1\u2013 DS\u22c5SF++------------------------------------------ - =RfastD2+() S\nD1+() SSM+-----------------------------------=\n\n221\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 22-2  and Table 22-3  list the maximum receiver baud rate error that can be tolerated. Note\nthat Normal Speed mode has higher toleration of baud rate variations.\nThe recommendations of the maximum receiver baud rate error was made under the assump-\ntion that the Receiver and Transmitter equally divides the maximum total error.\nThere are two possible sources fo r the receivers baud rate erro r. The Receiver\u2019s system clock\n(XTAL) will always have some minor instabilit y over the supply voltage range and the tempera-\nture range. When using a crystal to generate the system clock, this is rarely a problem, but for a\nresonator the system clock may differ more than 2% depending of the resonators tolerance. Thesecond source for the error is more controllable. The baud rate generator can not always do an\nexact division of the system frequency to get the b aud rate wanted. In this case an UBRR value\nthat gives an acceptable low error can be used if possible.\n22.8 Multi-processor Communication Mode\nSetting the Multi-processor Communication m ode (MPCMn) bit in UCSRnA enables a filtering\nfunction of incoming frames received by the USART Receiver. Frames that do not contain\naddress information will be ignored and not put in to the receive buffer. This effectively reduces\nthe number of incoming frames that has to be handled by the CPU, in a system with multiple\nMCUs that communicate via the same serial bu s. The Transmitter is unaffected by the MPCMn\nsetting, but has to be used diffe rently when it is a part of a system utilizing the Multi-processor\nCommunication mode.\nIf the Receiver is set up to receive frames that contain 5 to 8 data bits, then the first stop bit indi-\ncates if the frame contains data or address information. If the Receiver is set up for frames withTable 22-2. Recommended Maximum Receiver Baud Rate Error for Normal Speed Mode \n(U2Xn = 0)\nD\n# (Data+Parity Bit) Rslow (%) Rfast (%) Max Total Error (%)Recommended Max \nReceiver Error (%)\n5 93.20 106.67 +6.67/-6.8 \u00b13.0\n6 94.12 105.79 +5.79/-5.88 \u00b12.5\n7 94.81 105.11 +5.11/-5.19 \u00b12.0\n8 95.36 104.58 +4.58/-4.54 \u00b12.09 95.81 104.14 +4.14/-4.19 \u00b11.5\n10 96.17 103.78 +3.78/-3.83 \u00b11.5\nTable 22-3. Recommended Maximum Receiver Baud Rate Error for Double Speed Mode \n(U2Xn = 1)\nD\n# (Data+Parity Bit) Rslow (%) Rfast (%) Max Total Error (%)Recommended Max \nReceiver Error (%)\n5 94.12 105.66 +5.66/-5.88 \u00b12.56 94.92 104.92 +4.92/-5.08 \u00b12.0\n7 95.52 104.35 +4.35/-4.48 \u00b11.5\n8 96.00 103.90 +3.90/-4.00 \u00b11.59 96.39 103.53 +3.53/-3.61 \u00b11.5\n10 96.70 103.23 +3.23/-3.30 \u00b11.0\n\n222\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nnine data bits, then the ninth bit (RXB8n) is  used for identifying address and data frames. When\nthe frame type bit (the first stop or the ninth bit) is one, the frame contains an address. When the\nframe type bit is zero the frame is a data frame.\nThe Multi-processor Communication mode enables several slave MCUs to receive data from a\nmaster MCU. This is done by first decoding an address frame to find out which MCU has been\naddressed. If a particular slave MCU has been  addressed, it will rece ive the following data\nframes as normal, while the other slave MCUs will ignore the received frames until anotheraddress frame is received.\n22.8.1 Using MPCMn\nFor an MCU to act as a master MCU, it can us e a 9-bit character frame format (UCSZn = 7). The\nninth bit (TXB8n) must be set when an address frame (TXB8n = 1) or cleared when a data frame\n(TXB = 0) is being transmitted. The slave MCUs must in this case be set to use a 9-bit characterframe format.\nThe following procedure should be used to exchange data in Multi-processor Communication\nmode:\n1. All Slave MCUs are in Multi-processor Communication mode (MPCMn in UCSRnA is\nset).\n2. The Master MCU sends an address frame, and all slaves receive and read this frame. In \nthe Slave MCUs, the RXCn Flag in UCSRnA will be set as normal.\n3. Each Slave MCU reads the UDRn Register and determines if it has been selected. If so, \nit clears the MPCMn bit in UCSRnA, otherwise it waits for the next address byte and keeps the MPCMn setting.\n4. The addressed MCU will receive all data frames until a new address frame is received. \nThe other Slave MCUs, which still have the MP CMn bit set, will ignore the data frames.\n5.When the last data frame is received by the addressed MCU, the addressed MCU sets \nthe MPCMn bit and waits for a new address frame from master. The process then repeats from 2.\nUsing any of the 5-bit to 8-bit character frame formats is possible, but impractical since the\nReceiver must change between using n and n+1 character frame formats. This makes full-\nduplex operation difficult since the Transmitter a nd Receiver uses the same character size set-\nting. If 5-bit to 8-bit character frames are used, the Transmitter must be set to use two stop bit(USBSn = 1) since the first stop bit is  used for indicating the frame type.\nDo not use Read-Modify- Write instructions (SBI and CBI) to set or clear the MPCMn bit. The\nMPCMn bit shares the same I/O location as the TXCn Flag and this might accidentally becleared when using SBI or CBI instructions.\n22.9 Register Description\nThe following section describes the USART\u2019s registers.\n22.9.1 UDRn \u2013 USART I/O Data Register n\nB i t 76543210\nRXB[7:0] UDRn (Read)\nTXB[7:0] UDRn (Write)\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n223\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe USART Transmit Data Buffer Register and USART Receive Data Buffer Registers share the\nsame I/O address re ferred to as USART Data Register or  UDRn. The Transmit Data Buffer Reg-\nister (TXB) will be the destination for data wri tten to the UDRn Register  location. Reading the\nUDRn Register location will retu rn the contents of the Receiv e Data Buffer Register (RXB).\nFor 5-bit, 6-bit, or 7-bit characters the upper  unused bits will be ignored by the Transmitter and\nset to zero by the Receiver.\nThe transmit buffer can only be written when the UDREn Flag in the UCSRnA Register is set.\nData written to UDRn wh en the UDREn Flag is not set, will be  ignored by the USART Transmit-\nter. When data is written to the transmit buffer, and the Transmitter is enabled, the Transmitter\nwill load the data into the Transmit Shift Regist er when the Shift Register is empty. Then the\ndata will be serially transmitted on the TxDn pin.\nThe receive buffer consists of a two level FIFO . The FIFO will change its state whenever the\nreceive buffer is accessed. Due to this behavior of the receive buffer, do not use Read-Modify-Write instructions (SBI and CBI) on this location. Be careful when using bit test instructions\n(SBIC and SBIS), since these also will change the state of the FIFO.\n22.9.2 UCSRnA \u2013 USART Contro l and Status Register A\n\u0081 Bit 7 \u2013 RXCn: USART Receive Complete\nThis flag bit is set when there are unread data in the receive buffer and cleared when the receive\nbuffer is empty (that is, does not contain any unread data). If the Receiver is disabled, the\nreceive buffer will be flushed and conse quently the RXCn bit will be come zero. The RXCn Flag\ncan be used to generate a Receive Complete interrupt (see description of the RXCIEn bit).\n\u0081 Bit 6 \u2013 TXCn: USART Transmit Complete\nThis flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and\nthere are no new data currently present in the transmit buffer (UDRn). The TXCn Flag bit is auto-matically cleared when a transmit complete interrupt is executed, or it can be cleared by writing\na one to its bit location. The TXCn Flag can generate a Transmit Complete interrupt (see\ndescription of the TXCIEn bit).\n\u0081 Bit 5 \u2013 UDREn: USART Data Register Empty\nThe UDREn Flag indicates if the transmit buff er (UDRn) is ready to receive new data. If UDREn\nis one, the buffer is empty, and therefore ready to be written. The UDREn Flag can generate a\nData Register Empty interrupt (see description of the UDRIEn bit).\nUDREn is set after a reset to indicate that the Transmitter is ready.\n\u0081 Bit 4 \u2013 FEn: Frame Error\nThis bit is set if the next character in the receive buffer had a Frame Error when received, that is,\nwhen the first stop bit of the next character in the receive buffer is zero. This bit is valid until the\nreceive buffer (UDRn) is read. The FEn bit is zero when the stop bit of received data is one.\nAlways set this bit to ze ro when writing to UCSRnA.B i t 76543210\nRXCn TXCn UDREn FEn DORn UPEn U2Xn MPCMn UCSRnA\nRead/Write R R/ W RRRR R / W R/W\nI n i t i a l  V a l u e00100000\n\n224\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 DORn: Data OverRun\nThis bit is set if a Data OverRun condition is detected. A Data OverRun occurs when the receive\nbuffer is full (two characters), it is a new char acter waiting in the Receive Shift Register, and a\nnew start bit is detected. This bi t is valid until the receive buffer  (UDRn) is read . Always set this\nbit to zero when writing to UCSRnA.\n\u0081 Bit 2 \u2013 UPEn: USART Parity Error\nThis bit is set if the next character in the receive buffer had a Parity Error when received and the\nParity Checking was enabled at that point (UPMn1 = 1). This bit is valid until the receive buffer(UDRn) is read. Always set this bit to zero when writing to UCSRnA.\n\u0081 Bit 1 \u2013 U2Xn: Double the USART Transmission Speed\nThis bit only has effect for the asynchronous operation. Write this bit to zero when using syn-\nchronous operation.\nWriting this bit to one will reduce the divisor of th e baud rate divider from 16 to 8 effectively dou-\nbling the transfer rate for asynchronous communication.\n\u0081 Bit 0 \u2013 MPCMn: Multi-processor Communication Mode\nThis bit enables the Multi-processor Communication mode. When the MPCMn bit is written to\none, all the incoming frames received by the USART Receiver that do not contain address infor-\nmation will be ignored. The Transmitter is unaffe cted by the MPCMn setting. For more detailed\ninformation see \u201cMulti-processor Communication Mode\u201d on page 221 .\n22.9.3 UCSRnB \u2013 USART Control and Status Register n B\n\u0081 Bit 7 \u2013 RXCIEn: RX Comp lete Interrupt Enable n\nWriting this bit to one enables interrupt on the RXCn Flag. A USART Rece ive Complete interrupt\nwill be generated only if the RXCIEn bit is written to one, the Global Interrupt Flag in SREG iswritten to one and the RXCn bit in UCSRnA is set.\n\u0081 Bit 6 \u2013 TXCIEn: TX Complete Interrupt Enable n\nWriting this bit to one enables interrupt on the TXCn Flag. A USART Transmit Complete interrupt\nwill be generated only if the TXCIEn bit is written to one, the Global Interrupt Flag in SREG is\nwritten to one and the TXCn bit in UCSRnA is set.\n\u0081 Bit 5 \u2013 UDRIEn: USART Data Register Empty Interrupt Enable n\nWriting this bit to one enables interrupt on the UDREn Flag. A Data Register  Empty interrupt will\nbe generated only if the UDRIEn bit is written to one, the Global Interrupt Flag in SREG is writtento one and the UDREn bit in UCSRnA is set.\n\u0081 Bit 4 \u2013 RXENn: Receiver Enable n\nWriting this bit to one enables the USART Receiv er. The Receiver will override normal port oper-\nation for the RxDn pin when enabled. Disab ling the Receiver will fl ush the receive buffer\ninvalidating the FEn, DORn, and UPEn Flags.B i t 7654 321 0\nRXCIEn TXCIEn UDRIEn RXENn TXENn UCSZn2 RXB8n TXB8n UCSRnB\nRead/Write R/ W R/W R/W R/W R/W R/W RR / W\nInitial Value 0 0 0 0 0 0 0 0\n\n225\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 3 \u2013 TXENn: Transmitter Enable n\nWriting this bit to on e enables the USART Transmitter. Th e Transmitter will override normal port\noperation for the TxDn pin when enabled. The di sabling of the Transmitter (writing TXENn to\nzero) will not become effective until ongoing and pending transmissions are completed, that is,\nwhen the Transmit Shift Register and Transmit Buffer Register do not contain data to be trans-\nmitted. When disabled, the Transmitter will no  longer override the TxDn port.\n\u0081 Bit 2 \u2013 UCSZn2: Character Size n\nThe UCSZn2 bits combined with the UCSZn1:0 bit in UCSRnC sets the number of data bits\n(Character SiZe) in a frame the Receiver and Transmitter use.\n\u0081 Bit 1 \u2013 RXB8n: Receive Data Bit 8 n\nRXB8n is the ninth data bit of the received char acter when operating with serial frames with nine\ndata bits. Must be read before reading the low bits from UDRn.\n\u0081 Bit 0 \u2013 TXB8n: Transmit Data Bit 8 n\nTXB8n is the ninth data bit in the character to be transmitted when operating with serial frames\nwith nine data bits. Must be written before writing the low bits to UDRn.\n22.9.4 UCSRnC \u2013 USART Control and Status Register n C\n\u0081 Bits 7:6 \u2013 UMSELn1:0 USART Mode Select\nThese bits select the mode of operation of the USARTn as shown in Table 22-4 .\nNote: 1. See \u201cUSART in SPI Mode\u201d on page 232  for full description of the Master SPI Mode (MSPIM) \noperation.\n\u0081 Bits 5:4 \u2013 UPMn1:0: Parity Mode\nThese bits enable and set type of parity generation and check. If enabled, the Transmitter will\nautomatically generate and send the parity of th e transmitted data bits within each frame. TheBit 7 6 5 4 3 2 1 0\nUMSELn1 UMSELn0 UPMn1 UPMn0 USBSn UCSZn1 UCSZn0 UCPOLn UCSRnC\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 1 1 0\nTable 22-4. UMSELn Bits Settings\nUMSELn1 UMSELn0 Mode\n0 0 Asynchronous USART\n0 1 Synchronous USART1 0 (Reserved)\n1 1 Master SPI (MSPIM)\n(1)\n\n226\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nReceiver will generate a parity va lue for the incoming data and co mpare it to th e UPMn setting.\nIf a mismatch is detected, the UPEn Flag in UCSRnA will be set.\n\u0081 Bit 3 \u2013 USBSn: Stop Bit Select\nThis bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores\nthis setting.\n\u0081 Bit 2:1 \u2013 UCSZn1:0: Character Size\nThe UCSZn1:0 bits combined with the UCSZn2 bit in UCSRnB sets the number of data bits\n(Character SiZe) in a frame the Receiver and Transmitter use.\n\u0081 Bit 0 \u2013 UCPOLn: Clock Polarity\nThis bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is\nused. The UCPOLn bit sets the relationship between data output change and data input sample,\nand the synchronous clock (XCKn).Table 22-5. UPMn Bits Settings\nUPMn1 UPMn0 Parity Mode\n00 D i s a b l e d\n01 R e s e r v e d\n1 0 Enabled, Even Parity\n1 1 Enabled, Odd Parity\nTable 22-6. USBS Bit Settings\nUSBSn Stop Bit(s)\n01 - b i t12 - b i t\nTable 22-7. UCSZn Bits Settings\nUCSZn2 UCSZn1 UCSZn0 Character Size\n000 5 - b i t\n001 6 - b i t010 7 - b i t\n011 8 - b i t\n1 0 0 Reserved1 0 1 Reserved\n1 1 0 Reserved\n111 9 - b i t\nTable 22-8. UCPOLn Bit Settings\nUCPOLnTransmitted Data Ch anged (Output of \nTxDn Pin)Received Data Sampled (Input on RxDn \nPin)\n0 Rising XCKn Edge Falling XCKn Edge\n1 Falling XCKn Edge Rising XCKn Edge\n\n227\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n22.9.5 UBRRnL and UBRRnH \u2013 USART Baud Rate Registers\n\u0081 Bit 15:12 \u2013 Reserved Bits\nThese bits are reserved for future use. For compatibility with future devices, these bit must be\nwritten to zero when UBRRH is written.\n\u0081 Bit 11:0 \u2013 UBRR11:0: USART Baud Rate Register\nThis is a 12-bit register which contains the USART baud rate. The UBRRH contains the four\nmost significant bits, and the UBRRL contains th e eight least significant bits of the USART baud\nrate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if th e baud rate is\nchanged. Writing UBRRL will trigger an immediate update of the baud rate prescaler.\n22.10 Examples of Ba ud Rate Setting\nFor standard crystal and resonator frequencies, the most commonly used baud rates for asyn-\nchronous operation can be generated by using the UBRR settings in Table 22-9  to Table 22-12\non page 231 . UBRR values which yield an actual baud rate differing less than 0.5% from the tar-\nget baud rate, are bold in the table. Higher error ratings are acceptable, but the Receiver will\nhave less noise resistance when the error ratings are high, especially for large serial frames (see\n\u201cAsynchronous Operational Range\u201d on page 220 ). The error values are calculated using the fol-\nlowing equation:B i t 1 51 41 31 21 11 0 9 8\n\u2013 \u2013 \u2013 \u2013 UBRR[11:8] UBRRHn\nUBRR[7:0] UBRRLn\n76543210\nRead/Wr i t e RRRR R / W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n00000000\nError[%]BaudRateClosest Match\nBaudRate-------------------------------------------------------- 1\u2013\u239d\u23a0\u239b\u239e100%\u2022 =\nTable 22-9. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 1.0000MHz fosc = 1.8432MHz fosc = 2.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 25 0.2% 51 0.2% 47 0.0% 95 0.0% 51 0.2% 103 0.2%\n4800 12 0.2% 25 0.2% 23 0.0% 47 0.0% 25 0.2% 51 0.2%9600 6 -7.0% 12 0.2% 11 0.0% 23 0.0% 12 0.2% 25 0.2%\n14.4K 3 8.5% 8 -3.5% 7 0.0% 15 0.0% 8 -3.5% 16 2.1%\n19.2K 2 8.5% 6 -7.0% 5 0.0% 11 0.0% 6 -7.0% 12 0.2%28.8K 1 8.5% 3 8.5% 3 0.0% 7 0.0% 3 8.5% 8 -3.5%\n38.4K 1 -18.6% 2 8.5% 2 0.0% 5 0.0% 2 8.5% 6 -7.0%\n\n228\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%57.6K 0 8.5% 1 8.5% 1 0.0% 3 0.0% 1 8.5% 3 8.5%\n76.8K \u2013 \u2013 1 -18.6% 1 -25.0% 2 0.0% 1 -18.6% 2 8.5%\n115.2K \u2013 \u2013 0 8.5% 0 0.0% 1 0.0% 0 8.5% 1 8.5%\n230.4K \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 0 0.0% \u2013 \u2013 \u2013 \u2013\n2 5 0 K \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u20130 0 . 0 %\nMax.(1)62.5Kbps 125Kbps 115.2Kbps 2 30.4Kbps 125Kbps 250KbpsTable 22-9. Examples of UBRRn Settings for Common ly Used Oscillator Frequencies (Continued)\nBaud \nRate \n(bps)fosc = 1.0000MHz fosc = 1.8432MHz fosc = 2.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n\n229\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-10. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 3.6864MHz fosc = 4.0000MHz fosc = 7.3728MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 95 0.0% 191 0.0% 103 0.2% 207 0.2% 191 0.0% 383 0.0%\n4800 47 0.0% 95 0.0% 51 0.2% 103 0.2% 95 0.0% 191 0.0%\n9600 23 0.0% 47 0.0% 25 0.2% 51 0.2% 47 0.0% 95 0.0%\n14.4K 15 0.0% 31 0.0% 16 2.1% 34 -0.8% 31 0.0% 63 0.0%\n1 9 . 2 K1 10 . 0 %2 30 . 0 %1 20 . 2 %2 50 . 2 %2 30 . 0 %4 70 . 0 %28.8K 7 0.0% 15 0.0% 8 -3.5% 16 2.1% 15 0.0% 31 0.0%\n38.4K 5 0.0% 11 0.0% 6 -7.0% 12 0.2% 11 0.0% 23 0.0%\n57.6K 3 0.0% 7 0.0% 3 8.5% 8 -3.5% 7 0.0% 15 0.0%76.8K 2 0.0% 5 0.0% 2 8.5% 6 -7.0% 5 0.0% 11 0.0%\n115.2K 1 0.0% 3 0.0% 1 8.5% 3 8.5% 3 0.0% 7 0.0%\n230.4K 0 0.0% 1 0.0% 0 8.5% 1 8.5% 1 0.0% 3 0.0%\n250K 0 -7.8% 1 -7.8% 0 0.0% 1 0.0% 1 -7.8% 3 -7.8%\n0.5M \u2013 \u2013 0 -7.8% \u2013 \u2013 0 0.0% 0 -7.8% 1 -7.8%\n1 M \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u20130 - 7 . 8 %\nMax.\n(1)230.4Kbps 460.8Kbps 250Kbps 0. 5Mbps 460.8Kbps 921.6Kbps\n\n230\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-11. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 8.0000MHz fosc = 11.0592 MHz fosc = 14.7456MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 207 0.2% 416 -0.1% 287 0.0% 575 0.0% 383 0.0% 767 0.0%\n4800 103 0.2% 207 0.2% 143 0.0% 287 0.0% 191 0.0% 383 0.0%\n9600 51 0.2% 103 0.2% 71 0.0% 143 0.0% 95 0.0% 191 0.0%\n14.4K 34 -0.8% 68 0.6% 47 0.0% 95 0.0% 63 0.0% 127 0.0%\n1 9 . 2 K2 50 . 2 %5 10 . 2 %3 50 . 0 %7 10 . 0 %4 70 . 0 %9 50 . 0 %28.8K 16 2.1% 34 -0.8% 23 0.0% 47 0.0% 31 0.0% 63 0.0%\n3 8 . 4 K1 20 . 2 %2 50 . 2 %1 70 . 0 %3 50 . 0 %2 30 . 0 %4 70 . 0 %\n57.6K 8 -3.5% 16 2.1% 11 0.0% 23 0.0% 15 0.0% 31 0.0%76.8K 6 -7.0% 12 0.2% 8 0.0% 17 0.0% 11 0.0% 23 0.0%\n115.2K 3 8.5% 8 -3.5% 5 0.0% 11 0.0% 7 0.0% 15 0.0%\n230.4K 1 8.5% 3 8.5% 2 0.0% 5 0.0% 3 0.0% 7 0.0%\n250K 1 0.0% 3 0.0% 2 -7.8% 5 -7.8% 3 -7.8% 6 5.3%\n0.5M 0 0.0% 1 0.0% \u2013 \u2013 2 -7.8% 1 -7.8% 3 -7.8%\n1 M \u2013\u20130 0 . 0 % \u2013\u2013\u2013\u20130 - 7 . 8 % 1 - 7 . 8 %\nMax.\n(1)0.5Mbps 1Mbps 691.2Kbps 1.3824Mbps 921.6Kbps 1.8432Mbps\n\n231\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. UBRR = 0, Error = 0.0%Table 22-12. Examples of UBRRn Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate \n(bps)fosc = 16.0000MHz fosc = 18.4320MHz fosc = 20.0000MHz\nU2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1 U2Xn = 0 U2Xn = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 416 -0.1% 832 0.0% 479 0.0% 959 0.0% 520 0.0% 1041 0.0%\n4800 207 0.2% 416 -0.1% 239 0.0% 479 0.0% 259 0.2% 520 0.0%\n9600 103 0.2% 207 0.2% 119 0.0% 239 0.0% 129 0.2% 259 0.2%\n14.4K 68 0.6% 138 -0.1% 79 0.0% 159 0.0% 86 -0.2% 173 -0.2%\n19.2K 51 0.2% 103 0.2% 59 0.0% 119 0.0% 64 0.2% 129 0.2%28.8K 34 -0.8% 68 0.6% 39 0.0% 79 0.0% 42 0.9% 86 -0.2%\n3 8 . 4 K2 50 . 2 %5 10 . 2 %2 90 . 0 %5 90 . 0 %3 2 - 1 . 4 % 6 40 . 2 %\n57.6K 16 2.1% 34 -0.8% 19 0.0% 39 0.0% 21 -1.4% 42 0.9%7 6 . 8 K1 20 . 2 %2 50 . 2 %1 40 . 0 %2 90 . 0 %1 51 . 7 %3 2 - 1 . 4 %\n115.2K 8 -3.5% 16 2.1% 9 0.0% 19 0.0% 10 -1.4% 21 -1.4%\n230.4K 3 8.5% 8 -3.5% 4 0.0% 9 0.0% 4 8.5% 10 -1.4%\n250K 3 0.0% 7 0.0% 4 -7.8% 8 2.4% 4 0.0% 9 0.0%\n0.5M 1 0.0% 3 0.0% \u2013 \u2013 4 -7.8% \u2013 \u2013 4 0.0%\n1 M 0 0 . 0 % 1 0 . 0 % \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\nMax.\n(1)1Mbps 2Mbps 1.152Mbps 2.304Mbps 1.25Mbps 2.5Mbps\n\n232\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23. USART in SPI Mode\nThe Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) can be\nset to a master SPI compliant mode of operation. The Master SPI Mode (MSPIM) has the follow-\ning features:\n\u0081Full Duplex, Three-wire Synchronous Data Transfer\n\u0081Master Operation\n\u0081Supports all four SPI Modes of Operation (Mode 0, 1, 2, and 3)\n\u0081LSB First or MSB First Data Tran sfer (Configurable Data Order)\n\u0081Queued Operation (Double Buffered)\n\u0081High Resolution Baud Rate Generator\n\u0081High Speed Operatio n (fXCKmax = fCK/2)\n\u0081Flexible Interrupt Generation\n23.1 Overview\nSetting both UMSELn1:0 bits to one enables the USART in MSPIM logic. In this mode of opera-\ntion the SPI master control logic takes direct control over the USART resources. These\nresources include the transmitter and receiver shift register and buffers, and the baud rate gen-\nerator. The parity generator and checker, the data and clock recovery logic, and the RX and TXcontrol logic is disabled. The USART RX and TX control logic is replaced by a common SPI\ntransfer control logic. However, the pin control l ogic and interrupt generation logic is identical in\nboth modes of operation.\nThe I/O register locations are the same in both modes. However, some of the functionality of the\ncontrol registers changes when using MSPIM.\n23.2 USART MSPIM vs. SPI\nThe AVR USART in MSPIM mode is fully compatible with the AVR SPI regarding:\n\u0081 Master mode timing diagram\n\u0081 The UCPOLn bit functionality is identical to the SPI CPOL bit\u0081 The UCPHAn bit functionality is identical to the SPI CPHA bit\u0081 The UDORDn bit functionality is identical to the SPI DORD bit\nHowever, since the USART in MSPIM mode reuses the USART resources, the use of the\nUSART in MSPIM mode is somewhat different compared to the SPI. In addition to differences of\nthe control register bits, and that only master  operation is supported by the USART in MSPIM\nmode, the following features differ between the two modules:\n\u0081 The USART in MSPIM mode includes (double) buffering of the transmitter. The SPI has no \nbuffer\n\u0081 The USART in MSPIM mode receiver includes an additional buffer level\u0081 The SPI WCOL (Write Collision) bit is not incl uded in USART in MSPIM mode\n\u0081 The SPI double speed mode (SPI2X) bit is not included. However, the same effect is \nachieved by setting UBRRn accordingly\n\u0081 Interrupt timing is not compatible\u0081 Pin control differs due to the master only operation of the USART in MSPIM mode\n\n233\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA comparison of the USART in MSPIM mode and the SPI pins is shown in Table 23-4 on page\n240.\n23.2.1 Clock Generation\nThe Clock Generation logic generates the base clock for the Transmitter and Receiver. For\nUSART MSPIM mode of operation only internal cl ock generation (that is, master operation) is\nsupported. The Data Direction Register for the XCKn pin (DDR_XCKn) must therefore be set toone (that is, as output) for the USART in MSPIM to operate correctly. Preferably the DDR_XCKn\nshould be set up before the USART in MSPIM is enabled (that is, TXENn and RXENn bit set to\none).\nThe internal clock generation used in MSPIM mode is identical to the USART synchronous mas-\nter mode. The baud rate or UBRRn setting can therefore be calculated using the same\nequations, see Table 23-1 .\nNote: 1. The baud rate is defined to be the transfer rate in bit per second (bps).\nBAUD Baud rate (in bits per second, bps).\nfOSC System Oscillator clock frequency.\nUBRRn Contents of the UBRRnH and UBRRnL Registers, (0-4095).\n23.3 SPI Data Modes and Timing\nThere are four combinations of XCKn (SCK) phase and polarity with respect to serial data, which\nare determined by control bits UCPHAn and UCPOLn. The data transfer timing diagrams areshown in Figure 23-1 on page 234 . Data bits are shifted out and latched in on opposite edges of\nthe XCKn signal, ensuring sufficient time for data signals to stabilize. The UCPOLn and\nUCPHAn functionality is summarized in Table 23-2 . Note that changing the setting of any of\nthese bits will corrupt all ongoing communication for both the Receiver and Transmitter.Table 23-1. Equations for Calculating Baud Rate Register Setting\nOperating ModeEquation for Calculating Baud \nRate(1)Equation for Calculating \nUBRRn Value\nSynchronous Master \nmodeBAUDfOSC\n2UBRR n1+ ()-------------------------------------- - = UBRR nfOSC\n2BAUD-------------------- 1\u2013 =\nTable 23-2. UCPOLn and UCPHAn Functionality-\nUCPOLn UCPHAn SPI Mode Lead ing Edge Trailing Edge\n0 0 0 Sample (Rising) Setup (Falling)\n0 1 1 Setup (Rising) Sample (Falling)1 0 2 Sample (Falling) Setup (Rising)\n1 1 3 Setup (Falling) Sample (Rising)\n\n234\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 23-1. UCPHAn and UCPOLn data transfer timing diagrams.\n23.4 Frame Formats\nA serial frame for the MSPIM is defined to be one character of 8 data bits. The USART in MSPIM\nmode has two valid frame formats:\n\u0081 8-bit data with MSB first\n\u0081 8-bit data with LSB firstA frame starts with the least or most significant data bit. Then the next data bits, up to a total of\neight, are succeeding, ending with the most or least significant bit accordingly. When a complete\nframe is transmitted, a new frame can directly follow it, or the communication line can be set to\nan idle (high) state.\nThe UDORDn bit in UCSRnC sets the frame form at used by the USART in MSPIM mode. The\nReceiver and Transmitter use the same setting. Note that changing the setting of any of these\nbits will corrupt all ongoin g communication for both th e Receiver and Transmitter.\n16-bit data transfer can be achieved by writing two data bytes to UDRn. A UART transmit com-\nplete interrupt will then signal that the 16-bit value ha s been shifted out.\n23.4.1 USART MSPIM Initialization\nThe USART in MSPIM mode has to be initialized before any communication can take place. The\ninitialization process normally consists of setting the baud rate, setting master mode of operation\n(by setting DDR_XCKn to one), setting frame format and enabling the Transmitter and theReceiver. Only the transmitter can operate independently. For interrupt driven USART opera-\ntion, the Global Interrupt Flag should be clear ed (and thus interrupts globally disabled) when\ndoing the initialization.\nNote: To ensure immediate initialization of the XCKn output the baud-rate register (UBRRn) must be \nzero at the time the transmitter is enabled. Contrary to the normal mode USART operation the \nUBRRn must then be written to the desired value after the transmitter is enabled, but before the \nfirst transmission is started. Setting UBRRn to ze ro before enabling the transmitter is not neces-\nsary if the initialization is done immediatel y after a reset since UBRRn is reset to zero.\nBefore doing a re-initialization with changed baud rate, data mode, or frame format, be sure that\nthere is no ongoing transmissions during the per iod the registers are changed. The TXCn Flag\ncan be used to check that the Transmitter has completed all transfers, and the RXCn Flag can\nbe used to check that there are no unread data in the receive buffer. Note that the TXCn Flag\nmust be cleared bef ore each transmission (before UDRn is wri tten) if it is used  for this purpose.XCK\nData setup (TXD)\nData sample (RXD)\nXCK\nData setup (TXD)\nData sample (RXD)XCK\nData setup (TXD)\nData sample (RXD)\nXCK\nData setup (TXD)\nData sample (RXD)UCPOL=0 UCPOL=1\nUCPHA=0UCPHA=1\n\n235\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe following simple USART initialization code examples show one assembly and one C func-\ntion that are equal in functionality. The examples assume polling (no interrupts enabled). The\nbaud rate is given as a function parameter. For the assembly code, the baud rate parameter is\nassumed to be stored in the r17:r16 registers.\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.Assembly Code Example(1)\nUSART_Init:\nclr r18\nout UBRRnH,r18\nout UBRRnL,r18\n; Setting the XCKn port pin as output, enables master mode.\nsbi XCKn_DDR, XCKn\n; Set MSPI mode of operation and SPI data mode 0.ldi r18, (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn)\nout UCSRnC,r18\n; Enable receiver and transmitter.ldi r18, (1<<RXENn)|(1<<TXENn)\nout UCSRnB,r18\n; Set baud rate. \n; IMPORTANT: The Baud Rate must be set after the transmitter is enabled!\nout UBRRnH, r17\nout UBRRnL, r18\nret\nC Code Example(1)\nvoid USART_Init( unsigned int  baud )\n{\nUBRRn = 0;/* Setting the XCKn port pin as output, enables master mode. */\nXCKn_DDR |= (1<<XCKn);\n/* Set MSPI mode of operation and SPI data mode 0. */UCSRnC = (1<<UMSELn1)|(1<<UMSELn0)|(0<<UCPHAn)|(0<<UCPOLn);\n/* Enable receiver and transmitter. */\nUCSRnB = (1<<RXENn)|(1<<TXENn);/* Set baud rate. */\n/* IMPORTANT: The Baud Rate must be set after the transmitter is enabled \n*/\nUBRRn = baud;\n}\n\n236\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23.5 Data Transfer\nUsing the USART in MSPI mode requires the Transmitter to be enabled, that is, the TXENn bit in\nthe UCSRnB register is set to one. When the Transmitter is enabled, the normal port operation\nof the TxDn pin is overridden and given the func tion as the Transmitter's serial output. Enabling\nthe receiver is optional and is done by setting the RXENn bit in the UCSRnB register to one.\nWhen the receiver is enabled, the normal pin operation of the RxDn pin is overridden and given\nthe function as the Receiver's se rial input. The XCKn will in both cases be used as the transfer\nclock.\nAfter initialization the USART is re ady for doing data transfers. A data transfer is initiated by writ-\ning to the UDRn I/O location. This is the ca se for both sending and receiving data since the\ntransmitter controls the transfer clock. The data written to UDRn is moved from the transmit buf-\nfer to the shift register when the shift register is ready to send a new frame.\nNote: To keep the input buffer in sync with the number  of data bytes transmitted, the UDRn register must \nbe read once for each byte transmitted. The input buffer operation is identical to normal USART \nmode, that is, if an overflow occurs the character last received will be lost, not the first data in the \nbuffer. This means that if four bytes are transferr ed, byte 1 first, then byte 2, 3, and 4, and the \nUDRn is not read before all transfers are completed, then byte 3 to be received will be lost, and not \nbyte 1.\nThe following code examples show a simple U SART in MSPIM mode transfer function based on\npolling of the Data Register Empty (UDREn) Flag and the Receive Complete (RXCn) Flag. The\nUSART has to be initialized before the function can be used. For the assembly code, the data to\nbe sent is assumed to be stor ed in Register R16 and the data  received will be available in the\nsame register (R16) after the function returns.\nThe function simply waits for the transmit buffer to be em pty by checking the UDREn Flag,\nbefore loading it with new data to be transmitted. The function then waits for data to be presentin the receive buffer by checking the RXCn Flag, before reading the buffer and returning the\nvalue.\n\n237\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. See \u201cAbout Code Examples\u201d on page 11.\n23.5.1 Transmitter and Receiver Flags and Interrupts\nThe RXCn, TXCn, and UDREn flag s and corresponding interrupt s in USART in MSPIM mode\nare identical in function to the normal USART operation. However, the receiver error status flags(FE, DOR, and PE) are not in use and is always read as zero.\n23.5.2 Disabling the Transmitter or Receiver\nThe disabling of the transmitter or receiver in  USART in MSPIM mode is identical in function to\nthe normal USART operation.\n23.6 USART MSPIM R egister Description\nThe following section describes the registers used for SPI operation using the USART.\n23.6.1 UDRn \u2013 USART MSPI M I/O Data Register\nThe function and bit description of the USART data register (UDRn) in MSPI mode is identical to\nnormal USART operation. See \u201cUDRn \u2013 USART I/O Data Register n\u201d on page 222.Assembly Code Example(1)\nUSART_MSPIM_Transfer:\n; Wait for empty transmit buffer\nsbis UCSRnA, UDREn\nrjmp USART_MSPIM_Transfer\n; Put data (r16) into buffer, sends the data\nout UDRn,r16\n; Wait for data to be received\nUSART_MSPIM_Wait_RXCn:\nsbis UCSRnA, RXCn\nrjmp USART_MSPIM_Wait_RXCn\n; Get and return received data from buffer\nin r16, UDRn\nret\nC Code Example(1)\nunsigned char  USART_Receive( void )\n{\n/* Wait for empty transmit buffer */\nwhile ( !( UCSRnA & (1<<UDREn)) );\n/* Put data into buffer, sends the data */\nUDRn = data;\n/* Wait for data to be received */while ( !(UCSRnA & (1<<RXCn)) );\n/* Get and return received data from buffer */\nreturn UDRn;\n}\n\n238\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n23.6.2 UCSRnA \u2013 USART MSPIM Control and Status Register n A\n\u0081\n\u0081 Bit 7 - RXCn: USART Receive Complete\nThis flag bit is set when there are unread data in the receive buffer and cleared when the receive\nbuffer is empty (that is, does not contain any unread data). If the Receiver is disabled, thereceive buffer will be flushed and conse quently the RXCn bit will be come zero. The RXCn Flag\ncan be used to generate a Receive Complete interrupt (see description of the RXCIEn bit).\n\u0081 Bit 6 - TXCn: USART Transmit Complete\nThis flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and\nthere are no new data currently present in the transmit buffer (UDRn). The TXCn Flag bit is auto-matically cleared when a transmit complete interrupt is executed, or it can be cleared by writing\na one to its bit location. The TXCn Flag can generate a Transmit Complete interrupt (see\ndescription of the TXCIEn bit).\n\u0081 Bit 5 - UDREn: USART Data Register Empty\nThe UDREn Flag indicates if the transmit buff er (UDRn) is ready to receive new data. If UDREn\nis one, the buffer is empty, and therefore ready to be written. The UDREn Flag can generate a\nData Register Empty interrupt (see description of the UDRIE bit). UDREn is set after a reset to\nindicate that the Tr ansmitter is ready.\n\u0081 Bit 4:0 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnA is written.\n23.6.3 UCSRnB \u2013 USART MSPIM Control and Status Register n B\n\u0081 Bit 7 - RXCIEn: RX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the RXCn Flag. A USART Rece ive Complete interrupt\nwill be generated only if the RXCIEn bit is written to one, the Global Interrupt Flag in SREG is\nwritten to one and the RXCn bit in UCSRnA is set.\n\u0081 Bit 6 - TXCIEn: TX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the TXCn Flag. A USART Transmit Complete interrupt\nwill be generated only if the TXCIEn bit is written to one, the Global Interrupt Flag in SREG iswritten to one and the TXCn bit in UCSRnA is set.Bit 7 6 5 4 3 2 1 0\nRXCn TXCn UDREn - - - - - UCSRnA\nRead/Write R/ W R/W R/W RR R R R\nInitial Value 0 0 0 0 0 1 1 0\nB i t 7 6543 2 1 0\nRXCIEn TXCIEn UDRIE RXENn TXENn - - - UCSRnB\nRead/Write R/ W R/W R/W R/W R/W RRR\nInitial Value 0 0 0 0 0 1 1 0\n\n239\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 5 - UDRIE: USART Data Re gister Empty Interrupt Enable\nWriting this bit to one enables interrupt on the UDREn Flag. A Data Register  Empty interrupt will\nbe generated only if  the UDRIE bit is written to one, the Glob al Interrupt Flag in SREG is written\nto one and the UDREn bit in UCSRnA is set.\n\u0081 Bit 4 - RXENn: Receiver Enable\nWriting this bit to one enables the USART Rece iver in MSPIM mode. The Receiver will override\nnormal port oper ation for the RxDn pin when enabled . Disabling the Receiver will flush the\nreceive buffer. Only enabling the receiver in MSPI mode (that is, setting RXENn=1 and\nTXENn=0) has no meaning since it is the transmit ter that controls the transfer clock and since\nonly master mode is supported.\n\u0081 Bit 3 - TXENn: Transmitter Enable\nWriting this bit to on e enables the USART Transmitter. Th e Transmitter will override normal port\noperation for the TxDn pin when enabled. The di sabling of the Transmitter (writing TXENn to\nzero) will not become effective until ongoing and pending transmissions are completed, that is,\nwhen the Transmit Shift Register and Transmit Buffer Register do not contain data to be trans-mitted. When disabled, the Transmitter will no  longer override the TxDn port.\n\u0081 Bit 2:0 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnB is written.\n23.6.4 UCSRnC \u2013 USART MSPIM Control and Status Register n C\n\u0081 Bit 7:6 - UMSELn1:0: USART Mode Select\nThese bits select the mode of operation of the USART as shown in Table 23-3 . See \u201cUCSRnC \u2013\nUSART Control and Status Register n C\u201d on page 225  for full description of the normal USART\noperation. The MSPIM is enabled when both UMSELn bits are set to one. The UDORDn,UCPHAn, and UCPOLn can be set in the same write operation where the MSPIM is enabled.\n\u0081 Bit 5:3 - Reserved Bits in MSPI mode\nWhen in MSPI mode, these bits are reserved for future use. For compatib ility with future devices,\nthese bits must be written to  zero when UCSRnC is written.B i t 7 6 543 2 1 0\nUMSELn1 UMSELn0 - - - UDORDn UCPHAn UCPOLn UCSRnC\nRead/Write R/ W R/W RRR R / W R/W R/W\nInitial Value 0 0 0 0 0 1 1 0\nTable 23-3. UMSELn Bits Settings\nUMSELn1  UMSELn0 Mode\n0  0 Asynchronous USART\n0 1  Synchronous USART\n1 0 (Reserved)1 1 Master SPI (MSPIM)\n\n240\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 2 - UDORDn: Data Order\nWhen set to one the LSB of the data word is transmitted first. When set to zero the MSB of the\ndata word is transmitted first. Refer to \u201cSPI Data Modes and Timing\u201d on page 233  for details.\n\u0081 Bit 1 - UCPHAn: Clock Phase\nThe UCPHAn bit setting determine if data is sampled on the leasing edge (first) or tailing (last)\nedge of XCKn. Refer to \u201cSPI Data Modes and Timing\u201d on page 233  for details.\n\u0081 Bit 0 - UCPOLn: Clock Polarity\nThe UCPOLn bit sets the polarity of the XC Kn clock. The combination of the UCPOLn and\nUCPHAn bit settings determine the timing of the data transfer. Refer to \u201cSPI Data Modes and\nTiming\u201d on page 233  for details.\n23.6.5 UBRRnL and UBRRnH \u2013 USART MSPIM Baud Rate Registers\nThe function and bit description of the baud rate registers in MSPI mode is identical to normal\nUSART operation. See \u201cUBRRnL and UBRRnH \u2013 USART Baud Rate Registers\u201d on page 227.\nTable 23-4. Comparison of USART in MSPIM mode and SPI pins.\nUSART_MSPIM  SPI  Comment\nTxDn  MOSI  Master Out only\nRxDn  MISO  Master In only\nXCKn  SCK  (Functionally identical)\n(N/A)  SS  Not supported by USART in MSPIM\n\n241\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24. 2-wire Serial Interface\n24.1 Features\n\u0081Simple yet Powerful and Flexible Communication Interface, only two Bus Lines needed\n\u0081Both Master and Sla ve Operation Supported\n\u0081Device can Operate as Transmitter or Receiver\n\u00817-bit Address Space Allows up to 128 Different Slave Addresses\n\u0081Multi-master Arbitration Support\n\u0081Up to 400kHz Data Transfer Speed\n\u0081Slew-rate Limited Output Drivers\n\u0081Noise Suppression  Circuitry Rejects Spikes on Bus Lines\n\u0081Fully Programmable Slave Address with General Call Support\n\u0081Address Recognition Causes Wake-up  When AVR is in Sleep Mode\n24.2 2-wire Serial In terface Bus Definition\nThe 2-wire Serial Interface (T WI) is ideally suited for typica l microcontroller applications. The\nTWI protocol allows the systems designer to inte rconnect up to 128 different devices using only\ntwo bi-directional bus lines, one for clock (SCL) and one for data (SDA). The only external hard-\nware needed to implement the bus is a single pull-up resistor for each of the T WI bus lines. All\ndevices connected to the bus have individual addresses, and mechanisms for resolving bus\ncontention are inherent in the T WI protocol.\nFigure 24-1. TWI Bus Interconnection\n24.2.1 TWI Terminology\nThe following definitions are frequently encountered in this section.Device 1 Device 2 Device 3 Device n\nSDA\nSCL........ R1 R2VCC\nTable 24-1. TWI Terminology\nTerm Description\nMasterThe device that initiates and terminates a transmission. The Master also generates the \nSCL clock\nSlave The device addressed by a Master\nTransmitter The device placing data on the bus\nReceiver The device reading data from the bus\n\n242\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe Power Reduction T WI bit, PRT WI bit in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be written to zero to enable the 2-wire Serial Interface.\n24.2.2 Electrical Interconnection\nAs depicted in Figure 24-1 on page 241 , both bus lines are connected to the positive supply volt-\nage through pull-up resistors. The bus drivers of all T WI-compliant devices are open-drain or\nopen-collector. This implements a wired-AND function which is essential to the operation of theinterface. A low level on a T WI bus line is generated when one or more T WI devices output a\nzero. A high level is output when all T WI devices trim-state their outputs, allowing the pull-up\nresistors to pull the line high. Note that all AVR devices connected to the T WI bus must be pow-\nered in order to allow any bus operation.\nThe number of devices that can be connected to the bus is only limited by the bus capacitance\nlimit of 400pF and the 7-bit slave address space. A detailed specification of the electrical charac-\nteristics of the T WI is given in \u201cSPI Timing Characteristics\u201d on page 375 . Two different sets of\nspecifications are presented ther e, one relevant for bus speeds below 100kHz, and one valid for\nbus speeds up to 400kHz.\n24.3 Data Transfer and Frame Format\n24.3.1 Transferring Bits\nEach data bit transferred on the T WI bus is accompanied by a pulse on the clock line. The level\nof the data line must be stable when the clock line is  high. The only exception to this rule is for\ngenerating start and stop conditions.\nFigure 24-2. Data Validity\n24.3.2 START and STOP Conditions\nThe Master initiates and terminates a data transmi ssion. The transmission is initiated when the\nMaster issues a START condition on the bus, and it is terminated when the Master issues a\nSTOP condition. Between a START and a STOP condition, the bus is considered busy, and noother master should try to seize control of the bus. A special case occurs when a new START\ncondition is issued between a START and STOP condition. This  is referred to as a REPEATED\nSTART condition, and is used when the Master wis hes to initiate a new transfer without relin-\nquishing control of  the bus. After a REPEATED START, the bus is considered busy until the next\nSTOP. This is identical to the START behavior, and therefore START is used to describe both\nSTART and REPEATED START for the remainder of this datasheet, unless otherwise noted. Asdepicted below, START and STOP conditions are signalled by changing the level of the SDA\nline when the SCL line is high.SDA\nSCL\nData Stable Data Stable\nData Change\n\n243\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-3. START, REPEATED START and STOP conditions\n24.3.3 Address Packet Format\nAll address packets transmitted on the T WI bus are 9 bits long, consisting of 7 address bits, one\nREAD/ WRITE control bit and an acknowledge bit. If the READ/ WRITE bit is set, a read opera-\ntion is to be performed, otherwise a write operation should be performed. When a Slave\nrecognizes that it is being a ddressed, it should acknowledge by  pulling SDA low in the ninth SCL\n(ACK) cycle. If the addressed Slave is busy, or  for some other reason can not service the Mas-\nter\u2019s request, the SDA line should be left high in the ACK clock cycle. The Master can then\ntransmit a STOP condition, or a REPEATED START condition to initiate a new transmission. An\naddress packet consisting of a slave address and a READ or a WRITE bit is called SLA+R or\nSLA+W, respectively.\nThe MSB of the address byte is transmitted first. Slave addresses can freely be allocated by the\ndesigner, but the address 0000 000 is reserved for a general call.\nWhen a general call is issued, all slaves should  respond by pulling the SDA line low in the ACK\ncycle. A general call is used when a Master wi shes to transmit the same message to several\nslaves in the system. When the general call address followed by a Write bit is transmitted on the\nbus, all slaves set up to ackn owledge the general call will pull th e SDA line low in the ack cycle.\nThe following data packets will then  be received by all the slaves  that acknowle dged the general\ncall. Note that transmitting the general call add ress followed by a Read bit is meaningless, as\nthis would cause contention if several slaves started transmitting different data.\nAll addresses of the format 1111 xxx should be reserved for future purposes.\nFigure 24-4. Address Packet FormatSDA\nSCL\nSTART STOP REPEATED START STOP START\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\n\n244\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.3.4 Data Packet Format\nAll data packets transmitted on the T WI bus are nine bits long, consisting of one data byte and\nan acknowledge bit. During a data transfer, the Master generates the clock and the START andSTOP conditions, while the Receiver is res ponsible for acknowledging the reception. An\nAcknowledge (ACK) is signalled by the Receiver pulling the SDA line low during the ninth SCL\ncycle. If the Receiver leaves the SD A line high, a NACK is signalled. When the Receiver has\nreceived the last byte, or for some reason cannot receive any more bytes, it should inform the\nTransmitter by sending a NACK after the final byte. The MSB of the data byte is transmitted first. \nFigure 24-5. Data Packet Format\n24.3.5 Combining Address and Data  Packets into a Transmission\nA transmission basically consists of a START condition, a SLA+R/ W, one or more data packets\nand a STOP condition. An empty message, consisting of a START followed by a STOP condi-tion, is illegal. Note that the Wired-ANDing of the SCL line can be used to implement\nhandshaking between the Master and the Slave. The Slave can extend the SCL low period by\npulling the SCL line low. This is useful if the cloc k speed set up by the Master is too fast for the\nSlave, or the Slave needs extra time for proces sing between the data transmissions. The Slave\nextending the SCL low period will not affect t he SCL high period, which is determined by the\nMaster. As a consequence, the Slave can reduce the T WI data transfer speed by prolonging the\nSCL duty cycle.\nFigure 24-6  shows a typical data transmission. Note that several data bytes can be transmitted\nbetween the SLA+R/ W and the STOP condition, depending on the software protocol imple-\nmented by the application software.\nFigure 24-6. Typical Data Transmission12 789Data MSB Data LSB ACK\nAggregate\nSDA\nSDA from\nTransmitter\nSDA from\nReceiver\nSCL from\nMaster\nSLA+R/W Data ByteSTOP , REPEATED\nSTART or Next\nData Byte\n12 789\nData ByteData MSB Data LSB ACK\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\nSLA+R/W STOP\n\n245\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.4 Multi-master Bus Systems, Arbitration and Synchronization\nThe TWI protocol allows bus systems with severa l masters. Special concerns have been taken\nin order to ensure that transmis sions will proceed as normal, even if two or more masters initiate\na transmission at the same time. Two problems arise in multi-master systems:\n\u0081 An algorithm must be implemented allowing only one of the masters to complete the \ntransmission. All other masters should cease tr ansmission when they discover that they \nhave lost the selection process. This selection process is called arbitration. When a \ncontending master discovers that it has lost the arbitration process, it should immediately \nswitch to Slave mode to check whether it is being addressed by the winning master. The fact that multiple masters have started transmission at the same time should not be detectable to the slaves, that is, the data being transferred on the bus must not be corrupted.\n\u0081 Different masters may use different SCL frequencies. A scheme must be devised to \nsynchronize the serial clocks from all masters, in order to let the transmission proceed in a lockstep fashion. This will fac ilitate the arbitration process.\nThe wired-ANDing of the bus lines is used to solv e both these problems. The serial clocks from\nall masters will be wired-ANDed, yielding a co mbined clock with a high period equal to the one\nfrom the Master with the shortest high period. The low period of the combined clock is equal tothe low period of the Master with the longest low period. Note that all masters listen to the SCL\nline, effectively starting to count their SCL high and low time-out periods when the combined\nSCL line goes high or low, respectively.\nFigure 24-7. SCL Synchronization Betw een Multiple Masters\nArbitration is carried out by all masters cont inuously monitoring the SDA line after outputting\ndata. If the value read from the SDA line does not match the value the Master had output, it has\nlost the arbitration. Note that a Master can only lose arbitration when it outputs a high SDA value\nwhile another Master outputs a low value. The losing Master should immediately go to Slave\nmode, checking if it is being addressed by the winning Master. The SDA line should be left high,\nbut losing masters are allowed to generate a clock signal until the end of the current data or\naddress packet. Arbitration will cont inue until only one Master re mains, and this may take many\nbits. If several masters are trying to address th e same Slave, arbitratio n will continue into the\ndata packet.TAlowTAhigh\nSCL from\nMaster A\nSCL from\nMaster B\nSCL Bus\nLine\nTBlowTBhigh\nMasters Start\nCounting Low PeriodMasters Start\nCounting High Period\n\n246\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-8. Arbitration Between Two Masters\nNote that arbitration is not allowed between:\n\u0081 A REPEATED START cond ition and a data bit\n\u0081 A STOP condition and a data bit\u0081 A REPEATED START and a STOP conditionIt is the user software\u2019s responsibility to ensur e that these illegal arbitration conditions never\noccur. This implies that  in multi-master systems, all data transfers must use the same composi-\ntion of SLA+R/ W and data packets. In other words: All transmissions must contain the same\nnumber of data packets, otherwise the result of the arbitration is undefined.\n24.5 Overview of the TWI Module\nThe TWI module is comprised of several submodules, as shown in Figure 24-9 on page 247 . All\nregisters drawn in a thick line are accessible through the AVR data bus.SDA from\nMaster A\nSDA from\nMaster B\nSDA Line\nSynchronized\nSCL LineSTARTMaster A Loses\nArbitration, SDAA   SDA\n\n247\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-9. Overview of the T WI Module\n24.5.1 SCL and SDA Pins\nThese pins interface the AVR T WI with the rest of the MCU system. The output drivers contain a\nslew-rate limiter in order to conform to the T WI specification. The input stages contain a spike\nsuppression unit removing spikes shorter than 50ns. Note that the internal pull-ups in the AVR\npads can be enabled by setting the PORT bits corresponding to the SCL and SDA pins, as\nexplained in the I/O Port section. The internal pull-ups can in some systems eliminate the needfor external ones.\n24.5.2 Bit Rate Generator Unit\nThis unit controls the period of SCL when oper ating in a Master mode. The SCL period is con-\ntrolled by settings in the T WI Bit Rate Register (T WBR) and the Prescaler bits in the T WI Status\nRegister (T WSR). Slave operation does not depend on Bit Rate or Prescaler settings, but the\nCPU clock frequency in the Slave must be at l east 16 times higher than the SCL frequency. Note\nthat slaves may prolong the SCL low period, thereby reducing the average T WI bus clock\nperiod.\nTWI UnitAddress Register\n(TWAR)Address Match Unit\nAddress ComparatorControl Unit\nControl Register\n(TWCR)Status Register\n(TWSR)\nState Machine and\nStatus controlSCL\nSlew-rate\nControlSpike\nFilterSDA\nSlew-rate\nControlSpike\nFilter\nBit Rate Generator\nBit Rate Register\n(TWBR)PrescalerBus Interface Unit\nSTART / STOP\nControl\nArbitration detection AckSpike Suppression\nAddress/Data Shift\nRegister (TWDR)\n\n248\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe SCL frequency is generated according to the following equation:\n\u0081TWBR = Value of the T WI Bit Rate Register\n\u0081TWPS = Value of the prescaler bits in the T WI Status Register\nNote: Pull-up resistor values should be selected according to the SCL frequency and the capacitive bus\nline load. See \u201c2-wire Serial Interface Characteristics\u201d on page 373  for value of pull-up resistor.\n24.5.3 Bus Interface Unit\nThis unit contains the Data and Address Shift Register (T WDR), a START/STOP Controller and\nArbitration detection hardware. The T WDR contains the address or data bytes to be transmitted,\nor the address or data bytes received. In addition to the 8-bit T WDR, the Bus Interface Unit also\ncontains a register containing the (N)ACK bit to be transmitted or receiv ed. This (N)ACK Regis-\nter is not directly accessible by the application software. However, when re ceiving, it can be set\nor cleared by manipulating the T WI Control Register (T WCR). When in Transmitter mode, the\nvalue of the received (N)ACK bit can be determined by the value in the T WSR.\nThe START/STOP Controller is responsible for gene ration and detection of START, REPEATED\nSTART, and STOP conditions. The START/STOP controller is able to detect START and STOP\nconditions even when the AVR MCU is in one of  the sleep modes, enabling the MCU to wake up\nif addressed by a Master.\nIf the T WI has initiated a transmission as Master, the Arbitration Detection hardware continu-\nously monitors the transmission trying to determine if arbitration is in process. If the T WI has lost\nan arbitration, the Control Unit is informed. Correct action can then be taken and appropriatestatus codes generated.\n24.5.4 Address Match Unit\nThe Address Match unit checks if received address bytes match the seven-bit address in the\nTWI Address Register (T WAR). If the T WI General Call Recognition Enable (T WGCE) bit in the\nTWAR is written to one, all incoming address bi ts will also be compared against the General Call\naddress. Upon an address match, the Control Unit is informed, allowing correct action to betaken. The T WI may or may not acknowledge its address, depending on settings in the T WCR.\nThe Address Match unit is able to compare addresses even when the AVR MCU is in sleep\nmode, enabling the MCU to wake up if addressed by a Master. If another interrupt (for example,INT0) occurs during T WI Power-down address match and wakes up the CPU, the T WI aborts\noperation and return to it\u2019s idle state. If this cause any problems, ensure that T WI Address Match\nis the only enabled interrupt when entering Power-down.\n24.5.5 Control Unit\nThe Control unit monitors the T WI bus and generates responses corresponding to settings in the\nTWI Control Register (T WCR). When an event requiring the attention of the application occurs\non the T WI bus, the T WI Interrupt Flag (T WINT) is asserted. In the next clock cycle, the T WI Sta-\ntus Register (T WSR) is updated with a status code identifying the event. The T WSR only\ncontains relevant status information when the T WI Interrupt Flag is asserted. At all other times,\nthe TW\nSR contains a special status code indicating t hat no relevant status information is avail-\nable. As long as the T WINT Flag is set, the SCL line is held  low. This allows the application\nsoftware to complete its tasks before allowing the T WI transmission to continue.SCL frequencyCPU Clock frequency\n16 2(T WBR) 4TWPS\u22c5 +-----------------------------------------------------------=\n\n249\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe TWINT Flag is set in th e following situations:\n\u0081 After the T WI has transmitted a START/REPEATED START condition\n\u0081 After the T WI has transmitted SLA+R/ W\n\u0081 After the T WI has transmitted an address byte\n\u0081 After the T WI has lost arbitration\n\u0081 After the T WI has been addressed by own slave address or general call\n\u0081 After the T WI has received a data byte\n\u0081 After a STOP or REPEATED START has been received while still add ressed as a Slave\n\u0081When a bus error has occurr ed due to an illegal START or STOP condition\n24.6 Using the TWI\nThe AVR T WI is byte-oriented and interrupt based. Interrupts are issued after all bus events, like\nreception of a byte or transmission of a START condition. Because the T WI is interrupt-based,\nthe application software is free to carry on other operations during a T WI byte transfer. Note that\nthe TWI Interrupt Enable (T WIE) bit in T WCR together with the Global Interrupt Enable bit in\nSREG allow the application to decide whether or not assertion of the T WINT Flag should gener-\nate an interrupt request. If the T WIE bit is cleared, the application must poll the T WINT Flag in\norder to detect actions on the T WI bus.\nWhen the T WINT Flag is asserted, the T WI has finished an operation and awaits application\nresponse. In this case, the T WI Status Register (T WSR) contains a value indicating the current\nstate of the T WI bus. The application software can then decide how the T WI should behave in\nthe next T WI bus cycle by manipulating the T WCR and T WDR Registers.\nFigure 24-10  is a simple example of how the application can interface to the T WI hardware. In\nthis example, a Master wishes to transmit a single data byte to a Slave. This description is quite\nabstract, a more detailed explanation follows later in this section. A simple code example imple-\nmenting the desired behavior is also presented.\nFigure 24-10. Interfacing the Application to the T WI in a Typical Transmission\nSTART SLA+W A Data A STOP1. Application\nwrites to TWCR to\ninitiate\ntransmission of\nSTART\n2. TWINT set.\nStatus code indicates\nSTART condition sent4. TWINT set.\nStatus code indicates\nSLA+W sent, ACK\nreceived6. TWINT set.\nStatus code indicates\ndata sent, ACK received3. Check TWSR to see if START was \nsent. Application loads SLA+W into \nTWDR, and loads appropriate control \nsignals into TWCR, makin sure that \nTWINT is written to one, \nand TWSTA is written to zero.5. Check TWSR to see if SLA+W was\nsent and ACK received.\nApplication loads data into TWDR, and\nloads appropriate control signals into\nTWCR, making sure that TWINT is\nwritten to one7. Check TWSR to see if data was sent\nand ACK received.\nApplication loads appropriate control\nsignals to send STOP into TWCR,\nmaking sure that TWINT is written to one\nTWI bus\nIndicates\nTWINT setApplication\nAction TWI\nHardware\nAction\n\n250\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1. The first step in a T WI transmission is to transmit a START condition. This is done by \nwriting a specific value into T WCR, instructing the T WI hardware to transmit a START \ncondition. Which value to write is described later on. However, it is important that the \nTWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI will \nnot start any operation as long as the T WINT bit in T WCR is set. Immediately after the \napplication has cleared T WINT, the T WI will initiate transmission of the START condition.\n2.When the START condition has been transmitted, the T WINT Flag in T WCR is set, and \nTWSR is updated with a status code indicating that the START condition has success-\nfully been sent.\n3. The application software should now examine the value of T WSR, to make sure that the \nSTART condition was successfully transmitted. If T WSR indicates otherwise, the applica-\ntion software might take some special action,  like calling an error routine. Assuming that \nthe status code is as expected, the application must load SLA+ W into TWDR. Remember \nthat TWDR is used both for address and data. After T WDR has been loaded with the \ndesired SLA+ W, a specific value must be written to T WCR, instructing the T WI hardware \nto transmit the SLA+ W present in T WDR. Which value to write is described later on. \nHowever, it is important that the T WINT bit is set in the value written. Writing a one to \nTWINT clears the flag. The T WI will not start any operation as long as the T WINT bit in \nTWCR is set. Immediately after the application has cleared T WINT, the T WI will initiate \ntransmission of the address packet.\n4.When the address packet has been transmitted, the T WINT Flag in T WCR is set, and \nTWSR is updated with a status code indicating that the address packet has successfully \nbeen sent. The status code will also reflect whether a Slave acknowledged the packet or not.\n5. The application software should now examine the value of T WSR, to make sure that the \naddress packet was successfully transmitted, and that the value of the ACK bit was as expected. If T WSR indicates otherwise, the application software might take some special \naction, like calling an error routine. Assuming that the status code is as expected, the \napplication must load a data packet into T WDR. Subsequently, a specific value must be \nwritten to T WCR, instructing the T WI hardware to transmit the data packet present in \nTWDR. Which value to write is described later on. However, it is important that the \nTWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI will \nnot start any operation as long as the T WINT bit in T WCR is set. Immediately after the \napplication has cleared T WINT, the T WI will initiate transmissi on of the data packet.\n6.When the data packet has been transmitted, the T WINT Flag in T WCR is set, and T WSR \nis updated with a status code indicating that the data packet has successfully been sent. The status code will also re flect whether a Slave ackno wledged the packet or not.\n7. The application software should now examine the value of T WSR, to make sure that the \ndata packet was successfully transmitted, and that the value of the ACK bit was as expected. If T WSR indicates otherwise, the application software might take some special \naction, like calling an error routine. Assuming that the status code is as expected, the \napplication must write a specific value to T WCR, instructing the T WI hardware to transmit \na STOP condition. Which value to write is described late r on. However, it is important that \nthe TWINT bit is set in the value written. Writing a one to T WINT clears the flag. The T WI \nwill not start any operation as long as the T WINT bit in T WCR is set. Immediately after \nthe application has cleared T WINT, the T WI will initiate transmission of the STOP condi-\ntion. Note that T WINT is NOT set after a STOP condition has been sent.\n\n251\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nEven though this example is simple, it shows the principles involved in all T WI transmissions.\nThese can be summarized as follows:\n\u0081When the T WI has finished an operation and expects application response, the T WINT Flag \nis set. The SCL line is pulled low until T WINT is cleared.\n\u0081When the T WINT Flag is set, the user must update all T WI Registers with the value relevant \nfor the next T WI bus cycle. As an example, T WDR must be loaded with the value to be \ntransmitted in the next bus cycle.\n\u0081 After all T WI Register updates and other pending application software tasks have been \ncompleted, T WCR is written. When writing T WCR, the T WINT bit should be set. Writing a \none to T WINT clears the flag. The T WI will then commence executin g whatever operation \nwas specified by the T WCR setting.\nIn the following an assembly and C implementation  of the example is given. Note that the code\nbelow assumes that several definitions have been made, for example by using include-files.\nAssembly Code Example C Example Comments\n1ldir16, (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN)\noutTWCR, r16TWCR = (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN) Send START condition\n2wait1:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait1while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the START condition \nhas been transmitted\n3inr16,TWSR\nandir16, 0xF8\ncpir16, START\nbrneERRORif ((TWSR & 0xF8) != START)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from START go to \nERROR\nldir16, SLA_W\noutTWDR, r16 \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = SLA_W;\nTWCR = (1<<TWINT) | (1<<TWEN);Load SLA_ W into T WDR Register. \nClear T WINT bit in T WCR to start \ntransmission of address\n4wait2:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait2while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the SLA+ W has been \ntransmitted, and ACK/NACK has \nbeen received.\n5inr16,TWSR\nandir16, 0xF8\ncpir16, MT_SLA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_SLA_ACK)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from MT_SLA_ACK \ngo to ERROR\nldir16, DATA\noutTWDR, r16       \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = DATA;\nTWCR = (1<<TWINT) | (1<<TWEN);Load DATA into T WDR Register. \nClear T WINT bit in T WCR to start \ntransmission of data\n\n252\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.7 Transmission Modes\nThe TWI can operate in one of four major modes. These are named Master Transmitter (MT),\nMaster Receiver (MR), Slave Transmitter (ST)  and Slave Receiver (SR). Several of these\nmodes can be used in the same application. As an example, the T WI can use MT mode to write\ndata into a T WI EEPROM, MR mode to read  the data back from the EEPROM. If other masters\nare present in the system, some of these might transmit data to the T WI, and then SR mode\nwould be used. It is the application softw are that decides which modes are legal.\nThe following sections describe each of these modes. Possible status codes are described\nalong with figures detailing data transmission in  each of the modes. These figures contain the\nfollowing abbreviations:\nS: START condition\nRs: REPEATED START condition\nR: Read bit (high level at SDA)\nW: Write bit (low level at SDA)\nA: Acknowledge bit (low level at SDA)\nA:Not acknowledge bit (high level at SDA)\nData: 8-bit data byte\nP: STOP condition\nSLA: Slave Address\nIn Figure 24-12 on page 255  to Figure 24-18 on page 264 , circles are used to indicate that the\nTWINT Flag is set. The numbers in the circles show the status code held in T WSR, with the\nprescaler bits masked to zero. At these points, ac tions must be taken by the application to con-\ntinue or complete the T WI transfer. The T WI transfer is suspended until the T WINT Flag is\ncleared by software.\nWhen the T WINT Flag is set, the status code in T WSR is used to determine the appropriate soft-\nware action. For each status code, the required software action and details of the following serial\ntransfer are given in Table 24-2 on page 254  to Table 24-5 on page 263 . Note that the prescaler\nbits are masked to zero in these tables.6wait3:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait3while (!(TWCR & (1<<TWINT)))\n;Wait for T WINT Flag set. This \nindicates that the DATA has been \ntransmitted, and ACK/NACK has \nbeen received.\n7inr16,TWSR\nandir16, 0xF8\ncpir16, MT_DATA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_DATA_ACK)\nERROR();Check value of T WI Status \nRegister. Mask prescaler bits. If \nstatus different from \nMT_DATA_ACK go to ERROR\nldir16, (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO)\noutTWCR, r16 TWCR = (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO); Transmit STOP conditionAssembly Code Example C Example Comments\n\n253\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24.7.1 Master Transmitter Mode\nIn the Master Transmitter mode, a number of data bytes are transmitted to a Slave Receiver\n(see Figure 24-11 ). In order to enter a Master mode, a START condition must be transmitted.\nThe format of the following address packet determines whether Master Transmitter or Master\nReceiver mode is to be entered. If SLA+ W is transmitted, MT mode is entered, if SLA+R is trans-\nmitted, MR mode is entered. All the status codes mentioned in this section assume that theprescaler bits are zero or are masked to zero.\nFigure 24-11. Data Transfer in Master Transmitter Mode\nA START condition is sent by writing the following value to T WCR:\nTWEN must be set to enable the 2-wire Serial Interface, T WSTA must be written to one to trans-\nmit a START condition and T WINT must be written to one to clear the T WINT Flag. The T WI will\nthen test the 2-wire Serial Bus and generate a START condition as soon as the bus becomes\nfree. After a START condition has been transmitted, the T WINT Flag is set by hardware, and the\nstatus code in T WSR will be 0x08 (see Table 24-2 on page 254 ). In order to enter MT mode,\nSLA+W must be transmitted. This  is done by writing SLA+ W to TWDR. Thereafter the T WINT bit\nshould be cleared (by writing it to one) to continue the transfer. This is accomplished by writing\nthe following value to T WCR:\nWhen SLA+ W have been transmitted and an acknowledgement bit has been received, T WINT is\nset again and a number of status codes in T WSR are possible. Possible status codes in Master\nmode are 0x18, 0x20, or 0x38. The appropriate action to be taken for each of these status codesis detailed in Table 24-2 on page 254 .\nWhen SLA+ W has been successfully transmitted, a data packet should be transmitted. This is\ndone by writing the data byte to T WDR. TWDR must only be written when T WINT is high. If not,\nthe access will be discarded, and the Write Collision bit (T WWC) will be set in the T WCR Regis-\nter. After updating T WDR, the T WINT bit should be cleared (by writing it to one) to continue the\ntransfer. This is acco mplished by writing the following value to T WCR:TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 XDevice 1\nMASTER\nTRANSMITTERDevice 2\nSLAVE\nRECEIVERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n254\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThis scheme is repeated until the last byte has been sent and the transfer is ended by generat-\ning a STOP condition or a repeated START condition. A STOP condition is generated by writing\nthe following value to T WCR:\nA REPEATED START condition is generated by writing the following value to T WCR:\nAfter a repeated START condition (state 0x10) th e 2-wire Serial Interface can access the same\nSlave again, or a new Slave without transmitting a STOP condition. Repeated START enables\nthe Master to switch between Slaves, Master Transmitter mode and Master Receiver mode with-out losing control of the bus.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTable 24-2. Status codes for Master Transmitter Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDR To TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+W 0 0 1 X SLA+W will be transmitted;\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+W or \nLoad SLA+R0\n00\n01\n1X\nXSLA+W will be transmitted;\nACK or NOT ACK will be receivedSLA+R will be transmitted;\nLogic will switch to Master Receiver mode\n0x18 SLA+W has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmitted\nSTOP condition will be transmitted andTWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x20 SLA+W has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x28 Data byte has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmitted\nSTOP condition will be transmitted andTWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x30 Data byte has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x38 Arbitration lost in SLA+W or data\nbytesNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nX2-wire Serial Bus will be released and not addressed \nSlave mode enteredA START condition will be transmitted when the bus be-\ncomes free\n\n255\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-12. Formats and States in the Master Transmitter Mode \n24.7.2 Master Receiver Mode\nIn the Master Receiver mode, a number of data bytes are received from a Slave Transmitter\n(see Figure 24-13 on page 256 ). In order to enter a Master mode, a START condition must be\ntransmitted. The format of the following address packet determines whether Master Transmitter\nor Master Receiver mode is to be entered. If SLA+ W is transmitted, MT mode is entered, if\nSLA+R is transmitted, MR mode is entered. All the status codes mentioned in this section\nassume that the prescaler bits are zero or are masked to zero.S SLA W A DATA A P\n$08 $18 $28\nR SLA W\n$10\nAP\n$20\nP\n$30\nA or A\n$38A\nOther master\ncontinues A or A\n$38Other master\ncontinuesR\nA\n$68Other master\ncontinues\n$78 $B0To corresponding\nstates in slave modeMT\nMRSuccessfull\ntransmissionto a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nNot acknowledge\nreceived after a databyte\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. Theprescaler bits are zero or masked to zeroS\n\n256\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-13. Data Transfer in Ma ster Receiver Mode\nA START condition is sent by writing the following value to T WCR:\nTWEN must be written to one to enable the 2-wire Serial Interface, T WSTA must be written to\none to transmit a START condition and T WINT must be set to clear the T WINT Flag. The T WI\nwill then test the 2-wire Serial Bus and generate a START condition as soon as the busbecomes free. After a START condition has been transmitted, the T WINT Flag is set by hard-\nware, and the status code in T WSR will be 0x08 (see Table 24-2 on page 254 ). In order to enter\nMR mode, SLA+R must be transmitted. This is done by writing SLA+R to T WDR. Thereafter the\nTWINT bit should be cleared (by writing it to one) to continue the transfer. This is accomplished\nby writing the following value to T WCR:\nWhen SLA+R have been transmitted and an acknowledgement bit has been received, T WINT is\nset again and a number of status codes in T WSR are possible. Possible status codes in Master\nmode are 0x38, 0x40, or 0x48. The appropriate action to be taken for each of these status codes\nis detailed in Table 24-3 on page 257 . Received data can be read from the T WDR Register\nwhen the T WINT Flag is set high by hardware. This scheme is repeated until the last byte has\nbeen received. After the last byte has been received, the MR should inform the ST by sending a\nNACK after the last received data byte. The transfer is ended by generating a STOP condition ora repeated START condition. A STOP condition is generated by writing the following value toTWCR:\nA REPEATED START condition is generated by writing the following value to T WCR:\nAfter a repeated START condition (state 0x10) th e 2-wire Serial Interface can access the same\nSlave again, or a new Slave without transmitting a STOP condition. Repeated START enables\nthe Master to switch between Slaves, Master Transmitter mode and Master Receiver mode with-\nout losing control over the bus.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 XDevice 1\nMASTER\nRECEIVERDevice 2\nSLAVE\nTRANSMITTERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n257\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-3. Status codes for Master Receiver Mode\nStatus Code\n(TWSR)\nPrescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+R 0 0 1 X SLA+R will be transmitted\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+R or \nLoad SLA+W0\n00\n01\n1X\nXSLA+R will be transmitted\nACK or NOT ACK will be received\nSLA+W will be transmitted\nLogic will switch to Master Transmitter mode\n0x38 Arbitration lost in SLA+R or NOT\nACK bitNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nX2-wire Serial Bus will be released and not addressed \nSlave mode will be entered\nA START condition will be transmitted when the busbecomes free\n0x40 SLA+R has been transmitted;\nACK has been receivedNo TWDR action or\nNo TWDR action0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x48 SLA+R has been transmitted;\nNOT ACK has been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will \nbe reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x50 Data byte has been received;\nACK has been returnedRead data byte or\nRead data byte0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x58 Data byte has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n\n258\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-14. Formats and States in the Master Receiver Mode\n24.7.3 Slave Receiver Mode\nIn the Slave Receiver mode, a number of data bytes are received from a Master Transmitter\n(see Figure 24-15 ). All the status codes mentioned in this section assume that the prescaler bits\nare zero or are masked to zero.\nFigure 24-15. Data transfer in Slave Receiver mode\nTo initiate the Slave Receiver mode, T WAR and T WCR must be initialized as follows:S SLA R A DATA A\n$08 $40 $50\nSLA R\n$10\nAP\n$48\nA or A\n$38Other master\ncontinues\n$38Other master\ncontinuesW\nA\n$68Other master\ncontinues\n$78 $B0To corresponding\nstates in slave modeMR\nMTSuccessfull\nreceptionfrom a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP DATA A\n$58\nARS\nTWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave AddressDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nTRANSMITTERDevice 1\nSLAVE\nRECEIVER\n\n259\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe upper seven bits are the address to which the 2-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the T WI will respond to the general call address (0x00),\notherwise it will ignore the general call address.\nTWEN must be written to one to enable the T WI. The T WEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. T WSTA\nand TWSTO must be written to zero.\nWhen TWAR and T WCR have been initialized, the T WI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If the\ndirection bit is \u201c0\u201d (write), the T WI will operate in SR mode, otherw ise ST mode is entered. After\nits own slave address and the write bit have been received, the T WINT Flag is set and a valid\nstatus code can be read from T WSR. The status code is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 24-4 on\npage 260 . The Slave Receiver mode may also be en tered if arbitration is lost while the T WI is in\nthe Master mode (see states 0x68 and 0x78).\nIf the T WEA bit is reset during a transfer, the T WI will return a \u201cNot Acknowledge\u201d (\u201c1\u201d) to SDA\nafter the next received data byte. This can be used to indicate that the Slave is not able toreceive any more bytes. While TWEA is zero, the T WI does not acknowledge its own slave\naddress. However, the 2-wire Se rial Bus is still monitored and address recognit ion may resume\nat any time by setting T WEA. This implies that the T WEA bit may be used to temporarily isolate\nthe TWI from the 2-wire Serial Bus.\nIn all sleep modes other than Idle  mode, the clock system to the T WI is turned off. If the T WEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the 2-wire Serial Bus clock as a clock sour ce. The part will then wake up from sleep and\nthe TWI will hold the SCL clock low duri ng the wake up and until the T WINT Flag is cleared (by\nwriting it to one). Further data reception will be carried out as normal, with the AVR clocks run-ning as normal. Observe that if the AVR is set up with a long start-up time, the SCL line may be\nheld low for a long time, blocking other data transmissions.\nNote that the 2-wire Serial Interface Data Register \u2013 T WDR does not reflect the last byte present\non the bus when waking up from these Sleep modes.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 X\n\n260\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-4. Status Codes for Slave Receiver Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus and\n2-wire Serial Interface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x60 Own SLA+W has been received;\nACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x68 Arbitration lost in SLA+R/W as\nMaster; own SLA+W has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x70 General call address has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x78 Arbitration lost in SLA+R/W as\nMaster; General call address has\nbeen received; ACK has been \nreturnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x80 Previously addressed with own\nSLA+W; data has been received;\nACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x88 Previously addressed with own\nSLA+W; data has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;no recognition of own SLA or GCA;\na START condition will be transmitted when the bus \nbecomes freeSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0x90 Previously addressed with \ngeneral call; data has been re-\nceived; ACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be \nreturned\nData byte will be received and ACK will be returned\n0x98 Previously addressed with \ngeneral call; data has been \nreceived; NOT ACK has been \nreturnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0xA0 A STOP condition or repeated\nSTART condition has been \nreceived while still addressed as\nSlaveNo action 0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus \nbecomes free\n\n261\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-16. Formats and States in the Slave Receiver Mode\n24.7.4 Slave Transmitter Mode\nIn the Slave Transmitter mode, a number of data bytes are transmitted to a Master Receiver\n(see Figure 24-17 ). All the status codes mentioned in this section assume that the prescaler bits\nare zero or are masked to zero.\nFigure 24-17. Data Transfer in Slave Transmitter ModeS SLA W A DATA A\n$60 $80\n$88\nA\n$68Reception of the own\nslave address and one ormore data bytes.  All areacknowledged\nLast data byte received\nis not acknowledged\nArbitration lost as master\nand addressed as slave\nReception of the general call\naddress and one or more databytes\nLast data byte received is\nnot acknowledged\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA A\n$80 $A0\nP or S A\nA DATA A\n$70 $90\n$98\nA\n$78P or S DATA A\n$90 $A0\nP or S AGeneral Call\nArbitration lost as master and\naddressed as slave by general call\nDATA A\nDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nRECEIVERDevice 1\nSLAVE\nTRANSMITTER\n\n262\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTo initiate the Slave Transmitter mode, T WAR and T WCR must be initialized as follows:\nThe upper seven bits are the address to which the 2-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the T WI will respond to the general call address (0x00),\notherwise it will ignore the general call address.\nTWEN must be written to one to enable the T WI. The T WEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. T WSTA\nand TWSTO must be written to zero.\nWhen TWAR and T WCR have been initialized, the T WI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If the\ndirection bit is \u201c1\u201d (read), the T WI will operate in ST mode, otherw ise SR mode is entered. After\nits own slave address and the write bit have been received, the T WINT Flag is set and a valid\nstatus code can be read from T WSR. The status code is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 24-5 on\npage 263 . The Slave Transmitter mode may also be entered if arbitration is lost while the T WI is\nin the Master mode (see state 0xB0).\nIf the T WEA bit is written to zero during a transfer, the T WI will transmit the last  byte of the trans-\nfer. State 0xC0 or state 0xC8 will be entere d, depending on whether the Master Receiver\ntransmits a NACK or ACK after the final byte. The T WI is switched to the not addressed Slave\nmode, and will ignore the Mast er if it continues th e transfer. Thus the Ma ster Receiver receives\nall \u201c1\u201d as serial data. State 0xC8 is entered if the Master demands additional data bytes (by\ntransmitting ACK), even though the Slave has transmitted the last byte (T WEA zero and expect-\ning NACK from the Master).\nWhile TWEA is zero, the T WI does not respond to its own slave address. However, the 2-wire\nSerial Bus is still monitored an d address recognition may resume  at any time by setting T WEA.\nThis implies that the T WEA bit may be used to temporarily isolate the T WI from the 2-wire Serial\nBus.\nIn all sleep modes other than Idle  mode, the clock system to the T WI is turned off. If the T WEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the 2-wire Serial Bus clock as a clock sour ce. The part will then wake up from sleep and\nthe TWI will hold the SCL clock will low duri ng the wake up and until the T WINT Flag is cleared\n(by writing it to one). Further data tr ansmission will be carried out as normal, with the AVR clocks\nrunning as normal. Observe that if the AVR is set up with a long start-up time, the SCL line maybe held low for a long time, blocking other data transmissions.\nNote that the 2-wire Serial Interface Data Register \u2013 T WDR does not reflect the last byte present\non the bus when waking up from these sleep modes.TWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave Address\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 X\n\n263\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 24-5. Status Codes for Slave Transmitter Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus and\n2-wire Serial Interface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xA8 Own SLA+R has been received;\nACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-\nceived\n0xB0 Arbitration lost in SLA+R/W as\nMaster; own SLA+R has been \nreceived; ACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-ceived\n0xB8 Data byte in TWDR has been \ntransmitted; ACK has been receivedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe receivedData byte will be transmitted and ACK should be re-\nceived\n0xC0 Data byte in TWDR has been \ntransmitted; NOT ACK has been \nreceivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus becomes free\n0xC8 Last data byte in TWDR has been\ntransmitted (TWEA = \u201c0\u201d); ACKhas been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCASwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201dSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;\na START condition will be transmitted when the bus becomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus \nbecomes free\n\n264\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 24-18. Formats and States in the Slave Transmitter Mode\n24.7.5 Miscellaneous States\nThere are two status codes that do not correspond to a defined T WI state, see Table 24-6 .\nStatus 0xF8 indicates that no relevant  information is available because the T WINT Flag is not\nset. This occurs between other states, and when the T WI is not involved in a serial transfer.\nStatus 0x00 indicates that a bus error has occu rred during a 2-wire Serial Bus transfer. A bus\nerror occurs when a START or STOP condition occurs at an illegal position in the format frame.\nExamples of such illegal positions are during the serial transfer of an address byte, a data byte,\nor an acknowledge bit. When a bus error occurs, T WINT is set. To recover from a bus error, the\nTWSTO Flag must set and T WINT must be cleared by writing a logic one to it. This causes the\nTWI to enter the not addressed Slave mode and to clear the T WSTO Flag (no other bits in\nTWCR are affected). The SDA and SCL lines are released, and no STOP condition is\ntransmitted.\n24.7.6 Combining Several TWI Modes\nIn some cases, several T WI modes must be combined in order to complete the desired action.\nConsider for example reading data from a serial  EEPROM. Typically, such a transfer involves\nthe following steps:\n1. The transfer must be initiated.\n2. The EEPROM must be instructed what location should be read.\n3. The reading must be performed.4. The transfer must be finished.S SLA R A DATA A\n$A8 $B8\nA\n$B0Reception of the own\nslave address and one ormore data bytes\nLast data byte transmitted.\nSwitched to not addressedslave (TWEA = '0')Arbitration lost as master\nand addressed as slave\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA\n$C0\nDATA AA\n$C8P or S All 1'sA\nTable 24-6. Miscellaneous States\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the 2-wire Serial Bus\nand 2-wire Serial Interface Hard-\nwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xF8 No relevant state information\navailable; TWINT = \u201c0\u201dNo TWDR action No TWCR action Wait or proceed current transfer\n0x00 Bus error due to an illegal\nSTART or STOP conditionNo TWDR action 0 1 1 X Only the internal hardware is affected, no STOP condi-\ntion is sent on the bus. In all cases, the bus is released \nand TWSTO is cleared.\n\n265\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote that data is transmitted both from Master to Slave and vice versa. The Master must instruct\nthe Slave what location it wants to read, r equiring the use of the MT mode. Subsequently, data\nmust be read from the Slave, implying the use of  the MR mode. Thus, the transfer direction must\nbe changed. The Master must keep control of the bus during all these steps, and the stepsshould be carried out as an atomical operation. If th is principle is violated in a multimaster sys-\ntem, another Master can alter the data pointer in the EEPROM between steps 2 and 3, and the\nMaster will read the wrong data lo cation. Such a change in transfe r direction is accomplished by\ntransmitting a REPEATED START between the trans mission of the address byte and reception\nof the data. After a REPEATED START, the Master keeps ownership of the bus. The following\nfigure shows the flow in this transfer.\nFigure 24-19. Combining Several T WI Modes to Access a Serial EEPROM\n24.8 Multi-master Syst ems and Arbitration\nIf multiple masters are connected to the same bus, transmissions may be initiated simultane-\nously by one or more of them. The T WI standard ensures that such situations are handled in\nsuch a way that one of the mast ers will be allowed to proceed wit h the transfer, and that no data\nwill be lost in the process. An example of an ar bitration situation is depicted below, where two\nmasters are trying to transmit data to a Slave Receiver.\nFigure 24-20. An Arbitration Example\nSeveral different scenarios may arise during arbitration, as described below:\n\u0081 Two or more masters are performing identical communication with the same Slave. In this \ncase, neither the Slave nor any of the ma sters will know about the bus contention.\n\u0081 Two or more masters are accessing the same Slave with different data or direction bit. In this \ncase, arbitration will occur, either in the READ/ WRITE bit or in the data bits. The masters \ntrying to output a one on SDA while another Master outputs a zero will lose the arbitration. \nLosing masters will switch to no t addressed Slave mode or wa it until the bus is free and \ntransmit a new START condition, depending on application software action.Master Transmitter Master Receiver\nS = START Rs = REPEATED START P = STOP\nTransmitted from master to slave Transmitted from slave to masterS SLA+W A ADDRESS ARs SLA+R A DATA AP\nDevice 1\nMASTER\nTRANSMITTERDevice 2\nMASTER\nTRANSMITTERDevice 3\nSLAVE\nRECEIVERDevice n\nSDA\nSCL........ R1 R2VCC\n\n266\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Two or more masters are accessing different slav es. In this case, arbitration will occur in the \nSLA bits. Masters trying to ou tput a one on SDA while anot her Master outputs a zero will \nlose the arbitration. Masters lo sing arbitration in SLA will switch  to Slave mode to check if \nthey are being addressed by the winning Master. If addressed, they will switch to SR or ST \nmode, depending on the value of the READ/ WRITE bit. If they are not being addressed, they \nwill switch to not addressed Slav e mode or wait until the bu s is free and transmit a new \nSTART condition, depending on application software action.\nThis is summarized in Figure 24-21 . Possible status values are given in circles.\nFigure 24-21. Possible Status Codes Caused by Arbitration\n24.9 Register Description\n24.9.1 TWBR \u2013 TWI Bit Rate Register\n\u0081 Bits 7:0 \u2013 TWI Bit Rate Register\nTWBR selects the division factor for the bit rate generator. The bit rate generator is a frequency\ndivider which generates the SCL clock frequency in the Master modes. See \u201cBit Rate Generator\nUnit\u201d on page 247  for calculating bit rates.\n24.9.2 TWCR \u2013 TWI Control Register\nThe TWCR is used to control the operation of the T WI. It is used to enable the T WI, to initiate a\nMaster access by applying a START condition to the bus, to generate a Receiver acknowledge,to generate a stop condition, and to control halting of the bus while the data to be written to the\nbus are written to the T WDR. It also indicates a write collisio n if data is at tempted written to\nTWDR while the register  is inaccessible.Own\nAddress / General Call\nreceivedArbitration lost in SLA\nTWI bus will be released and not addressed slave mode will be enteredA START condition will be transmitted when the bus becomes free NoArbitration lost in Data\nDirectionYe s\nWrite Data byte will be received and NOT ACK will be returned\nData byte will be received and ACK will be returned\nLast data byte will be transmitted and NOT ACK should be receivedData byte will be transmitted and ACK should be received Read\nB068/7838SLA START Data STOP\nB i t 76543210\n(0xB8) TWBR7 TWBR6 TWBR5 TWBR4 TWBR3 TWBR2 TWBR1 TWBR0 TWBR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210(0xBC) TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE TWCR\nRead/Write R/W R/W R/W R/W R R/W R R/WInitial Value 0 0 0 0 0 0 0 0\n\n267\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 7 \u2013 TWINT: TWI Interrupt Flag\nThis bit is set by hardware when the T WI has finished its current job and expects application\nsoftware response. If the I-bit in SREG and T WIE in T WCR are set, the MCU will jump to the\nTWI Interrupt Vector. While the T WINT Flag is set, the SCL low period is stretched. The T WINT\nFlag must be cleared by software by writing a logic one to it. Note that this flag is not automati-\ncally cleared by hardware when executing the interr upt routine. Also note that clearing this flag\nstarts the operation of the T WI, so all accesses to the T WI Address Register (T WAR), T WI Sta-\ntus Register (T WSR), and T WI Data Register (T WDR) must be complete before clearing this\nflag.\n\u0081 Bit 6 \u2013 TWEA: TWI Enable Acknowledge Bit\nThe TWEA bit controls the generation of the acknowledge pulse. If the T WEA bit is written to\none, the ACK pulse is generated on the T WI bus if the following  conditions are met:\n1. The device\u2019s own slave address has been received.\n2. A general call has been received, while the T WGCE bit in the T WAR is set.\n3. A data byte has been received in Master Receiver or Slave Receiver mode.By writing the T WEA bit to zero, the device can be virtually disconnected from the 2-wire Serial\nBus temporarily. Address recognition can then be resumed by writing the T WEA bit to one\nagain.\n\u0081 Bit 5 \u2013 TWSTA: TWI START Condition Bit\nThe application writes the T WSTA bit to one when it desires to become a Master on the 2-wire\nSerial Bus. The T WI hardware checks if the bus is available, and generates a START condition\non the bus if it is free. However, if the bus is not free, the T WI waits until a STOP condition is\ndetected, and then generates a new START condition to claim the bus Master status. T WSTA\nmust be cleared by software when the START condition has been transmitted.\n\u0081 Bit 4 \u2013 TWSTO: TWI STOP Condition Bit\nWriting the T WSTO bit to one in Master mode will g enerate a STOP cond ition on the 2-wire\nSerial Bus. When the STOP condition is executed on the bus, the T WSTO bit is cleared auto-\nmatically. In Slave mode, setting the T WSTO bit can be used to recover from an error condition.\nThis will not generate a STOP  condition, but the T WI returns to a well-defined unaddressed\nSlave mode and releases the SCL and SDA lines to a high impedance state.\n\u0081 Bit 3 \u2013 TWWC: TWI Write Collision Flag\nThe TWW\nC bit is set when attempting to write to the T WI Data Register \u2013 T WDR when T WINT is\nlow. This flag is cl eared by writing the T WDR Register when T WINT is high.\n\u0081 Bit 2 \u2013 TWEN: TWI Enable Bit\nThe TWEN bit enables T WI operation and activates the T WI interface. When TWEN is written to\none, the T WI takes control over the I/O pins connected to the SCL and SDA pins, enabling the\nslew-rate limiters and spike filters. If  this bit is written to zero, the T WI is switched off and all T WI\ntransmissions are terminated, regardless of any ongoing operation.\n\u0081 Bit 1 \u2013 Res: Reserved Bit\nThis bit is a reserved bit an d will always read as zero.\n\n268\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 TWIE: TWI Interrupt Enable\nWhen this bit is written to one, and the I-bit in SREG is set, the T WI interrupt request will be acti-\nvated for as long as the T WINT Flag is high.\n24.9.3 TWSR \u2013 TWI Status Register\n\u0081 Bits 7:3 \u2013 TWS: TWI Status\nThese five bits reflect the status of the T WI logic and the 2-wire Serial Bus. The different status\ncodes are described later in this section. Note that the value read from T WSR contains both the\n5-bit status value and the 2-bit prescaler value. The application designer should mask the pres-\ncaler bits to zero when checking the Status bits. This makes status checking independent ofprescaler setting. This approach is used in this datasheet, unless otherwise noted.\n\u0081 Bit 2 \u2013 Res: Reserved Bit\nThis bit is reserved and will always read as zero.\n\u0081 Bits 1:0 \u2013 TWPS: TWI Prescaler Bits\nThese bits can be read and written, and control the bit rate prescaler.\nTo calculate bit rates, see \u201cBit Rate Generator Unit\u201d on page 247 . The value of T WPS1:0 is used\nin the equation.\n24.9.4 TWDR \u2013 TWI Data Register\nIn Transmit mode, T WDR contains the next byte to be transmitted. In Receive mode, the T WDR\ncontains the last byte receiv ed. It is writable while the T WI is not in the process of shifting a byte.\nThis occurs when the T WI Interrupt Flag (T WINT) is set by hardware. Note that the Data Regis-\nter cannot be initialized by the user before the first interrupt occurs. The data in T WDR remains\nstable as long as T WINT is set. While data is shifted out, data on the bus is simultaneously\nshifted in. T WDR always contains the last byte present on the bus, except after a wake up from\na sleep mode by the T WI interrupt. In this case, the contents of T WDR is undefined. In the case\nof a lost bus arbitration, no data is lost in the transition from Master to Slave. Handling of the\nACK bit is controlled automatically by the T WI logic, the CPU cannot access the ACK bit directly.B i t 76543210\n(0xB9) TWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 TWSR\nR e a d / W r i t e RRRRRR R / W R / WInitial Value 1 1 1 1 1 0 0 0\nTable 24-7. TWI Bit Rate Prescaler\nTWPS1 TWPS0 Prescaler Value\n001014\n101 6\n116 4\nB i t 76543210\n(0xBB) TWD7 TWD6 TWD5 TWD4 TWD3 TWD2 TWD1 TWD0 TWDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 1 1 1 1 1 1 1 1\n\n269\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bits 7:0 \u2013 TWD: TWI Data Register\nThese eight bits constitute the next data byte to be transmitted, or the latest data byte received\non the 2-wire Serial Bus.\n24.9.5 TWAR \u2013 TWI (Slave) Address Register\nThe TWAR should be loaded with the 7-bit Slave address (in the seven most significant bits of\nTWAR) to which the T WI will respond when programmed as a Slave Transmitter or Receiver,\nand not needed in the Master modes. In multimaster systems, T WAR must be set in masters\nwhich can be addressed as Slaves by other Masters.\nThe LSB of T WAR is used to enable recognition of the general call address (0x00). There is an\nassociated address comparator that looks for the slave address (or general call address if\nenabled) in the received serial address. If a match is found, an interrupt request is generated.\n\u0081 Bits 7:1 \u2013 TWA: TWI (Slave) Address Register\nThese seven bits constitute the slave address of the T WI unit.\n\u0081 Bit 0 \u2013 TWGCE: TWI General Call Recognition Enable Bit\nIf set, this bit enables the recognition of a General Call given over the 2-wire Serial Bus.\n24.9.6 TWAMR \u2013 TWI (Slave) Address Mask Register\n\u0081 Bits 7:1 \u2013 TWAM: TWI Address Mask\nThe TWAMR can be loaded with a 7-bit Slave A ddress mask. Each of the bits in T WAMR can\nmask (disable) the corresponding address bit in the T WI Address Register (T WAR). If the mask\nbit is set to one then the address match l ogic ignores the compare between the incoming\naddress bit and the corresponding bit in T WAR. Figure 24-22  shows the address match logic in\ndetail.\nFigure 24-22. TWI Address Match Logic, Block DiagramB i t 76543210\n(0xBA) TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE TWAR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 1 1 1 1 1 1 1 0\nB i t 76543210(0xBD)\nTWAM[6:0] \u2013 TWAMR\nRead/Write R/W R/W R/W R/W R/W R/W R/W RInitial Value 0 0 0 0 0 0 0 0\nAddress\nMatch\nAddress Bit Comparator 0\nAddress Bit Comparator 6..1TWAR0\nTWAMR0Address\nBit 0\n\n270\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 Res: Reserved Bit\nThis bit is reserved and will always read as zero.\n\n271\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25. AC \u2013 Analog Comparator\nThe Analog Comparator compares the input values on the positive pin AIN0 and negative pin\nAIN1. When the voltage on the positive pin AIN0 is higher than the voltage on the negative pin\nAIN1, the Analog Comparator output, ACO, is set. The comparator\u2019s output can be set to triggerthe Timer/Counter1 Input Capture function. In addition, the comparator can trigger a separate\ninterrupt, exclusive to the Analog Comparator. Th e user can select Interrupt triggering on com-\nparator output rise, fall or toggle. A block diagram of the comparator and its surrounding logic isshown in Figure 25-1 .\nThe Power Reduction ADC bit, PRADC, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be disabled by writing a logical zero to be able to use the ADC input MUX.\nFigure 25-1. Analog Comparator Block Diagram\n(2)\nNote: 1. See Table 25-1 .\n2. Refer to Figure 1-1 on page 2  and Table 13-5 on page 79  for Analog Comparator pin \nplacement.\n25.1 Analog Comparator  Multiplexed Input\nIt is possible to select any of the ADC15:0 pins  to replace the negative input to the Analog Com-\nparator. The ADC multiplexer is used to select this input, and consequently, the ADC must be\nswitched off to utilize this feature. If the Analog Comparator Multiplexer Enable bit (ACME in\nADCSRB) is set and the ADC is switched off (A DEN in ADCSRA is zero), MUX5 and MUX2:0 in\nADMUX select the input pin to replace the negati ve input to the Analog Comparator, as shown in\nTable 25-1 . If ACME is cleared or ADEN is set, AIN1  is applied to the negative input to the Ana-\nlog Comparator.ACBGBANDGAP\nREFERENCE\nADC MULTIPLEXER\nOUTPUTACME\nADEN\n(1)\nTable 25-1. Analog Comparator Mulitiplexed Input\nACME ADEN MUX5 MUX2:0 Analog Comparator Negative Input\n0 x x xxx AIN1\n1 1 x xxx AIN11 0 0 000 ADC0\n1 0 0 001 ADC1\n1 0 0 010 ADC21 0 0 011 ADC3\n\n272\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25.2 Register Description\n25.2.1 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 6 \u2013 ACME: Analog Comparator Multiplexer Enable\nWhen this bit is written logic one and the ADC is  switched off (ADEN in ADCSRA is zero), the\nADC multiplexer selects the negative input to the Analog Comparator. When this bit is written\nlogic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detailed\ndescription of this bit, see \u201cAnalog Comparator Multiplexed Input\u201d on page 271 .\n25.2.2 ACSR \u2013 Analog Comparator Control and Status Register\n\u0081 Bit 7 \u2013 ACD: Analog Comparator Disable\nWhen this bit is written logic one , the power to the Analog Comparator is switched off. This bit\ncan be set at any time to tu rn off the Analog Com parator. This will reduce power consumption in\nActive and Idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be\ndisabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is\nchanged.1 0 0 100 ADC4\n1 0 0 101 ADC5\n1 0 0 110 ADC6\n1 0 0 111 ADC7\n1 0 1 000 ADC8\n1 0 1 001 ADC91 0 1 010 ADC10\n1 0 1 011 ADC11\n1 0 1 100 ADC121 0 1 101 ADC13\n1 0 1 110 ADC14\n1 0 1 111 ADC15Table 25-1. Analog Comparator Mulitiplexed Input (Continued)\nACME ADEN MUX5 MUX2:0 Analog Comparator Negative Input\nB i t 76543210\n(0x7B) \u2013 ACME \u2013 \u2013 MUX5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 765432100x30 (0x50) ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 ACSR\nRead/Write R/ W R/W RR / W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00 N / A 00000\n\n273\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ACBG: Analog Comparator Bandgap Select\nWhen this bit is set, a fixed bandgap reference volt age replaces the positive input to the Analog\nComparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Compar-\nator. When the bandgap reference is used as input to the Analog Comparator, it will take a\ncertain time for the voltage to stabilize. If not stabilized, the first conversion may give a wrong\nvalue. See \u201cInternal Voltage Reference\u201d on page 62.\n\u0081 Bit 5 \u2013 ACO: Analog Comparator Output\nThe output of the Analog Comparator is synchronized and then directly connected to ACO. The\nsynchronization introduces a delay of 1 - 2 clock cycles.\n\u0081 Bit 4 \u2013 ACI: Analog Comparator Interrupt Flag\nThis bit is set by hardware when a comparator output event triggers the interrupt mode defined\nby ACIS1 and ACIS0. The Analog Comparator interr upt routine is executed if the ACIE bit is set\nand the I-bit in SREG is set. ACI is cleared by  hardware when executing the corresponding inter-\nrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.\n\u0081 Bit 3 \u2013 ACIE: Analog Comparator Interrupt Enable\nWhen the ACIE bit is written logic one and the I-bit in the Status Register is set, the Analog Com-\nparator interrupt is activated. When written logic zero, the interrupt is disabled.\n\u0081 Bit 2 \u2013 ACIC: Analog Comparator Input Capture Enable\nWhen written logic one, this bit enables the input capture function in Timer/Counter1 to be trig-\ngered by the Analog Comparator. The comparator output is in this case directly connected to the\ninput capture front-end logic, making the compar ator utilize the noise canceler and edge select\nfeatures of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection\nbetween the Analog Comparator and the input capture function exists. To make the comparator\ntrigger the Timer/Counter1 Input Capture interrupt, the ICIE1 bit in the Timer Interrupt Mask\nRegister (TIMSK1) must be set.\n\u0081 Bits 1, 0 \u2013 ACIS1, ACIS0: Analog Comparator Interrupt Mode Select\nThese bits determine which comparator events that trigger the Analog Comparator interrupt. The\ndifferent settings are shown in Table 25-2 .\nWhen changing the ACIS1/ACIS0 bits, the Analog Comparator Interrupt must be disabled by\nclearing its Interrupt Enable bit in the ACSR Register. Otherwise an interrupt can occur when thebits are changed.Table 25-2. ACIS1/ACIS0 Settings\nACIS1 ACIS0 Interrupt Mode\n0 0 Comparator Interrupt on Output Toggle\n01 R e s e r v e d1 0 Comparator Interrupt on Falling Output Edge\n1 1 Comparator Interrupt on Rising Output Edge\n\n274\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n25.2.3 DIDR1 \u2013 Digital In put Disable Register 1\n\u0081 Bit 1, 0 \u2013 AIN1D, AIN0D: AI N1, AIN0 Digita l Input Disable\nWhen this bit is written logic one, the digital input buffer on the AIN1/0 pin is disabled. The corre-\nsponding PIN Register bit will always re ad as zero when this bit is set. When an analog signal is\napplied to the AIN1/0 pin and the digital input from this pin is not needed, this bit should be writ-\nten logic one to reduce power consumption in the digital input buffer.B i t 76543210\n(0x7F) \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 AIN1D AIN0D DIDR1\nRead/Wr i t e RRRRRR R / W R/W\nI n i t i a l  V a l u e 00000000\n\n275\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26. ADC \u2013 Analog to Digital Converter\n26.1 Features\n\u008110-bit Resolution\n\u00811 LSB Integral Non-linearity\n\u0081\u00b12 LSB Absolute Accuracy\n\u008113\u00b5s - 260\u00b5s Conversion Time\n\u0081Up to 76.9kSPS (Up to 15kSP S at Maximum Resolution)\n\u008116 Multiplexed Single Ended Input Channels\n\u008114 Differential input channels\n\u00814 Differential Input Ch annels with Optional Gain of 10\u00d7 and 200\u00d7\n\u0081Optional Left Adjustment for ADC Result Readout\n\u00810V - VCC ADC Input Voltage Range\n\u00812.7V - VCC Differential ADC Voltage Range\n\u0081Selectable 2.56V or 1.1V ADC Reference Voltage\n\u0081Free Running or Single Conversion Mode\n\u0081Interrupt on ADC Conversion Complete\n\u0081Sleep Mode No ise Canceler\nThe ATmega640/1280/1281/2560/2561 features a 10-bit successive approximation ADC. The\nADC is connected to an 8/16-channel Analog Mult iplexer which allows eight/sixteen single-\nended voltage inputs constructed from the pins of Port F and Port K. The single-ended voltage\ninputs refer to 0V (GND).\nThe device also supports 16/32 differential voltage input combinations. Four of the differential\ninputs (ADC1 & ADC0, ADC3 & ADC2, ADC9 & ADC8 and ADC11 & ADC10) are equipped with\na programmable gain stage, providing amplificati on steps of 0 dB (1\u00d7), 20 dB (10\u00d7) or 46 dB\n(200\u00d7) on the differential input voltage before the ADC conversion. The 16 channels are split intwo sections of 8 channels where in each section seven differential analog input channels share\na common negative terminal (A DC1/ADC9), while any other ADC input in that section can be\nselected as the positive input terminal. If 1\u00d7  or 10\u00d7 gain is used, 8 bit resolution can be\nexpected. If 200\u00d7 gain is used, 7 bit resolution can be expected.\nThe ADC contains a Sample and Hold circuit whic h ensures that the input voltage to the ADC is\nheld at a constant level during conversion. A block diagram of the ADC is shown in Figure 26-1\non page 276 .\nThe ADC has a separate analog supply voltage pi n, AVCC. AVCC must not differ more than\n\u00b10.3V from V\nCC. See the paragraph \u201cADC Noise Canceler\u201d on page 283  on how to connect this\npin.\nInternal reference voltages of nominally 1.1V, 2.56V or AVCC are provided On-chip. The voltage\nreference may be externally decoupled at the AREF pin by a capacitor for better noise\nperformance.\nThe Power Reduction ADC bit, PRADC, in \u201cPRR0 \u2013 Power Reduction Register 0\u201d on page 56\nmust be disabled by writing a logical zero to enable the ADC.\n\n276\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-1. Analog to Digital Converter Block Schematic\n26.2 Operation\nThe ADC converts an analog input voltage to a 10-bit digital value through successive approxi-\nmation. The minimum value represents GND and the maximum value represents the voltage on\nthe AREF pin minus 1 LSB. Optionally, AVCC or an internal 1.1V or 2.56V reference voltage\nmay be connected to the AREF pin by writing to  the REFSn bits in the ADMUX Register. The\ninternal voltage reference may thus be decoupled by an external capacitor at the AREF pin to\nimprove noise immunity.\nThe analog input channel is selected by writing to the MUX bits in ADMUX and ADCSRB. Any of\nthe ADC input pins, as well as GND and a fixed bandgap voltage reference, can be selected as\nsingle ended inputs to the ADC. A selection of ADC input pins can be selected as positive and\nnegative inputs to the differential amplifier.ADC CONVERSION\nCOMPLETE IRQ\n8-BIT DATABUS\n15 0 ADIE\nADFR ADSC ADENADIFADIF\nMUX[4:0]ADPS[2:0]\nSAMPLE & HOLD\nCOMPARATORINTERNAL\nREFERENCE\n(1.1V/2.56V)AVCCREFS[1:0]ADLAR\nCHANNEL SELECTIONADC[9:0]\nADC\nMULTIPLEXER\nOUTPUTGAIN\nAMPLIFIE RAREF\nBANDGAP (1.1V)\nREFERENCE\nGNDCONVERSION LOGICADC CTRL & STATUS\nREGISTER B (ADCSRB)ADC CTRL & STATUS\nREGISTER A (ADCSRA)\nPRESCALERADC MULTIPLEXER\nSELECT (ADMUX)\nMUX DECODER\nDIFF / GAIN SELECTADC DATA REGISTER\n(ADCH/ADCL)\nADC[2:0]TRIGGER\nSELECT\nSTARTINTERRUPT\nFLAGS\nADTS[2:0]\n+-\nADC[15:0]+- 10-bit DACMUX[5]\nADC[10:8]\n\n277\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIf differential channels are selected, the voltage difference between the selected input channel\npair then becomes the analog input to the ADC. If single ended channels are used, the amplifier\nis bypassed altogether.\nThe ADC is enabled by setting the ADC Enable bit, ADEN in ADCSRA. Voltage reference and\ninput channel selections will not go into effect  until ADEN is set. The ADC does not consume\npower when ADEN is cleared, so it is recommended to switch off the ADC before entering power\nsaving sleep modes.\nThe ADC generates a 10-bit result which is pr esented in the ADC Data Registers, ADCH and\nADCL. By default, the result is presented right adjusted, but can optionally be presented left\nadjusted by setting the ADLAR bit in ADMUX.\nIf the result is left adjusted and no more than 8-bit precision is required, it is sufficient to read\nADCH. Otherwise, ADCL must be read first, then ADCH, to ensure that the content of the Data\nRegisters belongs to the same conversion. Once ADCL is read, ADC access to Data Registersis blocked. This means that if ADCL has been read, and a conversion completes before ADCH is\nread, neither register is updated and the result from the conversion is lost. When ADCH is read,\nADC access to the ADCH and AD CL Registers is re-enabled.\nThe ADC has its own interrupt which can be triggered when a conversion completes. When ADC\naccess to the Data Registers is prohibited between reading of ADCH and ADCL, the interrupt\nwill trigger even if the result is lost.\n26.3 Starting a Conversion\nA single conversion is started by writing a l ogical one to the ADC Start Conversion bit, ADSC.\nThis bit stays high as long as the conversi on is in progress and will be cleared by hardware\nwhen the conversion is completed. If a different  data channel is selected while a conversion is in\nprogress, the ADC will finish the current conv ersion before performing  the channel change.\nAlternatively, a conversion can be triggered automatically by various sources. Auto Triggering is\nenabled by setting the ADC Auto Trigger Enable bi t, ADATE in ADCSRA. The trigger source is\nselected by setting the ADC Trigger Select bits, ADTS in ADCSRB (see description of the ADTS\nbits for a list of the trigger sources). When a positive edge occurs on the selected trigger signal,\nthe ADC prescaler is reset and a conversion is st arted. This provides a method of starting con-\nversions at fixed intervals. If the trigger signal still is set when the conversion completes, a new\nconversion will not be star ted. If another positive edge occurs  on the trigger si gnal during con-\nversion, the edge will be ignored. Note that an Interrupt Flag will be set even if the specific\ninterrupt is disabled or the Global Interrupt Enable bit in SREG is cleared. A conversion can thusbe triggered without causing an interrupt. However, the Interrupt Flag must be cleared in order to\ntrigger a new conversion at the next interrupt event.\n\n278\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-2. ADC Auto Trigger Logic\nUsing the ADC Interrupt Flag as a trigger source makes the ADC start a new conversion as soon\nas the ongoing conversion has finished. The ADC then operates in Free Running mode, con-stantly sampling and updating the ADC Data Register. The first conversion must be started by\nwriting a logical one to the ADSC bit in ADCS RA. In this mode the ADC will perform successive\nconversions independently of whether the A DC Interrupt Flag, ADIF is cleared or not.\nIf Auto Triggering is enabled, single conversi ons can be started by writing ADSC in ADCSRA to\none. ADSC can also be used to determine if a conversion is in progress. The ADSC bit will be\nread as one during a conversion, independently of how the conversion was started.\n26.4 Prescaling and Conversion Timing\nFigure 26-3. ADC Prescaler\nBy default, the successive approximation circ uitry requires an input clock frequency between\n50kHz and 200kHz. If a lower resolution than 10 bits is needed, the input clock frequency to the\nADC can be as high as 1000kHz to get a higher sample rate.\nThe ADC module contains a prescaler, which generates an acceptable ADC clock frequency\nfrom any CPU frequency above 100kHz. The prescaling is set by the ADPS bits in ADCSRA.ADSCADIF\nSOURCE 1\nSOURCE nADTS[2:0]\nCONVER SION\nLOGICPRESCALER\nSTART CLKADC\n.\n.\n..\nEDGE\nDETECTORADATE\n7-BIT ADC PRE SCALER\nADC CLOCK SOURCECK\nADPS0\nADPS1\nADPS2CK/128\nCK/2CK/4CK/8\nCK/16CK/32CK/64ResetADEN\nSTART\n\n279\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe prescaler starts counting from the moment the ADC is switched on by setting the ADEN bit\nin ADCSRA. The prescaler keeps running for as lo ng as the ADEN bit is set, and is continuously\nreset when ADEN is low.\nWhen initiating a single ended conversion by setti ng the ADSC bit in ADCSRA, the conversion\nstarts at the following rising edge of the ADC clock cycle.\nA normal conversion takes 13 ADC clock cycles. The first conversion after the ADC is switched\non (ADEN in ADCSRA is set) takes 25 ADC clock cycles in order to initialize the analog circuitry.\nWhen the bandgap reference voltage is used as input to the ADC, it will take a certain time for\nthe voltage to stabilize. If not stabilized, the first value read after the first conversion may be\nwrong.\nThe actual sample-and-hold takes place 1.5 ADC clock cycles after the start of a normal conver-\nsion and 13.5 ADC clock cycles afte r the start of an first conversion. When a conversion is\ncomplete, the result is written to the ADC Data Re gisters, and ADIF is set. In Single Conversion\nmode, ADSC is cleared simultaneously. The software may then set ADSC again, and a new\nconversion will be init iated on the first rising ADC clock edge.\nWhen Auto Triggering is used, the prescaler is reset when the trigger event occurs. This assures\na fixed delay from the trigger event to the start of conversion. In this mode, the sample-and-hold\ntakes place two ADC clock cycles after the rising edge on the trigger source signal. Three addi-\ntional CPU clock cycles are used for synchronization logic.\nIn Free Running mode, a new conversion will be  started immediately after the conversion com-\npletes, while ADSC remains high. For a summary of conversion times, see Table 26-1 on page\n281.\nFigure 26-4. ADC Timing Diagram, First Conver sion (Single Conversion Mode)\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nSample & HoldADIF\nADCHADCLCycle Number\nADEN1 21 2 13 14 15 16 17 18 19 20 21 22 23 24 25 1 2First ConversionNext\nConversion\n3\nMUX and REF S\nUpdateMUX and REF S\nUpdateConversion\nComplete\n\n280\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-5. ADC Timing Diagram, Single Conversion\nFigure 26-6. ADC Timing Diagram, Auto Triggered Conversion\nFigure 26-7. ADC Timing Diagram, Free Running Conversion1 2 3 4 5 6 7 8 9 10 11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nADIFADCHADCLCycle Number 12One Conversion Next Conversion\n3\nSample & Hold\nMUX and REF S\nUpdateConversion\nCompleteMUX and REF S\nUpdate\n1 2 3 4 5 6 7 8 9 10 11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nTrigger\nSource\nADIF\nADCHADCLCycle Number 12One Conversion Next Conversion\nConversion\nCompletePrescaler ResetADATE\nPrescalerReset Sample &\nHold\nMUX and REF S \nUpdate\n11 12 13\nSign and M SB of Result\nLSB of ResultADC Clock\nADSC\nADIFADCHADCLCycle Number12One Conversion Next Conversion\n34\nConversion\nCompleteSample & Hold\nMUX and REF S\nUpdate\n\n281\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.4.1 Differential Channels\nWhen using differential channels, certain aspe cts of the conversion need to be taken into\nconsideration.\nDifferential conversions are synchronized to the internal clock CKADC2 equal to half the ADC\nclock. This synchronization is done automatically by the ADC interface in such a way that the\nsample-and-hold occurs at  a specific phase of CKADC2. A conversion initiated by the user (that is,\nall single conversions, and the first free running conversion) when CKADC2 is low will take the\nsame amount of time as a single ended conversion (13 ADC clock cycles from the next pres-caled clock cycle). A conversion initiated by the user when CK\nADC2 is high will take 14 ADC clock\ncycles due to the synchronization mechanism. In Free Running mode, a new conversion is initi-\nated immediately after the previous conversion completes, and since CKADC2 is high at this time,\nall automatically started (that is, all but the first) Free Running conversions will take 14 ADC\nclock cycles.\nIf differential channels are used and conversions ar e started by Auto Triggering, the ADC must\nbe switched off between conversions. When Auto Triggering is used, the ADC prescaler is reset\nbefore the conversion is started. Since the stage is dependent of a stable ADC clock prior to the\nconversion, this conversion w ill not be valid. By disabling a nd then re-enabling the ADC between\neach conversion (writing ADEN in ADCSRA to \u201c0\u201d then to \u201c1\u201d), only extended conversions are\nperformed. The result from the extended conversions will be valid. See \u201cPrescaling and Conver-\nsion Timing\u201d on page 278  for timing details.Table 26-1. ADC Conversion Time\nConditionSample & Hold (Cycles from \nStart of Conversion) Conversion Time (Cycles)\nFirst conversion 13.5 25\nNormal conversions, single ended 1.5 13\nAuto Triggered conversions 2 13.5\nNormal conversions, differential 1.5/2.5 13/14\n\n282\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.5 Changing Channel or  Reference Selection\nThe MUXn and REFS1:0 bits in the ADMUX Register are single buffered through a temporary\nregister to which the CPU has random access. This ensures that the channels and reference\nselection only takes place at a safe point dur ing the conversion. The channel and reference\nselection is continuously updated until a conversion is started. Once the conversion starts, the\nchannel and reference selection is locked to ensure a sufficient sampling time for the ADC. Con-\ntinuous updating resumes in the last ADC clock cycle before the conversion completes (ADIF inADCSRA is set). Note that the conversion star ts on the following rising  ADC clock edge after\nADSC is written. The user is thus advised not to write new channel or reference selection values\nto ADMUX until one ADC clock cycle after ADSC is written.\nIf Auto Triggering is used, the exact time of t he triggering event can be indeterministic. Special\ncare must be taken when updating the ADMUX Register, in order to control which conversion\nwill be affected by the new settings.\nIf both ADATE and ADEN is written to one, an interrupt event can occur at any time. If the\nADMUX Register is changed in this period, the user cannot tell if the next conversion is based\non the old or the new settings. ADMUX can be safely updated in the following ways:\n1.When ADATE or ADEN is cleared.\n2. During conversion, minimum one ADC clock cycle after the trigger event.3. After a conversion, before the Interrupt Flag used as trigger source is cleared.\nWhen updating ADMUX in one of these conditions, t he new settings will affect the next ADC\nconversion.\nSpecial care should be taken when changing differential channels. Once a differential channel\nhas been selected, the  stage may take as much as 125\u00b5s to stabilize to the new value. Thus\nconversions should not be started within the first 125\u00b5s after selecting a new differential chan-\nnel. Alternatively, conversion results obt ained within this period should be discarded.\nThe same settling time should be observed for th e first differential conversion after changing\nADC reference (by changing the REFS1:0 bits in ADMUX).\n26.5.1 ADC Input Channels\nWhen changing channel selections, the user should observe the following guidelines to ensure\nthat the correct channel is selected:\nIn Single Conversion mode, always select the channel before starting the conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the conversion to complete before changing the channel selection.\nIn Free Running mode, always select the channel before starting the first conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the first conversion to complete, and then change the channel\nselection. Since the next conver sion has already started automati cally, the next result will reflect\nthe previous channel selection.  Subsequent conversions will refl ect the new channel selection.\nWhen switching to a differential gain channel, the first conversion result may have a poor accu-\nracy due to the required settling time for the automatic offset cancellation circuitry. The usershould preferably disregard the first conversion result.\n\n283\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.5.2 ADC Voltage Reference\nThe reference voltage for the ADC (VREF) indicates the conversion range for the ADC. Single\nended channels that exceed VREF will result in code s close to 0x3FF. VREF can be selected as\neither AVCC, internal 1.1V reference, internal 2.56V reference or external AREF pin.\nAVCC is connected to the ADC through a passive switch. The internal 1.1V reference is gener-\nated from the internal bandgap reference (VBG) through an internal amplifier. In either case, theexternal AREF pin is directly connected to the ADC, and the reference voltage can be made\nmore immune to noise by connecting a capacitor between the AREF pin and ground. V\nREF can\nalso be measured at the AREF pin with a high impedant voltmeter. Note that VREF is a high\nimpedant source, and only a capacitive load shoul d be connected in a system. The Internal\n2.56V reference is generated from the 1.1V reference.\nIf the user has a fixed voltage source connected to the AREF pin, the user may not use the other\nreference voltage options in the ap plication, as they will be shorte d to the external voltage. If no\nexternal voltage is applied to the AREF pin, the user may switch between AVCC, 1.1V and\n2.56V as reference selection. The first ADC c onversion result after switching reference voltage\nsource may be inaccurate, and the user is advised to discard this result.\nIf differential channels are used, the selected reference should not be closer to AVCC than\nindicated in \u201cADC Characteristics \u2013 Preliminary Data\u201d on page 377 .\n26.6 ADC Noise Canceler\nThe ADC features a noise canceler that enables conversion during sleep mode to reduce noise\ninduced from the CPU core and other I/O peripherals. The noise canceler can be used with ADC\nNoise Reduction and Idle mode. To make use of this feature, the following procedure should beused:\n1. Make sure that the ADC is enabled and is not busy converting. Single Conversion \nmode must be selected and the ADC conversion complete interrupt must be enabled.\n2. Enter ADC Noise Reduction mode (or Id le mode). The ADC will start a conversion \nonce the CPU has been halted.\n3. If no other interrupts occur before the ADC conversion completes, the ADC interrupt \nwill wake up the CPU and execute the ADC Co nversion Complete interrupt routine. If \nanother interrupt wakes up the CPU before the ADC conversion is complete, that interrupt will be executed, and an ADC Conv ersion Complete interrupt request will be \ngenerated when the ADC conversion complete s. The CPU will remain in active mode \nuntil a new sleep command is executed.\nNote that the ADC will not be automatically turned off when entering other sleep modes than Idle\nmode and ADC Noise Reduction mode. The user is advised to write zero to ADEN before enter-\ning such sleep modes to avoid excessive power consumption.\nIf the ADC is enabled in such sleep modes and the user wants to perform differential conver-\nsions, the user is advised to switch the ADC off and on after waking up from sleep to prompt an\nextended conversion to get a valid result.\n\n284\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.6.1 Analog Input Circuitry\nThe analog input circuitry for single ended channels is illustrated in Figure 26-8.  An analog\nsource applied to ADCn is subjected to the pin capacitance and input leakage of that pin, regard-\nless of whether that channel is selected as input for the ADC. When the channel is selected, the\nsource must drive the S/H capacitor through the series resistance (combined resistance in theinput path).\nThe ADC is optimized for analog signals with an output impedance of approximately 10k \u03a9 or\nless. If such a source is used, the sampling time will be negligible. If a source with higher imped-ance is used, the sampling time  will depend on how long time the source nee ds to charge the\nS/H capacitor, which can vary widely. The user is recommended to only use low impedant\nsources with slowly varying signals, since this mi nimizes the required charge transfer to the S/H\ncapacitor.\nSignal components higher th an the Nyquist frequency (f\nADC/2) should not be present for either\nkind of channels, to avoid distortion from unpredictable signal convolution. The user is advisedto remove high frequency components with a low-pass filter before applying the signals as\ninputs to the ADC.\nFigure 26-8. Analog Input Circuitry\n26.6.2 Analog Noise Canceling Techniques\nDigital circuitry inside and outside the device ge nerates EMI which might affect the accuracy of\nanalog measurements. If conversion accuracy is critical, the noise level can be reduced by\napplying the following techniques:\n1. Keep analog signal paths as short as possible. Make sure analog tracks run over the \nground plane, and keep them well away from high-speed switching digital tracks.\n2. The AVCC pin on the device should be connected to the digital V\nCC supply voltage \nvia an LC network as shown in Figure 26-9 on page 285 .\n3. Use the ADC noise canceler function to reduce induced noise from the CPU.\n4. If any ADC port pins are used as digital outputs, it is essential that these do not \nswitch while a conversion is in progress.ADCnIIH\n1..100 k \u03a9\nCS/H= 14 pF\nVCC/2IIL\n\n285\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 26-9. ADC Power Connections, ATmega1281/2561.\nFigure 26-10. ADC Power Connections, ATmega640/1280/2560VCC\nGND\n100nF 100nF\n      Ground Plane(ADC0) PF0(ADC7) PF7\n(ADC1) PF1(ADC2) PF2(ADC3) PF3(ADC4) PF4(ADC5) PF5(ADC6) PF6\nAREF\nGND\nAVCC5253\n54\n55\n56\n57\n58\n59\n60\n6161\n6262\n6363\n6464\n151\nPG5PA0\n10\u03bc\u0397\n100nF\n      Gro und Pl ane100\n(OC0B) PG510\u03bc\u039779\n80818283\n84858687888990919293\n949596979899PJ7\nVCC\nGND\n(ADC15/PCINT2 3) PK7\n(ADC14/PCINT22) PK6(ADC1 3/PCINT21) PK5\n(ADC12/PCINT20) PK4(ADC11/PCINT19) PK 3\n(ADC10/PCINT18) PK2\n(ADC9/PCINT17) PK1(ADC8/PCINT16) PK0\n(ADC7/TDI) PF7\n(ADC6/TDO) PF6(ADC5/TMS) PF5\n(ADC4/TCK) PF4\n(ADC 3) PF3\n(ADC2) PF2(ADC1) PF1(ADC0) PF0\nAREF\nGND\nAVCC\n\n286\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.6.3 Offset Compensation Schemes\nThe stage has a built-in offset cancellation circuitr y that nulls the offset of differential measure-\nments as much as possible. The remaining offset in the analog path can be measured directly byselecting the same channel for both differential inputs. This offset residue can be then sub-\ntracted in software from the measurement results. Using this kind of software based offset\ncorrection, offset on any channel can be reduced below one LSB.\n26.6.4 ADC Accuracy Definitions\nAn n-bit single-ended ADC converts a voltage linearly between GND and V\nREF in 2n steps\n(LSBs). The lowest code is read as 0, and the highest code is read as 2n-1.\nSeveral parameters describe the deviation from the ideal behavior:\n\u0081 Offset: The deviation of the first transition (0x000 to 0x001) compared to the ideal transition \n(at 0.5 LSB). Ideal value: 0 LSB.\nFigure 26-11. Offset Error\n\u0081 Gain Error: After adjusting for offset, the Gain Error is found as the deviation of the last \ntransition (0x3FE to 0x3FF) compared to the ideal transition (at 1.5 LSB below maximum). Ideal value: 0 LSB.\nFigure 26-12. Gain ErrorOutput Code\nVREF Input VoltageIdeal ADC\nActual ADC\nOffset\nError\nOutput Code\nVREF Input VoltageIdeal ADC\nActual ADCGain\nError\n\n287\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Integral Non-linearity (INL): Afte r adjusting for offset and gain error, the INL is the maximum \ndeviation of an actual transition compared to an ideal transition for any code. Ideal value: 0 LSB.\nFigure 26-13. Integral Non-linearity (INL)\n\u0081 Differential Non-linearity (DNL ): The maximum deviation of the actual code width (the \ninterval between two adjacent transitions) from the ideal code width (1 LSB). Ideal value: 0 LSB.\nFigure 26-14. Differential Non-linearity (DNL)\n\u0081 Quantization Error: Due to the quantization of the input voltage into a finite number of codes, \na range of input voltages (1 LSB wide) will code to the same  value. Always \u00b10.5 LSB.\n\u0081 Absolute Accuracy: The maximum deviation of an  actual (unadjusted) transition compared \nto an ideal transition for any code. This is the compound effect of offset, gain error, differential error, non-linearity, and quantization error. Ideal value: \u00b10.5 LSB.Output Code\nVREFInput VoltageIdeal ADC\nActual ADCINL\nOutput Code\n0x3FF\n0x000\n0 VREFInput VoltageDNL1 LSB\n\n288\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.7 ADC Conversion Result\nAfter the conversion is complete (ADIF is high ), the conversion result can be found in the ADC\nResult Registers (ADCL, ADCH).\nFor single ended conversion, the result is\nwhere VIN is the voltage on the selected input pin and VREF the selected voltage reference (see\nTable 26-3 on page 289  and Table 26-4 on page 290 ). 0x000 represents analog ground, and\n0x3FF represents the selected reference voltage minus one LSB.\nIf differential channels are used, the result is\nwhere VPOS is the voltage on the positive input pin, VNEG the voltage on the negative input pin,\nand VREF the selected voltage reference. The result is presented in two\u2019s complement form, from\n0x200 (-512d) through 0x1FF (+511d). Note that if the user wants to perform a quick polarity\ncheck of the result, it is sufficient to read the MSB of the result (ADC9 in ADCH). If the bit is one,\nthe result is negative, and if this bit is zero, the result is positive. Figure 26-15  shows the decod-\ning of the differential input range.\nTable 26-2 on page 289  shows the resulting output codes if the differential input channel pair\n(ADCn - ADCm) is selected with a gain of GAIN and a reference voltage of VREF.\nFigure 26-15. Differential Measurement RangeADCVIN1024\u22c5\nVREF--------------------------=\nADCVPOSVNEG\u2013 () 512\u22c5\nVREF---------------------------------------------------- - =\n0Output Code\n0x1FF\n0x000\nVREFDifferential Input\nVoltage (Volts)0x3FF\n0x200- VREF\n\n289\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nExample:\nADMUX = 0xFB (ADC3 - ADC2, 10\u00d7 gain, 2.56V reference, left adjusted result).Voltage on ADC3 is 300mV, voltage on ADC2 is 500mV.\nADCR = 512 \u00d7 10 \u00d7 (300 - 500) / 2560 = -400 = 0x270.\nADCL will thus read 0x00,  and ADCH will read 0x9C. Writing zero to ADLAR right adjusts the\nresult: ADCL = 0x70, ADCH = 0x02.\n26.8 Register Description\n26.8.1 ADMUX \u2013 ADC Multiplexer Selection Register\n\u0081 Bit 7:6 \u2013 REFS1:0: Reference Selection Bits\nThese bits select the voltage reference for the ADC, as shown in Table 26-3 . If these bits are\nchanged during a conversion, the change will not go in effect until this conversion is complete(ADIF in ADCSRA is set). The internal voltage reference options may not be used if an external\nreference voltage is being applied to the AREF pin.\nNote: 1. If 10x or 200x gain is selected, only 2.56V should be used as Internal Voltage Reference. For \ndifferential conversion, only 1.1V cannot  be used as internal voltage reference.Table 26-2. Correlation Between Input Voltage and Output Codes\nVADCn Read Code Corresponding Decimal Value\n VADCm + VREF / GAIN 0x1FF 511\nVADCm + 0.999 VREF / GAIN 0x1FF 511\nVADCm + 0.998 VREF / GAIN 0x1FE 510\n... ... ...\nVADCm + 0.001 VREF / GAIN 0x001 1\nVADCm 0x000 0\nVADCm - 0.001 VREF / GAIN 0x3FF -1\n... ... ...V\nADCm - 0.999 VREF / GAIN 0x201 -511\nVADCm - VREF / GAIN 0x200 -512\nB i t 76543210\n(0x7C) REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 ADMUX\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 26-3. Voltage Reference Selections for ADC\nREFS1 REFS0 Voltage Reference Selection(1)\n0 0 AREF , Internal VREF turned off\n0 1 AVCC with external capacitor at AREF pin\n1 0 Internal 1.1V Voltage Reference with external capacitor at AREF pin\n1 1 Internal 2.56V Voltage Reference with external capacitor at AREF pin\n\n290\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 5 \u2013 ADLAR: ADC Left Adjust Result\nThe ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register.\nWrite one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing the\nADLAR bit will affect t he ADC Data Register immediately,  regardless of any ongoing conver-\nsions. For a complete description of this bit, see \u201cADCL and ADCH \u2013 The ADC Data Register\u201d on\npage 294 .\n\u0081 Bits 4:0 \u2013 MUX4:0: Analog Channel and Gain Selection Bits\nThe value of these bits selects which combination of analog inputs are connected to the ADC.\nSee Table 26-4  for details.  If these bits are changed during a conversion, the change will not go\nin effect until this conversion is complete (ADIF in ADCSRA is set).\n26.8.2 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 3 \u2013 MUX5: Analog Channel and Gain Selection Bit\nThis bit is used together with MUX4:0 in ADMU X to select which combin ation in of analog inputs\nare connected to the ADC. See Table 26-4  for details. If this bit is changed during a conversion,\nthe change will not go in  effect until this co nversion is complete.\nThis bit is not valid for ATmega1281/2561.B i t 76543210\n(0x7B) \u2013 ACME \u2013 \u2013M U X 5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\nTable 26-4. Input Channel Selections\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\n000000 ADC0\nN/A000001 ADC1\n000010 ADC2000011 ADC3\n000100 ADC4\n000101 ADC5000110 ADC6\n000111 ADC7\n\n291\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n001000(1)\nN/AADC0 ADC0 10\u00d7\n001001(1)ADC1 ADC0 10\u00d7\n001010(1)ADC0 ADC0 200\u00d7\n001011(1)ADC1 ADC0 200\u00d7\n001100(1)ADC2 ADC2 10\u00d7\n001101(1)ADC3 ADC2 10\u00d7\n001110(1)ADC2 ADC2 200\u00d7\n001111(1)ADC3 ADC2 200\u00d7\n010000 ADC0 ADC1 1\u00d7\n010001 ADC1 ADC1 1\u00d7\n010010 ADC2 ADC1 1\u00d7010011 ADC3 ADC1 1\u00d7\n010100 ADC4 ADC1 1\u00d7\n010101 ADC5 ADC1 1\u00d7010110 ADC6 ADC1 1\u00d7\n010111 ADC7 ADC1 1\u00d7\n011000 ADC0 ADC2 1\u00d7011001 ADC1 ADC2 1\u00d7\n011010\nN/AADC2 ADC2 1\u00d7\n011011 ADC3 ADC2 1\u00d7011100 ADC4 ADC2 1\u00d7\n011101 ADC5 ADC2 1\u00d7\n011110 1.1V (V\nBG)\nN/A\n011111 0V (GND)\n100000 ADC8\nN/A100001 ADC9\n100010 ADC10\n100011 ADC11\n100100 ADC12100101 ADC13\n100110 ADC14\n100111 ADC15Table 26-4. Input Channel Selections (Continued)\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\n\n292\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. To reach the given accuracy, 10\u00d7 or 200\u00d7 Gain should not be used for operating voltage below\n2.7V.\n26.8.3 ADCSRA \u2013 ADC Control and Status Register A\n\u0081 Bit 7 \u2013 ADEN: ADC Enable\nWriting this bit to one enables the ADC. By writing it to zero, the ADC is turned off. Turning the\nADC off while a conversion is in prog ress, will terminate this conversion.101000(1)\nN/AADC8 ADC8 10\u00d7\n101001(1)ADC9 ADC8 10\u00d7\n101010(1)ADC8 ADC8 200\u00d7\n101011(1)ADC9 ADC8 200\u00d7\n101100(1)ADC10 ADC10 10\u00d7\n101101(1)ADC11 ADC10 10\u00d7\n101110(1)ADC10 ADC10 200\u00d7\n101111(1)ADC11 ADC10 200\u00d7\n110000 ADC8 ADC9 1\u00d7\n110001 ADC9 ADC9 1\u00d7\n110010 ADC10 ADC9 1\u00d7110011 ADC11 ADC9 1\u00d7\n110100 ADC12 ADC9 1\u00d7\n110101 ADC13 ADC9 1\u00d7110110 ADC14 ADC9 1\u00d7\n110111 ADC15 ADC9 1\u00d7\n111000 ADC8 ADC10 1\u00d7111001 ADC9 ADC10 1\u00d7\n111010 ADC10 ADC10 1\u00d7\n111011 ADC11 ADC10 1\u00d7111100 ADC12 ADC10 1\u00d7\n111101\nN/A ADC13 ADC10 1\u00d7\n111110 Reserved N/A\n111111 Reserved N/ATable 26-4. Input Channel Selections (Continued)\nMUX5:0Single Ended \nInputPositive Differential \nInputNegative Differential \nInput Gain\nB i t 76543210\n(0x7A) ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 ADCSRA\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n293\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 ADSC: ADC Start Conversion\nIn Single Conversion mode, write this bit to one to start each conversion. In Free Running mode,\nwrite this bit to one to start the first conversion. The first conversion after ADSC has been written\nafter the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled,\nwill take 25 ADC clock cycles instead of the norma l 13. This first conversi on performs initializa-\ntion of the ADC.\nADSC will read as one as long as  a conversion is in progress. When the conversion is complete,\nit returns to zero. Writing zero to this bit has no effect.\n\u0081 Bit 5 \u2013 ADATE: ADC Auto Trigger Enable\nWhen this bit is written to one,  Auto Triggering of the ADC is enabled. The ADC will start a con-\nversion on a positive edge of the selected trigger signal. The trigger source is selected by setting\nthe ADC Trigger Select bits, ADTS in ADCSRB.\n\u0081 Bit 4 \u2013 ADIF: ADC Interrupt Flag\nThis bit is set when an ADC conversion completes and the Data Registers are updated. The\nADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set.\nADIF is cleared by hardware when executing th e corresponding interrupt handling vector. Alter-\nnatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a Read-Modify-\nWrite on ADCSRA, a pending interrupt can be dis abled. This also applies if the SBI and CBI\ninstructions are used.\n\u0081 Bit 3 \u2013 ADIE: ADC Interrupt Enable\nWhen this bit is written to one and the I-bit in SREG is set, the ADC Conversion Complete Inter-\nrupt is activated.\n\u0081 Bits 2:0 \u2013 ADPS2:0: ADC Prescaler Select Bits\nThese bits determine the division factor between the XTAL frequency and the input clock to the\nADC.\nTable 26-5. ADC Prescaler Selections\nADPS2 ADPS1 ADPS0 Division Factor\n0002\n00120104\n0118\n100 1 6101 3 2\n110 6 4\n111 1 2 8\n\n294\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n26.8.4 ADCL and ADCH \u2013 The ADC Data Register\n26.8.4.1 ADLAR = 0\n26.8.4.2 ADLAR = 1\nWhen an ADC conversion is complete, the result is found in these two registers. If differential\nchannels are used, the result is presented in two\u2019s complement form.\nWhen ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if\nthe result is left adjusted and no more than 8-bit precision (7 bit + sign bit for differential input\nchannels) is required, it  is sufficient to read ADCH. Otherwise, ADCL must be read first, then\nADCH.\nThe ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from\nthe registers. If ADLAR is set, the result is left adjusted. If ADLA R is cleared (default), the result\nis right adjusted.\n\u0081 ADC9:0: ADC Conversion Result\nThese bits represent the result from the conversion, as detailed in \u201cADC Conversion Result\u201d on\npage 288 .\n26.8.5 ADCSRB \u2013 ADC Control and Status Register B\n\u0081 Bit 7 \u2013 Res: Reserved Bit\nThis bit is reserved for future use. To ensure co mpatibility with future de vices, this bit must be\nwritten to zero when ADCSRB is written.\n\u0081 Bit 2:0 \u2013 ADTS2:0: ADC Auto Trigger Source\nIf ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger\nan ADC conversion. If ADATE is cleared, the ADTS2:0 settings will have no effect. A conversion\nwill be triggered by the risi ng edge of the selected Interrupt Flag . Note that switch ing from a trig-B i t 1 51 41 31 21 11 0 9 8\n(0x79) \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 ADC9 ADC8 ADCH\n(0x78) ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADC1 ADC0 ADCL\n76543210\nRead/Wr i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 1 51 41 31 21 11 0 9 8(0x79) ADC9 ADC8 ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADCH\n(0x78) ADC1 ADC0 \u2013 \u2013\u2013\u2013\u2013\u2013 ADCL\n76543210\nRead/Wr i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 76543210(0x7B)\n\u2013 ACME \u2013 \u2013 MUX5 ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R R/ W RR R / W R/W R/W R/W\nI n i t i a l  V a l u e00000000\n\n295\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nger source that is cleared to a trigger source that is set, will generate a positive edge on the\ntrigger signal. If ADEN in ADCSRA is set, this  will start a conversion. Switching to Free Running\nmode (ADTS[2:0]=0) will not cause a trigger event, even if t he ADC Interrupt Flag is set .\nNote: Free running mode cannot be used for differential channels (see chapter \u201cDifferential Channels\u201d \non page 281 ).\n26.8.6 DIDR0 \u2013 Digital In put Disable Register 0\n\u0081 Bit 7:0 \u2013 ADC7D:ADC0D: AD C7:0 Digital Input Disable\nWhen this bit is written logic one, the digital input buffer on the corresponding ADC pin is dis-\nabled. The corresponding PIN Re gister bit will always read as zero when this bit is set. When an\nanalog signal is applied to the ADC7:0 pin and the di gital input from this pin is not needed, this\nbit should be written logic one to reduce power consumption in the digital input buffer.\n26.8.7 DIDR2 \u2013 Digital In put Disable Register 2\n\u0081 Bit 7:0 \u2013 ADC15D:ADC8D: ADC15:8 Digital Input Disable\nWhen this bit is written logic one, the digital input buffer on the corresponding ADC pin is dis-\nabled. The corresponding PIN Re gister bit will always read as zero when this bit is set. When an\nanalog signal is applied to the ADC15:8 pin and the digital input from this pin is not needed, this\nbit should be written logic one to reduce power consumption in the digital input buffer.Table 26-6. ADC Auto Trigger Source Selections\nADTS2 ADTS1 ADTS0 Trigger Source\n0 0 0 Free Running mode\n0 0 1 Analog Comparator\n0 1 0 External Interrupt Request 00 1 1 Timer/Counter0 Compare Match A\n1 0 0 Timer/Counter0 Overflow\n1 0 1 Timer/Counter1 Compare Match B1 1 0 Timer/Counter1 Overflow\n1 1 1 Timer/Counter1 Capture Event\nB i t 76543210\n(0x7E) ADC7D ADC6D ADC5D ADC4D ADC3D ADC2D ADC1D ADC0D DIDR0\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210(0x7D) ADC15D ADC14D ADC13D ADC12D ADC11D ADC10D ADC9D ADC8D DIDR2\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n296\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n27. JTAG Interface and On-chip Debug System\n27.1 Features\n\u0081JTAG (IEEE std. 1149.1 Compliant) Interface\n\u0081Boundary-scan Ca pabilities According to the I EEE std. 1149.1 (JTAG) Standard\n\u0081Debugger Access to:\n\u2013 All Internal Peripheral Units\u2013 Internal and External RAM\n\u2013 The Internal Register File\n\u2013P r o g r a m  C o u n t e r\u2013 EEPROM and Flash Memories\n\u0081Extensive On-chip Debug Support for Break Conditions, Including\n\u2013 AVR Break Instruction\u2013 Break on Change of Program Memory Flow\n\u2013 Single Step Break\n\u2013 Program Memory Break Points on Single Address or Address Range\u2013 Data Memory Break Points on Si ngle Address or Address Range\n\u0081Programming of Flash, EEPROM , Fuses, and Lock Bits th rough the JTAG Interface\n\u0081On-chip Debugging Supported by AVR Studio\u00ae\n27.2 Overview\nThe AVR IEEE std. 1149.1 compliant JTAG interface can be used for\n\u0081 Testing PCBs by using the JTAG Boundary-scan capability\n\u0081 Programming the non-volatile memories, Fuses and Lock bits\u0081 On-chip debuggingA brief description is given in the following se ctions. Detailed descriptions for Programming via\nthe JTAG interface, and using the Boundary-scan Chain can be found in the sections \u201cProgram-\nming via the JTAG Interface\u201d on page 354  and \u201cIEEE 1149.1 (JTAG) Bo undary-scan\u201d on page\n302, respectively. The On-chip Debug support is considered being private JTAG instructions,\nand distributed within Atmel and to selected third party vendors only.\nFigure 27-1 on page 297  shows a block diagram of the JTAG interface and the On-chip Debug\nsystem. The TAP Controller is a state machine controlled by the TCK and TMS signals. The TAP\nController selects either the JTAG  Instruction Register or one of several Data Registers as the\nscan chain (Shift Register) between the TDI \u2013 input and TDO \u2013 output. The Instruction Registerholds JTAG instructions controlling the behavior of a Data Register.\nThe ID-Register, Bypass Register, and the Bou ndary-scan Chain are the Data Registers used\nfor board-level testing. The JTAG Programming Interface (actually consisting of several physicaland virtual Data Registers) is used for serial programming via the JTAG interface. The Internal\nScan Chain and Break Point Scan Chain are used for On-chip debugging only.\n\n297\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 27-1. Block Diagram\n27.3 TAP - Test Access Port\nThe JTAG interface is accessed through four of the AVR\u2019s pins. In JTAG terminology, these pins\nconstitute the Test Access Port \u2013 TAP. These pins are:\n\u0081TMS : Test mode select. This pin is used for navigating through the TAP-controller state \nmachine.\n\u0081TCK: Test Clock. JTAG operation is synchronous to TCK.\n\u0081TDI: Test Data In. Serial input data to be shifted in to the Instruction Register or Data \nRegister (Scan Chains).\n\u0081TDO : Test Data Out. Serial output data from Instruction Register or Data Register.\nThe IEEE std. 1149.1 also  specifies an optional TAP signal; TRST \u2013 Test ReSeT \u2013 which is not\nprovided.\nWhen the JTAGEN Fuse is unprogrammed, these four TAP pins are normal port pins, and the\nTAP controller is in reset. When programmed, the input TAP signals are internally pulled high\nand the JTAG is enabled for Boundary-scan and programming. The device is shipped with this\nfuse programmed.\nFor the On-chip Debug system, in addition to the JTAG interface pins, the RESET  pin is moni-\ntored by the debugger to be able to detect external reset sources. The debugger can also pull\nthe RESET  pin low to reset the whole system, assuming only open collectors on the reset line\nare used in the application.TAP\nCONTROLLERTDI\nTDO\nTCK\nTMS\nFLASH\nMEMORYAVR CPU\nDIGITAL\nPERIPHERAL\nUNIT S\nJTAG / AVR CORE\nCOMMUNICATION\nINTERFACEBREAKPOINT\nUNITFLOW CONTROL\nUNIT\nOCD STATU S\nAND CONTROLINTERNAL \nSCAN\nCHAIN\nM\nU\nXINSTRUCTION\nREGI STER\nID\nREGI STER\nBYPA SS\nREGI STERJTAG PROGRAMMING\nINTERFACE\nPC\nInstructionAddress\nData\nBREAKPOINT\nSCAN CHAIN\nADDRE SS\nDECODERANALOG\nPERIPHERIAL\nUNIT SI/O PORT 0\nI/O PORT nBOUNDARY SCAN CHAIN\nAnalog inputs\nControl & Clock linesDEVICE BOUNDARY\n\n298\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 27-2. TAP Controller State Diagram\n27.3.1 TAP Controller\nThe TAP controller is a 16-state finite state machine that controls the operation of the Boundary-\nscan circuitry, JTAG programming circuitry, or On-chip Debug system. The state transitions\ndepicted in Figure 27-2  depend on the signal present on TM S (shown adjacent to each state\ntransition) at the time of the rising edge at TCK. The initial state after a Power-on Reset is Test-\nLogic-Reset.\nAs a definition in this document, the LSB is shifted in and out first for all Shift Registers.\nAssuming Run-Test/Idle is the present state, a typical scenario for using the JTAG interface is:\n\u0081 At the TMS input, apply the sequence 1, 1, 0, 0 at the rising edges of TCK to enter the Shift \nInstruction Register \u2013 Shift-IR state. While in this state, shift the four bits of the JTAG \ninstructions into the JTAG Instruction Register from the TDI input at the rising edge of TCK. The TMS input must be held low during input of the 3 LSBs in order to remain in the Shift-IR state. The MSB of the instruction is shifted in when this state is left  by setting TMS high. \nWhile the instruction is shifted in from the TDI pin, the captured IR-state 0x01 is shifted out \non the TDO pin. The JTAG Instruction selects a particular Data Register as path between TDI and TDO and controls the circuitry surrounding the selected Data Register.Test-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n299\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Apply the TMS sequence 1, 1, 0 to re-enter the Run-Test/Idle state. The instruction is \nlatched onto the parallel output from the Shift Register path in the Update-IR state. The Exit-IR, Pause-IR, and Exit2-IR states are onl y used for navigating the state machine.\n\u0081 At the TMS input, apply the sequence 1, 0, 0 at the rising edges of TCK to enter the Shift \nData Register \u2013 Shift-DR state. While in this state, upload the selected Data Register \n(selected by the present JTAG instruction in the JTAG Instruction Register) from the TDI input at the rising edge of TCK. In order to remain in the Shift-DR state, the TMS input must be held low during input of all bits except the MSB. The MSB of the data is shifted in when this state is left by setting TMS high. While the Data Register is sh ifted in from the TDI pin, \nthe parallel inputs to the Data Register captured in the Capture-DR state is shifted out on the TDO pin.\n\u0081 Apply the TMS sequence 1, 1, 0 to re-enter the Run-Test/Idle state. If the selected Data \nRegister has a latched parallel-output, the latching takes place in the Update-DR state. The Exit-DR, Pause-DR, and Exit2-DR states are only used for navigating the state machine.\nAs shown in the state diagram, the Run-Test/Idle state need not be entered between selecting\nJTAG instruction and using Data Registers, and some JTAG instructions may select certain\nfunctions to be performed in the Run-Test/Idle, making it unsuitable as an Idle state.\nNote: Independent of the initial state of the TAP C ontroller, the Test-Logic-R eset state can always be \nentered by holding TMS high for five TCK clock periods.\nFor detailed information on the JTAG specification, refer to the literature listed in \u201cBibliography\u201d\non page 301 .\n27.4 Using the B oundary-scan Chain\nA complete description of the Boundary-sc an capabilities are gi ven in the section \u201cIEEE 1149.1\n(JTAG) Boundary-scan\u201d on page 302 .\n27.5 Using the On-c hip Debug System\nAs shown in Figure 27-1 on page 297 , the hardware support for On-chip Debugging consists\nmainly of:\n\u0081 A scan chain on the interface between the internal AVR CPU and the internal peripheral \nunits\n\u0081 Break Point unit\u0081 Communication interface between the CPU and JTAG systemAll read or modify/write operations needed for implementing the Debugger are done by applying\nAVR instructions via the internal AVR CPU Scan Chain. The CPU sends the result to an I/O\nmemory mapped location which is part of the communication interface between the CPU and the\nJTAG system.\nThe Break Point Unit implements Break on Change of Program Flow, Single Step Break, two\nProgram Memory Break Points, and two combined Break Points. Together, the four Break\nPoints can be configured as either:\n\u0081 4 single Program Memory Break Points\n\u0081 3 Single Program Memory Break Point + 1 single Data Memory Break Point\u0081 2 single Program Memory Break Points + 2 single Data Memory Break Points\u0081 2 single Program Memory Break Points + 1 Program Memory Break Point with mask (\u201crange \nBreak Point\u201d)\n\u0081 2 single Program Memory Break Points + 1 Data Memory Break Point with mask (\u201crange \nBreak Point\u201d)\n\n300\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA debugger, like the AVR Studio, may however use one or more of these resources for its inter-\nnal purpose, leaving less flexibility to the end-user.\nA list of the On-chip Debug specific JTAG instructions is given in \u201cOn-chip Debug Specific JTAG\nInstructions\u201d on page 300 .\nThe JTAGEN Fuse must be programmed to enable the JTAG Test Access Port. In addition, the\nOCDEN Fuse must be programmed and no Lock bits must be set for the On-chip debug system\nto work. As a security feature, the On-chip debug system is disabled when either of the LB1 or\nLB2 Lock bits are set. Otherwise, the On-chi p debug system would have provided a back-door\ninto a secu red device.\nThe AVR Studio\u00ae enables the user to fully control execution of programs on an AVR device with\nOn-chip Debug capability, AVR In- Circuit Emulator, or the built-i n AVR Instruction Set Simulator.\nAVR Studio supports source level execution of  Assembly programs assembled with Atmel Cor-\nporation\u2019s AVR Assembler and C programs compiled with third party vendors\u2019 compilers.\nAVR Studio runs under Microsoft\u00ae Windows\u00ae 95/98/2000 and Microsoft Windows NT\u00ae.\nFor a full description of the AVR Studio, please re fer to the AVR Studio User Guide. Only high-\nlights are presented in this document.\nAll necessary execution commands are available in AVR Studio, both on source level and on\ndisassembly level. The user can execute the program, single step through the code either by\ntracing into or stepping over functions, step out of functions, place the cursor on a statement andexecute until the statement is reached, stop th e execution, and reset the execution target. In\naddition, the user can have an unlimited number of code Break Points (using the BREAK\ninstruction) and up to two data memory Break Points, alternatively combined as a mask (range)Break Point.\n27.6 On-chip Debug Specific JTAG Instructions\nThe On-chip debug support is considered being private JTAG instructions, and distributed withinATMEL and to selected third party vendors only. Instruction opcodes are listed for reference.\n27.6.1 PRIVATE0; 0x8\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.2 PRIVATE1; 0x9\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.3 PRIVATE2; 0xA\nPrivate JTAG instruction for accessing On-chip debug system.\n27.6.4 PRIVATE3; 0xB\nPrivate JTAG instruction for accessing On-chip debug system.\n\n301\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n27.7 Using the JTAG Pr ogramming Capabilities\nProgramming of AVR parts via JTAG is performed via the 4-pin JTAG port, TCK, TMS, TDI, and\nTDO. These are the only pins that need to be controlled/observed to perform JTAG program-\nming (in addition to power pins). It is not requi red to apply 12V externally. The JTAGEN Fuse\nmust be programmed and the JTD bit in the MCUCR Register must be cleared to enable the\nJTAG Test Access Port.\nThe JTAG programmi ng capability supports:\n\u0081 Flash programming and verifying\n\u0081 EEPROM programming and verifying\u0081 Fuse programming and verifying\u0081 Lock bit programming and verifyingThe Lock bit security is exactly as in parallel programming mode. If the Lock bits LB1 or LB2 are\nprogrammed, the OCDEN Fuse cannot be programmed unless first doing a chip erase. This is a\nsecurity feature that ensures no back-door exists for reading out the content of a secureddevice.\nThe details on programming through the JTAG interface and programming specific JTAG\ninstructions are given in the section \u201cProgramming via the JTAG Interface\u201d on page 354 .\n27.8 Bibliography\nFor more information about general Boundary-scan, the following literature can be consulted:\n\u0081 IEEE: IEEE Std. 1149.1-1990. IEEE Standard Test Access  Port and Boundary-scan \nArchitecture, IEEE, 1993\n\u0081 Colin Maunder: The Board Designers Guide to Testable Logic Circuits, Addison- Wesley, \n1992\n27.9 On-chip Debug Related Register in I/O Memory\n27.9.1 OCDR \u2013 On-chi p Debug Register\nThe OCDR Register provides a co mmunication channel from the running pr ogram in the micro-\ncontroller to the debugger. The CPU can transfer a byte to the debugger by writing to this\nlocation. At the same time, an in ternal flag; I/O Debug Register Dirty \u2013 IDRD \u2013 is set to indicate\nto the debugger that the register has been written. When the CPU reads the OCDR Register the\n7 LSB will be from the OCDR Regi ster, while the MSB is the IDRD  bit. The debugger clears the\nIDRD bit when it has read the information.\nIn some AVR devices, this register is shared with a standard I/O location. In this case, the OCDR\nRegister can only be accessed if the OCDEN Fuse is programmed, and the debugger enables\naccess to the OCDR Register. In all other cases, the standard I/O location is accessed.\nRefer to the debugger documentation for further information on how to use this register.B i t 7 6543210\n0x31 (0x51) MSB/IDRD LSB OCDR\nRead/Write R/ W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 0 0000000\n\n302\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28. IEEE 1149.1 (JTAG) Boundary-scan\n28.1 Features\n\u0081JTAG (IEEE std. 1149.1 compliant) Interface\n\u0081Boundary-scan Capabilities Acco rding to the JTAG Standard\n\u0081Full Scan of all Port Functions as well as Analog Circuitry having Off-chip Connections\n\u0081Supports the Optional IDCODE Instruction\n\u0081Additional Public AVR_RESET Instruction to Reset the AVR\n28.2 System Overview\nThe Boundary-scan chain has the capability of drivin g and observing the logi c levels on the digi-\ntal I/O pins, as well as the boundary between digi tal and analog logic for analog circuitry having\noff-chip connections. At system level, all ICs having JTAG capabilities ar e connected serially by\nthe TDI/TDO signals to form a long Shift Register. An external controller sets up the devices to\ndrive values at their output pins, and observe the input values received from other devices. Thecontroller compares the received data with the expected result. In this way, Boundary-scan pro-\nvides a mechanism for testing interconnections and integrity of components on Printed Circuits\nBoards by using the four TAP signals only.\nThe four IEEE 1149.1 defined mandatory JTAG in structions IDCODE, BYPASS, SAMPLE/PRE-\nLOAD, and EXTEST, as well as the AVR specif ic public JTAG instruction AVR_RESET can be\nused for testing the Print ed Circuit Board. Initial scanning of the Data Register path will show the\nID-Code of the device, since IDCODE is the default JTAG instruction. It may be desirable to\nhave the AVR device in reset during test mode. If not reset, inputs to the device may be deter-\nmined by the scan operations, and the internal software may be in an undetermined state whenexiting the test mode. En tering reset, the outputs of any po rt pin will instantly enter the high\nimpedance state, making the HIGHZ instruction redundant. If needed, the BYPASS instruction\ncan be issued to make the shortest possible  scan chain through the device. The device can be\nset in the reset state either by pulling the external RESET\n pin low, or issuing the AVR_RESET\ninstruction with appropriate setting of the Reset Data Register.\nThe EXTEST instruction is used for sampling external pins and loading output pins with data.\nThe data from the output latch will be driven out on the pins as soon as  the EXTEST instruction\nis loaded into the JTAG IR-Register. Therefore, the SAMPLE/PRELOAD should also be used for\nsetting initial values to the scan ring, to avoid damaging the board when issuing the EXTEST\ninstruction for the first time. SAMPLE/PRELOAD c an also be used for taking a snapshot of the\nexternal pins during normal operation of the part.\nThe JTAGEN Fuse must be pr ogrammed and the JTD bit in the I/O Register MCUCR must be\ncleared to enable the JTAG Test Access Port.\nWhen using the JTAG interface for Boundary-scan, using a JTAG TCK clock frequency higher\nthan the internal chip frequency is possible. The chip clock is not required to run.\n28.3 Data Registers\nThe Data Registers relevant for Boundary-scan operations are:\n\u0081 Bypass Register\n\u0081 Device Identification Register\u0081 Reset Register\u0081 Boundary-scan Chain\n\n303\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.3.1 Bypass Register\nThe Bypass Register consists of a single Shift Register stage. When the Bypass Register is\nselected as path between TDI and TDO, the register is reset to 0 when leaving the Capture-DRcontroller state. The Bypass Register can be used to shorten the scan chain on a system when\nthe other devices are to be tested.\n28.3.2 Device Identification Register\nFigure 28-1  shows the structure of the De vice Identification Register.\nFigure 28-1. The Format of the Device Identification Register\n28.3.2.1 Version\nVersion is a 4-bit number identifying the revision of the component. The JTAG version number\nfollows the revision of the device. Revision A is 0x0, revision B is 0x1 and so on.\n28.3.2.2 Part Number\nThe part number is a 16-bit code identifying the component. The JTAG Part Number for\nATmega640/1280/1281/2560/2561 is listed in Table 30-6 on page 338 .\n28.3.2.3 Manufacturer ID\nThe Manufacturer ID is a 11-bit code identifying the manufacturer. The JTAG manufacturer ID\nfor ATMEL is listed in Table 30-6 on page 338 .\n28.3.3 Reset Register\nThe Reset Register is a test Data Register used to reset the part. Since the AVR tri-states Port\nPins when reset, the Reset Register can also replace the function of the unimplemented optional\nJTAG instruction HIGHZ.\nA high value in the Reset Register corresponds to pulling the external Reset low. The part is\nreset as long as there is a high value present in the Reset Register. Depending on the fuse set-\ntings for the clock options, the part will remain reset for a reset time-out period (see \u201cClock\nSources\u201d on page 41 ) after releasing the Reset Register. The output from this Data Register is\nnot latched, so the reset will take place immediately, as shown in Figure 28-2 on page 304 .MSB LSB\nBit 31 28 27 12 11 1 0\nDevice ID Version Part Number Manufacturer ID 1\n4 bits 16 bits 11 bits 1-bit\n\n304\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 28-2. Reset Register\n28.3.4 Boundary-scan Chain\nThe Boundary-scan Chain has the capability of driv ing and observing the lo gic levels on the dig-\nital I/O pins, as well as the boundary between di gital and analog logic for analog circuitry having\noff-chip connections.\nSee \u201cBoundary-scan Chain\u201d on page 305  for a complete description.\n28.4 Boundary-scan Specifi c JTAG Instructions\nThe Instruction Register is 4-bit wide, suppor ting up to 16 instructions. Listed below are the\nJTAG instructions useful for Boundary-scan operation. Note that the optional HIGHZ instructionis not implemented, but all outputs with tri-stat e capability can be set in high-impedant state by\nusing the AVR_RESET instruction,  since the initial state for all port pins is tri-state.\nAs a definition in this datasheet, the LSB is shifted in and out first for all Shift Registers.The OPCODE for each instruction is shown behind the instruction name in hex format. The text\ndescribes which Data Register is selected as  path between TDI and TDO for each instruction.\n28.4.1 EXTEST; 0x0\nMandatory JTAG instruction for selecting the Boundary-scan Chain as Data Register for testing\ncircuitry external to the AVR package. For port- pins, Pull-up Disable, Output Control, Output\nData, and Input Data are all accessible in the scan chain. For Analog ci rcuits having off-chip\nconnections, the interface between the analog and th e digital logic is in the scan chain. The con-\ntents of the latched outputs of the Boundary-scan chain is driven out as soon as the JTAG IR-\nRegister is loaded with  the EXTEST instruction.\nThe active states are:\n\u0081Capture-DR : Data on the external pins are sampled into the Boundary-scan Chain\n\u0081Shift-DR : The Internal Scan Chain is shifted by the TCK input\n\u0081Update-DR : Data from the scan chain is applied to output pins\n28.4.2 IDCODE; 0x1\nOptional JTAG instruction selecting the 32-bit ID-Register as Data Register. The ID-Register\nconsists of a version number, a device number and the manufacturer code chosen by JEDEC.\nThis is the default inst ruction after power-up.DQFrom\nTDI\nClockDR \u00b7 AVR_RE SETTo \nTDO\nFrom Other Internal and\nExternal Reset Sources\nInternal reset\n\n305\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nThe active states are:\n\u0081Capture-DR : Data in the IDCODE Register is sampled into the Boundary-scan Chain\n\u0081Shift-DR : The IDCODE scan chain is shifted by the TCK input\n28.4.3 SAMPLE_PRELOAD; 0x2\nMandatory JTAG instruction for pre-loading the output latches and taking a snap-shot of the\ninput/output pins without affecting the system operation. However, the output latches are not\nconnected to the pins. The Boundary-scan Chain is selected as Data Register.\nThe active states are:\u0081Capture-DR : Data on the external pins are sampled into the Boundary-scan Chain\n\u0081Shift-DR : The Boundary-scan Chain is shifted by the TCK input\n\u0081Update-DR : Data from the Boundary-scan chain is applied to the output latches. However, \nthe output latches are not connected to the pins\n28.4.4 AVR_RESET; 0xC\nThe AVR specific public JTAG instruction for forcing the AVR device into the Reset mode or\nreleasing the JTAG reset source. The TAP controller is not reset by this in struction. The one bit\nReset Register is selected as Da ta Register. Note that the reset will be active as long as there is\na logic \u201cone\u201d in the Reset Chain. The output from this chain is not latched.\nThe active states are:\n\u0081Shift-DR : The Reset Register is shifted by the TCK input\n28.4.5 BYPASS; 0xF\nMandatory JTAG instructio n selecting the Bypass Register for Data Register.\nThe active states are:\n\u0081Capture-DR : Loads a logic \u201c0\u201d into the Bypass Register\n\u0081Shift-DR : The Bypass Register cell between TDI and TDO is shifted\n28.5 Boundary-scan Chain\nThe Boundary-scan chain has the capability of drivin g and observing the logi c levels on the digi-\ntal I/O pins, as well as the boundary between digi tal and analog logic for analog circuitry having\noff-chip connection.\n28.5.1 Scanning the Digital Port Pins\nFigure 28-3 on page 306  shows the Boundary-scan Cell for a bi-directional port pin. The pull-up\nfunction is disabled during Boundary-scan w hen the JTAG IC contains EXTEST or\nSAMPLE_PRELOAD. The cell consists of a bi-dir ectional pin cell that combines the three sig-\nnals Output Control - OCxn, Output Data - ODxn, and Input Data - IDxn, into only a two-stage\nShift Register. The port and pin indexes are not used in the following description.\nThe Boundary-scan logic is not included in the figures in the datasheet. Figure 28-4 on page 307\nshows a simple digital port pin as described in the section \u201cI/O-Ports\u201d on page 70 . The Bound-\nary-scan details from Figure 28-3 on page 306  replaces the dashed box in Figure 28-4 on page\n307.\nWhen no alternate port function is present, the Input Data - ID - corresponds to the PINxn Regis-\nter value (but ID has no synchronizer), Output Data corresponds to the PORT Register, Output\n\n306\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nControl corresponds to the Data Direction - DD Register, and the Pull-up Enable - PUExn - cor-\nresponds to logic expression PUD  \u00b7 DDxn  \u00b7 PORTxn.\nDigital alternate port functions are connected outside the dotted box in Figure 28-4 on page 307\nto make the scan chain read the actual pin value.  For analog function, there is a direct connec-\ntion from the external pin to the analog circuit. There is no scan chain on the interface between\nthe digital and the analog circuitry, but some digi tal control signal to analog circuitry are turned\noff to avoid driving contention on the pads.\nWhen JTAG IR contains EXTEST or SAMPLE_PRELOAD the clock is not sent out on the port\npins even if the CKOUT fuse is programmed. Ev en though the clock is output when the JTAG IR\ncontains SAMPLE_PRELOAD, the clock is not sampled by the boundary scan.\nFigure 28-3. Boundary-scan Cell for Bi-directional Port Pin with Pull-up Function.\nDQ DQ\nG01\n01\nDQ DQ\nG0\n10101\nPort Pin (PXn)Vcc EXTEST To Next Cell ShiftDR\nOutput Control (OC)\nOutput Data (OD)\nInput Data (ID)\nFrom Last Cell UpdateDR ClockDRFF1 LD1\nLD0 FF00\n1Pull-up Enable (PUE)\n\n307\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 28-4. General Port Pin Schematic Diagram\n28.5.2 Scanning the RESET Pin\nThe RESET pin accepts 5V active low logic fo r standard reset operation, and 12V active high\nlogic for High Voltage Parallel programming. An observe-only cell as shown in Figure 28-5  is\ninserted for the 5V reset signal.\nFigure 28-5. Observe-only CellCLKRPxRRxWRxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWRx: WRITE PORTx\nRRx: READ PORTx REGISTER\nRPx: READ PORTx PINPUD: PULLUP DISABLE\nCLK     : I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQ D\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/OI/OSee Boundary-scan \nDescription for Details!\nPUExn\nOCxn\nODxn\nIDxn\nPUExn: PULLUP ENABLE for pin Pxn\nOCxn: OUTPUT CONTROL for pin PxnODxn: OUTPUT DATA to pin Pxn\nIDxn: INPUT DATA from pin Pxn\n0\n1DQ\nFrom\nPrevious\nCellClockDRShiftDRTo\nNext\nCell\nFrom  System Pin To System Logic\nFF1\n\n308\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.6 Boundary-scan Related Re gister in I/O Memory\n28.6.1 MCUCR \u2013 MCU Control Register\nThe MCU Control Register contains control bits for general MCU functions.\n\u0081 Bits 7 \u2013 JTD: JTAG Interface Disable\nWhen this bit is zero, the JTAG interface is enabl ed if the JTAGEN Fuse is programmed. If this\nbit is one, the JTAG interface is disabled. In or der to avoid unintentional disabling or enabling of\nthe JTAG interface, a timed sequence must be followed when changing this bit: The applicationsoftware must write this bit to the desired value twice within four cycles to change its value. Note\nthat this bit must not be altered when using the On-chip Debug system.\n28.6.2 MCUSR \u2013 MCU Status Register\nThe MCU Status Register provides information on which reset source caused an MCU reset.\n\u0081 Bit 4 \u2013 JTRF: JTAG Reset Flag\nThis bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by\nthe JTAG instruction AVR_RESET. This bit is rese t by a Power-on Reset, or by writing a logic\nzero to the flag.\n28.7 ATmega640/1280/1281/2560/ 2561 Boundary-scan Order\nTable 28-1 on page 309  shows the Scan order between TDI and TDO when the Boundary-scan\nchain is selected as data path. Bit 0 is the LSB; the first bit scanned in, and the first bit scannedout. The scan order follows the pin-out order as fa r as possible. Therefore, the bits of Port A and\nPort K is scanned in the opposite bit order of the other ports. Exceptions from the rules are the\nScan chains for the analog circuits, which constitute the most significant bits of the scan chain\nregardless of which physical pin they are connected to. In Figure 28-3 on page 306 , PXn. Data\ncorresponds to FF0, PXn. Control corresponds to FF1, PXn. Bit 4, bit 5, bit 6 and bit 7 of Port F\nis not in the scan chain, since these pins co nstitute the TAP pins when the JTAG is enabled.\n28.8 Boundary-scan Description Language Files\nBoundary-scan Description Language (BSDL) files describe Boundary-scan capable devices in\na standard format used by automated test-generation software. The order and function of bits in\nthe Boundary-scan Data Register are included in th is description. BSDL files are available for\nATmega1281/2561 and ATmega640/1280/2560.B i t 76543210\n0x35 (0x55) JTD \u2013 \u2013 PUD \u2013 \u2013 IVSEL IVCE MCUCR\nRead/Write R/ W RR R / W RR R / W R/W\nI n i t i a l  V a l u e00000000\nB i t 765432100x34 (0x54)\n\u2013 \u2013 \u2013J T R F WDRF BORF EXTRF PORF MCUSR\nRead/Wr i t e RRR R / W R/W R/W R/W R/W\nInitial Value 0 0 0 See Bit Description\n\n309\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 28-1. ATmega640/1280/2560 Boundary-scan Order\nBit Number Signal Name Module\n164 PG5.Data\nPort G\n163 PG5.Control\n162 PE0.Data\nPort E161 PE0.Control\n160 PE1.Data\n159 PE1.Control\n158 PE2.Data157 PE2.Control\n156 PE3.Data\n155 PE3.Control154 PE4.Data\n153 PE4.Control\n152 PE5.Data151 PE5.Control\n150 PE6.Data\n149 PE6.Control148 PE7.Data\n147 PE7.Control\n146 PH0.Data\nPort H145 PH0.Control\n144 PH1.Data\n143 PH1.Control142 PH2.Data\n141 PH2.Control\n140 PH3.Data139 PH3.Control\n138 PH4.Data\n137 PH4.Control136 PH5.Data\n135 PH5.Control\n134 PH6.Data\n133 PH6.Control\n\n310\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n132 PB0.Data\nPort B131 PB0.Control\n130 PB1.Data\n129 PB1.Control\n128 PB2.Data\n127 PB2.Control126 PB3.Data\n125 PB3.Control\n124 PB4.Data123 PB4.Control\n122 PB5.Data\n121 PB5.Control120 PB6.Data\n119 PB6.Control\n118 PB7.Data117 PB7.Control\n116 PH7.Data\nPort H\n115 PH7.Control\n114 PG3.Data\nPort G113 PG3.Control\n112 PG4.Data111 PG4.Control\n110 RSTT Reset Logic (Observe Only)\n109 PL0.Data\nPort L108 PL0.Control\n107 PL1.Data\n106 PL1.Control105 PL2.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n311\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n104 PL2.Control\n103 PL3.Data\n102 PL3.Control\n101 PL4.Data\n100 PL4.Control\n99 PL5.Data98 PL5.Control\n97 PL6.Data\n96 PL6.Control95 PL7.Data\n94 PL7.Control\n93 PD0.Data\nPort D92 PD0.Control\n91 PD1.Data\n90 PD1.Control89 PD2.Data\n88 PD2.Control\n87 PD3.Data86 PD3.Control\n85 PD4.Data\n84 PD4.Control83 PD5.Data\n82 PD5.Control\n81 PD6.Data80 PD6.Control\n79 PD7.Data\n78 PD7.Control77 PG0.Data\nPort G76 PG0.Control\n75 PG1.Data74 PG1.Control\n73 PC0.Data\nPort C72 PC0.Control\n71 PC1.Data\n70 PC1.Control69 PC2.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n312\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n68 PC2.Control\n67 PC3.Data\n66 PC3.Control\n65 PC4.Data\n64 PC4.Control\n63 PC5.Data62 PC5.Control\n61 PC6.Data\n60 PC6.Control59 PC7.Data\n58 PC7.Control\n57 PJ0.Data\nPort J56 PJ0.Control\n55 PJ1.Data\n54 PJ1.Control53 PJ2.Data\n52 PJ2.Control\n51 PJ3.Data50 PJ3.Control\n49 PJ4.Data\n48 PJ4.Control47 PJ5.Data\n46 PJ5.Control\n45 PJ6.Data44 PJ6.Control\n43 PG2.Data\nPort G\n42 PG2.Control\n41 PA7.Data\nPort A40 PA7.Control\n39 PA6.Data38 PA6.Control\n37 PA5.Data\n36 PA5.Control\n35 PA4.Data\n34 PA4.Control33 PA3.DataTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n313\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32 PA3.Control\n31 PA2.Data\n30 PA2.Control\n29 PA1.Data\n28 PA1.Control\n27 PA0.Data26 PA0.Control\n25 PJ7.Data\nPort J\n24 PJ7.Control\n23 PK7.Data\nPort K22 PK7.Control\n21 PK6.Data20 PK6.Control\n19 PK5.Data\n18 PK5.Control17 PK4.Data\n16 PK4.Control\n15 PK3.Data14 PK3.Control\n13 PK2.Data\n12 PK2.Control11 PK1.Data\n10 PK1.Control\n9 PK0.Data8 PK0.Control\n7P F 3 . D a t a\nPort F6 PF3.Control\n5P F 2 . D a t a\n4 PF2.Control\n3P F 1 . D a t a2 PF1.Control\n1P F 0 . D a t a\n0 PF0.ControlTable 28-1. ATmega640/1280/2560 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n314\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 28-2. ATmega1281/2561 Boundary-scan Order\nBit Number Signal Name Module\n100 PG5.Data\nPort G\n99 PG5.Control\n98 PE0.Data\nPort E97 PE0.Control\n96 PE1.Data95 PE1.Control\n94 PE2.Data\n93 PE2.Control92 PE3.Data\n91 PE3.Control\n90 PE4.Data89 PE4.Control\n88 PE5.Data\n87 PE5.Control86 PE6.Data\n85 PE6.Control\n84 PE7.Data83 PE7.Control\n82 PB0.Data\nPort B81 PB0.Control\n80 PB1.Data\n79 PB1.Control\n78 PB2.Data77 PB2.Control\n76 PB3.Data\n75 PB3.Control74 PB4.Data\n73 PB4.Control\n72 PB5.Data71 PB5.Control\n70 PB6.Data\n69 PB6.Control\n68 PB7.Data\n67 PB7.Control66 PG3.Data Port G\n\n315\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n65 PG3.Control\n64 PG4.Data\n63 PG4.Control\n62 RSTT Reset Logic (Observe Only)\n61 PD0.Data\nPort D60 PD0.Control\n59 PD1.Data\n58 PD1.Control\n57 PD2.Data56 PD2.Control\n55 PD3.Data\n54 PD3.Control53 PD4.Data\n52 PD4.Control\n51 PD5.Data50 PD5.Control\n49 PD6.Data\n48 PD6.Control47 PD7.Data\n46 PD7.Control\n45 PG0.Data\nPort G44 PG0.Control\n43 PG1.Data\n42 PG1.Control41 PC0.Data\nPort C40 PC0.Control\n39 PC1.Data38 PC1.Control\n37 PC2.Data\n36 PC2.Control35 PC3.Data\n34 PC3.Control\n33 PC4.Data\n32 PC4.Control\n31 PC5.Data30 PC5.ControlTable 28-2. ATmega1281/2561 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n316\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29 PC6.Data\n28 PC6.Control\n27 PC7.Data\n26 PC7.Control\n25 PG2.Data\nPort G\n24 PG2.Control\n23 PA7.Data\nPort A22 PA7.Control\n21 PA6.Data20 PA6.Control\n19 PA5.Data\n18 PA5.Control17 PA4.Data\n16 PA4.Control\n15 PA3.Data14 PA3.Control\n13 PA2.Data\n12 PA2.Control11 PA1.Data\n10 PA1.Control\n9P A 0 . D a t a8P A 0 . C o n t r o l\n7P F 3 . D a t a\nPort F6 PF3.Control\n5P F 2 . D a t a\n4 PF2.Control\n3P F 1 . D a t a2 PF1.Control\n1P F 0 . D a t a\n0 PF0.ControlTable 28-2. ATmega1281/2561 Boundary-scan Order (Continued)\nBit Number Signal Name Module\n\n317\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29. Boot Loader Support \u2013 Read -While-Write Self-Programming\nThe Boot Loader Support provides a real Read- While-Write Self-Programming mechanism for\ndownloading and uploading program code by the M CU itself. This feature a llows flexible applica-\ntion software updates controlled by the MCU using a Flash-resident Boot Loader program. TheBoot Loader program can use any available data interface and associated protocol to read code\nand write (program) that code into the Flash memory, or read the code from the program mem-\nory. The program code within the Boot Loader section has the capability to write into the entireFlash, including the Boot Loader memory. The B oot Loader can thus even modify itself, and it\ncan also erase itself from the code if the feature is not needed anymore. The size of the Boot\nLoader memory is configurable with fuses and t he Boot Loader has two separate sets of Boot\nLock bits which can be set indepen dently. This gives the user a uniq ue flexibility to select differ-\nent levels of protection.\n29.1 Features\n\u0081Read-While-Write Self-Programming\n\u0081Flexible Boot Memory Size\n\u0081High Security (Separate Boot Lock Bits for a Flexible Protection)\n\u0081Separate Fuse to Select Reset Vector\n\u0081Optimized Page(1) Size\n\u0081Code Efficient Algorithm\n\u0081Efficient Read-Modify-Write Support\nNote: 1. A page is a section in the Flash consisting of several bytes (see Table 30-7 on page 338 ) used \nduring programming. The page organization does not affect normal operation.\n29.2 Application and Boot  Loader Flash Sections\nThe Flash memory is organized in two main sections, the Application section and the Boot\nLoader section (see Figure 29-2 on page 320 ). The size of the different sections is configured by\nthe BOOTSZ Fuses as shown in Table 29-7 on page 328  and Figure 29-2 on page 320 . These\ntwo sections can have different level of protecti on since they have different sets of Lock bits.\n29.2.1 Application Section\nThe Application section is the section of the Flash that is used for storing the application code.\nThe protection level for the Application section can be selected by the application Boot Lock bits(Boot Lock bits 0), see Table 29-2 on page 321 . The Application section can never store any\nBoot Loader code since the SPM instruction is disabled when executed from the Application\nsection.\n29.2.2 BLS \u2013 Boot Loader Section\nWhile the Application section is used for storing the application code, the The Boot Loader soft-\nware must be located in the BLS since the SPM instruction can initiate a programming when\nexecuting from the BLS only. The SPM instruct ion can access the entire Flash, including the\nBLS itself. The protection level for the Boot Loader section can be selected by the Boot LoaderLock bits (Boot Lock bits 1), see Table 29-3 on page 321 .\n29.3 Read-While-Write and No R ead-While-Write Flash Sections\nWhether the CPU supports Read- While-Write or if the CPU is halted during a Boot Loader soft-\nware update is dependent on which address that is being programmed. In addition to the twosections that are configurable by the BOOTSZ  Fuses as described above, the Flash is also\n\n318\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\ndivided into two fixed sections, the Read- While-Write (R WW) section and the No Read- While-\nWrite (NR WW) section. The limit between the R WW- and NR WW sections is given in Table 29-\n1 and Figure 29-1 on page 319 . The main difference between the two sections is:\n\u0081When erasing or writing a page located inside the R WW section, the NR WW section can be \nread during the operation\n\u0081When erasing or writing a page located inside the NR WW section, the CPU is halted during \nthe entire operation\nNote that the user software can never read any code that is located inside the R WW section dur-\ning a Boot Loader software operation. The syntax \u201cRead- While-Write section\u201d refers to which\nsection that is being programmed (erased or written), not which section that actually is being\nread during a Boot Loader software update.\n29.3.1 RWW \u2013 Read-While-Write Section\nIf a Boot Loader software update is programming a page inside the R WW section, it is possible\nto read code from the Flash, but only code that is located in the NR WW section. During an on-\ngoing programming, the software must ensure that the R WW section never is being read. If the\nuser software is trying to read code that is located inside the R WW section (that is, by load pro-\ngram memory, call, or jump instructions or an interrupt) during programming, the software might\nend up in an unknown state. To avoid this, the in terrupts should either be disabled or moved to\nthe Boot Loader section. The Boot Loader section is always located in the NR WW section. The\nRWW Section Busy bit (R WWSB) in the Store Program Memory Control and Status Register\n(SPMCSR) will be read as lo gical one as long as the R WW section is blocked for reading. After\na programming is completed, the R WWSB must be cleared by software before reading code\nlocated in the R WW section. See \u201cSPMCSR \u2013 Store Program Memory Control and Status Reg-\nister\u201d on page 332.  for details on how to clear R WWSB.\n29.3.2 NRWW \u2013 No Read-While-Write Section\nThe code located in the NR WW section can be read when the Boot Loader software is updating\na page in the R WW section. When the Boot Loader code updates the NR WW section, the CPU\nis halted during the entire Page Erase or Page Write operation.\nTable 29-1. Read- While-Write Features\nWhich Section does the Z-pointer\nAddress during the Programming?Which Section can be \nRead during Programming? CPU Halted?Read-While-Write \nSupported?\nRWW Section NR WW Section No Yes\nNRWW Section None Y es No\n\n319\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 29-1. Read- While-Write vs. No Read- While-Write\nRead-While-Write\n(RWW) Section\nNo Read-While-Write \n(NRWW) SectionZ-pointer\nAddresses RWWSectionZ-pointer\nAddresses NRWWSection\nCPU is Halted\nDuring the Operation\nCode Located in \nNRWW Section\nCan be Read Duringthe Operation\n\n320\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 29-2. Memory Sections\nNote: 1. The parameters in the figure above are given in Table 29-7 on page 328 .\n29.4 Boot Loader Lock Bits\nIf no Boot Loader capability is n eeded, the entire Flash is available for application code. The\nBoot Loader has two separate sets of Boot Lock bits which can be set independently. This givesthe user a unique flexibility to sele ct different levels  of protection.\nThe user can select:\n\u0081 To protect the entire Flash from a software update by the MCU\n\u0081 To protect only the Boot Loader Flash section from a software update by the MCU\u0081 To protect only the Application Flash section from a software update by the MCU\u0081 Allow software update in the entire FlashSee Table 29-2 on page 321  and Table 29-3 on page 321  for further details. The Boot Lock bits\ncan be set in software and in Serial or Parallel Programming mode, but they can be cleared by a\nChip Erase command only. The general Write Lock (Lock Bit mode 2) does not control the pro-\ngramming of the Flash memory by SPM instruction. Similarly, the general Read/ Write Lock\n(Lock Bit mode 1) does not control reading nor writing by (E)LPM/SPM, if it is attempted.0x0000\nFlashendProgram Memory\nBOOTSZ = '11'\nApplication Flash Section\nBoot Loader Flash Section\nFlashendProgram Memory\nBOOTSZ = '10'\n0x0000Program Memory\nBOOTSZ = '01'Program Memory\nBOOTSZ = '00'Application Flash Section\nBoot Loader Flash Section0x0000\nFlashendApplication Flash Section\nFlashendEnd RWW\nStart NRWWApplication Flash Section\nBoot Loader Flash Section\nBoot Loader Flash SectionEnd RWW\nStart NRWWEnd RWW\nStart NRWW\n0x0000\nEnd RWW, End Application\nStart NRWW, Start Boot LoaderApplication Flash Section Application Flash Section\nApplication Flash Section\nRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionEnd Application\nStart Boot LoaderEnd Application\nStart Boot Loader\nEnd Application\nStart Boot Loader\n\n321\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\n29.4.1 Entering the Boot Loader Program\nEntering the Boot Loader takes place by a jump or call from the application program. This may\nbe initiated by a trigger such as a command received via USART, or SPI interface. Alternatively,\nthe Boot Reset Fuse can be programmed so that the Reset Vector is pointing to the Boot Flashstart address after a reset. In this case, the Boot Loader is started after a reset. After the applica-\ntion code is loaded, the program can start execut ing the application code. Note that the fuses\ncannot be changed by the MCU itself. This means that once the Boot Reset Fuse is pro-grammed, the Reset Vector will always point to the Boot Loader Reset and the fuse can only be\nchanged through the serial or parallel programming interface.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.Table 29-2. Boot Lock Bit0 Protection Modes (Application Section)(1)\nBLB0 Mode BLB02 BLB01 Protection\n11 1No restrictions for SPM or (E)LPM accessing the Application \nsection.\n2 1 0 SPM is not allowed to write to the Application section.\n30 0SPM is not allowed to write to the Application section, and \n(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application sectio n. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\n40 1(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application sectio n. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\nTable 29-3. Boot Lock Bit1 Protection Modes (Boot Loader Section)(1)\nBLB1 Mode BLB12 BLB11 Protection\n11 1No restrictions for SPM or (E)L PM accessing the Boot Loader \nsection.\n2 1 0 SPM is not allowed to write to the Boot Loader section.\n30 0SPM is not allowed to write to the Boot Loader section, and \n(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader section. If Interrupt Vectors are placed in the Application section, interrupts are disabled while \nexecuting from the B oot Loader section.\n40 1(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader section. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while \nexecuting from the B oot Loader section.\nTable 29-4. Boot Reset Fuse(1)\nBOOTRST Reset Address\n1 Reset Vector = Application Reset (address 0x0000)\n0 Reset Vector = Boot Loader Reset (see Table 29-7 on page 328 )\n\n322\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.5 Addressing the Flash During Self-Programming\nThe Z-pointer is used to address the SPM commands. The Z pointer consists of the Z-registers\nZL and ZH in the register file, and RAMPZ in the I/O space. The number of bits actually used is\nimplementation dependent. Note that the RAMPZ register is only implemented when the pro-gram space is larger than 64Kbytes.\nSince the Flash is organized in pages (see Table 30-7 on page 338 ), the Program Counter can\nbe treated as having two different sections. One sect ion, consisting of the least significant bits, is\naddressing the words within a page, while the most significant bits are addressing the pages.\nThis is shown in Figure 29-3 . Note that the Page Erase and Page Write operations are\naddressed independently. Therefore it is of major importance that the Boot Loader softwareaddresses the same page in both the Page Erase and Page Write operation. Once a program-\nming operation is initiated, the address is latched and the Z-pointer can be used for other\noperations.\nThe (E)LPM instruction use the Z-pointer to st ore the address. Since this instruction addresses\nthe Flash byte-by-byte, also bit Z0 of the Z-pointer is used.\nFigure 29-3. Addressing the Flash During SPM\n(1)\nNote: 1. The different variables used in Figure 29-3  are listed in Table 29-9 on page 329 .B i t 2 32 22 12 01 91 81 71 6\n15 14 13 12 11 10 9 8\nRAMPZ RAMPZ7 RAMPZ6 RAMPZ5 RAMPZ4 RAMPZ3 RAMPZ2 RAMPZ1 RAMPZ0ZH (R31) Z15 Z14 Z13 Z12 Z11 Z10 Z9 Z8Z L  ( R 3 0 ) Z 7Z 6Z 5Z 4Z 3Z 2Z 1Z 0\n76543210\nPROGRAM MEMORY01 15\nZ - REGI STERBIT\n0ZPAGEM SB\nWORD ADDRE SS\nWITHIN A PAGEPAGE ADDRE SS\nWITHIN THE FLA SHZPCM SB\nINSTRUCTION WORDPAGEPCWORD[PAGEM SB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCM SB PAGEM SB\nPROGRAM\nCOUNTER\n\n323\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6 Self-Programming the Flash\nThe program memory is updated in a page by page fashion. Before programming a page with\nthe data stored in the temporary page buffer, the page must be erased. The temporary page buf-\nfer is filled one word at a time using SPM and the buffer can be filled either before the PageErase command or between a Page Erase and a Page Write operation:\nAlternative 1, fill the bu ffer before a Page Erase\n\u0081 Fill temporary page buffer\n\u0081 Perform a Page Erase\u0081 Perform a Page Write\nAlternative 2, fill the bu ffer after Page Erase\n\u0081 Perform a Page Erase\n\u0081 Fill temporary page buffer\u0081 Perform a Page Write\nIf only a part of the page needs to be changed, the rest of the page must be stored (for example\nin the temporary page buffer) before the erase, and then be rewritten. When using alternative 1,\nthe Boot Loader provides an effective Read-Modify- Write feature which allows the user software\nto first read the page, do the necessary changes, and then write back the modified data. If alter-\nnative 2 is used, it is not possible to read the old data while loading since the page is already\nerased. The temporary page buffer can be accessed in a random sequence. It is essential thatthe page address used in both the Page Erase and Page Write operation is addressing the same\npage. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on page 327  for an assembly\ncode example.\n29.6.1 Performing Page Erase by SPM\nTo execute Page Erase, set up the address in the Z-pointer, write \u201cX0000011\u201d to SPMCSR and\nexecute SPM within four clock cycles after writing SPMCSR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE in the Z-register. Other bits in the Z-pointer will\nbe ignored during this operation.\n\u0081 Page Erase to the R WW section: The NR WW section can be read during the Page Erase\n\u0081 Page Erase to the NR WW section: The CPU is halted during the operation\n29.6.2 Filling the Temporary Buffer (Page Loading)\nTo write an instruction word, set up the address in the Z-pointer and data in R1:R0, write\n\u201c00000001\u201d to SPMCSR and execute SPM within four  clock cycles after writing SPMCSR. The\ncontent of PC WORD in the Z-register is used to address the data in the temporary buffer. The\ntemporary buffer will auto-erase after a Page Write operation or by writing the R WWSRE bit in\nSPMCSR. It is also erased after a system reset. Note that it is not possible to write more thanone time to each address without erasing the temporary buffer.\nIf the EEPROM is written in the middle of an SPM Page Load oper ation, all data loaded is still\nbuffered.\n\n324\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.3 Performing a Page Write\nTo execute Page Write, set up the address in the Z-pointer, write \u201cX0000101\u201d to SPMCSR and\nexecute SPM within four clock cycles after writing SPMCSR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE. Other bits in the Z-pointer must be written to\nzero during this operation.\n\u0081 Page Write to the R WW section: The NR WW section can be read during the Page Write\n\u0081 Page Write to the NR WW section: The CPU is halted during the operation\n29.6.4 Using the SPM Interrupt\nIf the SPM interrupt is en abled, the SPM interrupt will genera te a constant in terrupt when the\nSPMEN bit in SPMCSR is cleared. This means th at the interrupt can be used instead of polling\nthe SPMCSR Register in software. When using the SPM interrupt, the Interrupt Vectors should\nbe moved to the BLS section to avoid that an interrupt is accessing the R WW section when it is\nblocked for reading. How to move the interrupts is described in \u201cInterrupts\u201d on page 105 .\n29.6.5 Consideration While Updating BLS\nSpecial care must be taken if the user allows the Boot Loader section to be updated by leaving\nBoot Lock bit11 unprogrammed. An accidental write to the Boot Loader itself can corrupt the\nentire Boot Loader, and further software updates might  be impossible. If it is not necessary to\nchange the Boot Loader software itself, it is recommended to program the Boot Lock bit11 to\nprotect the Boot Loader software from any internal software changes.\n29.6.6 Prevent Reading the RWW Section During Self-Programming\nDuring Self-Programming (either Page Erase or Page Write), the R WW section is always\nblocked for reading. The user software itself must prevent that this section is addressed duringthe self programming operation. The R WWSB in the SPMCSR will be set as long as the R WW\nsection is busy. During Self-Programming the Interrupt Vector table should be moved to the BLS\nas described in \u201cInterrupts\u201d on page 105 , or the interrupts must be disabled. Before addressing\nthe RWW section after the programming is completed, the user software must clear the\nRWWSB by writing the R WWSRE. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on\npage 327  for an example.\n29.6.7 Setting the Boot Loader Lock Bits by SPM\nTo set the Boot Loader Lock bits and general Lock bits, write the desired data to R0, write\n\u201cX0001001\u201d to SPMCSR and execute SPM within four clock cycles after writing SPMCSR.\nSee Table 29-2 on page 321  and Table 29-3 on page 321  for how the different settings of the\nBoot Loader bits affect the Flash access.\nIf bits 5:0 in R0 are cleare d (zero), the corresponding Loc k bit will be programmed if an SPM\ninstruction is exec uted within four cycles after BLBSET and SPMEN are set in SPMCSR. The Z-\npointer is don\u2019t care during this operation, but fo r future compatibility it is recommended to load\nthe Z-pointer with 0x0001 (same as used for reading the lO\nck bits). For future compatibility it is\nalso recommended to set bits 7 and 6 in R0 to \u201c1\u201d when writing the Lock bits. When program-\nming the Lock bits the entire Flas h can be read during the operation.B i t 76543210\nR0 1 1 BLB12 BLB11 BLB02 BLB01 LB2 LB1\n\n325\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.8 EEPROM Write Prevents Writing to SPMCSR\nNote that an EEPROM write oper ation will block all software progra mming to Flash. Reading the\nFuses and Lock bits  from software will also  be prevented during the EEPROM write operation. It\nis recommended that the user checks the status bit (EEPE) in the EECR Register and verifies\nthat the bit is cleared before writing to the SPMCSR Register.\n29.6.9 Reading the Fuse and Lock Bits from Software\nIt is possible to read both the Fuse and Lock bits from software. To read the Lock bits, load the\nZ-pointer with 0x0001 and set the BLBSET and SPMEN bits in SPMCSR. When an (E)LPM\ninstruction is executed within three CPU cycles after the BLBSET and SPMEN bits are set in\nSPMCSR, the value of the Lock bi ts will be loaded in the desti nation register. The BLBSET and\nSPMEN bits will auto-clear upon comple tion of reading the Lock bits  or if no (E)LPM instruction\nis executed within three CPU cycles or no SPM instruction is executed within four CPU cycles.\nWhen BLBSET and SPMEN are cleared, (E )LPM will work as described in the Instruction set\nManual .\nThe algorithm for reading the Fuse Low byte is  similar to the one described above for reading\nthe Lock bits. To read the Fuse Low byte, load the Z-pointer with 0x0000 and set the BLBSET\nand SPMEN bits in SPMCSR. When an (E)LPM instruction is executed within three cycles after\nthe BLBSET and SPMEN bits are set in the SPMC SR, the value of the Fuse Low byte (FLB) will\nbe loaded in the destination register as shown below. Refer to Table 30-5 on page 337  for a\ndetailed description and mapping of the Fuse Low byte.\nSimilarly, when reading the Fuse High byte, load 0x0003 in the Z-pointer. When an (E)LPM\ninstruction is executed within three cycles after the BLBSET and SPMEN bits are set in the\nSPMCSR, the value of the Fuse High byte (FHB ) will be loaded in the destination register as\nshown below. Refer to Table 30-4 on page 337  for detailed description and mapping of the Fuse\nHigh byte.\nWhen reading the Extended Fuse byte, load 0x0002 in the Z-pointer. When an (E)LPM instruc-\ntion is executed within three cycles after the BLBSET and SPMEN bits are set in the SPMCSR,\nthe value of the Exten ded Fuse byte (EFB) will be loaded in  the destination r egister as shown\nbelow. Refer to Table 30-3 on page 336  for detailed description and mapping of the Extended\nFuse byte.\nFuse and Lock bits that are programmed, will be read as zero. Fuse and Lock bits that are\nunprogrammed, will be  read as one.\n29.6.10 Reading the Signature Row from Software\nTo read the Signature Row from software, load the Z-pointer with the signature byte address\ngiven in Table 29-5 on page 326  and set the SIGRD and SPMEN bits in SPMCSR. When an\nLPM instruction is executed within three CPU cycles after the SIGRD and SPMEN bits are set inB i t 76543210\nRd \u2013 \u2013 BLB12 BLB11 BLB02 BLB01 LB2 LB1\nB i t 76543210\nRd FLB7 FLB6 FLB5 FLB4 FLB3 FLB2 FLB1 FLB0\nB i t 76543210\nRd FHB7 FHB6 FHB5 FHB4 FHB3 FHB2 FHB1 FHB0\nB i t 76543210\nRd \u2013 \u2013 \u2013 \u2013 \u2013 EFB2 EFB1 EFB0\n\n326\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nSPMCSR, the signature byte valu e will be loaded in the destin ation register. The SIGRD and\nSPMEN bits will auto-clear upon completion of re ading the Signature Row Lo ck bits or if no LPM\ninstruction is executed within three CPU cycles. When SIGRD and SPMEN are cleared, LPM will\nwork as described in the Instruction set Manual .\nNote: All other addresses are reserved for future use.\n29.6.11 Preventing Flash Corruption\nDuring periods of low VCC, the Flash program can be corrupted because the supply voltage is\ntoo low for the CPU and the Flash to operate properly. These issues are the same as for board\nlevel systems using the Flash, and the same design solutions should be applied.\nA Flash program corruption can be caused by two situ ations when the voltage is too low. First, a\nregular write sequence to the Flash requires a minimum voltage to operate correctly. Secondly,\nthe CPU itself can execute instruct ions incorrectly, if the supply voltage for executing instructions\nis too low.\nFlash corruption can easily be avoided by following these design recommendations (one is\nsufficient):\n1. If there is no need for a Boot Loader update in the system, program the Boot Loader Lock \nbits to prevent any Boot Loader software updates.\n2. Keep the AVR RESET active (low) during peri ods of insufficient power supply voltage. \nThis can be done by enabling the internal Brown-out Detector (BOD) if the operating volt-age matches the detection level. If not, an external low V\nCC reset protection circuit can be \nused. If a reset occurs while a write operatio n is in progress, the write operation will be \ncompleted provided that the power supply voltage is sufficient.\n3. Keep the AVR core in Power-down sleep mode during periods of low VCC. This will pre-\nvent the CPU from attempting to decode and execute instructions, effectively protecting the SPMCSR Register and thus the Flash from unintentional writes.\n29.6.12 Programming Time for Flash when Using SPM\nThe calibrated RC Oscillator is  used to time Flash accesses. Table 29-6  shows the typical pro-\ngramming time for Flash accesses from the CPU.Table 29-5. Signature Row Addressing\nSignature Byte Z-Pointer Address\nDevice Signature Byte 1 0x0000Device Signature Byte 2 0x0002\nDevice Signature Byte 3 0x0004\nRC Oscillator Calibration Byte 0x0001\nTable 29-6. SPM Programming Time\nSymbol Min Programming Time Max Programming Time\nFlash write (Page Erase, Page Write, and \nwrite Lock bits by SPM)3.7ms 4.5ms\n\n327\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.13 Simple Assembly Code Example for a Boot Loader\n;-the routine writes one page of data from RAM to Flash\n; the first data location in RAM is pointed to by the Y pointer; the first data location in Flash is pointed to by the Z-pointer\n;-error handling is not included\n;-the routine must be placed inside the Boot space; (at least the Do_spm sub routine). Only code inside NRWW section can\n; be read during Self-Programming (Page Erase and Page Write).\n;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24), \n; loophi (r25), spmcrval (r20)\n; storing and restoring of registers is not included in the routine; register usage can be optimized at the expense of code size\n;-It is assumed that either the interrupt table is moved to the Boot\n; loader section or that the interrupts are disabled.\n.equ PAGESIZEB = PAGESIZE*2 ;PAGESIZEB is page size in BYTES, not words\n.org SMALLBOOTSTART\nWrite_page:\n; Page Erase\nldi spmcrval, (1<<PGERS) | (1<<SPMEN)\ncall Do_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)call Do_spm\n; transfer data from RAM to Flash page buffer\nldi looplo, low(PAGESIZEB) ;init loop variable\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nWrloop:\nld r0, Y+\nld r1, Y+\nldi spmcrval, (1<<SPMEN)call Do_spm\nadiw ZH:ZL, 2\nsbiw loophi:looplo, 2 ;use subi for PAGESIZEB<=256brne Wrloop\n; execute Page Write\nsubi ZL, low(PAGESIZEB) ;restore pointer\nsbci ZH, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nldi spmcrval, (1<<PGWRT) | (1<<SPMEN)call Do_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\ncall Do_spm\n; read back and check, optional\nldi looplo, low(PAGESIZEB) ;init loop variable\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256subi YL, low(PAGESIZEB) ;restore pointer\nsbci YH, high(PAGESIZEB)\nRdloop:\nelpm r0, Z+\nld r1, Y+cpse r0, r1\njmp Error\nsbiw loophi:looplo, 1 ;use subi for PAGESIZEB<=256brne Rdloop\n\n328\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n; return to RWW section\n; verify that RWW section is safe to read\nReturn:\nin temp1, SPMCSRsbrs temp1, RWWSB ; If RWWSB is set, the RWW section is not ready yet\nret\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\ncall Do_spmrjmp Return\nDo_spm:\n; check for previous SPM complete\nWait_spm:\nin temp1, SPMCSRsbrc temp1, SPMEN\nrjmp Wait_spm\n; input: spmcrval determines SPM action; disable interrupts if enabled, store status\nin temp2, SREG\ncli; check that no EEPROM write access is present\nWait_ee:\nsbic EECR, EEPErjmp Wait_ee\n; SPM timed sequence\nout SPMCSR, spmcrvalspm\n; restore SREG (to enable interrupts if originally enabled)\nout SREG, temp2ret\n29.6.14 ATmega640 Boot Loader Parameters\nIn Table 29-7  through Table 29-9 on page 329 , the parameters used in the description of the\nSelf-Programming are given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .Table 29-7. Boot Size Configuration, ATmega640(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset\nAddress\n(Start Boot Loader Section)\n11512\nwords40x0000 - \n0x7DFF0x7E00 - \n0x7FFF0x7DFF 0x7E00\n101024\nwords80x0000 - \n0x7BFF0x7C00 - \n0x7FFF0x7BFF 0x7C00\n012048\nwords160x0000 - \n0x77FF0x7800 - \n0x7FFF0x77FF 0x7800\n004096\nwords320x0000 - \n0x6FFF0x7000 - \n0x7FFF0x6FFF 0x7000\n\n329\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page \n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .\nNote: 1. Z0: should be zero for all SPM commands, byte select for the (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.Table 29-8. Read- While-Write Limit, ATmega640\nSection(1)Pages Address\nRead- While-Write section (R WW) 224 0x0000 - 0x6FFF\nNo Read- While-Write section (NR WW) 32 0x7000 - 0x7FFF\nTable 29-9. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega640\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 14Most significant bit in the Program Counter. \n(The Program Counter is 15 bits PC[14:0]).\nPAGEMSB 6Most significant bit which is used to address \nthe words within one page (128 words in a \npage requires seven bits PC [6:0]).\nZPCMSB Z15Bit in Z-pointer that is mapped to PCMSB. \nBecause Z0 is not used, the ZPCMSB equals \nPCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. \nBecause Z0 is not used, the ZPAGEMSB \nequals PAGEMSB + 1.\nPCPAGE PC[14:7] Z15:Z8Program Counter page address: Page select, \nfor Page Erase and Page Write.\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, \nfor filling temporary buffer (must be zero \nduring Page Write operation).\n\n330\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n29.6.15 ATmega1280/1281 Boot Loader Parameters\nIn Table 29-10  and Table 29-11 , the parameters used in the description of the Self-Programming\nare given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page\n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .Table 29-10. Boot Size Configuration, ATmega1280/1281(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset Address\n(Start Boot LoaderSection)\n11512\nwords40x0000 - \n0xFDFF0xFE00 - \n0xFFFF0xFDFF 0xFE00\n101024\nwords80x0000 - \n0xFBFF0xFC00 - \n0xFFFF0xFBFF 0xFC00\n012048\nwords160x0000 - \n0xF7FF0xF800 - \n0xFFFF0xF7FF 0xF800\n004096\nwords320x0000 - \n0xEFFF0xF000 - \n0xFFFF0xEFFF 0xF000\nTable 29-11. Read- While-Write Limit, ATmega1280/1281\nSection(1)Pages Address\nRead- While-Write section (R WW) 480 0x0000 - 0xEFFF\nNo Read- While-Write section (NR WW) 32 0xF000 - 0xFFFF\nTable 29-12. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega1280/1281\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 15Most significant bit in the Program Counter. (The \nProgram Counter is 16 bits PC[15:0])\n\n331\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. Z0: should be zero for all SPM command s, byte select for t he (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.\n3. The Z-register is only 16 bits wide. Bit 16 is  located in the RAMPZ register in the I/O map.\n29.6.16 ATmega2560/2561 Boot Loader Parameters\nIn Table 29-13  through Table 29-15 on page 332 , the parameters used in the description of the\nSelf-Programming are given.\nNote: 1. The different BOOTSZ Fuse configurations are shown in Figure 29-2 on page 320 .PAGEMSB 6Most significant bit which is used to address the \nwords within one page (128 words in a page \nrequires seven bits PC [6:0]).\nZPCMSB Z16(3) Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPCMSB equals PCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPAGEMSB equals PAGEMSB + \n1.\nPCPAGE PC[15:7] Z16(3):Z8Program Counter page address: Page select, for \nPage Erase and Page Write\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, for \nfilling temporary buffer (must be zero during Page \nWrite operation)Table 29-12. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega1280/1281 (Continued)\nVariableCorresponding\nZ-value(2)Description(1)\nTable 29-13. Boot Size Configuration, ATmega2560/2561(1)BOOTSZ1\nBOOTSZ0\nBoot SizePages\nAppli-cation \nFlash Section\nBoot Loader \nFlash Section\nEnd Application \nSection\nBoot Reset Address\n(Start Boot LoaderSection)\n11512\nwords40x00000 - \n0x1FDFF0x1FE00 - \n0x1FFFF0x1FDFF 0x1FE00\n101024\nwords80x00000 - \n0x1FBFF0x1FC00 - \n0x1FFFF0x1FBFF 0x1FC00\n012048\nwords160x00000 - \n0x1F7FF0x1F800 - \n0x1FFFF0x1F7FF 0x1F800\n004096\nwords320x00000 - \n0x1EFFF0x1F000 - \n0x1FFFF0x1EFFF 0x1F000\n\n332\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: 1. For details about these two section, see \u201cNRWW \u2013 No Read- While-Write Section\u201d on page \n318 and \u201cRWW \u2013 Read- While-Write Section\u201d on page 318 .\nNotes: 1. Z0: should be zero for all SPM command s, byte select for t he (E)LPM instruction.\n2. See \u201cAddressing the Flash During Self-Programming\u201d on page 322  for details about the use of \nZ-pointer during Self-Programming.\n3. The Z-register is only 16 bits wide. Bit 16 is  located in the RAMPZ register in the I/O map.\n29.7 Register Description\n29.7.1 SPMCSR \u2013 Store Program Memory Control and Status Register\nThe Store Program Memory Control and Status Register contains the control bits needed to con-\ntrol the Boot Loader operations.\n\u0081 Bit 7 \u2013 SPMIE: SPM Interrupt Enable\nWhen the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM\nready interrupt will be enabled. The SPM ready In terrupt will be ex ecuted as long as the SPMEN\nbit in the SPMCSR Register is cleared.Table 29-14. Read- While-Write Limit, ATmega2560/2561\nSection(1)Pages Address\nRead- While-Write section (R WW) 992 0x00000 - 0x1EFFF\nNo Read- While-Write section (NR WW) 32 0x1F000 - 0x1FFFF\nTable 29-15. Explanation of different variables used in Figure 29-3 on page 322  and the map-\nping to the Z-pointer, ATmega2560/2561\nVariableCorresponding\nZ-value(2)Description(1)\nPCMSB 16Most significant bit in the Program Counter. (The \nProgram Counter is 17 bits PC[16:0]).\nPAGEMSB 6Most significant bit which is used to address the \nwords within one page (128 words in a page \nrequires seven bits PC [6:0]).\nZPCMSB Z17:Z16(3) Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPCMSB equals PCMSB + 1.\nZPAGEMSB Z7Bit in Z-pointer that is mapped to PCMSB. Because \nZ0 is not used, the ZPAGEMSB equals PAGEMSB + \n1.\nPCPAGE PC[16:7] Z17(3):Z8Program Counter page address: Page select, for \nPage Erase and Page Write.\nPCWORD PC[6:0] Z7:Z1Program Counter word address: Word select, for \nfilling temporary buffer (must be zero during Page Write operation).\nBit 7 6 5 4 3 2 1 0\n0x37 (0x57) SPMIE RWWSB SIGRD RWWSRE BLBSET PGWRT PGERS SPMEN SPMCSR\nRead/Write R/ W RR / W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n333\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 6 \u2013 RWWSB: Read-While-Write Section Busy\nWhen a Self-Programming (Page Erase or Page Write) operation to the R WW section is initi-\nated, the R WWSB will be set (one) by hardware. When the R WWSB bit is set, the R WW section\ncannot be accessed. The R WWSB bit will be cleared if the R WWSRE bit is written to one after a\nSelf-Programming operation is completed. Alternatively the R WWSB bit will automatically be\ncleared if a page load operation is initiated.\n\u0081 Bit 5 \u2013 SIGRD: Signature Row Read\nIf this bit is written to one at the same time as SPMEN, the next LPM instruction within three\nclock cycles will read a byte from the signatu re row into the dest ination register. see \u201cReading\nthe Signature Row from Software\u201d on page 325  for details. An SPM inst ruction within four cycles\nafter SIGRD and SPMEN are set will have no effect. This operation is reserved for future useand should not be used.\n\u0081 Bit 4 \u2013 RWWSRE: Read-While-Write Section Read Enable\nWhen programming (Page Erase or Page Write) to the R WW section, the R WW section is\nblocked for reading (the R WWSB will be set by hardware). To re-enable the R WW section, the\nuser software must wait unt il the programming is complet ed (SPMEN will be cl eared). Then, if\nthe RWWSRE bit is written to one at the same time  as SPMEN, the next SPM instruction within\nfour clock cycles re-enables the R WW section. The R WW section cannot be re-enabled while\nthe Flash is busy with a Page Erase or a Page Write (SPMEN is set). If the R WWSRE bit is writ-\nten while the Flash is being loaded, the Flas h load operation will abort and the data loaded will\nbe lost.\n\u0081 Bit 3 \u2013 BLBSET: Boot Lock Bit Set\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles sets Boot Lock bits, according to the data in R0. The data in R1 and the address in the Z-pointer are ignored. The BLBSET bit will autom atically be cleared upon completion of the Lock\nbit set, or if no SPM instruction is executed within four clock cycles.\nAn (E)LPM instructio n within three cycles after BLBSET and SPMEN are set in the SPMCSR\nRegister, will read either the Lock bits or the Fuse bits (depending on Z0 in th e Z-pointer) into the\ndestination register. See \u201cReading the Fuse and Lock Bits from Software\u201d on page 325  for\ndetails.\n\u0081 Bit 2 \u2013 PGWRT: Page Write\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes Page Write, with the data stored in the temporary buffer. The page address is\ntaken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PG WRT bit\nwill auto-clear upon co mpletion of a Page Write, or if no SPM instruction is executed within four\nclock cycles. The CPU is halted during the entire Page W\nrite operation if the NR WW section is\naddressed.\n\u0081 Bit 1 \u2013 PGERS: Page Erase\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes Page Erase. The page address is taken from the high part of the Z-pointer. The\ndata in R1 and R0  are ignored. The PGERS bi t will auto-clear upon comp letion of a Page Erase,\nor if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire\nPage Write operation if the NR WW section is addressed.\n\n334\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n\u0081 Bit 0 \u2013 SPMEN: Store Program Memory Enable\nThis bit enables the SPM instruction for the next four clock cycles. If written to one together with\neither R WWSRE, BLBSET, PG WRT\u2019 or PGERS, the following SPM instruction will have a spe-\ncial meaning, see description abo ve. If only SPMEN is written, the following SPM instruction will\nstore the value in R1:R0 in the temporary page buffer addressed by the Z-pointer. The LSB of\nthe Z-pointer is ignored. The SPMEN bit will aut o-clear upon completion of an SPM instruction,\nor if no SPM instruction is executed within four clock cycles. During Page Erase and Page Write,\nthe SPMEN bit remains high until the operation is completed.\nWriting any other combination than \u201c10001\u201d, \u201c01001\u201d, \u201c00101\u201d, \u201c00011\u201d or \u201c00001\u201d in the lower\nfive bits will have no effect.\nNote: Only one SPM instruction should be active at any time.\n\n335\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30. Memory Programming\n30.1 Program And Data Memory Lock Bits\nThe ATmega640/1280/1281/2560/2561 provides six Lock bits which can be left unprogrammed\n(\u201c1\u201d) or can be programmed (\u201c0\u201d) to obtain the additional features listed in Table 30-2 . The Lock\nbits can only be erased to \u201c1\u201d with the Chip Erase command.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmedTable 30-1. Lock Bit Byte(1)\nLock Bit Byte Bit No Description Default Value\n7 \u2013 1 (unprogrammed)\n6 \u2013 1 (unprogrammed)\nBLB12 5 Boot Lock bit 1 (unprogrammed)\nBLB11 4 Boot Lock bit 1 (unprogrammed)\nBLB02 3 Boot Lock bit 1 (unprogrammed)BLB01 2 Boot Lock bit 1 (unprogrammed)\nLB2 1 Lock bit 1 (unprogrammed)\nLB1 0 Lock bit 1 (unprogrammed)\nTable 30-2. Lock Bit Protection Modes(1)(2) \nMemory Lock Bits Protection Type\nLB Mode LB2 LB1\n1 1 1 No memory lock features enabled.\n21 0Further programming of the Flash and EEPROM is disabled in \nParallel and Serial Programming mode. The Fuse bits are \nlocked in both Serial and Parallel Programming mode.(1)\n30 0Further programming and verification of the Flash and EEPROM \nis disabled in Parallel and Serial Programming mode. The Boot \nLock bits and Fuse bits are locked in both Serial and Parallel Programming mode.\n(1)\nBLB0 Mode BLB02 BLB01\n11 1No restrictions for SPM or (E)LPM accessing the Application \nsection.\n2 1 0 SPM is not allowed to write to the Application section.\n30 0SPM is not allowed to write to  the Application section, and \n(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application section. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while executing from the Application section.\n40 1(E)LPM executing from the Boot Loader section is not allowed to \nread from the Application section. If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section.\n\n336\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. Program the Fuse bits and Boot Lock bits before programming the LB1 and LB2.\n2. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed.\n30.2 Fuse Bits\nThe ATmega640/1280/1281/2560/2561 has three Fuse bytes. Table 30-3  through Table 30-5 on\npage 337  describe briefly the functionality of all the fuses and how they are mapped into the\nFuse bytes. Note that the fuses are read as logical zero, \u201c0\u201d, if they are programmed.\nNote: 1. See \u201cSystem and Reset Characteristics\u201d on page 372  for BODLEVEL Fuse decoding.BLB1 Mode BLB12 BLB11\n11 1No restrictions for SPM or (E)LPM accessing the Boot Loader \nsection.\n2 1 0 SPM is not allowed to write to the Boot Loader section.\n30 0SPM is not allowed to write to the Boot Loader section, and \n(E)LPM executing from the Application section is not allowed to read from the Boot Loader sect ion. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while \nexecuting from the Boot Loader section.\n40 1(E)LPM executing from the Application section is not allowed to \nread from the Boot Loader sect ion. If Interrupt Vectors are \nplaced in the Application section, interrupts are disabled while executing from the Boot Loader section.Table 30-2. Lock Bit Protection Modes(1)(2)  (Continued)\nMemory Lock Bits Protection Type\nTable 30-3. Extended Fuse Byte\nExtended Fuse Byte Bit No Description Default Value\n\u20137 \u2013 1\n\u20136 \u2013 1\u20135 \u2013 1\n\u20134 \u2013 1\n\u20133 \u2013 1\nBODLEVEL2\n(1)2 Brown-out Detector trigger level 1 (unprogrammed)\nBODLEVEL1(1)1 Brown-out Detector trigger level 1 (unprogrammed)\nBODLEVEL0(1)0 Brown-out Detector trigger level 1 (unprogrammed)\n\n337\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. The SPIEN Fuse is not accessible in serial programming mode.\n2. The default value of BOOTSZ1:0 results in maximum Boot Size. See Table 29-7 on page 328  \nfor details.\n3. See \u201cWDTCSR \u2013 Watchdog Timer Control Register\u201d on page 67  for details.\n4. Never ship a product with the OCDEN Fuse prog rammed regardless of the setting of Lock bits \nand JTAGEN Fuse. A programmed OCDEN Fuse en ables some parts of the clock system to \nbe running in all sleep modes. This may increase the power consumption.\nNotes: 1. The default value of SUT1:0 results in maxi mum start-up time for the default clock source. See \n\u201cSystem and Reset Characteristics\u201d on page 372  for details.\n2. The default setting of CKSEL3:0 results in internal RC Oscillator @ 8 MHz. See Table 10-1 on \npage 41  for details.\n3. The CKOUT Fuse allow the system cl ock to be output on PORTE7. See \u201cClock Output Buffer\u201d \non page 49  for details.\n4. See \u201cSystem Clock Prescaler\u201d on page 49  for details.\nThe status of the Fuse bits is not affected by Chip Erase. Note that the Fuse bits are locked if\nLock bit1 (LB1) is programmed. Program the Fuse bits before programming the Lock bits.Table 30-4. Fuse High Byte\nFuse High Byte Bit No Description Default Value\nOCDEN(4)7 Enable OCD1 (unprogrammed, OCD \ndisabled)\nJTAGEN 6 Enable JTAG 0 (programmed, JTAG enabled)\nSPIEN(1)5Enable Serial Program and Data \nDownloading0 (programmed, SPI prog. \nenabled)\nWDTON(3)4 Watchdog Timer always on 1 (unprogrammed)\nEESAVE 3EEPROM memory is preserved \nthrough the Chip Erase1 (unprogrammed, EEPROM \nnot preserved)\nBOOTSZ1 2Select Boot Size (see Table 30-9 on \npage 339  for details)0 (programmed)(2)\nBOOTSZ0 1Select Boot Size (see Table 30-9 on \npage 339  for details)0 (programmed)(2)\nBOOTRST 0 Select Reset Vector 1 (unprogrammed)\nTable 30-5. Fuse Low Byte\nFuse Low Byte Bit No Description Default Value\nCKDIV8(4)7 Divide clock by 8 0 (programmed)\nCKOUT(3)6 Clock output 1 (unprogrammed)\nSUT1 5 Select start-up time 1 (unprogrammed)(1)\nSUT0 4 Select start-up time 0 (programmed)(1)\nCKSEL3 3 Select Clock source 0 (programmed)(2)\nCKSEL2 2 Select Clock source 0 (programmed)(2)\nCKSEL1 1 Select Clock source 1 (unprogrammed)(2)\nCKSEL0 0 Select Clock source 0 (programmed)(2)\n\n338\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.2.1 Latching of Fuses\nThe fuse values are latched when the device enters programming mode and changes of the\nfuse values will have no effect until the part leaves Programming mode. This does not apply tothe EESAVE Fuse which will take effect once it is  programmed. The fuse s are also latched on\nPower-up in Normal mode.\n30.3 Signature Bytes\nAll Atmel microcontrollers have a three-byte signature code which identifies the device. This\ncode can be read in both serial and parallel mode, also when the device is locked. The three\nbytes reside in a separate address space. For the ATmega640/1280/1281/2560/2561 the signa-\nture bytes are given in Table 30-6 .\n30.4 Calibration Byte\nThe ATmega640/1280/1281/2560/2561 has a byte calibration value for the internal RC Oscilla-\ntor. This byte resides in t he high byte of address 0x000 in the signature address space. During\nreset, this byte is automatically written into the OSCCAL Register to ensure correct frequency of\nthe calibrated RC Oscillator.\n30.5 Page Size\n30.6 Parallel Programming Paramete rs, Pin Mapping,  and Commands\nThis section describes how to parallel program and verify Flash Program memory, EEPROM\nData memory, Memory Lock bits, and Fuse bits in the ATmega640/1280/1281/2560/2561.\nPulses are assumed to be at least 250ns unless otherwise noted.Table 30-6. Device and JTAG ID\nPartSignature Bytes Address JTAG\n0x000 0x001 0x002 Part Number Manufacture ID\nATmega640 0x1E 0x96 0x08 9608 0x1F\nATmega1280 0x1E 0x97 0x03 9703 0x1F\nATmega1281 0x1E 0x97 0x04 9704 0x1FATmega2560 0x1E 0x98 0x01 9801 0x1F\nATmega2561 0x1E 0x98 0x02 9802 0x1F\nTable 30-7. No. of Words in a Page and No. of Pages in the Flash\nFlash Size Page Size PCWORDNo. of \nPages PCPAGE PCMSB\n128K words (256Kbytes) 128 words PC[6:0] 1024 PC[16:7] 16\nTable 30-8. No. of Words in a Page and No . of Pages in the EEPROM\nEEPROM Size Page Size PCWORDNo. of \nPages PCPAGE EEAMSB\n4Kbytes 8 bytes EEA[2:0] 512 EEA[11:3] 11\n\n339\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.6.1 Signal Names\nIn this section, some pins of the ATmega640/1280/1281/2560/2561 are referenced by signal\nnames describing their functionality during parallel programming, see Figure 30-1  and Table 30-\n9. Pins not described in the following table are referenced by pin names.\nThe XA1/XA0 pins determine the action executed  when the XTAL1 pin is given a positive pulse.\nThe bit coding is shown in Table 30-12 on page 340 .\nWhen pulsing WR or OE , the command loaded determines the action executed. The different\ncommands are shown in Table 30-13 on page 340 .\nFigure 30-1. Parallel Programming(1)\nNote: 1. Unused Pins should be left floating.\nTable 30-9. Pin Name Mapping\nSignal Name in \nProgramming Mode Pin Name I/O Function\nRDY/BSY PD1 O0: Device is busy programming, 1: Device is ready for \nnew command\nOE PD2 I Output Enable (Active low)\nWR PD3 I Write Pulse (Active low)\nBS1 PD4 I Byte Select 1\nXA0 PD5 I XTAL Action Bit 0XA1 PD6 I XTAL Action Bit 1\nPAGEL PD7 I Program Memory and EEPROM data Page Load\nBS2 PA0 I Byte Select 2\nDATA PB7-0 I/O Bi-directional Data bus (Output when OE is low\n)VCC+5V\nGNDXTAL1PD1\nPD2PD3PD4PD5PD6\n PB7 - PB0 DATA\nRESETPD7\n+12VBS1\nXA0XA1OERDY/ B SY\nPAGEL\nPA0WR\nBS2AVCC+5V\n\n340\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 30-10. BS2 and BS1 Encoding\nBS2 BS1Flash / EEPROM \nAddressFlash Data \nLoading / \nReadingFuse \nProgrammingReading Fuse \nand Lock Bits\n0 0 Low Byte Low Byte Low Byte Fuse Low Byte\n0 1 High Byte High Byte High Byte Lockbits\n10Extended High \nByteReserved Extended ByteExtended Fuse \nByte\n1 1 Reserved Reserved Reserved Fuse High Byte\nTable 30-11. Pin Values Used to Enter Programming Mode\nPin Symbol Value\nPAGEL Prog_enable[3] 0\nXA1 Prog_enable[2] 0XA0 Prog_enable[1] 0\nBS1 Prog_enable[0] 0\nTable 30-12. XA1 and XA0 Enoding\nXA1 XA0 Action when  XTAL1 is Pulsed\n0 0 Load Flash or EEPROM Address (High or low address byte determined \nby BS2 and BS1)\n0 1 Load Data (High or Low data byte for Flash determined by BS1)\n1 0 Load Command\n1 1 No Action, Idle\nTable 30-13. Command Byte Bit Encoding\nCommand Byte Command Executed\n1000 0000 Chip Erase\n0100 0000 Write Fuse bits\n0010 0000 Write Lock bits\n0001 0000 Write Flash\n0001 0001 Write EEPROM\n0000 1000 Read Signature Bytes and Calibration byte\n0000 0100 Read Fuse and Lock bits\n0000 0010 Read Flash\n0000 0011 Read EEPROM\n\n341\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.7 Parallel Programming\n30.7.1 Enter Programming Mode\nThe following algorithm puts the devi ce in parallel programming mode:\n1. Apply 4.5V - 5.5V between VCC and GND.\n2. Set RESET  to \u201c0\u201d and toggle XTAL1 at least six times.\n3. Set the Prog_enable pins listed in Table 30-11 on page 340  to \u201c0000\u201d and wait at least\n100ns.\n4. Apply 11.5V - 12.5V to RESET . Any activity on Prog_enable pins within 100ns after +12V\nhas been applied to RESET , will cause the device to fa il entering programming mode.\n5.Wait at least 50\u00b5s before sending a new command.\n30.7.2 Considerations for Efficient Programming\nThe loaded command and address are retained in the device during programming. For efficient\nprogramming, the following should be considered.\n\u0081 The command needs only be loaded once when writing or reading multiple memory \nlocations\n\u0081 Skip writing the data value 0xFF , that is t he contents of the enti re EEPROM (unless the \nEESAVE Fuse is programmed) and Flash after a Chip Erase\n\u0081 Address high byte needs only be loaded before programming or reading a new 256 word \nwindow in Flash or 256 byte EEPROM. This consideration also applies to Signature bytes reading\n30.7.3 Chip Erase\nThe Chip Erase will erase the Flash and EEPROM\n(1) memories plus Lock bits. The Lock bits are\nnot reset until the program memory has been completely erased. The Fuse bits are notchanged. A Chip Erase must be perfor med before the Flas h and/or EEPROM are\nreprogrammed.\nNote: 1. The EEPRPOM memory is preserved duri ng Chip Erase if the EESAVE Fuse is programmed.\nLoad Command \u201cChip Erase\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set BS1 to \u201c0\u201d.3. Set DATA to \u201c1000 0000\u201d. This is the command for Chip Erase.4. Give XTAL1 a positive pulse. This loads the command.5. Give WR\n a negative pulse. This starts the Chip Erase. RDY/BSY  goes low.\n6.Wait until RDY/BSY  goes high before loading a new command.\n30.7.4 Programming the Flash\nThe Flash is organized in pages, see Table 30-7 on page 338 . When programming the Flash,\nthe program data is latched into a page buffer. This allows one page of program data to be pro-\ngrammed simultaneously. The following procedure describes how to program the entire Flashmemory:\nA. Load Command \u201c Write Flash\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set BS1 to \u201c0\u201d.\n\n342\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n3. Set DATA to \u201c0001 0000\u201d. This is the command for Write Flash.\n4. Give XTAL1 a positive pulse. This loads the command.B. Load Address Low byte (Address bits 7:0)\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c00\u201d. This selects the address low byte.3. Set DATA = Address low byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address low byte.C. Load Data Low Byte\n1. Set XA1, XA0 to \u201c01\u201d. This enables data loading.\n2. Set DATA = Data low byte (0x00 - 0xFF).3. Give XTAL1 a positive pulse. This loads the data byte.D. Load Data High Byte\n1. Set BS1 to \u201c1\u201d. This selects high data byte.\n2. Set XA1, XA0 to \u201c01\u201d. This enables data loading.3. Set DATA = Data high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the data byte.E. Latch Data\n1. Set BS1 to \u201c1\u201d. This selects high data byte.\n2. Give PAGEL a positive pulse. This latches the data bytes. See Figure 30-3 on page 343\nfor signal waveforms.\nF. Repeat B through E until the entire buffer is filled or until all data within the page is loaded\nWhile the lower bits in the address are mapped to words within the page, the higher bits address\nthe pages within the FLASH . This is illustrated in Figure 30-2 on page 343 . Note that if less than\neight bits are required to address words in the page (pagesize < 256), the most significant bit(s)\nin the address low byte are used to address the page when performing a Page Write.\nG. Load Address High byte (Address bits15:8)1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c01\u201d. This selects the address high byte.3. Set DATA = Address high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address high byte.H. Load Address Extended High byte (Address bits 23:16)\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading.\n2. Set BS2, BS1 to \u201c10\u201d. This selects the address extended high byte.3. Set DATA = Address extended high byte (0x00 - 0xFF).4. Give XTAL1 a positive pulse. This loads the address high byte.I. Program Page\n1. Set BS2, BS1 to \u201c00\u201d.\n2. Give WR\n a negative pulse. This starts programming of the entire page of data. RDY/BSY\ngoes low.\n3.Wait until RDY/BSY  goes high (see Figure 30-3 on page 343  for signal waveforms).\nJ. Repeat B through I until the entire Flash is programmed or until all data has been\nprogrammed\n\n343\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nK. End Page Programming\n1. 1. Set XA1, XA0 to \u201c10\u201d. This enables command loading.\n2. Set DATA to \u201c0000 0000\u201d. This is the command for No Operation.3. Give XTAL1 a positive pulse. This loads the command, and the internal write signals are\nreset.\nFigure 30-2. Addressing the Flash Which is Organized in Pages\n(1)\nNote: 1. PCPAGE and PC WORD are listed in Table 30-7 on page 338 .\nFigure 30-3. Programming the Flash Waveforms(1)\nNote: 1. \u201cXX\u201d is don\u2019t care. The letters refer to the programming description above.\n30.7.5 Programming the EEPROM\nThe EEPROM is organized in pages, see Table 30-8 on page 338 . When programming the\nEEPROM, the program data is latche d into a page buffer. This al lows one page of data to be\nprogrammed simultaneously. Th e programming algorithm for th e EEPROM data memory is asPROGRAM MEMORYWORD ADDRE SS\nWITHIN A PAGEPAGE ADDRE SS\nWITHIN THE FLA SH\nINSTRUCTION WORDPAGEPCWORD[PAGEM SB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCM SB PAGEM SB\nPROGRAM\nCOUNTER\nRDY/B SYWR\nOERESET+12V\nPAGELBS20x10 ADDR. LOW ADDR. HIGHDATADATA LOW DATA HIGH ADDR. LOW DATA LOW DATA HIGH\nXA1\nXA0\nBS1\nXTAL1XX XX XXABCD E BCD E GF\nADDR. EXT.HH I\n\n344\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nfollows (refer to \u201cProgramming the Flash\u201d on page 341  for details on Command, Address and\nData loading):\n1. A: Load Command \u201c0001 0001\u201d.\n2. G: Load Address High Byte (0x00 - 0xFF).3. B: Load Address Low Byte (0x00 - 0xFF).4. C: Load Data (0x00 - 0xFF).5. E: Latch data (give PAGEL a positive pulse).K: Repeat 3 through 5 until the entire buffer is filled\nL: Program EEPROM page1. Set BS2, BS1 to \u201c00\u201d.\n2. Give WR\n a negative pulse. This starts pr ogramming of the EEPROM page. RDY/BSY\ngoes low.\n3.Wait until to RDY/BSY  goes high before programming the next page (see Figure 30-4  for\nsignal waveforms).\nFigure 30-4. Programming the EEPROM Waveforms\n30.7.6 Reading the Flash\nThe algorithm for reading the Flash memory is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0010\u201d.\n2. H: Load Address Extended Byte (0x00- 0xFF).3. G: Load Address High Byte (0x00 - 0xFF).4. B: Load Address Low Byte (0x00 - 0xFF).5. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The Flash word low byte can now be read at DATA.\n6. Set BS to \u201c1\u201d. The Flash word high byte can now be read at DATA.7. Set OE\n to \u201c1\u201d.RDY/B SYWR\nOERESET +12V\nPAGEL\nBS20x11 ADDR. HIGHDATAADDR. LOW DATA ADDR. LOW DATA XX\nXA1\nXA0\nBS1\nXTAL1XXAGBC E B C E LK\n\n345\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.7.7 Reading the EEPROM\nThe algorithm for reading the EEPROM memory is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0011\u201d.\n2. G: Load Address High Byte (0x00 - 0xFF).3. B: Load Address Low Byte (0x00 - 0xFF).4. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The EEPROM Data byte can now be read at DATA.\n5. Set OE  to \u201c1\u201d.\n30.7.8 Programming the Fuse Low Bits\nThe algorithm for programming the Fuse Low bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n30.7.9 Programming the Fuse High Bits\nThe algorithm for programming the Fuse High bits is as follows (refer to \u201cProgramming the\nFlash\u201d on page 341  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. Set BS2, BS1 to \u201c01\u201d. This selects high data byte.4. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n5. Set BS2, BS1 to \u201c00\u201d. This selects low data byte.\n30.7.10 Programming the Extended Fuse Bits\nThe algorithm for programming the Extended Fuse bits is as follows (refer to \u201cProgramming the\nFlash\u201d on page 341  for details on Command and Data loading):\n1. 1. A: Load Command \u201c0100 0000\u201d.\n2. 2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit.3. 3. Set BS2, BS1 to \u201c10\u201d. This selects extended data byte.4. 4. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\n5. 5. Set BS2, BS1 to \u201c00\u201d. This selects low data byte.\n\n346\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-5. Programming the FUSES Waveforms\n30.7.11 Programming the Lock Bits\nThe algorithm for programming the Lock bits is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Data loading):\n1. A: Load Command \u201c0010 0000\u201d.\n2. C: Load Data Low Byte. Bit n = \u201c0\u201d programs the Lock bit. If LB mode 3 is programmed\n(LB1 and LB2 is programmed), it is not possible to program the Boot Lock bits by anyExternal Programming mode.\n3. Give WR\n a negative pulse and wait for RDY/BSY  to go high.\nThe Lock bits can only be cleared by executing Chip Erase.\n30.7.12 Reading the Fuse and Lock Bits\nThe algorithm for reading the Fuse and Lock bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 341  for details on Command loading):\n1. A: Load Command \u201c0000 0100\u201d.\n2. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c00\u201d. The status of the Fuse Low bits can now be read at\nDATA (\u201c0\u201d means programmed).\n3. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c11\u201d. The status of the Fuse High bits can now be read at\nDATA (\u201c0\u201d means programmed).\n4. Set OE to \u201c0\u201d, and BS2, BS1 to \u201c10\u201d. The status of the Extended Fuse bits can now be\nread at DATA (\u201c0\u201d means programmed).\n5. Set OE  to \u201c0\u201d, and BS2, BS1 to \u201c01\u201d. The status of the Lock bits can now be read at DATA\n(\u201c0\u201d means programmed).\n6. Set OE  to \u201c1\u201d.RDY/B SYWR\nOERESET +12V\nPAGEL0x40DATADATA XX\nXA1\nXA0\nBS1\nXTAL1AC\n0x40 DATA XXACWrite Fuse Low byte Write Fuse high byte\n0x40 DATA XXACWrite Extended Fuse byte\nBS2\n\n347\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-6. Mapping Between BS1, BS2 and the Fuse and Lock Bits During Read\n30.7.13 Reading the Signature Bytes\nThe algorithm for reading the Signatur e bytes is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d.\n2. B: Load Address Low Byte (0x00 - 0x02).3. Set OE\n to \u201c0\u201d, and BS to \u201c0\u201d. The selected Signature byte can now be read at DATA.\n4. Set OE  to \u201c1\u201d.\n30.7.14 Reading the Calibration Byte\nThe algorithm for reading the Calibration byte is as follows (refer to \u201cProgramming the Flash\u201d on\npage 341  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d.\n2. B: Load Address Low Byte, 0x00.3. Set OE\n to \u201c0\u201d, and BS1 to \u201c1\u201d. The Calibration byte can now be read at DATA.\n4. Set OE  to \u201c1\u201d.\n30.7.15 Parallel Programming Characteristics\nFigure 30-7. Parallel Programming Timing, Including some General Timing RequirementsLock Bits 0\n1\nBS2Fuse High Byte0\n1\nBS1DATAFuse Low Byte 0\n1\nBS2Extended Fuse Byte\nData & Contol\n(DATA, XA0/1, B S1, BS2)XTAL1tXHXL\ntWLWHtDVXH tXLDX\ntPLWL\ntWLRHWR\nRDY/B SYPAGEL tPHPLtPLBX tBVPHtXLWL\ntWLBXtBVWL\nWLRL\n\n348\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-8. Parallel Programming Timing, Loading Sequence with Timing Requirements(1)\nNote: 1. The timing requirements shown in Figure 30-7 on page 347  (that is, tDVXH , tXHXL, and tXLDX)\nalso apply to loading operation.\nFigure 30-9. Parallel Programming Timing, Reading Sequence (within the Same Page) with \nTiming Requirements(1)\nNote: 1. The timing requirements shown in Figure 30-7 on page 347  (that is, tDVXH , tXHXL, and tXLDX) \nalso apply to reading operation.\nTable 30-14. Parallel Programming Characteristics, VCC = 5V \u00b110% \nSymbol Parameter Min Typ Max Units\nVPP Programming Enable Voltage 11.5 12.5 V\nIPP Programming Enable Current 250 \u03bcAXTAL1\nPAGELtPLXH XLXHttXLPH\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRE SS\n(LOW BYTE)LOAD DATA \n(LOW BYTE)LOAD DATA\n(HIGH BYTE)LOAD DATA LOAD ADDRE SS\n(LOW BYTE)\nXTAL1\nOE\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRE SS\n(LOW BYTE)READ DATA \n(LOW BYTE)READ DATA\n(HIGH BYTE)LOAD ADDRE SS\n(LOW BYTE)\ntBVDV\ntOLDVtXLOL\ntOHDZ\n\n349\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1.  tWLRH is valid for the Write Flash, Write EEPROM, Write Fuse bits and Write Lock bits \ncommands.\n2.  tWLRH_CE is valid for the Chip Erase command.\n30.8 Serial Downloading\nBoth the Flash and EEPROM memo ry arrays can be programmed using a serial programming\nbus while RESET  is pulled to GND. The serial programming interface consists of pins SCK, PDI\n(input) and PDO (output). After RESET  is set low, the Programming Enable instruction needs to\nbe executed first before program/erase operations can be executed. NOTE, in Table 30-15 on\npage 350 , the pin mapping for serial programming is  listed. Not all packages use the SPI pins\ndedicated for the internal Serial Peripheral Interface - SPI.tDVXH Data and Control Valid before XTAL1 High 67\nnstXLXH XTAL1 Low to XTAL1 High 200\ntXHXL XTAL1 Pulse Width High 150\ntXLDX Data and Control Hold after XTAL1 Low 67\ntXLWL XTAL1 Low to WR Low 0\ntXLPH XTAL1 Low to PAGEL high 0\ntPLXH PAGEL low to XTAL1 high 150\ntBVPH BS1 Valid before PAGEL High 67\ntPHPL PAGEL Pulse Width High 150\ntPLBX BS1 Hold after PAGEL Low 67\ntWLBX BS2/1 Hold after WR Low 67\ntPLWL PAGEL Low to WR Low 67\ntBVWL BS2/1 Valid to WR Low 67\ntWLWH WR Pulse Width Low 150\ntWLRL WR Low to RDY/BSY  Low 0 1 \u03bcs\ntWLRH WR Low to RDY/BSY  High(1)3.7 4.5\nms\ntWLRH_CE WR Low to RDY/BSY  High for Chip Erase(2)7.5 9\ntXLOL XTAL1 Low to OE  Low 0\nnstBVDV BS1 Valid to DATA valid 0 250\ntOLDV OE Low to DATA Valid 250\ntOHDZ OE High to DATA Tri-stated 250Table 30-14. Parallel Programming Characteristics, VCC = 5V \u00b110%  (Continued)\nSymbol Parameter Min Typ Max Units\n\n350\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.8.1 Serial Programming Pin Mapping\nFigure 30-10. Serial Programming and Verify(1)\nNotes: 1. If the device is clocked by the internal Oscillator, it is no need to connect a clock source to the \nXTAL1 pin.\n2. VCC - 0.3V < AVCC < VCC + 0.3V, however, AVCC should always be within 1.8V - 5.5V. When \nprogramming the EEPROM, an auto-erase cycle is built into the self-timed programming oper-\nation (in the Serial mode ONL Y) and there is  no need to first execute the Chip Erase \ninstruction. The Chip Erase operation turns the content of every memory location in both the \nProgram and EEPROM arrays into 0xFF .\nDepending on CKSEL Fuses, a valid clock must be present. The minimum low and high periods\nfor the serial clock (SCK) input are defined as follows:\nLow: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck >= 12MHz\nHigh: > 2 CPU clock cycles for fck < 12MHz, 3 CPU clock cycles for fck >= 12MHz\n30.8.2 Serial Programming Algorithm\nWhen writing serial data to the ATmega640/1280/1281/2560/2561, data is clocked on the rising\nedge of SCK.\nWhen reading data from the ATmega640/1280/1281/2560/2561, data is clocked on the falling\nedge of SCK. See Figure 30-12 on page 353  for timing details.Table 30-15. Pin Mapping Serial Programming\nSymbolPins \n(TQFP-100)Pins\n(TQFP-64) I/O Description\nPDI PB2 PE0 I Serial Data in\nPDO PB3 PE1 O Serial Data out\nSCK PB1 PB1 I Serial Clock\nVCC\nGNDXT AL1SCKPDOPDI\nRESET+1.8V - 5.5V\nAVCC+1.8V - 5.5V(2)\n\n351\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTo program and verify the ATmega640/1280/1281/2560/2561 in the serial programming mode,\nthe following sequence is recommended (see four byte instruction formats in Table 30-17 on\npage 352 ):\n1. Power-up sequence:\nApply power between VCC and GND while RESET  and SCK are set to \u201c0\u201d. In some sys-\ntems, the programmer can not guarantee that SCK is held low during power-up. In thiscase, RESET\n must be given a positive pulse of at least two CPU clock cycles duration\nafter SCK has been set to \u201c0\u201d.\n2.Wait for at least 20ms and enable serial programming by sending the Programming\nEnable serial instruction to pin PDI.\n3. The serial programming instructions will not wo rk if the communication is out of synchro-\nnization. When in sync. the second byte (0x53), w ill echo back when issuing the third\nbyte of the Programming Enable instruction. Whether the echo is correct or not, all four\nbytes of the instruction must be transmitted. If the 0x53 did not echo back, give RESET  a\npositive pulse and issue a new Programming Enable command.\n4. The Flash is programmed one page at a time. The memory page is loaded one byte at a\ntime by supplying the 7 LSB of the address and data together with the Load ProgramMemory Page instruction. To ensure correct loading of the page, the data low byte mustbe loaded before data high byte is applied for a given address. The Program MemoryPage is stored by loading the Write Program Memory Page instruction with the address\nlines 15:8. Before issuing this command, make sure the instruction Load ExtendedAddress Byte has been used to define the MSB of the address. The extended addressbyte is stored until the command is re-issued, that is, the command needs only be issuedfor the first page, and when crossing the 64K Word boundary. If polling (\nRDY/BSY ) is not\nused, the user must wait at least tWD_FLASH  before issuing the next page (see Table 30-\n16). Accessing the serial programming interface before the Flash write operation com-\npletes can result in incorrect programming.\n5. The EEPROM array is programmed one byte at  a time by supplyin g the address and data\ntogether with the appropriate Write instruction. An EEPROM memory location is first\nautomatically erased before new data is written. If polling is not used, the user must waitat least t\nWD_EEPROM before issuing the next byte (see Table 30-16 ). In a chip erased\ndevice, no 0xFFs in the data file(s) need to be programmed.\n6. Any memory location can be verified by using the Read instruction which returns the con-\ntent at the selected address at serial output PDO. When reading the Flash memory, use\nthe instruction Load Extended Address Byte to define the upper address byte, which isnot included in the Read Program Memory instruction. The extended address byte isstored until the command is re-issued, that is, the command needs only be issued for thefirst page, and when crossing the 64K Word boundary.\n7. At the end of the programming session, RESET\n can be set high to commence normal\noperation.\n8. Power-off sequence (if needed):\nSet RESET  to \u201c1\u201d.\nTur n VCC power off.\nTable 30-16. Minimum Wait Delay Before Writing the Next Flas h or EEPROM Location\nSymbol Minimum Wait Delay\ntWD_FLASH 4.5ms\ntWD_EEPROM 3.6ms\ntWD_ERASE 9.0ms\n\n352\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.8.3 Serial Programming Instruction set\nTable 30-17  and Figure 30-11 on page 353  describes the Instruction set.\nNotes: 1. Not all instructions are applicable for all parts.\n2. a = address.3. Bits are programmed \u20180\u2019, unprogrammed \u20181\u2019.\n4. To ensure future compatibility, unused Fuses and Lock bits should be unprogrammed (\u20181\u2019).\n5. Refer to the correspondig section for Fuse and Lock bits, Calibration and Signature bytes and \nPage size.\n6. See htt://www.atmel.com/avr  for Application Notes regarding programming and programmers.\nIf the LSB in RDY/BSY data byte out is \u20181\u2019,  a programming operation is still pending. Wait until\nthis bit returns \u20180\u2019 before the ne xt instruction is carried out.Table 30-17. Serial Programming Instruction Set\nInstruction/OperationInstruction Format\nByte 1 Byte 2 Byte 3 Byte 4\nProgramming Enable $AC $53 $00 $00\nChip Erase (Program Memory/EEPROM) $AC $80 $00 $00Poll RDY/BSY\n$F0 $00 $00 data byte out\nLoad Instructions\nLoad Extended Address byte(1)$4D $00 Extended adr $00\nLoad Program Memory Page, High byte $48 $00 adr LSB high data byte in\nLoad Program Memory Page, Low byte $40 $00 adr LSB low data byte in\nLoad EEPROM Memory Page (page access) $C1 $00 0000 000aa data byte inRead Instructions\nRead Program Memory, High byte $28 adr MSB adr LSB high data byte out\nRead Program Memory, Low byte $20 adr MSB adr LSB low data byte outRead EEPROM Memory $A0 0000 aaaa aaaa aaaa data byte out\nRead Lock bits $58 $00 $00 data byte out\nRead Signature Byte $30 $00 0000 000aa data byte outRead Fuse bits $50 $00 $00 data byte out\nRead Fuse High bits $58 $08 $00 data byte out\nRead Extended Fuse Bits $50 $08 $00 data byte outRead Calibration Byte $38 $00 $00 data byte out\nWrite Instructions\nWrite Program Memory Page $4C adr MSB adr LSB $00\nWrite EEPROM Memory $C0 0000 aaaa aaaa aaaa data byte in\nWrite EEPROM Memory Page (page access) $C2 0000 aaaa aaaa 00 $00\nWrite Lock bits $AC $E0 $00 data byte in\nWrite Fuse bits $AC $A0 $00 data byte in\nWrite Fuse High bits $AC $A8 $00 data byte in\nWrite Extended Fuse Bits $AC $A4 $00 data byte in\n\n353\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nWithin the same page, the low data byte must be loaded prior to the high data byte.\nAfter data is loaded to the page buffer, program the EEPROM page, see Figure 30-11 .\nFigure 30-11. Serial Programming Instruction example\n30.8.4 Serial Programming Characteristics\nFor characteristics of the Serial Programming module, see \u201cSPI Timing Characteristics\u201d on page\n375.\nFigure 30-12. Serial Programming WaveformsByte 1 Byte 2 Byte 3 Byte 4\nAdr LSB\nBit 15  B        0Serial Programming Instruction\nProgram Memory/\nEEPROM MemoryPage 0\nPage 1\nPage 2\nPage N-1Page BufferWrite Program Memory Page/\nWrite EEPROM Memory PageLoad Program Memory Page (High/Low Byte)/\nLoad EEPROM Memory Page (page access)\nByte 1 Byte 2 Byte 3 Byte 4\nBit 15  B        0Adr MSB\nPage Offset\nPage NumberAdr MMSSB A AAdrr LLSBB\nMSB\nMSBLSB\nLSB\nSERIAL CLOCK INPUT\n(SCK)SERIAL DATA INPUT\n (MO SI)\n(MISO)\nSAMPLESERIAL DATA OUTPUT\n\n354\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9 Programming via the JTAG Interface\nProgramming through the JTAG interface requires control of the four JTAG specific pins: TCK,\nTMS, TDI, and TDO. Control of the reset and clock pins is not required.\nTo be able to use the JTAG interface, the JTAGEN Fuse must be programmed. The device is\ndefault shipped with the fuse pr ogrammed. In addition, the JTD bit in MCUCR must be cleared.\nAlternatively, if the JTD bit is set, the external reset can be fo rced low. Then, the JTD bit will be\ncleared after two chip clocks, and the JTAG pins are available for programming. This provides a\nmeans of using the JTAG pins as normal port pi ns in Running mode while still allowing In-Sys-\ntem Programming via the JTAG interface. Note th at this technique can not be used when using\nthe JTAG pins for Boundary-scan or On-chip Debug. In these cases the JTAG pins must be ded-icated for this purpose.\nDuring programming the clock frequency of the TCK Input must be less than the maximum fre-\nquency of the chip. The System Clock Prescaler can not be used to divide the TCK Clock Inputinto a sufficiently low frequency.\nAs a definition in this datasheet, the LSB is shifted in and out first of all Shift Registers.\n30.9.1 Programming Specific JTAG Instructions\nThe Instruction Register is 4-bit wide, supporting up to 16 instructions. The JTAG instructions\nuseful for programming are listed below.\nThe OPCODE for each instruction is shown behind the instruction name in hex format. The text\ndescribes which Data Register is selected as  path between TDI and TDO for each instruction.\nThe Run-Test/Idle state of the TAP controller is used to generate internal clocks. It can also be\nused as an idle state between JTAG sequences . The state machine sequence for changing the\ninstruction word is shown in Figure 30-13 on page 355 .\n\n355\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-13. State Machine Sequence for Changing the Instruction Word\n30.9.2 AVR_RESET (0xC)\nThe AVR specific public JTAG in struction for setting the AVR device in the Reset mode or taking\nthe device out from the Reset mode. The TAP controller is not reset by this instruction. The onebit Reset Register is selected as Data Register. No te that the reset will be active as long as there\nis a logic \u201cone\u201d in the Reset Chain. The output from this chain is not latched.\nThe active states are:\u0081Shift-DR : The Reset Register is shifted by the TCK input\n30.9.3 PROG_ENABLE (0x4)\nThe AVR specific public JTAG instruction for enabling programming via the JTAG port. The 16-\nbit Programming Enable Register is selected as Data Register. The active states are the\nfollowing:\n\u0081Shift-DR : The programming enable signature is shifted into the Data Register\n\u0081Update-DR : The programming enable signature is compared to the correct value, and \nProgramming mode is entered if the signature is validTest-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n356\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.4 PROG_COMMANDS (0x5)\nThe AVR specific public JTAG instruction for entering programming commands via the JTAG\nport. The 15-bit Programming Command Register is selected as Data Register. The active\nstates are the following:\n\u0081Capture-DR : The result of the previous command is loaded into the Data Register\n\u0081Shift-DR : The Data Register is shifted by the TCK input, shifting out the result of the \nprevious command and shifting in the new command\n\u0081Update-DR : The programming command is applied to the Flash inputs\n\u0081Run-Test/Idle : One clock cycle is generated, executing the applied command\n30.9.5 PROG_PAGELOAD (0x6)\nThe AVR specific public JTAG instruction to directly load the Flash data page via the JTAG port.\nAn 8-bit Flash Data Byte Register is selected as  the Data Register. This is physically the 8 LSBs\nof the Programming Command Register. The active states are the following:\n\u0081Shift-DR : The Flash Data Byte Register is shifted by the TCK input.\n\u0081Update-DR : The content of the Flash Data Byte Register is copied into a temporary register. \nA write sequence is initiated that within 11 TCK cycles loads the content of the temporary register into the Flash page buffer. The AVR automatically alternates between writing the low and the high byte for each new Update-DR state, starting with the low byte for the first Update-DR encountered after entering the PROG_PAGELOAD command. The Program Counter is pre-incremented before  writing the low byte, except fo r the first written byte. This \nensures that the first data is written to the address set up by PROG_COMMANDS, and loading the last location in the page buffer does not make the program counter increment into the next page.\n30.9.6 PROG_PAGEREAD (0x7)\nThe AVR specific public JTAG instruction to dire ctly capture the Flash content via the JTAG port.\nAn 8-bit Flash Data Byte Register is selected as  the Data Register. This is physically the 8 LSBs\nof the Programming Command Register. The active states are the following:\n\u0081Capture-DR : The content of the selected Flash byte is captured into the Flash Data Byte \nRegister. The AVR automatically alternates between reading the low and the high byte for each new Capture-DR state, starting with the low byte for the first Capture-DR encountered after entering the PROG_PAGEREAD command. The Program Counter is post-incremented after reading each high byte, including the first read byte. This ensures that the first data is \ncaptured from the first address set up by PROG_COMMANDS, and reading the last location in the page makes the program counter increment into the next page.\n\u0081Shift-DR : The Flash Data Byte Register is shifted by the TCK input.\n30.9.7 Data Registers\nThe Data Registers are selected by the JTAG  instruction registers described in section \u201cPro-\ngramming Specific JTAG Instructions\u201d on page 354 . The Data Registers relevant for\nprogramming operations are:\n\u0081 Reset Register\n\u0081 Programming Enable Register\u0081 Programming Command Register\u0081 Flash Data Byte Register\n\n357\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.8 Reset Register\nThe Reset Register is a Test Data Register used to reset the part during programming. It is\nrequired to reset the part before entering Programming mode.\nA high value in the Reset Register  corresponds to pulling the external  reset low. The part is reset\nas long as there is a high value present in t he Reset Register. Depending on the Fuse settings\nfor the clock options, the part will remain reset for a Re set Time-out period (refer to \u201cClock\nSources\u201d on page 41 ) after releasing the Reset Register. The output from this Data Register is\nnot latched, so the reset will take place immediately, as shown in Figure 28-2 on page 304 .\n30.9.9 Programming Enable Register\nThe Programming Enable Register is a 16-bit regist er. The contents of this register is compared\nto the programming enable signature, binary code 0b1010_0011_0111_0000. When the con-\ntents of the register is equal to the programming enable signature, programming via the JTAG\nport is enabled. The register is reset to 0 on Power-on Reset, and should always be reset when\nleaving Programming mode.\nFigure 30-14. Programming Enable Register\n30.9.10 Programming Command Register\nThe Programming Command Register is a 15-bit regist er. This register is us ed to serially shift in\nprogramming commands, and to serially shift out the result of the previous command, if any. TheJTAG Programming Instruction Set is shown in Table 30-18 on page 359 . The state sequence\nwhen shifting in the programmi ng commands is  illustrated in Figure 30-16 on page 362 .TDI\nTDOD\nA\nT\nA=DQ\nClockDR & PROG_ENABLEProgramming Enable0xA370\n\n358\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-15. Programming Command Register\nTDI\nTDOS\nT\nR\nO\nBES\nA\nDDR\nESS\n/\nD\nA\nT\nAFlash\nEEPROM\nFuses\nLock Bits\n\n359\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 30-18. JTAG Programming Instruction \nSet  a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, o = data out, \ni = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n1a. Chip Erase0100011_10000000\n0110001_100000000110011_100000000110011_10000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx\n1b. Poll for Chip Erase Complete 0110011_10000000 xxxxx ox_xxxxxxxx (2)\n2a. Enter Flash Write 0100011_00010000 xxxxxxx_xxxxxxxx\n2b. Load Address Extended High Byte 0001011_ cccccccc xxxxxxx_xxxxxxxx (10)\n2c. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx\n2d. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n2e. Load Data Low Byte 0010011_ iiiiiiii xxxxxxx_xxxxxxxx\n2f. Load Data High Byte 0010111_ iiiiiiii xxxxxxx_xxxxxxxx\n2g. Latch Data0110111_00000000\n1110111_000000000110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx(1)\n2h. Write Flash Page0110111_00000000\n0110101_00000000\n0110111_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n2i. Poll for Page Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n3a. Enter Flash Read 0100011_00000010 xxxxxxx_xxxxxxxx\n3b. Load Address Extended High Byte 0001011_ cccccccc xxxxxxx_xxxxxxxx (10)\n3c. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx\n3d. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n3e. Read Data Low and High Byte0110010_00000000\n0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\nxxxxxxx_ ooooooooLow byte\nHigh byte\n4a. Enter EEPROM Write 0100011_00010001 xxxxxxx_xxxxxxxx\n4b. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx (10)\n4c. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n4d. Load Data Byte 0010011_ iiiiiiii xxxxxxx_xxxxxxxx\n4e. Latch Data0110111_00000000\n1110111_000000000110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx(1)\n4f. Write EEPROM Page0110011_00000000\n0110001_00000000\n0110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n\n360\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n4g. Poll for Page Write Complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n5a. Enter EEPROM Read 0100011_00000011 xxxxxxx_xxxxxxxx\n5b. Load Address High Byte 0000111_ aaaaaaaa xxxxxxx_xxxxxxxx (10)\n5c. Load Address Low Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n5d. Read Data Byte0110011_ bbbbbbbb\n0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n6a. Enter Fuse Write 0100011_01000000 xxxxxxx_xxxxxxxx\n6b. Load Data Low Byte(6)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6c. Write Fuse Extended Byte0111011_00000000\n0111001_00000000\n0111011_00000000\n0111011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6d. Poll for Fuse Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n6e. Load Data Low Byte(7)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6f. Write Fuse High Byte0110111_00000000\n0110101_00000000\n0110111_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6g. Poll for Fuse Write Complete 0110111_00000000 xxxxx ox_xxxxxxxx (2)\n6h. Load Data Low Byte(7)0010011_ iiiiiiii xxxxxxx_xxxxxxxx (3)\n6i. Write Fuse Low Byte0110011_00000000\n0110001_00000000\n0110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n6j. Poll for Fuse Write Complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n7a. Enter Lock Bit Write 0100011_00100000 xxxxxxx_xxxxxxxx\n7b. Load Data Byte(9)0010011_11 iiiiii xxxxxxx_xxxxxxxx (4)\n7c. Write Lock Bits0110011_00000000\n0110001_000000000110011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxxxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxx(1)\n7d. Poll for Lock Bit Write complete 0110011_00000000 xxxxx ox_xxxxxxxx (2)\n8a. Enter Fuse/Lock Bit Read 0100011_00000100 xxxxxxx_xxxxxxxx\n8b. Read Extended Fuse Byte\n(6)0111010_00000000\n0111011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n8c. Read Fuse High Byte(7)0111110_00000000\n0111111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ ooooooooTable 30-18. JTAG Programming Instruction  (Continued)\nSet  (Continued) a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, \no = data out, i = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n\n361\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This command sequence is not required if the seven MSB are correctly set by the previous command sequence (which is \nnormally the case).\n2. Repeat until o = \u201c1\u201d.\n3. Set bits to \u201c0\u201d to program the corresponding Fuse, \u201c1\u201d to unprogram the Fuse.\n4. Set bits to \u201c0\u201d to program the corresponding Lock bit, \u201c1\u201d to leave the Lock bit unchanged.5. \u201c0\u201d = programmed, \u201c1\u201d = unprogrammed.\n6. The bit mapping for Fuses Extended byte is listed in Table 30-3 on page 336 .\n7. The bit mapping for Fuses High byte is listed in Table 30-4 on page 337 .\n8. The bit mapping for Fuses Low byte is listed in Table 30-5 on page 337 .\n9. The bit mapping for Lock bits byte is listed in Table 30-1 on page 335 .\n10. Address bits exceeding PCMSB and EEAMSB ( Table 30-7 on page 338  and Table 30-8 on page 338 ) are don\u2019t care.\n11. All TDI and TDO sequences are represented by binary digits (0b...).8d. Read Fuse Low Byte\n(8)0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n8e. Read Lock Bits(9)0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xx oooooo(5)\n8f. Read Fuses and Lock Bits0111010_00000000\n0111110_000000000110010_00000000\n0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo\nxxxxxxx_ oooooooo(5)\nFuse Ext. byteFuse High byte\nFuse Low byte\nLock bits\n9a. Enter Signature Byte Read 0100011_00001000 xxxxxxx_xxxxxxxx\n9b. Load Address Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n9c. Read Signature Byte0110010_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n10a. Enter Calibration Byte Read 0100011_00001000 xxxxxxx_xxxxxxxx10b. Load Address Byte 0000011_ bbbbbbbb xxxxxxx_xxxxxxxx\n10c. Read Calibration Byte0110110_00000000\n0110111_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_ oooooooo\n11a. Load No Operation Command0100011_00000000\n0110011_00000000xxxxxxx_xxxxxxxx\nxxxxxxx_xxxxxxxxTable 30-18. JTAG Programming Instruction  (Continued)\nSet  (Continued) a = address high bits, b = address low bits, c = address extended bits, H = 0 - Low byte, 1 - High Byte, \no = data out, i = data in, x = don\u2019t care\nInstruction TDI Sequence TDO Sequence Notes\n\n362\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 30-16. State Machine Sequence for Changing/Reading the Data Word\n30.9.11 Flash Data Byte Register\nThe Flash Data Byte Register provides an ef ficient way to load the entire Flash page buffer\nbefore executing Page Write, or to read out/verify the content of the Flash. A state machine sets\nup the control signals to the Flash and senses the strobe signals from the Flash, thus only the\ndata words need to be shifted in/out.\nThe Flash Data Byte Register actually consists of the 8-bit scan chain and a 8-bit temporary reg-\nister. During page load, the Update-DR state copies the content of the scan chain over to the\ntemporary register and initiates a write sequence that within 11 TCK cycles loads the content of\nthe temporary register into the Flash page bu ffer. The AVR automatically alternates between\nwriting the low and the high byte for each new Update-DR state, starting with the low byte for the\nfirst Update-DR encountered after entering the PROG_PAGELOAD command. The Program\nCounter is pre-incremented before writing the low byte, except for the first written byte. Thisensures that the first data is written to the address set up by PROG_COMMANDS, and loadingthe last location in the page buffer does not make the Program Counter increment into the next\npage.\nDuring Page Read, the content of the selected Flash byte is captured into the Flash Data Byte\nRegister during the Capture-DR state. The AVR  automatically alternates between reading the\nlow and the high byte for each new Capture-DR state, starting with the low byte for the first Cap-Test-Logic-Reset\nRun-Test/Idle\nShift-DR\nExit1-DR\nPause-DR\nExit2-DR\nUpdate-DRSelect-IR Scan\nCapture-IR\nShift-IR\nExit1-IR\nPause-IR\nExit2-IR\nUpdate-IRSelect-DR Scan\nCapture-DR01\n011 1\n00\n0011\n1 0110100\n1 0110100\n0 01 1\n\n363\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nture-DR encountered after entering the PROG_PAGEREAD command. The Program Counter is\npost-incremented after reading each high byte, including the first read byte. This ensures that\nthe first data is captured from the first ad dress set up by PROG_COMMANDS, and reading the\nlast location in the page makes the program counter increment into the next page.\nFigure 30-17. Flash Data Byte Register\nThe state machine controlling the Flash Data By te Register is clocked by TCK. During normal\noperation in which eight bits are shifted for eac h Flash byte, the clock cycles needed to navigate\nthrough the TAP controller automatically feeds the state machine for the Flash Data Byte Regis-\nter with sufficient number of clock pulses to complete its operation transparently for the user.\nHowever, if too few bits are shifted between each Update-DR state during page load, the TAPcontroller should stay in the Run-Test/Idle state for some TCK cycles to ensure that there are at\nleast 11 TCK cycles between each Update-DR state.\n30.9.12 Programming Algorithm\nAll references below of type \u201c1a\u201d, \u201c1b\u201d, and so on, refer to Table 30-18 on page 359 .\n30.9.13 Entering Programming Mode\n1. Enter JTAG instruction AVR_RESET and shift 1 in the Reset Register.\n2. Enter instruction PROG_ENABLE and shift 0b1010_0011_0111_0000 in the Program-\nming Enable Register.\n30.9.14 Leaving Programming Mode\n1. Enter JTAG instruction PROG_COMMANDS.2. Disable all programming instructions by using no operation instruction 11a.3. Enter instruction PROG_ENABLE and shift 0b0000_0000_0000_0000 in the program-\nming Enable Register.\n4. Enter JTAG instruction AVR_RESET and shift 0 in the Reset Register.TDI\nTDOD\nA\nT\nAFlash\nEEPROM\nFuses\nLock BitsSTROBE S\nADDRE SSState\nMachine\n\n364\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n30.9.15 Performing Chip Erase\n1. Enter JTAG instruction PROG_COMMANDS.2. Start Chip Erase using pr ogramming instruction 1a.\n3. Poll for Chip Erase complete using programming instruction 1b, or wait for t\nWLRH_CE  (refer\nto Table 30-14 on page 348 ).\n30.9.16 Programming the Flash\nBefore programming the Flash a Chip Erase must be performed, see \u201cPerforming Chip Erase\u201d\non page 364.\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash write using programming instruction 2a.3. Load address Extended High byte using programming instruction 2b.4. Load address High byte using programming instruction 2c.5. Load address Low byte using programming instruction 2d.6. Load data using programming instructions 2e, 2f and 2g.7. Repeat steps 5 and 6 for all instruction words in the page.8.Write the page using programming instruction 2h.\n9. Poll for Flash write complete using programming instruction 2i, or wait for t\nWLRH (refer to\nTable 30-14 on page 348 ).\n10. Repeat steps 3 to 9 until all data have been programmed.A more efficient data transfer can be achieved using the PROG_PAGELOAD instruction:\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash write using programming instruction 2a.3. Load the page address using programming instructions 2b, 2c and 2d. PC WORD (refer\nto Table 30-7 on page 338 ) is used to address within one page and must be written as 0.\n4. Enter JTAG instruction PROG_PAGELOAD.5. Load the entire page by shifting in all instruction words in the page byte-by-byte, starting\nwith the LSB of the first instruction in the page and ending with the MSB of the lastinstruction in the page. Use Update-DR to copy the contents of the Flash Data Byte Reg-\nister into the Flash page location and to auto-increment the Program Counter before\neach new word.\n6. Enter JTAG instruction PROG_COMMANDS.7.Write the page using programming instruction 2h.\n8. Poll for Flash write complete using programming instruction 2i, or wait for t\nWLRH (refer to\nTable 30-14 on page 348 ).\n9. Repeat steps 3 to 8 until all data have been programmed.\n30.9.17 Reading the Flash\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Flash read using programming instruction 3a.3. Load address using programming instructions 3b, 3c and 3d.4. Read data using programming instruction 3e.5. Repeat steps 3 and 4 until all data have been read.\n\n365\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nA more efficient data transfer can be ac hieved using the PROG_PAGEREAD instruction:\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable Flash read using programming instruction 3a.3. Load the page address using programming instructions 3b, 3c and 3d. PC WORD (refer\nto Table 30-7 on page 338 ) is used to address within one page and must be written as 0.\n4. Enter JTAG instruction PROG_PAGEREAD.5. Read the entire page (or Flash) by shifting out all instruction words in the page (or Flash),\nstarting with the LSB of the first instruction in the page (Flash) and ending with the MSBof the last instruction in the page (Flash). The Capture-DR state both captures the datafrom the Flash, and also auto-increments the program counter after each word is read.Note that Capture-DR comes before the shift-DR state. Hence, the first byte which isshifted out contains valid data.\n6. Enter JTAG instruction PROG_COMMANDS.7. Repeat steps 3 to 6 until all data have been read.\n30.9.18 Programming the EEPROM\nBefore programming the EEPROM a Chip Erase must be performed, see \u201cPerforming Chip\nErase\u201d on page 364 .\n1. Enter JTAG instruction PROG_COMMANDS.\n2. Enable EEPROM write using programming instruction 4a.3. Load address High byte using programming instruction 4b.4. Load address Low byte using programming instruction 4c.5. Load data using programming instructions 4d and 4e.6. Repeat steps 4 and 5 for all data bytes in the page.7.Write the data using programming instruction 4f.\n8. Poll for EEPROM write complete using pr ogramming instruction 4g, or wait for t\nWLRH\n(refer to Table 30-14 on page 348 ).\n9. Repeat steps 3 to 8 until all data have been programmed.\nNote that the PROG_ PAGELOAD instruction can not be us ed when program ming the EEPROM.\n30.9.19 Reading the EEPROM\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable EEPROM read using programming instruction 5a.3. Load address using programming instructions 5b and 5c.4. Read data using programming instruction 5d.5. Repeat steps 3 and 4 until all data have been read.Note that the PROG_PAGEREAD instructio n can not be used when reading the EEPROM.\n30.9.20 Programming the Fuses\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Fuse write using programming instruction 6a.3. Load data high byte using programming instru ctions 6b. A bit value of \u201c0\u201d will program the\ncorresponding fuse, a \u201c1\u201d will unprogram the fuse.\n4.Write Fuse High byte using programming instruction 6c.\n\n366\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5. Poll for Fuse write complete using prog ramming instruction 6d, or wait for tWLRH (refer to\nTable 30-14 on page 348 ).\n6. Load data low byte using programming inst ructions 6e. A \u201c0\u201d will pr ogram the fuse, a \u201c1\u201d\nwill unprogram the fuse.\n7.Write Fuse low byte using programming instruction 6f.\n8. Poll for Fuse write complete using prog ramming instruction 6g, or wait for tWLRH (refer to\nTable 30-14 on page 348 ).\n30.9.21 Programming the Lock Bits\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Lock bit write using programming instruction 7a.3. Load data using prog ramming instructions 7b. A bit va lue of \u201c0\u201d will program the corre-\nsponding lock bit, a \u201c1\u201d will leave the lock bit unchanged.\n4.Write Lock bits using programming instruction 7c.\n5. Poll for Lock bit write complete using programming instruction 7d, or wait for t\nWLRH (refer\nto Table 30-14 on page 348 ).\n30.9.22 Reading the Fuses and Lock Bits\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Fuse/Lock bit read using programming instruction 8a.3. To read all Fuses and Lock bits, use programming instruction 8e.\nTo only read Fuse High byte, use programming instruction 8b.To only read Fuse Low byte, use programming instruction 8c.To only read Lock bits, use programming instruction 8d.\n30.9.23 Reading the Signature Bytes\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Signature byte read using programming instruction 9a.3. Load address 0x00 using programming instruction 9b.4. Read first signature byte using programming instruction 9c.5. Repeat steps 3 and 4 with address 0x01 and address 0x02 to read the second and third\nsignature bytes, respectively.\n30.9.24 Reading the Calibration Byte\n1. Enter JTAG instruction PROG_COMMANDS.2. Enable Calibration byte read using programming instruction 10a.3. Load address 0x00 using programming instruction 10b.4. Read the calibration byte using programming instruction 10c.\n\n367\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31. Electrical Characteristics\nAbsolute Maximum Ratings*\n31.1 DC CharacteristicsOperating Temperature.................................. -55 \u00b0C to +125 \u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or \nother conditions beyond those indicated in the \noperational sections of th is specification is not \nimplied. Exposure to absolute maximum rating \nconditions for extended periods may affect \ndevice reliability.Storage Temperature ..................................... -65\u00b0C to +150\u00b0C\nVoltage on any Pin except RESET\nwith respect to Ground ................................-0.5V to VCC+0.5V\nVoltage on RESET with respect to Ground......-0.5V to +13.0V\nMaximum Operating Voltage ............................................ 6.0VDC Current per I/O Pin ................................................ 40.0mA\nDC Current \nVCC and GND Pins................................. 200.0mA\nTA = -40 \u00b0C to 85 \u00b0C, VCC = 1.8V to 5.5V (unless otherwise noted) \nSymbol Parameter Condition Min. Typ. Max. Units\nVILInput Low Voltage,Except \nXTAL1 and Reset pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V-0.5\n-0.50.2VCC(1)\n0.3VCC(1)\nVVIL1Input Low Voltage,\nXTAL1 pinVCC = 1.8V - 5.5V -0.5 0.1VCC(1)\nVIL2Input Low Voltage, \nRESET pinVCC = 1.8V - 5.5V -0.5 0.1VCC(1)\nVIHInput High Voltage, \nExcept XTAL1 and \nRESET pinsVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.7VCC(2)\n0.6VCC(2)VCC + 0.5\nVCC + 0.5\nVIH1Input High Voltage, \nXTAL1 pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.8VCC(2)\n0.7VCC(2)VCC + 0.5\nVCC + 0.5\nVIH2Input High Voltage, \nRESET pinVCC = 1.8V - 5.5V 0.9VCC(2)VCC + 0.5\nVOLOutput Low Voltage(3),\nExcept RESET pinIOL = 20mA, VCC = 5V\nIOL = 10mA, VCC = 3V0.9\n0.6\nVOHOutput High Voltage(4),\nExcept RESET pinIOH = -20mA, VCC = 5V\nIOH = -10mA, VCC = 3V4.2\n2.3\nIILInput Leakage\nCurrent I/O PinVCC = 5.5V, pin low\n(absolute value)1\n\u00b5A\nIIHInput Leakage\nCurrent I/O PinVCC = 5.5V, pin high\n(absolute value)1\nRRST Reset Pull-up Resistor 30 60\nk\u03a9\nRPU I/O Pin Pull-up Resistor 20 50\n\n368\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. \"Max\" means the highest value where the pin is guaranteed to be read as low.\n2. \"Min\" means the lowest value where the pin is guaranteed to be read as high.\n3. Although each I/O port can sink more than the test conditi ons (20mA at VCC = 5V, 10mA at VCC = 3V) under steady state \nconditions (non-transient), th e following must be observed:\nATmega1281/2561:\n1.)The sum of all IOL, for ports A0-A7, G2, C4-C7 should not exceed 100mA.\n2.)The sum of all IOL, for ports C0-C3,  G0-G1, D0-D7 should not exceed 100mA.\n3.)The sum of all IOL, for ports G3-G5,  B0-B7, E0-E7 should not exceed 100mA.\n4.)The sum of all IOL, for ports F0-F7 should not exceed 100mA.\nATmega640/1280/2560:1.)The sum of all IOL, for ports J0-J 7, A0-A7, G2 should not exceed 200mA.\n2.)The sum of all IOL, for ports C0-C7, G0 -G1, D0-D7, L0-L7 s hould not exceed 200mA.\n3.)The sum of all IOL, for ports G3-G4,  B0-B7, H0-B7 should not exceed 200mA.\n4.)The sum of all IOL, for ports E0-E7, G5 should not exceed 100mA.\n5.)The sum of all IOL, for ports F0-F7, K0-K7 should not exceed 100mA.\nIf IOL exceeds the test condition, VOL may exceed the related sp ecification. Pins are not guar anteed to sink current greater \nthan the listed test condition.\n4. Although each I/O port can source more than the test co nditions (20mA at VCC = 5V, 10mA at VCC = 3V) under steady \nstate conditions (non-transient), the following must be observed:ATmega1281/2561:\n1)The sum of all IOH, for ports A0-A7, G2, C4-C7 should not exceed 100mA.\n2)The sum of all IOH, for ports C0-C3, G0-G1, D0-D7 should not exceed 100mA.\n3)The sum of all IOH, for ports G3-G5, B0-B7, E0-E7 should not exceed 100mA.\n4)The sum of all IOH, for ports F0-F7 should not exceed 100mA.ATmega640/1280/2560:\n1)The sum of all IOH, for ports J0-J7, G2, A0-A7 should not exceed 200mA.\n2)The sum of all IOH, for ports C0-C7, G0 -G1, D0-D7, L0-L7 should not exceed 200mA.\n3)The sum of all IOH, for ports G3-G4, B0-B7, H0-H7 should not exceed 200mA.\n4)The sum of all IOH, for ports E0-E7, G5 should not exceed 100mA.I\nCCPower Supply Current(5)Active 1MHz, VCC = 2V\n(ATmega640/1280/2560/1V)0.5 0.8\nmAActive 4MHz, VCC = 3V\n(ATmega640/1280/2560/1L)3.2 5\nActive 8MHz, VCC = 5V\n(ATmega640/1280/1281/2560/2561)10 14\nIdle 1MHz, VCC = 2V\n(ATmega640/1280/2560/1V)0.14 0.22\nIdle 4MHz, VCC = 3V\n(ATmega640/1280/2560/1L)0.7 1.1\nIdle 8MHz, VCC = 5V\n(ATmega640/1280/1281/2560/2561)2.7 4\nPower-down modeWDT enabled, VCC = 3V <5 15\n\u00b5A\nWDT disabled, VCC = 3V <1 7.5\nVACIOAnalog Comparator \nInput Offset VoltageVCC = 5V\nVin = VCC/2<10 40 mV\nIACLKAnalog Comparator \nInput Leakage CurrentVCC = 5V\nVin = VCC/2-50 50 nA\ntACIDAnalog Comparator \nPropagation DelayVCC = 2.7V\nVCC = 4.0V750\n500nsTA = -40 \u00b0C to 85 \u00b0C, VCC = 1.8V to 5.5V (unless otherwise noted)  (Continued)\nSymbol Parameter Condition Min. Typ. Max. Units\n\n369\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5)The sum of all IOH, for ports F0-F7, K0-K7 should not exceed 100mA.\nIf IOH exceeds the test condition, VOH ma y exceed the related specification. Pins  are not guaranteed to source current \ngreater than the listed test condition.\n5. Values with \u201cPRR1 \u2013 Power Reduction Register 1\u201d  enabled (0xFF).\n31.2 Speed Grades\nMaximum frequency is depending on VCC. As shown in Figure 31-1  trough Figure 31-4 on page\n370, the Maximum Frequency vs. VCC curve is linear between 1.8V < VCC < 2.7V and between\n2.7V < VCC < 4.5V.\n31.2.1 8MHz\nFigure 31-1. Maximum Frequency vs. VCC, ATmega640V/1280V/1281V/2560V/2561V\nFigure 31-2. Maximum Frequency vs. VCC when also No-Read- While-Write Section(1), \nATmega2560V/ATmega2561V, is used\nNote: 1. When only using the Read- While-Write Section of the program memory, a higher speed can \nbe achieved at low voltage, see \u201cRead- While-Write and No Read- While-Write Flash Sections\u201d \non page 317  for addresses.8 MHz\n4 MHz\n1.8V 2.7V 5.5VSafe Operating Area\n8 MHz\n2 MHz\n1.8V 2.7V 5.5VSafe Operating Area\n\n370\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.2.2 16 MHz\nFigure 31-3. Maximum Frequency vs. VCC, ATmega640/ATmega1280/ATmega1281\nFigure 31-4. Maximum Frequency vs. VCC, ATmega2560/ATmega256116 MHz\n8 MHz\n2.7V 4.5V 5.5VSafe Operating Area\n16 MHz\n4.5V 5.5VSafe Operating Area\n\n371\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.3 Clock Characteristics\n31.3.1 Calibrated Internal RC Oscillator Accuracy\nNotes: 1. Voltage range for ATmega640V/1281V/1280V/2561V/2560V.\n2. Voltage range for ATmega640/1281/1280/2561/2560.\n31.3.2 External Clock Drive Waveforms\nFigure 31-5. External Clock Drive Waveforms\n31.4 External Clock DriveTable 31-1. Calibration Accuracy of Internal RC Oscillator\nFrequency VCC Temperature Calibration Accuracy\nFactory Calibration 8.0MHz 3V 25 \u00b0C\u00b1 1 0 %\nUser Calibration 7.3MHz - 8.1MHz1.8V - 5.5V(1)\n2.7V - 5.5V(2) -40\u00b0C - 85 \u00b0C\u00b1 1 %\nVIL1VIH1\nTable 31-2. External Clock Drive\nSymbol ParameterVCC = 1.8V - 5.5V VCC = 2.7V - 5.5V VCC = 4.5V - 5.5V\nUnits Min. Max. Min. Max. Min. Max.\n1/tCLCLOscillator \nFrequency02080 1 6 M H z\ntCLCL Clock Period 500 125 62.5\nns tCHCX High Time 200 50 25\ntCLCX Low Time 200 50 25\ntCLCH Rise Time 2.0 1.6 0.5\n\u03bcs\ntCHCL Fall Time 2.0 1.6 0.5\n\u0394tCLCLChange in period \nfrom one clock \ncycle to the next22 2 %\n\n372\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.5 System and Reset Characteristics\nNote: 1. The Power-on Reset will not work unless the supply voltage has been below VPOT (falling).\n31.5.1 Standard Power-On Reset\nThis implementation of power-on reset existed in early versions of\nATmega640/1280/1281/2560/2561. The table below de scribes the characteristics of this power-\non reset and it is valid for the following devices only:\n\u0081 ATmega640: revision A\n\u0081 ATmega1280: revision A\u0081 ATmega1281: revision A\u0081 ATmega2560: revision A to E\u0081 ATmega2561: revision A to E\nTable 31-4. Characteristics of Standard Power-On Reset. T\nA= -40 to +85\u00b0C.\nNotes: 1. Values are guidelines only.\n2. Threshold where device is released from reset when voltage is rising.\n3. The power-on reset threshold voltage (falling) will not work unless the supply voltage has been\nbelow VPOT.Table 31-3. Reset, Brown-out and Internal voltage CharacteristicsCharacteristics\nSymbol Parameter Condi tion Min Typ Max Units\nVRST RESET  Pin Threshold Voltage 0.2 VCC 0.9VCC V\ntRST Minimum pulse width on RESET  Pin 2.5 \u00b5s\nVHYST Brown-out Detector Hysteresis 50 mV\ntBOD Min Pulse Width on Brown-out Reset 2 \u00b5s\nVBG Bandgap reference voltage VCC=2.7V, TA= 25\u00b0C 1.0 1.1 1.2 V\ntBG Bandgap reference start-up time VCC=2.7V, TA= 25\u00b0C4 0 7 0 \u00b5 s\nIBG Bandgap reference current consumption VCC=2.7V, TA= 25\u00b0C1 0 \u00b5 A\nSymbol Parameter Min.(1)Typ.(1)Max.(1)Units\nVPOTPower-on Reset Threshold Voltage (rising)(2)0.7 1.0 1.4 V\nPower-on Reset Threshold Voltage (falling)(3)0.05 0.9 1.3 V\nVPSR Power-on slope rate 0.01 4.5 V/ms\n\n373\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.5.2 Enhanced Power-On Reset\nThis implementation of power-on reset exists in newer versions of\nATmega640/1280/1281/2560/2561. The table below de scribes the characteristics of this power-\non reset and it is valid for the following devices only:\n\u0081 ATmega640: revision B and newer\n\u0081 ATmega1280: revision B and newer\u0081 ATmega1281: revision B and newer\u0081 ATmega2560: revision F and newer\u0081 ATmega2561: revision F and newerTable 31-5. Characteristics of Enhanced Power-On Reset. T\nA= -40 to +85\u00b0C.\nNotes: 1. Values are guidelines only.\n2. Threshold where device is released from reset when voltage is rising.\n3. The power-on reset threshold voltage (falling) will not work unless the supply voltage has been\nbelow VPOT.\nNote: 1. VBOT may be below nominal minimum operating voltage for some devices. For devices where this is the case, the device is \ntested down to VCC = VBOT during the production test. This guarantees  that a Brown-Out Reset will occur before VCC drops to \na voltage where correct operation of the microcontroller is no longer guaran teed. The test is performed using \nBODLEVEL = 110 for 4MHz operation of ATmega640V/1280V/ 1281V/2560V/2561V, BODLEVEL = 101 for 8MHz operation \nof ATmega640V/1280V/1281V/2560V/2561V  and ATmega640/1280/1281, and BODLEVEL = 100 for 16MHz operation of \nATmega640/1280/1281/2560/2561.\n31.6 2-wire Serial Inte rface Characteristics\nTable 31-7 on page 374  describes the requirements for devices connected to the 2-wire Serial\nBus. The ATmega640/1280/1281/2560/2561 2-wire Serial Interface meets or exceeds these\nrequirements under the noted conditions.\nTiming symbols refer to Figure 31-6 on page 375 .Symbol Parameter Min.(1)Typ.(1)Max.(1)Units\nVPOTPower-on Reset Threshold Voltage (rising)(2)1.1 1.4 1.6 V\nPower-on Reset Threshold Voltage (falling)(3)0.6 1.3 1.6 V\nVPSR Power-On Slope Rate 0.01 V/ms\nTable 31-6. BODLEVEL Fuse Coding(1)\nBODLEVEL 2:0 Fuses Min VBOT Typ VBOT Max VBOT Units\n111 BOD Disabled110 1.7 1.8 2.0\nV 101 2.5 2.7 2.9\n100 4.1 4.3 4.5011\nReserved010\n001000\n\n374\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. In ATmega640/1280/1281/2560/2561, this parameter is characterized and not 100% tested.\n2. Required only for fSCL > 100kHz.\n3. Cb = capacitance of one bus line in pF .\n4. fCK = CPU clock frequency.Table 31-7. 2-wire Serial Bus Requirements \nSymbol Parameter Condition Min Max Units\nVIL Input Low-voltage -0.5 0.3 VCC\nVVIH Input High-voltage 0.7 VCC VCC + 0.5\nVhys(1)Hysteresis of Schmitt Trigger Inputs 0.05 VCC(2)\u2013\nVOL(1)Output Low-voltage 3mA sink current 0 0.4\ntr(1)Rise Time for both SDA and SCL20 + \n0.1Cb(3)(2) 300\nnstof(1)Output Fall Time from VIHmin to VILmax 10pF < Cb < 400pF(3) 20 + \n0.1Cb(3)(2) 250\ntSP(1)Spikes Suppressed by Input Filter 0 50(2)\nIi Input Current each I/O Pin 0.1VCC < Vi < 0.9VCC -10 10 \u00b5A\nCi(1)Capacitance for each I/O Pin \u2013 10 pF\nfSCL SCL Clock FrequencyfCK(4) > max(16fSCL, \n250kHz)(5) 0 400 kHz\nRp Value of Pull-up resistorfSCL \u2264 100kHz\nfSCL > 100kHz\ntHD;STA Hold Time (repeated) START ConditionfSCL \u2264 100kHz 4.0 \u2013\n\u00b5sfSCL > 100kHz 0.6 \u2013\ntLOW Low Period of the SCL ClockfSCL \u2264 100kHz(6)4.7 \u2013\nfSCL > 100kHz(7)1.3 \u2013\ntHIGH High period of the SCL clockfSCL \u2264 100kHz 4.0 \u2013\nfSCL > 100kHz 0.6 \u2013\ntSU;STA Set-up time for a repeated START conditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 0.6 \u2013\ntHD;DAT Data hold timefSCL \u2264 100kHz 0 3.45\nfSCL > 100kHz 0 0.9\ntSU;DAT Data setup timefSCL \u2264 100kHz 250 \u2013\nfSCL > 100kHz 100 \u2013\ntSU;STO Setup time for STOP conditionfSCL \u2264 100kHz 4.0 \u2013\nfSCL > 100kHz 0.6 \u2013\ntBUFBus free time between a STOP and START \nconditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 1.3 \u2013VCC0.4V\u2013\n3mA----------------------------1000ns\nCb-------------------\n\u03a9\nVCC0.4V\u2013\n3mA----------------------------300 ns\nCb----------------- -\n\n375\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n5. This requirement applies to all ATme ga640/1280/1281/2560/2561 2-wire Serial Interface operation. Other devices con-\nnected to the 2-wire Serial Bus need only obey the general fSCL requirement.\n6. The actual low period generated by the ATmega640/ 1280/1281/2560/2561 2-wire Serial Interface is (1/fSCL - 2/fCK), thus fCK \nmust be greater than 6MHz for the low time requirement to be strictly met at fSCL = 100kHz.\n7. The actual low period generated by the ATmega640/1280/1281/2560/2561 2-wire Serial Interface is (1/fSCL - 2/fCK), thus the \nlow time requirement will not be strictly met for fSCL > 308kHz when fCK = 8MHz. Still, ATmega640/1280/1281/2560/2561 \ndevices connected to the bus may communicate at fu ll speed (400kHz) with other ATmega640/1280/1281/2560/2561 \ndevices, as well as any other device with a proper tLOW acceptance margin.\nFigure 31-6. 2-wire Serial Bus Timing\n31.7 SPI Timing Characteristics\nSee Figure 31-7 on page 376  and Figure 31-8 on page 376  for details.\nNote: 1. In SPI Programming mode the minimum SCK high/low period is:\n- 2 tCLCL for fCK < 12MHz\n- 3 tCLCL for fCK > 12MHztSU;STAtLOWtHIGH\ntLOWtof\ntHD;STA tHD;DAT tSU;DATtSU;STO\ntBUFSCL\nSDAtr\nTable 31-8. SPI Timing Parameters\nDescription Mode Min Typ Max\n1 SCK period MasterSee Table 21-5 on \npage 203\nns2 SCK high/low Master 50% duty cycle\n3 Rise/Fall time Master 3.64 Setup Master 10\n5H o l dM a s t e r 1 0\n6 Out to SCK Master 0.5 \u0081 t\nsck\n7 SCK to out Master 10\n8 SCK to out high Master 10\n9S S  low to out Slave 15\n10 SCK period Slave 4 \u0081 tck\n11 SCK high/low(1)Slave 2 \u0081 tck\n12 Rise/Fall time Slave 160013 Setup Slave 10\n14 Hold Slave t\nck\n15 SCK to out Slave 15\n16 SCK to SS  high Slave 20\n17 SS  high to tri-state Slave 10\n18 SS  low to SCK Slave 20\n\n376\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-7. SPI Interface Timing Requirements (Master Mode)\nFigure 31-8. SPI Interface Timing Requirements (Slave Mode)MOSI\n(Data Output)SCK\n(CPOL = 1)\nMISO\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...61\n22\n3 45\n8 7\nMISO\n(Data Output)SCK\n(CPOL = 1)\nMOSI\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...10\n11 11\n12 13 14\n17 159\nX16\n\n377\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n31.8 ADC Characteristics  \u2013 Preliminary Data\nNote: 1. Values are guidelines only.Table 31-9. ADC Characteristics, Singel Ended Channels\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nResolution Single Ended Conversion 10 Bits\nAbsolute accuracy (Including \nINL, DNL, quantization error, \ngain and offset error)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC= 200kHz2.25 2.5\nLSBSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 1MHz3\nSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz\nNoise Reduction Mode2\nSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 1MHz\nNoise Reduction Mode3\nIntegral Non-Linearity (INL)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz1.25\nDifferential Non-Linearity (DNL)Single Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz0.5\nGain ErrorSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC= 200kHz2\nOffset ErrorSingle Ended Conversion\nVREF = 4V, VCC = 4V,\nCLKADC = 200kHz-2\nConversion Time Free Running Conversion 13 260 \u00b5s\nClock Frequency Single Ended Conversion 50 1000 kHz\nAVCC Analog Supply Voltage VCC - 0.3 VCC + 0.3\nV VREF Reference Voltage 1.0 AVCC\nVIN Input Voltage GND VREF\nInput Bandwidth 38,5 kHz\nVINT1 Internal Voltage Reference 1.1V 1.0 1.1 1.2\nV\nVINT2 Internal Voltage Reference 2.56V 2.4 2.56 2.8\nRREF Reference Input Resistance 32 k \u03a9\nRAIN Analog Input Resistance 100 M \u03a9\n\n378\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 31-10. ADC Characteristics, Differential Channels\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nResolutionGain =  1\u00d7 8\nBits Gain = 10\u00d7 8\nGain = 200\u00d7 7\nAbsolute Accuracy(In cluding INL, DNL, \nQuantization Error, Gain and Offset Error)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz18\nLSBGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz17\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz9\nIntegral Non-Linearity (INL)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2.5\nGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz5\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz9\nDifferential Non-Linearity (DNL)Gain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz0.75\nGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz1.5\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz10\nGain ErrorGain = 1\u00d7 1.7\n% Gain = 10\u00d7 1.7\nGain = 200\u00d7 0.5\nOffset ErrorGain = 1\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2\nLSBGain = 10\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz2\nGain = 200\u00d7\nVREF = 4V, VCC = 5V\nCLKADC = 50 - 200kHz3\nClock Frequency 50 200 kHz\nConversion Time 65 260 \u00b5s\n\n379\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: Values are guidelines only.\n31.9 External Data Memory Timing\nNotes: 1. This assumes 50% clock duty cycl e. The half peri od is actually the high time of the external clock, XTAL1.\n2. This assumes 50% clock duty cycle. The half period  is actually the low time of the external clock, XTAL1.AVCC Analog Supply Voltage VCC - 0.3 VCC + 0.3\nVVREF Reference Voltage 2.7 AVCC - 0.5\nVIN Input Voltage GND VCC\nVDIFF Input Differential Voltage -VREF/Gain VREF/Gain\nADC Conversion Output -511 511 LSB\nInput Bandwidth 4k H z\nVINT Internal Voltage Reference 2.3 2.56 2.8 V\nRREF Reference Input Resistance 32 k \u03a9\nRAIN Analog Input Resistance 100 M \u03a9\nTable 31-11. External Data Memory Characteristics, 4.5 to 5.5 Volts, No Wait-state \nSymbol Parameter8MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n1tLHLL ALE Pulse Width 115 1.0tCLCL-10\nns2tAVLL Address Valid A to ALE Low 57.5 0.5tCLCL-5(1)\n3a tLLAX_STAddress Hold After ALE Low, \nwrite access55\n3b tLLAX_LDAddress Hold after ALE Low, \nread access55\n4tAVLLC Address Valid C to ALE Low 57.5 0.5tCLCL-5(1)\n5tAVRL Address Valid to RD Low 115 1.0tCLCL-10\n6tAVWL Address Valid to WR Low 115 1.0tCLCL-10\n7tLLWL ALE Low to WR Low 47.5 67.5 0.5tCLCL-15(2)0.5tCLCL+5(2)\n8tLLRL ALE Low to RD Low 47.5 67.5 0.5tCLCL-15(2)0.5tCLCL+5(2)\n9tDVRH Data Setup to RD High 40 40\n10 tRLDV Read Low to Data Valid 75 1.0tCLCL-50\n11 tRHDX Data Hold After RD High 0 0\n12 tRLRH RD Pulse Width 115 1.0tCLCL-10\n13 tDVWL Data Setup to WR Low 42.5 0.5tCLCL-20(1)\n14 tWHDX Data Hold After WR High 115 1.0tCLCL-10\n15 tDVWH Data Valid to WR High 125 1.0tCLCL\n16 tWLWH WR Pulse Width 115 1.0tCLCL-10Table 31-10. ADC Characteristics, Differe ntial Channels (Continued)\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\n\n380\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable 31-12. External Data Memory Characterist ics, 4.5 to 5.5 Volts, 1 Cycle Wait-state\nSymbol Parameter8MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 200 2.0tCLCL-50\nns12 tRLRH RD Pulse Width 240 2.0tCLCL-10\n15 tDVWH Data Valid to WR High 240 2.0tCLCL\n16 tWLWH WR Pulse Width 240 2.0tCLCL-10\nTable 31-13. External Data Memory Characteristics, 4.5 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 0\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 325 3.0tCLCL-50\nns12 tRLRH RD Pulse Width 365 3.0tCLCL-10\n15 tDVWH Data Valid to WR High 375 3.0tCLCL\n16 tWLWH WR Pulse Width 365 3.0tCLCL-10\nTable 31-14. External Data Memory Characteristics, 4.5 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 16 MHz\n10 tRLDV Read Low to Data Valid 325 3.0tCLCL-50\nns12 tRLRH RD Pulse Width 365 3.0tCLCL-10\n14 tWHDX Data Hold After WR High 240 2.0tCLCL-10\n15 tDVWH Data Valid to WR High 375 3.0tCLCL\n16 tWLWH WR Pulse Width 365 3.0tCLCL-10\nTable 31-15. External Data Memory Characteristics, 2.7 to 5.5 Volts, No Wait-state \nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n\n381\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This assumes 50% clock duty cycl e. The half peri od is actually the high time of the external clock, XTAL1.\n2. This assumes 50% clock duty cycle. The half period  is actually the low time of the external clock, XTAL1.1tLHLL ALE Pulse Width 235 tCLCL-15\nns2tAVLL Address Valid A to ALE Low 115 0.5tCLCL-10(1)\n3a tLLAX_STAddress Hold After ALE Low, \nwrite access55\n3b tLLAX_LDAddress Hold after ALE Low, \nread access55\n4tAVLLC Address Valid C to ALE Low 115 0.5tCLCL-10(1)\n5tAVRL Address Valid to RD Low 235 1.0tCLCL-15\n6tAVWL Address Valid to WR Low 235 1.0tCLCL-15\n7tLLWL ALE Low to WR Low 115 130 0.5tCLCL-10(2)0.5tCLCL+5(2)\n8tLLRL ALE Low to RD Low 115 130 0.5tCLCL-10(2)0.5tCLCL+5(2)\n9tDVRH Data Setup to RD High 45 45\n10 tRLDV Read Low to Data Valid 190 1.0tCLCL-60\n11 tRHDX Data Hold After RD High 0 0\n12 tRLRH RD Pulse Width 235 1.0tCLCL-15\n13 tDVWL Data Setup to WR Low 105 0.5tCLCL-20(1)\n14 tWHDX Data Hold After WR High 235 1.0tCLCL-15\n15 tDVWH Data Valid to WR High 250 1.0tCLCL\n16 tWLWH WR Pulse Width 235 1.0tCLCL-15Table 31-15. External Data Memory Characteristics, 2.7 to 5.5 Volts, No Wait-state  (Continued)\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\nTable 31-16. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 0, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 440 2.0tCLCL-60\nns12 tRLRH RD Pulse Width 485 2.0tCLCL-15\n15 tDVWH Data Valid to WR High 500 2.0tCLCL\n16 tWLWH WR Pulse Width 485 2.0tCLCL-15\n\n382\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-9. External Memory Timing (SR Wn1 = 0, SR Wn0 = 0Table 31-17. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 0\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 690 3.0tCLCL-60\nns12 tRLRH RD Pulse Width 735 3.0tCLCL-15\n15 tDVWH Data Valid to WR High 750 3.0tCLCL\n16 tWLWH WR Pulse Width 735 3.0tCLCL-15\nTable 31-18. External Data Memory Characteristics, 2.7 to 5.5 Volts, SR Wn1 = 1, SR Wn0 = 1\nSymbol Parameter4MHz Oscillator Variable Oscillator\nUnit Min Max Min Max\n01 / tCLCL Oscillator Frequency 0.0 8 MHz\n10 tRLDV Read Low to Data Valid 690 3.0tCLCL-60\nns12 tRLRH RD Pulse Width 735 3.0tCLCL-15\n14 tWHDX Data Hold After WR High 485 2.0tCLCL-15\n15 tDVWH Data Valid to WR High 750 3.0tCLCL\n16 tWLWH WR Pulse Width 735 3.0tCLCL-15\nALET1 T2 T3\nWrite\nReadWRT4\nA15: 8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9\n\n383\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-10. External Memory Timing (SR Wn1 = 0, SR Wn0 = 1)\nFigure 31-11. External Memory Timing (SR Wn1 = 1, SR Wn0 = 0)ALET1 T2 T3\nWrite\nReadWRT5\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4\nALET1 T2 T3\nWrite\nReadWRT6\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4 T5\n\n384\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 31-12. External Memory Timing (SR Wn1 = 1, SR Wn0 = 1)()\nThe ALE pulse in the last period (T 4-T7) is only present if the next instruction accesses the RAM\n(internal or external). ALET1 T2 T3\nWrite\nReadWRT7\nA15:8 Address Prev. addr.\nDA7:0 Address Data Prev. data XX\nRDDA7:0 (XMBK = 0) Data AddressSystem Clock (CLKCPU)\n1\n4\n27\n63a\n3b\n5\n8 121613\n10111415\n9T4 T5 T6\n\n385\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32. Typical Characteristics\nThe following charts show typical behavior. T hese figures are not tested during manufacturing.\nAll current consumption measurements are performed with all I/O pins configured as inputs and\nwith internal pull-ups enabled. A sine wave generator with rail-to-rail output is used as clocksource.\nAll Active- and Idle current consumption measurem ents are done with all bits in the PRR regis-\nters set and thus, the corresponding I/O modules are turned off. Also the Analog Comparator isdisabled during these measurements. Table 32-1 on page 390  and Table 32-2 on page 391\nshow the additional current consumption compared to I\nCC Active and ICC Idle for every I/O mod-\nule controlled by the Power Reduction Register. See \u201cPower Reduction Register\u201d on page 54  for\ndetails.\nThe power consumption in Power-down mode is independent of clock selection.\nThe current consumption is a function of several factors such as: operating voltage, operating\nfrequency, loading of I/O pins, switching rate  of I/O pins, code executed and ambient tempera-\nture. The dominating factors are operating voltage and frequency.\nThe current drawn from capacitive loaded pi ns may be estimated (for one pin) as CL \u00d7 VCC \u00d7 f\nwhere CL = load capacitance, VCC = operating voltage and f = average switching frequency of I/O\npin.\nThe parts are characterized at frequencies higher than test limits. Parts are not guaranteed to\nfunction properly at frequencies higher than the ordering code indicates.\nThe difference between current consumption in Power-down mode with Watchdog Timer\nenabled and Power-down mode with Watchdog Timer disabled represents the differential cur-\nrent drawn by the Watchdog Timer.\n32.1 Active Supply Current\nFigure 32-1. Active Supply Current vs. frequency (0.1MHz - 1.0MHz)\n5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.511.522.5\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1\nFrequency (MHz)ICC (mA)\n\n386\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-2. Active Supply Current vs . Frequency (1MHz - 16MHz)\nFigure 32-3. Active Supply Current vs. VCC (Internal RC O scillator, 8MHz)5.5V\n5.0V\n4.5V\n0510152025\n0246 8 10 12 14 16\nFrequency (MHz)ICC (m A)4.0V\n3.3V\n2.7V\n1.8V\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n02468101214\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n\n387\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-4. Active Supply Current vs. VCC (Internal RC O scillator, 1MHz)\nFigure 32-5. Active Supply Current vs. VCC (Internal RC O scillator, 128kHz)85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.7\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n\n388\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.2 Idle Supply Current\nFigure 32-6. Idle Supply Current vs. Low Frequency (0.1MHz - 1.0MHz)\nFigure 32-7. Idle Supply Current vs. Frequency (1MHz - 16MHz)5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.10.20.30.40.50.6\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (mA)\n5.5V\n5.0V\n4.5V\n012345678\n0246 8 10 12 14 16Frequency (MHz)ICC (mA)\n4.0V\n3.3V\n2.7V\n1.8V\n\n389\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-8. Idle Supply Current vs. VCC (Internal RC O scillator, 8MHz)\nFigure 32-9. Idle Supply Current vs. VCC (Internal RC O scillator, 1MHz)85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.533.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n85\u00b0C\n25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.70.80.9\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (mA)\n\n390\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-10. Idle Supply Current vs. VCC (Internal RC O scillator, 128kHz)I\n32.2.1 Supply Current of IO modules\nThe tables and formulas below can be used to calculate the additional current consumption for\nthe different I/O modules in Active and Idle mode. The enabling or disabling of the I/O modulesare controlled by the Power Reduction Register. See \u201cPower Reduction Register\u201d on page 54  for\ndetails.85\u00b0C25\u00b0C-40\u00b0C\n00.050.10.150.20.250.3\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (m     A )\nTable 32-1. Additional Current Consumption for the different I/O modules (absolute values)\nPRR bit Typical numbers\nVCC = 2V, F = 1MHz VCC = 3V, F = 4MHz VCC = 5V, F = 8MHz\nPRUSART3 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRUSART2 8.0\u00b5A 51\u00b5A 220\u00b5APRUSART1 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRUSART0 8.0\u00b5A 51\u00b5A 220\u00b5A\nPRTWI 12\u00b5A 75\u00b5A 315\u00b5A\nPRTIM5 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM4 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM3 6.0\u00b5A 39\u00b5A 150\u00b5APRTIM2 11\u00b5A 72\u00b5A 300\u00b5A\nPRTIM1 6.0\u00b5A 39\u00b5A 150\u00b5A\nPRTIM0 4.0\u00b5A 24\u00b5A 100\u00b5APRSPI 15\u00b5A 95\u00b5A 400\u00b5A\nPRADC 12\u00b5A 75\u00b5A 315\u00b5A\n\n391\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nIt is possible to calculate the typical current consumption based on the numbers from Table 32-1\non page 390  for other VCC and frequency settings than listed in Table 32-2 .\n32.2.1.1 Example 1\nCalculate the expected current consumption in idle mode with USART0, TIMER1, and T WI\nenabled at VCC = 2.0V and F = 1MHz. From Table 32-2 , third column, we see that we need to\nadd 17% for the USART0, 24% for the T WI, and 10% for the TIMER1 module. Reading from Fig-\nure 32-6 on page 388 , we find that the idle current consumption is ~0.15mA at VCC = 2.0V and F\n= 1MHz. The total current consumption in idle mode with USART0, TIMER1, and T WI enabled,\ngives:Table 32-2. Additional Current Consumption (percentage) in Active and Idle mode\nPRR bitAdditional Current consumption \ncompared to Active wi th external clock Additional Current consumption \ncompared to Idle with external clock \nPRUSART3 3.0% 17%\nPRUSART2 3.0% 17%\nPRUSART1 3.0% 17%\nPRUSART0 3.0% 17%\nPRTWI4 . 4 % 2 4 %\nPRTIM5 1.8% 10%\nPRTIM4 1.8% 10%\nPRTIM3 1.8% 10%PRTIM2 4.3% 23%\nPRTIM1 1.8% 10%\nPRTIM0 1.5% 8.0%PRSPI 3.3% 18%\nPRADC 4.5% 24%\nICCtotal 0.15mA 10 . 1 70 . 2 40 . 1 0+++()\u2022 0.227 mA \u2248\u2248\n\n392\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.3 Power-down Supply Current\nFigure 32-11. Power-down Supply Current vs. VCC (Watchdog Timer Disabled)\nFigure 32-12. Power-down Supply Current vs. VCC (Watchdog Timer Enabled) 85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.522.533.54\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n25\u00b0C-40\u00b0C\n024681012\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)85\u00b0C\n\n393\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.4 Power-save Supply Current\nFigure 32-13. Power-save Supply Current vs. VCC (Watchdog Timer Disabled)\nFigure 32-14. Power-save Supply Current vs. VCC (Watchdog Timer Enabled)g\n25\u00b0C\n4567891011\n1.5 2 2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC(uA)\n0123456789\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (\u00b5A)25\u00b0C\n\n394\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.5 Standby Supply Current\nFigure 32-15. Standby Supply Current vs. VCC (Watchdog Timer Disabled)\n32.6 Pin Pull-up\nFigure 32-16. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 1.8V)    6MHz xtal\n    6MHz res\n    4MHz xtal    4MHz res\n    455kHz res\n    32kHz xtal    2MHz xtal    2MHz res\n    1MHz res\n00.020.040.060.080.10.120.140.160.180.2\n1.5 2 2.5 3 3.5 4 4.5 5 5.5 VCC (V)ICC (mA)\n85\u00b0C25\u00b0C\n-40\u00b0C0102030405060\n0 0.2 0.4 0.6 0. 8 1 1.2 1.4 1.6 1. 8 2\nVOP (V)IOP (\u00b5A)\n\n395\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-17. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 2.7V)\nFigure 32-18. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 5V)85\u00b0C\n25\u00b0C\n-40\u00b0C0102030405060708090\n0 0.5 1 1.5 2 2.5 3VOP (V)IOP (\u00b5A)\n85\u00b0C25\u00b0C\n-40\u00b0C020406080100120140160\n0123456VOP (V)IOP (\u00b5A)\n\n396\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-19. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 1.8V)\nFigure 32-20. Reset pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 2.7V)85\u00b0C25\u00b0C\n-40\u00b0C\n0510152025303540\n0 0.2 0.4 0.6 0. 8 1 1.2 1.4 1.6 1. 8 2VRESET (V)IRESET (\u00b5A)\n85\u00b0C25\u00b0C\n-40\u00b0C\n010203040506070\n0 0.5 1 1.5 2 2.5 3\nVRESET (V)IRESET (\u00b5A)\n\n397\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-21. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 5V)\n32.7 Pin Driver Strength\nFigure 32-22. I/O Pin output Voltage vs.Sink Current (VCC = 3V)85\u00b0C25\u00b0C\n-40\u00b0C\n020406080100120\n0123 456\nVRESET (V)IRESET (\u00b5A)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.10.20.30.40.50.60.70.80.91\n0 5 10 15 20 25 IOL (mA)VOL (V)\n\n398\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-23. I/O Pin Output Voltage vs. Sink Current (VCC = 5V)\nFigure 32-24. I/O Pin Output Voltage vs. Source Current (VCC = 3V)25\u00b0C\n-40\u00b0C\n00.10.20.30.40.50.6\n0 5 10 15 20 25IOL (mA)VOL (V)85\u00b0C\n85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.5\n0 5 10 15 20 25\nIOH (mA)VOH (V)\n\n399\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-25. I/O Pin Output Voltage vs. Source Current (VCC = 5V)\n32.8 Pin Threshold and Hysteresis\nFigure 32-26. I/O Pin Input Threshold Voltage vs. VCC (VIH, IO Pin Read as \u201c1\u201c)85\u00b0C25\u00b0C-40\u00b0C\n4.34.44.54.64.74.84.955.1\n0 5 10 15 20 25IOH (mA)VOH (V)\n85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n\n400\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-27. I/O Pin Input Threshold Voltage vs. VCC (VIL, IO Pin Read as \u201c0\u201c)  \nFigure 32-28. I/O Pin Input Hysteresis85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.70.8\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)Input Hyst eresis  (mV)\n\n401\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-29. Reset Input Threshold Voltage vs. VCC (VIH, IO Pin Read as \u201c1\u201c)\nFigure 32-30. Reset Input Threshold Voltage vs. VCC (VIL, IO Pin Read as \u201c0\u201c)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Thres hold (V )\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.522.5\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Threshold (V)\n\n402\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-31. Reset Pin Input Hysteresis vs. VCC  \n32.9 BOD Threshold and Analog Comparator Offset\nFigure 32-32. BOD Threshold vs. Temperature (BOD Level is 4.3V)85\u00b0C25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.7\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)Input  Hy steresis (mV)\nRising Vcc\nFalling Vcc\n4.24.254.34.354.4\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)Threshold (V)\n\n403\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-33. BOD Threshold vs. Temperature (BOD Level is 2.7V)\nFigure 32-34. BOD Threshold vs. Temperature (BOD Level is 1.8V)Rising Vcc\nFalling Vcc\n2.62.652.72.752.8\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)Threshold (V)\nRising Vcc\nFallling  Vcc\n1.71.751.81.851.9\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)T hre shold (V )\n\n404\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.10 Internal Oscillator Speed\nFigure 32-35. Watchdog Oscillator Frequency vs. VCC\nFigure 32-36. Watchdog Oscillator Freq uency vs. Temperature85\u00b0C25\u00b0C-40\u00b0C\n114116118120122124126128\n2 2.5 3 3.5 4 4.5 5 5.5VCC (V)FRC (kHz)\n5.5V4.0V3.3V2.7V2.1V\n114116118120122124126128\n-60 -40 -20 0 20 40 60 80 100Temperature (\u00b0C)FRC (kHz )\n\n405\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-37. Calibrated 8MHz RC Oscillator Frequency vs. VCC\nFigure 32-38. Calibrated 8MHz RC Oscillator Frequency vs. Temperature85\u00b0C\n25\u00b0C\n-40\u00b0C\n7.67.77.87.988.18.28.3\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)FRC (MHz)\n5.0V\n3.0V\n7.988.18.28.38.48.5\n-60 -40 -20 0 20 40 60 80 100\nTemperature (\u00b0C)FRC (MHz)\n\n406\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-39. Calibrated 8MHz RC Oscillator Frequency vs. Osccal Value\n32.11 Current Consumption of Peripheral Units\nFigure 32-40. Brownout Detector Current vs. VCC85\u00b0C\n25\u00b0C\n-40\u00b0C\n0246810121416\n01 6 3 2 4 864 80 96 112 12 8144 160 176 192 20 8224 240 256\nOSCCAL (X1)FRC (MHz)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n051015202530\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n407\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-41. ADC Current vs. VCC (AREF = AVCC)\nFigure 32-42. AREF External Reference Current vs. VCC85\u00b0C25\u00b0C-40\u00b0C\n050100150200250300350\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n85\u00b0C25\u00b0C-40\u00b0C\n050100150200250\n1.5 2 2.5 3 3.5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n408\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-43. Watchdog Timer Current vs. VCC\nFigure 32-44. Analog Comparator Current vs. VCC85\u00b0C25\u00b0C-40\u00b0C\n0123456789\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (\u00b5A)\n85\u00b0C25\u00b0C-40\u00b0C\n0102030405060708090100\n1.5 2 2.5 3 3.5 4 4.5 5 5.5 VCC (V)ICC (\u00b5A)\n\n409\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-45. Programming Current vs. VCC\n32.12 Current Consumption in Reset and Reset Pulsewidth\nFigure 32-46. Reset Supply Current vs VCC (0.1MHz - 1.0MHz, Excluding Current Through The \nReset Pull-up)85\u00b0C25\u00b0C-40\u00b0C\n0246810121416\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (mA)\n5.5V\n5.0V\n4.5V\n4.0V\n3.3V\n2.7V\n1.8V\n00.050.10.150.20.250.30.35\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (m A )\n\n410\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nFigure 32-47. Reset Supply Current vs. VCC (1MHz - 16MHz, Excluding Current Through The \nReset Pull-up)\nFigure 32-48. Minimum Reset Pulse Width vs. VCC5.5V\n5.0V\n4.5V\n00.511.522.533.54\n0246 8 10 12 14 16\nFrequency (MHz)ICC (m A)\n4.0V\n3.3V\n2.7V\n1.8V\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n05001000150020002500\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)Pu l sew i d t h  (ns)\n\n411\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n33. Register Summary\nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n(0x1FF) Reserved - - - - - - - -\n... Reserved - - - - - - - -\n(0x13F) Reserved\n(0x13E) Reserved\n(0x13D) Reserved\n(0x13C) Reserved\n(0x13B) Reserved\n(0x13A) Reserved\n(0x139) Reserved\n(0x138) Reserved\n(0x137) Reserved\n(0x136) UDR3  USART3 I/O Data Register 222\n(0x135) UBRR3H - - - - USART3 Baud Rate Register High Byte 227\n(0x134) UBRR3L  USART3 Baud Rate Register Low Byte 227\n(0x133) Reserved - - - - - - - -\n(0x132) UCSR3C UMSEL31 UMSEL30 UPM 31 UPM30 USBS3 UCSZ31 UCSZ30 UCPOL3 239\n(0x131) UCSR3B RXCIE3 TXCIE3 UDR IE3 RXEN3 TXEN3 UCSZ32 RXB83 TXB83 238\n(0x130) UCSR3A RXC3 TXC3 UDRE3 FE3 DOR3 UPE3 U2X3 MPCM3 238\n(0x12F) Reserved - - - - - - - -\n(0x12E) Reserved - - - - - - - -\n(0x12D) OCR5CH Timer/Counter5 - Output Compare Register C High Byte 165\n(0x12C) OCR5CL Timer/Counter5 - Output Compare Register C Low Byte 165\n(0x12B) OCR5BH Timer/Counter5 - Output Compare Register B High Byte 165\n(0x12A) OCR5BL Timer/Counter5 - Output Compare Register B Low Byte 165\n(0x129) OCR5AH Timer/Counter5 - Output Compare Register A High Byte 164\n(0x128) OCR5AL Timer/Counter5 - Output Compare Register A Low Byte 164\n(0x127) ICR5H Timer/Counter5 - Input Capture Register High Byte 165\n(0x126) ICR5L Timer/Counter5 - Input Capture Register Low Byte 165\n(0x125) TCNT5H Timer/Counter5 - Counter Register High Byte 163\n(0x124) TCNT5L Timer/Counter5 - Counter Register Low Byte 163\n(0x123) Reserved - - - - - - - -\n(0x122) TCCR5C FOC5A FOC5B FOC5C - - - - - 162\n(0x121) TCCR5B ICNC5 ICES5 - WGM53 WGM52 CS52 CS51 CS50 160\n(0x120) TCCR5A COM5A1 COM5A0 COM5B1 COM5B0 COM5C1 COM5C0 WGM51 WGM50 158\n(0x11F) Reserved - - - - - - - -\n(0x11E) Reserved - - - - - - - -\n(0x11D) Reserved - - - - - - - -\n(0x11C) Reserved - - - - - - - -\n(0x11B) Reserved - - - - - - - -\n(0x11A) Reserved - - - - - - - -\n(0x119) Reserved - - - - - - - -\n(0x118) Reserved - - - - - - - -\n(0x117) Reserved - - - - - - - -\n(0x116) Reserved - - - - - - - -\n(0x115) Reserved - - - - - - - -\n(0x114) Reserved - - - - - - - -\n(0x113) Reserved - - - - - - - -\n(0x112) Reserved - - - - - - - -\n(0x111) Reserved - - - - - - - -\n(0x110) Reserved - - - - - - - -\n(0x10F) Reserved - - - - - - - -\n(0x10E) Reserved - - - - - - - -\n(0x10D) Reserved - - - - - - - -\n(0x10C) Reserved - - - - - - - -\n(0x10B) PORTL PORTL7 PORTL6 PORTL5 PORTL4 PORTL3 PORTL2 PORTL1 PORTL0 104\n(0x10A) DDRL DDL7 DDL6 DDL5 DDL4 DDL3 DDL2 DDL1 DDL0 104\n(0x109) PINL PINL7 PINL6 PINL5 PINL4 PINL3 PINL2 PINL1 PINL0 104\n(0x108) PORTK PORTK7 PORTK6 PORTK5 PORTK4 PORTK3 PORTK2 PORTK1 PORTK0 103\n(0x107) DDRK DDK7 DDK6 DDK5 DDK4 DDK3 DDK2 DDK1 DDK0 103\n(0x106) PINK PINK7 PINK6 PINK5 PINK4 PINK3 PINK2 PINK1 PINK0 103\n(0x105) PORTJ PORTJ7 PORTJ6 PORTJ5 PORTJ4 PORTJ3 PORTJ2 PORTJ1 PORTJ0 103\n(0x104) DDRJ DDJ7 DDJ6 DDJ5 DDJ4 DDJ3 DDJ2 DDJ1 DDJ0 103\n(0x103) PINJ PINJ7 PINJ6 PINJ5 PINJ4 PINJ3 PINJ2 PINJ1 PINJ0 103\n(0x102) PORTH PORTH7 PORTH6 PORTH5 PORTH4 PORTH3 PORTH2 PORTH1 PORTH0 102\n(0x101) DDRH DDH7 DDH6 DDH5 DDH4 DDH3 DDH2 DDH1 DDH0 103\n\n412\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0x100) PINH PINH7 PINH6 PINH5 PINH4 PINH3 PINH2 PINH1 PINH0 103\n(0xFF) Reserved - - - - - - - -\n(0xFE) Reserved - - - - - - - -\n(0xFD) Reserved - - - - - - - -\n(0xFC) Reserved - - - - - - - -\n(0xFB) Reserved - - - - - - - -\n(0xFA) Reserved - - - - - - - -\n(0xF9) Reserved - - - - - - - -\n(0xF8) Reserved - - - - - - - -\n(0xF7) Reserved - - - - - - - -\n(0xF6) Reserved - - - - - - - -\n(0xF5) Reserved - - - - - - - -\n(0xF4) Reserved - - - - - - - -\n(0xF3) Reserved - - - - - - - -\n(0xF2) Reserved - - - - - - - -\n(0xF1) Reserved - - - - - - - -\n(0xF0) Reserved - - - - - - - -\n(0xEF) Reserved - - - - - - - -\n(0xEE) Reserved - - - - - - - -\n(0xED) Reserved - - - - - - - -\n(0xEC) Reserved - - - - - - - -\n(0xEB) Reserved - - - - - - -\n(0xEA) Reserved - - - - - - - -\n(0xE9) Reserved - - - - - - - -\n(0xE8) Reserved - - - - - - - -\n(0xE7) Reserved - - - - - - -\n(0xE6) Reserved - - - - - - - -\n(0xE5) Reserved - - - - - - - -\n(0xE4) Reserved - - - - - - - -\n(0xE3) Reserved - - - - - - -\n(0xE2) Reserved - - - - - - - -\n(0xE1) Reserved - - - - - - -\n(0xE0) Reserved - - - - - - -\n(0xDF) Reserved - - - - - - - -\n(0xDE) Reserved - - - - - - - -\n(0xDD) Reserved - - - - - - -\n(0xDC) Reserved - - - - - - - -\n(0xDB) Reserved - - - - - - - -\n(0xDA) Reserved - - - - - - - -\n(0xD9) Reserved - - - - - - -\n(0xD8) Reserved - - - - - - - -\n(0xD7) Reserved - - - - - - - -\n(0xD6) UDR2  USART2 I/O Data Register 222\n(0xD5) UBRR2H - - - - USART2 Baud Rate Register High Byte 227\n(0xD4) UBRR2L  USART2 Baud Rate Register Low Byte 227\n(0xD3) Reserved - - - - - - - -\n(0xD2) UCSR2C UMSEL21 UMSEL20 UPM2 1 UPM20 USBS2 UCSZ21 UCSZ20 UCPOL2 239\n(0xD1) UCSR2B RXCIE2 TXCIE2 UDRIE 2 RXEN2 TXEN2 UCSZ22 RXB82 TXB82 238\n(0xD0) UCSR2A RXC2 TXC2 UDRE2 FE2 DOR2 UPE2 U2X2 MPCM2 238\n(0xCF) Reserved - - - - - - - -\n(0xCE) UDR1  USART1 I/O Data Register 222\n(0xCD) UBRR1H - - - - USART1 Baud Rate Register High Byte 227\n(0xCC) UBRR1L  USART1 Baud Rate Register Low Byte 227\n(0xCB) Reserved - - - - - - - -\n(0xCA) UCSR1C UMSEL11 UMSEL10 UPM1 1 UPM10 USBS1 UCSZ11 UCSZ10 UCPOL1 239\n(0xC9) UCSR1B RXCIE1 TXCIE1 UDRIE 1 RXEN1 TXEN1 UCSZ12 RXB81 TXB81 238\n(0xC8) UCSR1A RXC1 TXC1 UDRE1 FE1 DOR1 UPE1 U2X1 MPCM1 238\n(0xC7) Reserved - - - - - - - -\n(0xC6) UDR0  USART0 I/O Data Register 222\n(0xC5) UBRR0H - - - - USART0 Baud Rate Register High Byte 227\n(0xC4) UBRR0L  USART0 Baud Rate Register Low Byte 227\n(0xC3) Reserved - - - - - - - -\n(0xC2) UCSR0C UMSEL01 UMSEL00 UPM0 1 UPM00 USBS0 UCSZ01 UCSZ00 UCPOL0 239\n(0xC1) UCSR0B RXCIE0 TXCIE0 UDRIE 0 RXEN0 TXEN0 UCSZ02 RXB80 TXB80 238\n(0xC0) UCSR0A RXC0 TXC0 UDRE0 FE0 DOR0 UPE0 U2X0 MPCM0 238\n(0xBF) Reserved - - - - - - - -Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n413\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0xBE) Reserved - - - - - - - -\n(0xBD) T WAMR T WAM6 T WAM5 T WAM4 T WAM3 T WAM2 T WAM1 T WAM0 - 269\n(0xBC) T WCR T WINT T WEA T WSTA T WSTO T WWCT WEN -T WIE 266\n(0xBB) T WDR  2-wire Serial Interface Data Register 268\n(0xBA) T WAR T WA6 T WA5 T WA4 T WA3 T WA2 T WA1 T WA0 T WGCE 269\n(0xB9) T WSR T WS7 T WS6 T WS5 T WS4 T WS3 -T WPS1 T WPS0 268\n(0xB8) T WBR 2-wire Serial Interface Bit Rate Register 266\n(0xB7) Reserved - - - - - - - -\n(0xB6) ASSR - EXCLK AS2 TCN2UB OCR2AUB OCR2BUB TCR2AUB TCR2BUB 184\n(0xB5) Reserved - - - - - - - -\n(0xB4) OCR2B  Timer/Counter2 Output Compare Register B 191\n(0xB3) OCR2A  Timer/Counter2 Output Compare Register A 191\n(0xB2) TCNT2  Timer/Counter2 (8 Bit) 191\n(0xB1) TCCR2B FOC2A FOC2B - - WGM22 CS22 CS21 CS20 190\n(0xB0) TCCR2A COM2A1 COM2A0 COM2B1 COM2B0 - - WGM21 WGM20 191\n(0xAF) Reserved - - - - - - - -\n(0xAE) Reserved - - - - - - - -\n(0xAD) OCR4CH Timer/Counter4 - Output Compare Register C High Byte 164\n(0xAC) OCR4CL Timer/Counter4 - Output Compare Register C Low Byte 164\n(0xAB) OCR4BH Timer/Counter4 - Output Compare Register B High Byte 164\n(0xAA) OCR4BL Timer/Counter4 - Output Compare Register B Low Byte 164\n(0xA9) OCR4AH Timer/Counter4 - Output Compare Register A High Byte 164\n(0xA8) OCR4AL Timer/Counter4 - Output Compare Register A Low Byte 164\n(0xA7) ICR4H Timer/Counter4 - Input Capture Register High Byte 165\n(0xA6) ICR4L Timer/Counter4 - Input Capture Register Low Byte 165\n(0xA5) TCNT4H Timer/Counter4 - Counter Register High Byte 163\n(0xA4) TCNT4L Timer/Counter4 - Counter Register Low Byte 163\n(0xA3) Reserved - - - - - - - -\n(0xA2) TCCR4C FOC4A FOC4B FOC4C - - - - - 162\n(0xA1) TCCR4B ICNC4 ICES4 - WGM43 WGM42 CS42 CS41 CS40 160\n(0xA0) TCCR4A COM4A1 COM4A0 COM4B1 COM4B0 COM4C1 COM4C0 WGM41 WGM40 158\n(0x9F) Reserved - - - - - - - -\n(0x9E) Reserved - - - - - - - -\n(0x9D) OCR3CH Timer/Counter3 - Output Compare Register C High Byte 164\n(0x9C) OCR3CL Timer/Counter3 - Output Compare Register C Low Byte 164\n(0x9B) OCR3BH Timer/Counter3 - Output Compare Register B High Byte 164\n(0x9A) OCR3BL Timer/Counter3 - Output Compare Register B Low Byte 164\n(0x99) OCR3AH Timer/Counter3 - Output Compare Register A High Byte 163\n(0x98) OCR3AL Timer/Counter3 - Output Compare Register A Low Byte 163\n(0x97) ICR3H Timer/Counter3 - Input Capture Register High Byte 165\n(0x96) ICR3L Timer/Counter3 - Input Capture Register Low Byte 165\n(0x95) TCNT3H Timer/Counter3 - Counter Register High Byte 162\n(0x94) TCNT3L Timer/Counter3 - Counter Register Low Byte 162\n(0x93) Reserved - - - - - - - -\n(0x92) TCCR3C FOC3A FOC3B FOC3C - - - - - 162\n(0x91) TCCR3B ICNC3 ICES3 - WGM33 WGM32 CS32 CS31 CS30 160\n(0x90) TCCR3A COM3A1 COM3A0 COM3B1 COM3B0 COM3C1 COM3C0 WGM31 WGM30 158\n(0x8F) Reserved - - - - - - - -\n(0x8E) Reserved - - - - - - - -\n(0x8D) OCR1CH Timer/Counter1 - Output Compare Register C High Byte 163\n(0x8C) OCR1CL Timer/Counter1 - Output Compare Register C Low Byte 163\n(0x8B) OCR1BH Timer/Counter1 - Output Compare Register B High Byte 163\n (0x8A) OCR1BL Timer/Counter1 - Output Compare Register B Low Byte 163\n(0x89) OCR1AH Timer/Counter1 - Output Compare Register A High Byte 163\n(0x88) OCR1AL Timer/Counter1 - Output Compare Register A Low Byte 163\n(0x87) ICR1H Timer/Counter1 - Input Capture Register High Byte 165\n(0x86) ICR1L Timer/Counter1 - Input Capture Register Low Byte 165\n(0x85) TCNT1H Timer/Counter1 - Counter Register High Byte 162\n(0x84) TCNT1L Timer/Counter1 - Counter Register Low Byte 162\n(0x83) Reserved - - - - - - - -\n(0x82) TCCR1C FOC1A FOC1B FOC1C - - - - - 161\n(0x81) TCCR1B ICNC1 ICES1 - WGM13 WGM12 CS12 CS11 CS10 160\n(0x80) TCCR1A COM1A1 COM1A0 COM1B1 COM1B0 COM1C1 COM1C0 WGM11 WGM10 158\n(0x7F) DIDR1 - - - - - -A I N 1 D A I N 0 D 274\n(0x7E) DIDR0 ADC7D ADC6D ADC5D ADC4D ADC3D ADC2D ADC1D ADC0D 295\n(0x7D) DIDR2 ADC15D ADC14D ADC13D ADC12D ADC11D ADC10D ADC9D ADC8D 295Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n414\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n(0x7C) ADMUX REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 289\n(0x7B) ADCSRB -A C M E - - MUX5 ADTS2 ADTS1 ADTS0 272, 290, 294\n(0x7A) ADCSRA ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 292\n(0x79) ADCH ADC Data Register High byte 294\n(0x78) ADCL ADC Data Register Low byte 294\n(0x77) Reserved - - - - - - - -\n(0x76) Reserved - - - - - - - -\n(0x75) XMCRB XMBK - - - - XMM2 XMM1 XMM0 38\n(0x74) XMCRA SRE SRL2 SRL1 SRL0 SR W11 SR W10 SR W01 SR W00 37\n(0x73) TIMSK5 - -I C I E 5 - OCIE5C OCIE5B OCIE5A TOIE5 166\n(0x72) TIMSK4 - -I C I E 4 - OCIE4C OCIE4B OCIE4A TOIE4 166\n(0x71) TIMSK3 - -I C I E 3 - OCIE3C OCIE3B OCIE3A TOIE3 166\n(0x70) TIMSK2 - - - - - OCIE2B OCIE2A TOIE2 193\n(0x6F) TIMSK1 - -I C I E 1 - OCIE1C OCIE1B OCIE1A TOIE1 166\n(0x6E) TIMSK0 - - - - - OCIE0B OCIE0A TOIE0 134\n(0x6D) PCMSK2 PCINT23 PCINT22 PCINT21 PCINT20 PCINT19 PCINT18 PCINT17 PCINT16 116\n(0x6C) PCMSK1 PCINT15 PCINT14 PCINT13 P CINT12 PCINT11 PCINT10 PCINT9 PCINT8 116\n(0x6B) PCMSK0 PCINT7 PCINT6 PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 117\n(0x6A) EICRB ISC71 ISC70 ISC61 ISC60 ISC51 ISC50 ISC41 ISC40 114\n(0x69) EICRA ISC31 ISC30 ISC21 ISC20 ISC11 ISC10 ISC01 ISC00 113\n(0x68) PCICR - - - - - PCIE2 PCIE1 PCIE0 115\n(0x67) Reserved - - - - - - - -\n(0x66) OSCCAL Oscillator Calibration Register 50\n(0x65) PRR1 - - PRTIM5 PRTIM4 PRTIM3 PRUSART3 PRUSART2 PRUSART1 57\n(0x64) PRR0 PRT WI PRTIM2 PRTIM0 - PRTIM1 PRSPI PRUSART0 PRADC 56\n(0x63) Reserved - - - - - - - -\n(0x62) Reserved - - - - - - - -\n(0x61) CLKPR CLKPCE - - - CLKPS3 CLKPS2 CLKPS1 CLKPS0 50\n(0x60) WDTCSR WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 67\n0x3F (0x5F) SREG I T H S V N Z C 14\n0x3E (0x5E) SPH SP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 16\n0x3D (0x5D) SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 16\n0x3C (0x5C) EIND - - - - - - -E I N D 0 17\n0x3B (0x5B) RAMPZ - - - - - - RAMPZ1 RAMPZ0 17\n0x3A (0x5A) Reserved - - - - - - - -\n0x39 (0x59) Reserved - - - - - - - -\n0x38 (0x58) Reserved - - - - - - - -\n0x37 (0x57) SPMCSR SPMIE R WWSB SIGRD R WWSRE BLBSET PG WRT PGERS SPMEN 332\n0x36 (0x56) Reserved - - - - - - - -\n0x35 (0x55) MCUCR JTD - -P U D - - IVSEL IVCE 67, 110, 100, 308\n0x34 (0x54) MCUSR - - -J T R F WDRF BORF EXTRF PORF 308\n0x33 (0x53) SMCR - - - - SM2 SM1 SM0 SE 52\n0x32 (0x52) Reserved - - - - - - - -\n0x31 (0x51) OCDR OCDR7 OCDR6 OCDR5 OCDR4 OCDR3 OCDR2 OCDR1 OCDR0 301\n0x30 (0x50) ACSR ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 272\n0x2F (0x4F) Reserved - - - - - - - -\n0x2E (0x4E) SPDR  SPI Data Register 204\n0x2D (0x4D) SPSR SPIF WCOL - - - - - SPI2X 203\n0x2C (0x4C) SPCR SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 202\n0x2B (0x4B) GPIOR2 General Purpose I/O Register 2 37\n0x2A (0x4A) GPIOR1 General Purpose I/O Register 1 37\n0x29 (0x49) Reserved - - - - - - - -\n0x28 (0x48) OCR0B  Timer/Counter0 Output Compare Register B 133\n0x27 (0x47) OCR0A  Timer/Counter0 Output Compare Register A 133\n0x26 (0x46) TCNT0  Timer/Counter0 (8 Bit) 133\n0x25 (0x45) TCCR0B FOC0A FOC0B - - WGM02 CS02 CS01 CS00 132\n0x24 (0x44) TCCR0A COM0A1 COM0A0 COM0B1 COM0B0 - - WGM01 WGM00 129\n0x23 (0x43) GTCCR TSM - - - - - PSRASY PSRSYNC 170, 194\n0x22 (0x42) EEARH - - - - EEPROM Address Register High Byte 35\n0x21 (0x41) EEARL EEPROM Address Register Low Byte 35\n0x20 (0x40) EEDR EEPROM Data Register 35\n0x1F (0x3F) EECR - - EEPM1 EEPM0 EERIE EEMPE EEPE EERE 35\n0x1E (0x3E) GPIOR0 General Purpose I/O Register 0 37\n0x1D (0x3D) EIMSK INT7 INT6 INT5 INT4 INT3 INT2 INT1 INT0 115\n0x1C (0x3C) EIFR INTF7 INTF6 INTF5 INTF4 INTF3 INTF2 INTF1 INTF0 115\n0x1B (0x3B) PCIFR - - - - - PCIF2 PCIF1 PCIF0 116Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n415\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. For compatibility with future devices, reserved bits s hould be written to zero if accessed. Reserved I/O memory address es \nshould never be written.\n2. I/O registers within the address range $00 - $1F are directly bit-accessible using th e SBI and CBI instructions. In these reg -\nisters, the value of single bits can be checked by using the SBIS and SBIC instructions.\n3. Some of the status flags are cleared by writing a logical o ne to them. Note that the CBI and SBI instructions will operate on  \nall bits in the I/O register, writing a one back into any flag r ead as set, thus clearing the fl ag. The CBI and SBI instruction s \nwork with registers 0x00 to 0x1F only.\n4.When using the I/O specific commands IN and OU T, the I/O addresses $00 - $3F must be used. When addressing I/O regis-\nters as data space using LD and ST instructions, $20 must be added to these addresses. The \nATmega640/1280/1281/2560/2561 is a complex microcontroller with  more peripheral units than can be supported within the \n64 location reserved in Opcode for the IN  and OUT instructions. For the Extended I/O space from $60 - $1FF in SRAM, only \nthe ST/STS/STD and LD/LDS/LDD instructions can be used.0x1A (0x3A) TIFR5 - -I C F 5 - OCF5C OCF5B OCF5A TOV5 166\n0x19 (0x39) TIFR4 - -I C F 4 - OCF4C OCF4B OCF4A TOV4 167\n0x18 (0x38) TIFR3 - -I C F 3 - OCF3C OCF3B OCF3A TOV3 167\n0x17 (0x37) TIFR2 - - - - - OCF2B OCF2A TOV2 193\n0x16 (0x36) TIFR1 - -I C F 1 - OCF1C OCF1B OCF1A TOV1 167\n0x15 (0x35) TIFR0 - - - - - OCF0B OCF0A TOV0 134\n0x14 (0x34) PORTG - - PORTG5 PORTG4 PORTG3 PORTG2 PORTG1 PORTG0 102\n0x13 (0x33) DDRG - - DDG5 DDG4 DDG3 DDG2 DDG1 DDG0 102\n0x12 (0x32) PING - - PING5 PING4 PING3 PING2 PING1 PING0 102\n0x11 (0x31) PORTF PORTF7 PORTF6 PORTF5 PORTF4 PORTF3 PORTF2 PORTF1 PORTF0 101\n0x10 (0x30) DDRF DDF7 DDF6 DDF5 DDF4 DDF3 DDF2 DDF1 DDF0 102\n0x0F (0x2F) PINF PINF7 PINF6 PINF5 PINF4 PINF3 PINF2 PINF1 PINF0 102\n0x0E (0x2E) PORTE PORTE7 PORTE6 PORTE 5 PORTE4 PORTE3 PORTE2 PORTE1 PORTE0 101\n0x0D (0x2D) DDRE DDE7 DDE6 DDE5 DDE4 DDE3 DDE2 DDE1 DDE0 101\n0x0C (0x2C) PINE PINE7 PINE6 PINE5 PINE4 PINE3 PINE2 PINE1 PINE0 102\n0x0B (0x2B) PORTD PORTD7 PORTD6 PORTD 5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 101\n0x0A (0x2A) DDRD DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 101\n0x09 (0x29) PIND PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 101\n0x08 (0x28) PORTC PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 101\n0x07 (0x27) DDRC DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 101\n0x06 (0x26) PINC PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 101\n0x05 (0x25) PORTB PORTB7 PORTB6 PORTB 5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 100\n0x04 (0x24) DDRB DDB7 DDB6 D DB5 DDB4 DDB3 DDB2 DDB1 DDB0 100\n0x03 (0x23) PINB PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 100\n0x02 (0x22) PORTA PORTA7 PORTA6 PORTA 5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 100\n0x01 (0x21) DDRA DDA7 DDA6 D DA5 DDA4 DDA3 DDA2 DDA1 DDA0 100\n0x00 (0x20) PINA PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 100Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n416\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n34. Instruction Set Summary\nMnemonics Operands Description Operation Flags #Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \u2190 Rd + Rr Z, C, N, V, H 1\nADC Rd, Rr Add with Carry two Registers Rd \u2190 Rd + Rr + C Z, C, N, V, H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \u2190 Rdh:Rdl + K Z, C, N, V, S 2\nSUB Rd, Rr Subtract two Registers Rd \u2190 Rd - Rr Z, C, N, V, H 1\nSUBI Rd, K Subtract Constant from Register Rd \u2190 Rd - K Z, C, N, V, H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \u2190 Rd - Rr - C Z, C, N, V, H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \u2190 Rd - K - C Z, C, N, V, H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \u2190 Rdh:Rdl - K Z, C, N, V, S 2\nAND Rd, Rr Logical AND Registers Rd \u2190 Rd \u2022 Rr Z, N, V 1\nANDI Rd, K Logical AND Register and Constant Rd \u2190 Rd \u2022 K Z, N, V 1\nOR Rd, Rr Logical OR Registers Rd \u2190 Rd v Rr Z, N, V 1\nORI Rd, K Logical OR Register and Constant Rd \u2190 Rd v K Z, N, V 1\nEOR Rd, Rr Exclusive OR Registers Rd \u2190 Rd \u2295 Rr Z, N, V 1\nCOM Rd One\u2019s Complement Rd \u2190 0xFF \u2212 Rd Z, C, N, V 1\nNEG Rd Two\u2019s Complement Rd \u2190 0x00 \u2212 Rd Z, C, N, V, H 1\nSBR Rd,K Set Bit(s) in Register Rd \u2190 Rd v K Z, N, V 1\nCBR Rd,K Clear Bit(s) in Register Rd \u2190 Rd \u2022 (0xFF - K) Z, N, V 1\nINC Rd Increment Rd \u2190 Rd + 1 Z, N, V 1\nDEC Rd Decrement Rd \u2190 Rd \u2212 1 Z, N, V 1\nTST Rd Test for Zero or Minus Rd \u2190 Rd \u2022 Rd Z, N, V 1\nCLR Rd Clear Register Rd  \u2190 Rd \u2295 Rd Z, N, V 1\nSER Rd Set Register Rd \u2190 0xFF None 1\nMUL Rd, Rr Multiply Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nMULS Rd, Rr Multiply Signed R1:R0 \u2190 Rd x Rr Z, C 2\nMULSU Rd, Rr Multiply Signed with Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nFMUL Rd, Rr Fractional Multiply Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULS Rd, Rr Fractional Multiply Signed R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULSU Rd, Rr Fractional Multiply Signed with Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nBRANCH INSTRUCTIONSRJMP k Relative Jump PC  \u2190 PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \u2190 Z None 2\nEIJMP Extended Indirect Jump to (Z) PC \u2190(EIND:Z) None 2\nJMP k Direct Jump PC  \u2190 kN o n e 3\nRCALL k Relative Subroutine Call PC \u2190 PC + k + 1 None 4\nICALL Indirect Call to (Z) PC \u2190 ZN o n e 4\nEICALL Extended Indirect Call to (Z) PC \u2190(EIND:Z) None 4\nCALL k Direct Subroutine Call PC \u2190 kN o n e 5\nRET Subroutine Return PC \u2190 STACK None 5\nRETI Interrupt Return PC \u2190 STACK I 5\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC  \u2190 PC + 2 or 3 None 1/2/3\nCP Rd,Rr Compare Rd \u2212 Rr Z, N, V, C, H 1 \nCPC Rd,Rr Compare with Carry Rd \u2212 Rr \u2212 C Z, N, V, C, H 1\nCPI Rd,K Compare Register with Immediate Rd \u2212 K Z, N, V, C, H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \u2190 PC + 2 or 3 None 1/2/3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \u2190 PC + 2 or 3 None 1/2/3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \u2190 PC + 2 or 3 None 1/2/3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \u2190 PC + 2 or 3 None 1/2/3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \u2190PC+k + 1 None 1/2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \u2190PC+k + 1 None 1/2\nBREQ  k Branch if Equal if (Z = 1) then PC \u2190 PC + k + 1 None 1/2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \u2190 PC + k + 1 None 1/2\nBRCS  k Branch if Carry Set if (C = 1) then PC \u2190 PC + k + 1 None 1/2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \u2190 PC + k + 1 None 1/2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \u2190 PC + k + 1 None 1/2\nBRLO  k Branch if Lower if (C = 1) then PC \u2190 PC + k + 1 None 1/2\nBRMI  k Branch if Minus if (N = 1) then PC \u2190 PC + k + 1 None 1/2\nBRPL  k Branch if Plus if (N = 0) then PC \u2190 PC + k + 1 None 1/2\nBRGE  k Branch if Greater or Equal, Signed if (N \u2295 V= 0) then PC \u2190 PC + k + 1 None 1/2\nBRLT  k Branch if Less Than Zero, Signed if (N \u2295 V= 1) then PC \u2190 PC + k + 1 None 1/2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \u2190 PC + k + 1 None 1/2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \u2190 PC + k + 1 None 1/2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \u2190 PC + k  + 1 None 1/2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \u2190 PC + k + 1 None 1/2\n\n417\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \u2190 PC + k + 1 None 1/2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \u2190 PC + k + 1 None 1/2\nBRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \u2190 PC + k + 1 None 1/2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \u2190 PC + k + 1 None 1/2\nBIT AND BIT-TEST INSTRUCTIONS\nSBI P,b Set Bit in I/O Register I/O(P,b) \u2190 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \u2190 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \u2190 Rd(n), Rd(0) \u2190 0 Z, C, N, V 1\nLSR Rd Logical Shift Right Rd(n) \u2190 Rd(n+1), Rd(7) \u2190 0 Z, C, N, V 1\nROL Rd Rotate Left Through Carry Rd(0) \u2190C,Rd(n+1) \u2190 Rd(n),C \u2190Rd(7) Z, C, N, V 1\nROR Rd Rotate Right Through Carry Rd(7) \u2190C,Rd(n) \u2190 Rd(n+1),C \u2190Rd(0) Z, C, N, V 1\nASR Rd Arithmetic Shift Right Rd(n) \u2190 Rd(n+1), n=0..6 Z, C, N, V 1\nSWAP Rd Swap Nibbles Rd(3..0) \u2190Rd(7..4),Rd(7..4) \u2190Rd(3..0) None 1\nBSET s Flag Set SREG(s) \u2190 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \u2190 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \u2190 Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \u2190 TN o n e 1\nSEC Set Carry C \u2190 1C 1\nCLC Clear Carry C \u2190 0 C 1\nSEN Set Negative Flag N \u2190 1N 1\nCLN Clear Negative Flag N \u2190 0 N 1\nSEZ Set Zero Flag Z \u2190 1Z 1\nCLZ Clear Ze ro Flag Z \u2190 0 Z 1\nSEI Global Interrupt Enable I \u2190 1I 1\nCLI Global Interrupt Disable I  \u2190 0 I 1\nSES Set Signed Test Flag S \u2190 1S 1\nCLS Clear Signed Test Flag S \u2190 0 S 1\nSEV Set Twos Complement Overflow. V \u2190 1V 1\nCLV Clear Twos Complement Overflow V \u2190 0 V 1\nSET Set T in SREG T \u2190 1T 1\nCLT Clear T in SREG T \u2190 0 T 1\nSEH Set Half Carry Flag in SREG H \u2190 1H 1\nCLH Clear Half Carry Flag in SREG H \u2190 0 H 1\nDATA TRANSFER INSTRUCTIONS\nMOV Rd, Rr Move Between Registers Rd \u2190 Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \u2190 Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \u2190 KN o n e 1\nLD Rd, X Load Indirect Rd \u2190 (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \u2190 (X), X \u2190 X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \u2190 X - 1, Rd \u2190 (X) None 2\nLD Rd, Y Load Indirect Rd \u2190 (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \u2190 (Y), Y \u2190 Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \u2190 Y - 1, Rd \u2190 (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \u2190 (Y + q) None 2\nLD Rd, Z Load Indirect Rd \u2190 (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \u2190 (Z), Z \u2190 Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \u2190 Z - 1, Rd \u2190 (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \u2190 (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \u2190 (k) None 2\nST X, Rr Store Indirect (X)  \u2190 Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X)  \u2190 Rr, X \u2190 X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \u2190 X - 1, (X) \u2190 Rr None 2\nST Y, Rr Store Indirect (Y) \u2190 Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \u2190 Rr, Y \u2190 Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \u2190 Y - 1, (Y) \u2190 Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \u2190 Rr None 2\nST Z, Rr Store Indirect (Z) \u2190 Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \u2190 Rr, Z \u2190 Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \u2190 Z - 1, (Z) \u2190 Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \u2190 Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \u2190 Rr None 2\nLPM Load Program Memory R0 \u2190 (Z) None 3\nLPM Rd, Z Load Program Memory Rd \u2190 (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \u2190 (Z), Z \u2190 Z+1 None 3\nELPM Extended Load Program Memory R0 \u2190 (RAMPZ:Z) None 3\nELPM Rd, Z Extended Load Program Memory Rd \u2190 (RAMPZ:Z) None 3Mnemonics Operands Description Operation Flags #Clocks\n\n418\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNote: EICALL and EIJMP do not exist in ATmega640/1280/1281.\nELPM does not exist in ATmega640.ELPM Rd, Z+ Extended Load Program Memory Rd \u2190 (RAMPZ:Z), RAMPZ:Z \u2190RAMPZ:Z+1 None 3\nSPM Store Program Memory (Z) \u2190 R1:R0 None -\nIN Rd, P In Port Rd \u2190 PN o n e 1\nOUT P, Rr Out Port P \u2190 Rr None 1\nPUSH Rr Push Register on Stack STACK \u2190 Rr None 2\nPOP Rd Pop Register from Stack Rd \u2190 STACK None 2\nMCU CONTROL INSTRUCTIONSNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1\nWDR Watchdog Reset (see specific descr. for WDR/timer) None 1\nBREAK Break For On-chip Debug Only None N/AMnemonics Operands Description Operation Flags #Clocks\n\n419\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n35. Ordering Information\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2.See \u201cSpeed Grades\u201d on page 369.\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.1 ATmega640\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8 - 5.5VATmega640V-8AU\nATmega640V-8AUR(4)\nATmega640V-8CUATmega640V-8CUR\n(4)100A100A\n100C1\n100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 2.7 - 5.5VATmega640-16AU\nATmega640-16AUR\n(4)\nATmega640-16CUATmega640-16CUR\n(4)100A100A\n100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n420\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.2 ATmega1280\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8V - 5.5VATmega1280V-8AU\nATmega1280V-8AUR(4)\nATmega1280V-8CU\nATmega1280V-8CUR(4)100A\n100A\n100C1100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 2.7V - 5.5VATmega1280-16AU\nATmega1280-16AUR\n(4)\nATmega1280-16CU\nATmega1280-16CUR(4)100A\n100A100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n421\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.3 ATmega1281\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8 - 5.5VATmega1281V-8AU\nATmega1281V-8AUR(4)\nATmega1281V-8MUATmega1281V-8MUR\n(4)64A64A\n64M2\n64M2 Industrial\n(-40\u00b0C to 85 \u00b0C)\n16 2.7 - 5.5VATmega1281-16AU\nATmega1281-16AUR\n(4)\nATmega1281-16MU\nATmega1281-16MUR(4)64A\n64A\n64M264M2\nPackage Type\n64A 64-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n64M2 64-pad, 9mm \u00d7 9mm \u00d7 1.0mm Body, Quad Flat No-lead/Micro Lead Frame Package (QFN/MLF)\n\n422\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.4 ATmega2560\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n8 1.8V - 5.5VATmega2560V-8AU\nATmega2560V-8AUR(4)\nATmega2560V-8CU\nATmega2560V-8CUR(4)100A\n100A\n100C1100C1\nIndustrial (-40 \u00b0C to 85 \u00b0C)\n16 4.5V - 5.5VATmega2560-16AU\nATmega2560-16AUR\n(4)\nATmega2560-16CU\nATmega2560-16CUR(4)100A\n100A100C1\n100C1\nPackage Type\n100A 100-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n100C1 100-ball, Chip Ball Grid Array (CBGA)\n\n423\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation \nand minimum quantities.\n2. See \u201cSpeed Grades\u201d on page 369 .\n3. Pb-free packaging, complies to the European Directive for Restriction of Hazardous Subst ances (RoHS directive). Also \nHalide free and fully Green.\n4. Tape & Reel35.5 ATmega2561\nSpeed (MHz)(2)Power Supply Ordering Code Package(1)(3)Operation Range\n81 . 8 V  -  5 . 5 VATmega1281V-8AU\nATmega1281V-8AUR(4)\nATmega1281V-8MU\nATmega1281V-8MUR(4)64A\n64A\n64M264M2 Industrial\n(-40\u00b0C to 85 \u00b0C)\n16 4.5V - 5.5VATmega1281-16AU\nATmega1281-16AUR\n(4)\nATmega1281-16MU\nATmega1281-16MUR(4)64A\n64A64M2\n64M2\nPackage Type\n64A 64-lead, Thin (1.0mm) Plastic Gull Wing Quad Flat Package (TQFP)\n64M2 64-pad, 9mm \u00d7 9mm \u00d7 1.0mm Body, Quad Flat No-lead/Micro Lead Frame Package (QFN/MLF)\n\n424\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36. Packaging Information\n36.1 100A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n100A,  100-le ad, 14 x 14 mm Body Size, 1.0 mm Body Thickne ss,\n0.5 mm Le ad Pitch, Thin Profile Pl astic Quad Flat Package (TQFP) D 100A2010-10-20PIN 1 IDENTIFIER\n0\u00b0~7\u00b0PIN 1 \nLC\nA1 A2 AD1\nDe E1 EB\n A \u2013 \u2013 1.20\n A1 0.05 \u2013 0.15 A2  0.95 1.00 1.05            D 15.75 16.00 16.25 D1 1 3.90 14.00 14.10 Note 2\n E 15.75 16.00 16.25 E1 1 3.90 14.00 14.10 Note 2\n B           0.17 \u2013 0.27 C 0.09 \u2013 0.20 L 0.45 \u2013  0.75 e  0.50 TYPNotes: \n 1. Thi s package conform s to JEDEC reference MS-026, V ariation AED. \n 2. Dimen sions D1 and E1 do not incl ude mold protr usion.  Allow able \n  protr usion is 0.25 mm per side. Dimen sions D1 and E1 are maximum \n  p l astic body size dimen sions including mold mi smatch.\n 3. Lead copl anarity is 0.08 mm m aximum.COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n\n425\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.2 100C1\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n100C1 , 100-ball, 9 x 9 x 1.2 mm Body, Ball Pitch 0.80 mm \nChip Array BGA Package (CBGA)   A 100C15/25/06TOP VIEWSIDE VIEW\nBOTTOM VIEWCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 1.10  \u2013  1.20\n A1 0.30 0.35 0.40\n D 8.90 9.00 9.10\n E 8.90 9.00 9.10\n D1 7.10 7.20 7.30\n E1 7.10 7.20 7.30\n \u00d8b 0.35 0.40 0.45\n e  0.80 TYPMarked A1 Identifier\n1 2 3 4 5 67 8\nA\nB\nC\nD\nE 9\nF\nG\nH\nI\nJ100.90 TYP\n0.90 TYPA1 Corner0.12 Z\nE\nD\ne\ne \u00d8bA\nA1\nE1D1\n\n426\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.3 64A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n64A,  64-le ad, 14 x 14 mm Body Size, 1.0 mm Body Thickne ss,\n0.8 mm Le ad Pitch, Thin Profile Pl astic Quad Flat Package (TQFP) C 64A2010-10-20PIN 1 IDENTIFIER\n0\u00b0~7\u00b0PIN 1 \nLC\nA1 A2 AD1\nDe\nE1 EB\nCOMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes:\n     1.Thi s package conform s to JEDEC reference MS-026, V ariation AEB. \n 2. Dimen sions D1 and E1 do not incl ude mold protr usion.  Allow able \n  protr usion is 0.25 mm per side. Dimen sions D1 and E1 are maximum \n  p l astic body size dimen sions including mold mi smatch.\n 3. Lead copl anarity is 0.10 mm m aximum. A \u2013 \u2013 1.20\n A1 0.05 \u2013 0.15 A2  0.95 1.00 1.05            D 15.75 16.00 16.25 D1 1 3.90 14.00 14.10 Note 2\n E 15.75 16.00 16.25 E1 1 3.90 14.00 14.10 Note 2\n B           0. 30 \u2013 0.45\n C 0.09 \u2013 0.20 L 0.45 \u2013  0.75 e  0.80 TYP\n\n427\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n36.4 64M2\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n64M2 , 64-p ad, 9 x 9 x 1.0 mm Body, Le ad Pitch 0.50 mm, E 64M22010-10-20COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 0.80 0.90 1.00\n A1 \u2013 0.02 0.05 \nb \n0.18 0.25 0. 30  \nD  \n \nD2 \n7.50 7.65 7.808.90 9.00 9.10\n8.90 9.00 9.10 \nE \n \nE2 \n7.50 7.65 7.80  \ne  \n0.50 BSC\nL0 . 35 0.40 \n0.45 TOP VIEW\nSIDE VIEW\nBOTTOM VIEWD\nEMarked Pin# 1 ID\nSEATING PLANE\nA1C\nA\nC 0.08\n1\n23\nK 0.20 0.27 0.40\n  2. Dimen sion and toler ance conform to ASMEY14.5M-1994. 0.20 REF A3A3\nE2D2\nb ePin #1 CornerL\nPin #1 \nTriangle\nPin #1 \nChamfer\n(C 0. 30)Option A\nOption B\nPin #1 \nNotch(0.20 R)Option CK\nK\nNotes:  1. JEDEC St andard MO-220, (SAW Sing ulation) Fig. 1, VMMD.\n7.65 mm Expo sed Pad, Micro Le ad Frame P ackage (MLF) \n\n428\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37. Errata\n37.1 ATmega640 rev. B\n\u0081Inaccurate ADC conversion in differential mode with 200\u00d7 gain\n\u0081High current consumption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.2 ATmega640 rev. A\n\u0081Inaccurate ADC conversion in differential mode with 200\u00d7 gain\n\u0081High current consumption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.3 ATmega1280 rev. B\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\n\n429\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.4 ATmega1280 rev. A\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.5 ATmega1281 rev. B\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n\n430\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.6 ATmega1281 rev. A\n\u0081Inaccurate ADC conversion  in differential mode with 200\u00d7 gain\n\u0081High current consum ption in sleep mode\n1.  Inaccurate ADC conversion in differential mode with 200\u00d7 gain\nWith AVCC <3.6V, random conversions will be in accurate. Typical absolute accuracy may\nreach 64 LSB.\nProblem Fix/Workaround\nNone.\n2. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.7 ATmega2560 rev. F\nNot sampled.\n37.8 ATmega2560 rev. E\nNo known errata.\n37.9 ATmega2560 rev. D\nNot sampled.\n37.10 ATmega2560 rev. C\n\u0081High current consumption in sleep mode\n1. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.11 ATmega2560 rev. B\nNot sampled.\n\n431\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.12 ATmega2560 rev. A\n\u0081Non-Read-While-Write area  of flash not functional\n\u0081Part does not work under 2.4 volts\n\u0081Incorrect ADC reading in differential mode\n\u0081Internal ADC reference has too low value\n\u0081IN/OUT instructions may be executed twice when Stack is in external RAM\n\u0081EEPROM read from appli cation code does not work in Lock Bit Mode 3\n1.  Non-Read-While-Write area of flash not functional\nThe Non-Read- While-Write area of the flash is not working as expected. The problem is\nrelated to the speed of the part when reading the flash of this area.\nProblem Fix/Workaround\n- Only use the first 248K of the flash.\n- If boot functionality is needed, run the code in the Non-Read- While-Write area at maximum\n1/4th of the maximum frequency of the device at any given voltage. This is done by writing\nthe CLKPR register before entering the boot section of the code.\n2. Part does not work under 2.4 volts\nThe part does not execute code correctly below 2.4 volts.\nProblem Fix/Workaround\nDo not use the part at voltages below 2.4 volts.\n3. Incorrect ADC reading in differential mode\nThe ADC has high noise in differential mode. It can give up to 7 LSB error.\nProblem Fix/Workaround\nUse only the 7 MSB of the result when using the ADC in differential mode.\n4. Internal ADC reference has too low value\nThe internal ADC reference has a value lower than specified.\nProblem Fix/Workaround\n- Use AVCC or external reference.\n- The actual value of the reference can be measured by applying a known voltage to the\nADC when using the internal reference. The result when doing later conversions can then becalibrated.\n5. IN/OUT instructions may be executed twice when Stack is in external RAM\nIf either an IN or an OUT instruction is exec uted directly before an interrupt occurs and the\nstack pointer is located in exte rnal ram, the instruction will be ex ecuted twice. In some cases\nthis will cause a prob lem, for example:\n- If reading SREG it will appear that the I-flag is cleared.\n- If writing to the PIN regist ers, the port will toggle twice.\n- If reading registers with interrupt flags, the flags will appea r to be cleared.\n\n432\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nThere are two application work-arounds, where selecting one of them, will be omitting the\nissue:\n- Replace IN and OUT with LD/LDS/L DD and ST/STS/STD instructions.\n- Use internal RAM for stack pointer.\n6. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does\nnot work from the application code.\nProblem Fix/Workaround\nDo not set Lock Bit Protection Mode 3 when the application code needs to read from\nEEPROM.\n37.13 ATmega2561 rev. F\nNot sampled.\n37.14 ATmega2561 rev. E\nNo known errata.\n37.15 ATmega2561 rev. D\nNot sampled.\n37.16 ATmega2561 rev. C\n\u0081High current consumpt ion in sleep mode.\n1. High current consumption in sleep mode\nIf a pending interrupt cannot wake the part up from the selected sleep mode, the current\nconsumption will increase during sleep when exec uting the SLEEP instruction directly after\na SEI instruction.\nProblem Fix/Workaround\nBefore entering sleep, interrupts not used to wake the part from the sleep mode should be\ndisabled.\n37.17 ATmega2561 rev. B\nNot sampled.\n37.18 ATmega2561 rev. A\n\u0081Non-Read-While-Write area of flash not functional\n\u0081Part does not work under 2.4 Volts\n\u0081Incorrect ADC reading in differential mode\n\u0081Internal ADC reference has too low value\n\u0081IN/OUT instructions may be executed twice when Stack is in external RAM\n\u0081EEPROM read from applicat ion code does not work  in Lock Bit Mode 3\n\n433\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n1.  Non-Read-While-Write area of flash not functional\nThe Non-Read- While-Write area of the flash is not working as expected. The problem is\nrelated to the speed of the part when reading the flash of this area.\nProblem Fix/Workaround\n- Only use the first 248K of the flash.\n- If boot functionality is needed, run the code in the Non-Read- While-Write area at maximum\n1/4th of the maximum frequency of the device at any given voltage. This is done by writing\nthe CLKPR register before entering the boot section of the code.\n2. Part does not work under 2.4 volts\nThe part does not execute code correctly below 2.4 volts.\nProblem Fix/Workaround\nDo not use the part at voltages below 2.4 volts.\n3. Incorrect ADC reading in differential mode\nThe ADC has high noise in differential mode. It can give up to 7 LSB error.\nProblem Fix/Workaround\nUse only the 7 MSB of the result when using the ADC in differential mode.\n4. Internal ADC reference has too low value\nThe internal ADC reference has a value lower than specified.\nProblem Fix/Workaround\n- Use AVCC or external reference.\n- The actual value of the reference can be measured by applying a known voltage to the\nADC when using the internal reference. The result when doing later conversions can then be\ncalibrated.\n5. IN/OUT instructions may be executed twice when Stack is in external RAM\nIf either an IN or an OUT instruction is exec uted directly before an interrupt occurs and the\nstack pointer is located in exte rnal ram, the instruction will be ex ecuted twice. In some cases\nthis will cause a prob lem, for example:\n- If reading SREG it will appear that the I-flag is cleared.\n- If writing to the PIN regist ers, the port will toggle twice.\n- If reading registers with interrupt flags, the flags will appea r to be cleared.\nProblem Fix/Workaround\nThere are two application workarounds, wher e selecting one of them, will be omitting the\nissue:\n- Replace IN and OUT with LD/LDS/L DD and ST/STS/STD instructions.\n- Use internal RAM for stack pointer.\n6. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does\nnot work from the application code.\n\n434\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nProblem Fix/Workaround\nDo not set Lock Bit Protection Mode 3 when the application code needs to read from\nEEPROM.\n\n435\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38. Datasheet Revision History\nPlease note that the referring page numbers in this section are referring to this document.The\nreferring revision in this  section are referring to  the document revision.\n38.1 Rev. 2549N-05/11\n38.2 Rev. 2549M-09/10\n38.3 Rev. 2549L-08/071. Added Atmel QTouch Library Support and  QTouch Sensing Capablity Features\n2. Updated Cross-reference in \u201cBit 5, 2:0 - WDP3:0: Watchdog Timer Prescaler 3, 2, 1 and 0\u201d on\npage 68\n3. Updated Assembly codes in section \u201cUSART Initialization\u201d on page 210\n4. Added \u201cStandard Power-On Reset\u201d on page 372 .\n5. Added \u201cEnhanced Power-On Reset\u201d on page 373 .\n6. Updated Figure 32-13 on page 393\n7. Updated \u201cOrdering Information\u201d on page 419  to include Tape & Reel devices.\n1. Updated typos in Figure 26-9 on page 285  and in Figure 26-10 on page 285 .\n2. Note is added below Table 1-1 on page 3 .\n3. The values for \u201ctypical characteristics\u201d in Table 31-9 on page 377  and Table 31-10 on page 378 ,\nhas been rounded.\n4. Units for tRST and tBOD in Table 31-3 on page 372  have been changed from \u201cns\u201d to \u201c\u00b5s\u201d.\n5. The figure text for Table 31-2 on page 371  has been changed.\n6. Text in first column in Table 30-3 on page 336  has been changed from \u201cFuse Low Byte\u201d to\n\u201cExtended Fuse Byte\u201d.\n7. The text in \u201cPower Reduction Register\u201d on page 54  has been changed.\n8. The value of the inductor in Figure 26-9 on page 285  and Figure 26-10 on page 285  has been\nchanged to 10 \u00b5H.\n9. \u201cPort A\u201d has been changed into \u201cPort K\u201d in the first paragraph of \u201cFeatures\u201d on page 275 .\n10. Minimum wait delay for t WD_EEPROM in Table 30-16 on page 351  has been changed from\n9.0ms to 3.6ms\n11. Dimension A3 is added in \u201c64M2\u201d on page 427 .\n12. Several cross-references are corrected.13. \u201cCOM0A1:0\u201d on page 130 is corrected to \u201cCOM0B1:0\u201d.\n14. Corrected some Figure and Table numbering.\n15. Updated Section 10.6 \u201cLow Frequency Cr ystal Oscillator\u201d on page 45 .\n1. Updated note in Table 10-11 on page 47 .\n2. Updated Table 10-3 on page 43 , Table 10-5 on page 44 , Table 10-9 on page 47 .\n3. Updated typos in \u201cDC Characteristics\u201d on page 367\n4. Updated \u201cClock Characteristics\u201d on page 371\n5. Updated \u201cExternal Clock Drive\u201d on page 371 . \n6. Added \u201cSystem and Reset Characteristics\u201d on page 372 .\n\n436\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.4 Rev. 2549K-01/07\n38.5 Rev. 2549J-09/06\n38.6 Rev. 2549I-07/06\n38.7 Rev. 2549H-06/067. Updated \u201cSPI Timing Characteristics\u201d on page 375 .\n8. Updated \u201cADC Characteristics \u2013 Preliminary Data\u201d on page 377 .\n9. Updated ordering code in \u201cATmega640\u201d on page 419 .\n1. Updated Table 1-1 on page 3 .\n2. Updated \u201cPin Descriptions\u201d on page 7 .\n3. Updated \u201cStack Pointer\u201d on page 16 .\n4. Updated \u201cBit 1 \u2013 EEPE: EEPROM Programming Enable\u201d on page 36 .\n5. Updated Assembly code example in \u201cThus, when the BOD is not enabled, after setting the ACBG\nbit or enabling the ADC, the user  must always allow the refer ence to start up before the output\nfrom the Analog Comparator or ADC is used. To reduce power consumption in Power-down\nmode, the user can avoid the three conditions above to ensure that the reference is turned offbefore entering Power-down mode.\u201d on page 63 .\n6: Updated \u201cEIMSK \u2013 External Interrupt Mask Register\u201d on page 115 .\n7. Updated Bit description in \u201cPCIFR \u2013 Pin Change Interrupt Flag Register\u201d on page 116 .\n8. Updated code example in \u201cUSART Initialization\u201d on page 210 .\n9. Updated Figure 26-8 on page 284 .\n10. Updated \u201cDC Characteristics\u201d on page 367 .\n1. Updated \u201c\u201d on page 46 .\n2. Updated code example in \u201cMoving Interrupts Between Applicat ion and Boot Section\u201d on page\n109.\n3. Updated \u201cTimer/Counter Prescaler\u201d on page 186 .\n4. Updated \u201cDevice Identification Register\u201d on page 303 .\n5. Updated \u201cSignature Bytes\u201d on page 338 .\n6. Updated \u201cInstruction Set Summary\u201d on page 416 .\n1. Added \u201cData Retention\u201d on page 11 .\n2. Updated Table 16-3 on page 129 , Table 16-6 on page 130 , Table 16-8 on page 131 , Table 17-2\non page 148 , Table 17-4 on page 159 , Table 17-5 on page 160 , Table 20-3 on page 187 , Table\n20-6 on page 188  and Table 20-8 on page 189 .\n3. Updated \u201cFast P WM Mode\u201d on page 150 .\n1. Updated \u201c\u201d on page 46 .\n2. Updated \u201cOSCCAL \u2013 Oscillator Calibration Register\u201d on page 50 .\n3. Added Table 31-1 on page 371\n.\n\n437\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.8 Rev. 2549G-06/06\n38.9 Rev. 2549F-04/06\n38.10 Rev. 2549E-04/06\n38.11 Rev. 2549D-12/051. Updated \u201cFeatures\u201d on page 1 .\n2. Added Figure 1-2 on page 3 , Table 1-1 on page 3 .\n3. Updated \u201c\u201d on page 46 .\n4. Updated \u201cPower Management and Sleep Modes\u201d on page 52 .\n5. Updated note for Table 12-1 on page 68 .\n6. Updated Figure 26-9 on page 285  and Figure 26-10 on page 285 .\n7. Updated \u201cSetting the Boot Loader Lock Bits by SPM\u201d on page 324 .\n8. Updated \u201cOrdering Information\u201d on page 419 .\n9. Added Package information \u201c100C1\u201d on page 425 .\n10. Updated \u201cErrata\u201d on page 428 .\n1. Updated Figure 9-3 on page 31 , Figure 9-4 on page 31  and Figure 9-5 on page 32 . \n2. Updated Table 20-2 on page 187  and Table 20-3 on page 187 .\n3. Updated Features in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275 .\n4. Updated \u201cFuse Bits\u201d on page 336 .\n1. Updated \u201cFeatures\u201d on page 1 .\n2. Updated Table 12-1 on page 62 .\n3. Updated note for Table 12-1 on page 62 .\n4. Updated \u201cBit 6 \u2013 ACBG: Analog Comparator Bandgap Select\u201d on page 273 .\n5. Updated \u201cPrescaling and Conversion Timing\u201d on page 278 .\n5. Updated \u201cMaximum speed vs. VCC\u201d on page 373 .\n6. Updated \u201cOrdering Information\u201d on page 419 .\n1. Advanced Information Status changed to Preliminary.\n2. Changed number of I/O Ports from 51 to 54.\n3. Updatet typos in \u201cTCCR0A \u2013 Timer/Counter Cont rol Register A\u201d on page 129 .\n4. Updated Features in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275 .\n5. Updated Operation in \u201cADC \u2013 Analog to Digital Converter\u201d on page 275\n6. Updated Stabilizing Time in \u201cChanging Channel or Reference Selection\u201d on page 282 .\n7. Updated Figure 26-1 on page 276 , Figure 26-9 on page 285 , Figure 26-10 on page 285 .\n8. Updated Text in \u201cADCSRB \u2013 ADC Control and Status Register B\u201d on page 290 .\n9. Updated Note for Table 4 on page 43 , Table 13-15 on page 86 , Table 26-3 on page 289  and\nTable 26-6 on page 295 .\n10. Updated Table 31-9 on page 377  and Table 31-10 on page 378 .\n11. Updated \u201cFilling the Temporary Buffer (Page Loading)\u201d on page 323 .\n12. Updated \u201cTypical Characteristics\u201d on page 385 .\n13. Updated \u201cPackaging Information\u201d on page 424 .\n14. Updated \u201cErrata\u201d on page 428 .\n\n438\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n38.12 Rev. 2549C-09/05\n38.13 Rev. 2549B-05/05\n38.14 Rev. 2549A-03/051. Updated Speed Grade in section \u201cFeatures\u201d on page 1 .\n2. Added \u201cResources\u201d on page 11 .\n3. Updated \u201cSPI \u2013 Serial Peripheral Interface\u201d on page 195 . In Slave mode, low and high period SPI\nclock must be larger than 2 CPU cycles.\n4. Updated \u201cBit Rate Generator Unit\u201d on page 247 .\n5. Updated \u201cMaximum speed vs. VCC\u201d on page 373 .\n6. Updated \u201cOrdering Information\u201d on page 419 .\n7. Updated \u201cPackaging Information\u201d on page 424 . Package 64M1 replaced by 64M2.\n8. Updated \u201cErrata\u201d on page 428 .\n1. JTAG ID/Signature for ATmega640 updated: 0x9608.\n2. Updated Table 13-7 on page 81 .\n3. Updated \u201cSerial Programming Instruction set\u201d on page 352 .\n4. Updated \u201cErrata\u201d on page 428 .\n1. Initial version.\n\n2549N\u2013AVR\u201305/11Atmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel:  (+1)(408) 441-0311\nFax: (+1)(408) 487-2600 \nwww.atmel.comAtmel Asia Limited\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHONG KONG\nTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4\nD-85748 Garching b. MunichGERMANY\nTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033JAPAN\nTel: (+81)(3) 3523-3551\nFax: (+81)(3) 3523-7581\n\u00a9 2011 Atmel Corporation. All rights reserved.\nAtmel\n\u00ae, Atmel logo and combinations thereof, AVR\u00ae, QTouch\u00ae, QMatrix\u00ae, AVR Studio\u00ae and others are registered trademarks or trade-\nmarks of Atmel Corporation or its subsidiaries. Windows\u00ae and others are registered trademarks of Microsoft Corporation in U.S. and \nother countries. Other terms and product names may be trademarks of others.\nDisclaimer:  The information in this document is provided in connection wi th Atmel products. No license, ex press or implied, by estoppel or  otherwise, to \nany intellectual property right is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL \nTERMS AND CONDITIONS OF SALES LOCATED ON THE ATMEL WEBSITE,  ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY \nEXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRO DUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURP OSE, OR NON-INFRINGEMENT. IN NO EVEN T SHALL ATMEL BE LIABLE FOR ANY DIRECT, \nINDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATI ON, DAMAGES FOR LOSS AND PROF-\nITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL \nHAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no representations or warranties with respect to the accuracy or com-\npleteness of the contents of th is document and reserves the right to make changes  to specifications and product descriptions at  any time without notice. \nAtmel does not make any commitment to update the information cont ained herein. Unless specifically  provided otherwise, Atmel pr oducts are not suit-\nable for, and shall not be used in, automotive applications. Atme l products are not intended, authorized, or warranted for use as components in applica-\ntions intended to support or sustain life.\n\ni\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\nTable of Contents\nFeatures ................ ................ .............. ............... .............. .............. ............ 1\n1 Pin Configurations ..... ................ ................. ................ ................. ............ 2\n2 Overview ............ ................ ................ ............... .............. .............. ............ 5\n2.1 Block Diagram ...................................................................................................5\n2.2 Comparison Between ATmega1281/2561 and ATmega640/1280/2560 ...........72.3 Pin Descriptions .................................................................................................7\n3 Resources .............. .............. .............. ............... .............. .............. .......... 11\n4 About Code Examples ........ .............. ............... .............. .............. .......... 11\n5 Data Retention .......... ................ ................ ................. ................ ............. 11\n6 Capacitive touch sensing  ................. ............... .............. .............. .......... 11\n7 AVR CPU Core  ................. ................ ................. .............. .............. .......... 12\n7.1 Introduction ......................................................................................................12\n7.2 Architectural Overview .....................................................................................127.3 ALU \u2013 Arithmetic Logic Unit .............................................................................137.4 Status Register ................................................................................................147.5 General Purpose Register File ........................................................................157.6 Stack Pointer ...................................................................................................167.7 Instruction Execution Timing ...........................................................................177.8 Reset and Interrupt Handling ...........................................................................18\n8 AVR Memories .......... ................ ................ ................. ................ ............. 21\n8.1 In-System Reprogrammable Flash Program Memory .....................................21\n8.2 SRAM Data Memory ........................................................................................218.3 EEPROM Data Memory . ................. ................ ............. ............ ............. ..........23\n8.4 I/O Memory ......................................................................................................27\n9 External Memory Interface . .............. ............... .............. .............. .......... 28\n9.1 Overview ..........................................................................................................28\n9.2 Register Description ........................................................................................359.3 General Purpose registers ...............................................................................379.4 External Memory registers ...............................................................................37\n10 System Clock and Clock Options  .............. ................ ................. .......... 40\n10.1 Overview ..........................................................................................................40\n\nii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n10.2 Clock Systems and their Distribution ...............................................................40\n10.3 Clock Sources .................................................................................................4110.4 Low Power Crystal Oscillator ...........................................................................4210.5 Full Swing Crystal Oscillator ............... .............................................................44\n10.6 Low Frequency Crystal Oscillator ....................................................................4510.7 Calibrated Internal RC Oscillator .....................................................................46\n10.8 128 kHz Internal Oscillator ..............................................................................4710.9 External Clock .................................................................................................4810.10 Clock Output Buffer .........................................................................................4910.11 Timer/Counter Oscillator ..................................................................................4910.12 System Clock Prescaler ..................................................................................4910.13 Register Description ........................................................................................50\n11 Power Management and Sleep Modes ........ ................. .............. .......... 52\n11.1 Sleep Modes ....................................................................................................52\n11.2 Idle Mode .........................................................................................................5211.3 ADC Noise Reduction Mode ............................................................................5311.4 Power-down Mode ...........................................................................................5311.5 Power-save Mode ............................................................................................5311.6 Standby Mode .................................................................................................5411.7 Extended Standby Mode .................................................................................5411.8 Power Reduction Register ...............................................................................5411.9 Minimizing Power Consumption ......................................................................5411.10 Register Description ........................................................................................56\n12 System Control and Reset .... .............. .............. .............. .............. ........ 59\n12.1 Resetting the AVR ...........................................................................................59\n12.2 Reset Sources .................................................................................................5912.3 Internal Voltage Reference ..............................................................................6212.4 Watchdog Timer ..............................................................................................63\n12.5 Register Description ........................................................................................67\n13 I/O-Ports ........ ................ ................. ................ ................. .............. .......... 70\n13.1 Introduction ......................................................................................................70\n13.2 Ports as General Digital I/O .............................................................................7113.3 Alternate Port Functions ..................................................................................7513.4 Register Description for I/O-Ports ..................................................................100\n14 Interrupts ............. .............. .............. .............. .............. .............. ........... 105\n\niii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n14.1 Interrupt Vectors in ATmega640/1280/1281/2560/2561 ................................105\n14.2 Reset and Interrupt Vector placement ...........................................................10714.3 Moving Interrupts Between Application and Boot Section .............................10914.4 Register Description ......................................................................................110\n15 External Interrupts .......... ................ .............. .............. .............. ........... 112\n15.1 Pin Change Interrupt Timing ..........................................................................112\n15.2 Register Description ......................................................................................113\n16 8-bit Timer/Counter0 with PWM ................... .............. .............. ........... 118\n16.1 Features ........................................................................................................118\n16.2 Overview ........................................................................................................11816.3 Timer/Counter Clock Sources .......................................................................11916.4 Counter Unit ..................................................................................................11916.5 Output Compare Unit .....................................................................................12016.6 Compare Match Output Unit ..........................................................................12216.7 Modes of Operation .......................................................................................12316.8 Timer/Counter Timing Diagrams ...................................................................12716.9 Register Description ......................................................................................129\n17 16-bit Timer/Counter (Timer /Counter 1, 3, 4, and 5) ............... ........... 136\n17.1 Features ........................................................................................................136\n17.2 Overview ........................................................................................................13617.3 Accessing 16-bit Registers ............................................................................13817.4 Timer/Counter Clock Sources .......................................................................14117.5 Counter Unit ..................................................................................................14217.6 Input Capture Unit .........................................................................................14317.7 Output Compare Units ...................................................................................14517.8 Compare Match Output Unit ..........................................................................14717.9 Modes of Operation .......................................................................................14817.10 Timer/Counter Timing Diagrams ...................................................................15617.11 Register Description ......................................................................................158\n18 Timer/Counter 0, 1,  3, 4, and 5 Prescaler ........... ............ ............ ........ 169\n18.1 Internal Clock Source ....................................................................................169\n18.2 Prescaler Reset .............................................................................................16918.3 External Clock Source ...................................................................................16918.4 Register Description ......................................................................................170\n\niv\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n19 Output Compare Modulato r (OCM1C0A) ....... .............. .............. ........ 172\n19.1 Overview ........................................................................................................172\n19.2 Description .....................................................................................................172\n20 8-bit Timer/Counter2 with PW M and Asynchronous Operation ...... 174\n20.1 Overview ........................................................................................................174\n20.2 Timer/Counter Clock Sources .......................................................................17520.3 Counter Unit ..................................................................................................17520.4 Modes of Operation .......................................................................................17620.5 Output Compare Unit .....................................................................................18020.6 Compare Match Output Unit ..........................................................................18220.7 Timer/Counter Timing Diagrams ...................................................................18320.8 Asynchronous Operation of Timer/Counter2 .................................................18420.9 Timer/Counter Prescaler ...............................................................................18620.10 Register Description ......................................................................................187\n21 SPI \u2013 Serial Peripheral Interface ......... .............. .............. ............ ........ 195\n21.1 SS  Pin Functionality ......................................................................................200\n21.2 Register Description ......................................................................................202\n22 USART ............. ................. ................ .............. .............. .............. ........... 205\n22.1 Features ........................................................................................................205\n22.2 Clock Generation ...........................................................................................20622.3 Frame Formats ..............................................................................................20922.4 USART Initialization .......................................................................................210\n22.5 Data Transmission \u2013 The USART Transmitter ..............................................212\n22.6 Data Reception \u2013 The USART Receiver .......................................................21422.7 Asynchronous Data Reception ......................................................................21822.8 Multi-processor Communication Mode ..........................................................22122.9 Register Description ......................................................................................22222.10 Examples of Baud Rate Setting .....................................................................227\n23 USART in SPI Mode .......... .............. .............. .............. .............. ........... 232\n23.1 Overview ........................................................................................................232\n23.2 USART MSPIM vs. SPI .................................................................................23223.3 SPI Data Modes and Timing ..........................................................................23323.4 Frame Formats ..............................................................................................23423.5 Data Transfer .................................................................................................23623.6 USART MSPIM Register Description ............................................................237\n\nv\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n24 2-wire Serial Interface ..... ................ .............. .............. .............. ........... 241\n24.1 Features ........................................................................................................241\n24.2 2-wire Serial Interface Bus Definition ............................................................24124.3 Data Transfer and Frame Format ..................................................................24224.4 Multi-master Bus Systems, Arbitration and Synchronization .........................24524.5 Overview of the T WI Module .........................................................................246\n24.6 Using the T WI ................................................................................................249\n24.7 Transmission Modes .....................................................................................25224.8 Multi-master Systems and Arbitration ............................................................26524.9 Register Description ......................................................................................266\n25 AC \u2013 Analog Comparator ... .............. ............... .............. .............. ........ 271\n25.1 Analog Comparator Multiplexed Input ...........................................................271\n25.2 Register Description ......................................................................................272\n26 ADC \u2013 Analog to Digital Co nverter .............. .............. .............. ........... 275\n26.1 Features ........................................................................................................275\n26.2 Operation .......................................................................................................27626.3 Starting a Conversion ....................................................................................27726.4 Prescaling and Conversion Timing ................................................................27826.5 Changing Channel or Reference Selection ...................................................28226.6 ADC Noise Canceler .....................................................................................28326.7 ADC Conversion Result .................................................................................28826.8 Register Description ......................................................................................289\n27 JTAG Interface and On-chi p Debug System ............ .............. ........... 296\n27.1 Features ........................................................................................................296\n27.2 Overview ........................................................................................................29627.3 TAP - Test Access Port .................................................................................29727.4 Using the Boundary-scan Chain ....................................................................29927.5 Using the On-chip Debug System .................................................................29927.6 On-chip Debug Specific JTAG Instructions ...................................................30027.7 Using the JTAG Programming Capabilitie s ...................................................301\n27.8 Bibliography ...................................................................................................30127.9 On-chip Debug Related Register in I/O Memory ...........................................301\n28 IEEE 1149.1 (JTAG)  Boundary-scan ....... ................. ................ ........... 302\n28.1 Features ........................................................................................................302\n28.2 System Overview ...........................................................................................302\n\nvi\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n28.3 Data Registers ...............................................................................................302\n28.4 Boundary-scan Specific JTAG Instructions ...................................................30428.5 Boundary-scan Chain ....................................................................................30528.6 Boundary-scan Related Register in I/O Memory ...........................................30828.7 ATmega640/1280/1281/2560/2561 Boundary-scan Order ............................30828.8 Boundary-scan Description Language Files ..................................................308\n29 Boot Loader Support \u2013 Read-While-Wri te Self-Programming ......... 317\n29.1 Features ........................................................................................................317\n29.2 Application and Boot Loader Flash Sections .................................................31729.3 Read- While-Write and No Read- While-Write Flash Sections ........................317\n29.4 Boot Loader Lock Bits ...................................................................................32029.5 Addressing the Flash During Self-Programming ...........................................32229.6 Self-Programming the Flash ..........................................................................32329.7 Register Description ......................................................................................332\n30 Memory Programming ........ .............. ............... .............. .............. ........ 335\n30.1 Program And Data Memory Lock Bits ...........................................................335\n30.2 Fuse Bits ........................................................................................................33630.3 Signature Bytes .............................................................................................33830.4 Calibration Byte .............................................................................................33830.5 Page Size ......................................................................................................33830.6 Parallel Programming Parameters, Pin Mapping, and Commands ...............33830.7 Parallel Programming ....................................................................................34130.8 Serial Downloading ........................................................................................34930.9 Programming via the JTAG Interface ............................................................354\n31 Electrical Characteristics ... .............. ............... .............. .............. ........ 367\n31.1 DC Characteristics .........................................................................................367\n31.2 Speed Grades ...............................................................................................36931.3 Clock Characteristics .....................................................................................37131.4 External Clock Drive ......................................................................................37131.5 System and Reset Characteristics ................................................................37231.6 2-wire Serial Interface Characteristics ...........................................................37331.7 SPI Timing Characteristics ............................................................................37531.8 ADC Characteristics \u2013 Preliminary Data ........................................................37731.9 External Data Memory Timing .......................................................................379\n32 Typical Characteristics ....... .............. ............... .............. .............. ........ 385\n\nvii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n32.1 Active Supply Current ....................................................................................385\n32.2 Idle Supply Current ........................................................................................38832.3 Power-down Supply Current ..........................................................................39232.4 Power-save Supply Current ...........................................................................39332.5 Standby Supply Current ................................................................................39432.6 Pin Pull-up .....................................................................................................39432.7 Pin Driver Strength ........................................................................................39732.8 Pin Threshold and Hysteresis ........................................................................39932.9 BOD Threshold and Analog Comparator Offset ............................................40232.10 Internal Oscillator Speed ...............................................................................40432.11 Current Consumption of Peripheral Units ......................................................40632.12 Current Consumption in Reset and Reset Pulsewidth ..................................409\n33 Register Summary ............ .............. .............. .............. .............. ........... 411\n34 Instruction Set Summary ... .............. ............... .............. .............. ........ 416\n35 Ordering Information .......... .............. ............... .............. .............. ........ 419\n35.1 ATmega640 ...................................................................................................419\n35.2 ATmega1280 .................................................................................................42035.3 ATmega1281 .................................................................................................42135.4 ATmega2560 .................................................................................................42235.5 ATmega2561 .................................................................................................423\n36 Packaging Information .......... ................ ................. ................ ............. 424\n36.1 100A ..............................................................................................................424\n36.2 100C1 ............................................................................................................42536.3 64A ................................................................................................................42636.4 64M2 ..............................................................................................................427\n37 Errata ........... ................ ................ ................. ................ .............. ........... 428\n37.1 ATmega640 rev. B .........................................................................................428\n37.2 ATmega640 rev. A .........................................................................................42837.3 ATmega1280 rev. B .......................................................................................42837.4 ATmega1280 rev. A .......................................................................................42937.5 ATmega1281 rev. B .......................................................................................42937.6 ATmega1281 rev. A .......................................................................................43037.7 ATmega2560 rev. F .......................................................................................43037.8 ATmega2560 rev. E .......................................................................................430\n\nviii\n2549N\u2013AVR\u201305/11ATmega640/1280/1281/2560/2561\n37.9 ATmega2560 rev. D ......................................................................................430\n37.10 ATmega2560 rev. C ......................................................................................43037.11 ATmega2560 rev. B .......................................................................................43037.12 ATmega2560 rev. A .......................................................................................43137.13 ATmega2561 rev. F .......................................................................................43237.14 ATmega2561 rev. E .......................................................................................43237.15 ATmega2561 rev. D ......................................................................................43237.16 ATmega2561 rev. C ......................................................................................43237.17 ATmega2561 rev. B .......................................................................................43237.18 ATmega2561 rev. A .......................................................................................432\n38 Datasheet Revision History .. ................ ................. ................ ............. 435\n38.1 Rev. 2549N-05/11 .........................................................................................435\n38.2 Rev. 2549M-09/10 .........................................................................................43538.3 Rev. 2549L-08/07 ..........................................................................................43538.4 Rev. 2549K-01/07 ..........................................................................................43638.5 Rev. 2549J-09/06 ..........................................................................................43638.6 Rev. 2549I-07/06 ...........................................................................................43638.7 Rev. 2549H-06/06 .........................................................................................43638.8 Rev. 2549G-06/06 .........................................................................................43738.9 Rev. 2549F-04/06 ..........................................................................................43738.10 Rev. 2549E-04/06 ..........................................................................................43738.11 Rev. 2549D-12/05 .........................................................................................43738.12 Rev. 2549C-09/05 .........................................................................................43838.13 Rev. 2549B-05/05 ..........................................................................................43838.14 Rev. 2549A-03/05 ..........................................................................................438\nTable of Contents.......... ................. ................ ................. ................ ........... i\n\n2549N\u2013AVR\u201305/11Atmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel:  (+1)(408) 441-0311\nFax: (+1)(408) 487-2600 \nwww.atmel.comAtmel Asia Limited\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHONG KONG\nTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4\nD-85748 Garching b. MunichGERMANY\nTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033JAPAN\nTel: (+81)(3) 3523-3551\nFax: (+81)(3) 3523-7581\n\u00a9 2011 Atmel Corporation. All rights reserved.\nAtmel\n\u00ae, Atmel logo and combinations thereof, AVR\u00ae, QTouch\u00ae, QMatrix\u00ae, AVR Studio\u00ae and others are registered trademarks or trade-\nmarks of Atmel Corporation or its subsidiaries. Windows\u00ae and others are registered trademarks of Microsoft Corporation in U.S. and \nother countries. Other terms and product names may be trademarks of others.\nDisclaimer:  The information in this document is provided in connection wi th Atmel products. No license, ex press or implied, by estoppel or  otherwise, to \nany intellectual property right is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL \nTERMS AND CONDITIONS OF SALES LOCATED ON THE ATMEL WEBSITE,  ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY \nEXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRO DUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURP OSE, OR NON-INFRINGEMENT. IN NO EVEN T SHALL ATMEL BE LIABLE FOR ANY DIRECT, \nINDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATI ON, DAMAGES FOR LOSS AND PROF-\nITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL \nHAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no representations or warranties with respect to the accuracy or com-\npleteness of the contents of th is document and reserves the right to make changes  to specifications and product descriptions at  any time without notice. \nAtmel does not make any commitment to update the information cont ained herein. Unless specifically  provided otherwise, Atmel pr oducts are not suit-\nable for, and shall not be used in, automotive applications. Atme l products are not intended, authorized, or warranted for use as components in applica-\ntions intended to support or sustain life.", "atmega 8.pdf": "Features\n\u2022High-performance, Low-power Atmel\u00aeAVR\u00ae 8-bit Microcontroller\n\u0081Advanced RISC Architecture\n\u2013 130 Powerful Instructions \u2013 Most  Single-clock Cycle Execution\n\u2013 32 \u00d7 8 General Purpose Working Registers\u2013 Fully Static Operation\n\u2013 Up to 16MIPS Throughput at 16MHz\n\u2013 On-chip 2-cycle Multiplier\n\u0081High Endurance Non-volatile Memory segments\n\u2013 8Kbytes of In-System Self-pro grammable Flash program memory\n\u2013 512Bytes EEPROM\n\u2013 1Kbyte Internal SRAM\n\u2013 Write/Erase Cycles: 10,000 Flash/1 00,000 EEPROM\n\u2013 Data retention: 20 years at 85\u00b0C/100 years at 25\u00b0C(1)\n\u2013 Optional Boot Code Section with Independent Lock Bits\nIn-System Programming by On-chip Boot Program\nTrue Read-While-W rite Operation\n\u2013 Programming Lock for Software Security\n\u0081Peripheral Features\n\u2013 Two 8-bit Timer/Counters with Se parate Prescaler, one Compare Mode\n\u2013 One 16-bit Timer/Counter with Separate Prescaler, Compare Mode, and Capture \nMode\n\u2013 Real Time Counter with Separate Oscillator\n\u2013 Three PWM Channels\n\u2013 8-channel ADC in TQFP and QFN/MLF package\nEight Channels 10-bit Accuracy\n\u2013 6-channel ADC in PDIP package\nSix Channels 10-bit Accuracy\n\u2013 Byte-oriented Two-wi re Serial Interface\n\u2013 Programmable Serial USART\n\u2013 Master/Slave SPI Serial Interface\u2013 Programmable Watchdog Timer with Separate On-chip Oscillator\n\u2013 On-chip Analog Comparator\n\u0081Special Microcontroller Features\n\u2013 Power-on Reset and Programmable Brown-out Detection\n\u2013 Internal Calibrated RC Oscillator\n\u2013 External and Internal Interrupt Sources\u2013 Five Sleep Modes: Idle, ADC Noise Re duction, Power-save, Power-down, and \nStandby\n\u0081I/O and Packages\n\u2013 23 Programmable I/O Lines\n\u2013 28-lead PDIP, 32-lead TQ FP, and 32-pad QFN/MLF\n\u0081Operating Voltages\n\u2013 2.7V - 5.5V (ATmega8L) \n\u2013 4.5V - 5.5V (ATmega8)\n\u0081Speed Grades\n\u2013 0 - 8MHz (ATmega8L)\n\u2013 0 - 16MHz (ATmega8)\n\u0081Power Consumption at 4Mhz, 3V, 25 \u00b0C\n\u2013 Active: 3.6mA\n\u2013 Idle Mode: 1.0mA\n\u2013 Power-down Mode: 0.5\u00b5A8-bit  \nwith 8KBytes  In-SystemProgrammable \nFlash\nATmega8\nATmega8L\nRev.2486Z\u2013AVR\u201302/11\n\n2\n2486Z\u2013AVR\u201302/11ATmega8(L)Pin \nConfigurations\n1\n234567824\n23222120191817\n(INT1) PD3\n(XCK/T0) PD4\nGND\nVCC\nGND\nVCC\n(XTAL1/TOSC1) PB6(XTAL2/TOSC2) PB7PC1 (ADC1)\nPC0 (ADC0)ADC7GNDAREFADC6AVCCPB5 (SCK)32313029282726259\n10111213141516(T1) PD5\n(AIN0) PD6(AIN1) PD7\n(ICP1) PB0\n(OC1A) PB1\n(SS/OC1B) PB2\n(MOSI/OC2) PB3\n(MISO) PB4PD2 (INT0)\nPD1 (TXD)PD0 (RXD)PC6 (RESET)PC5 (ADC5/SCL)PC4 (ADC4/SDA)PC3 (ADC3)PC2 (ADC2)TQFP Top View123456789101112131428\n27262524232221201918171615\n(RESET) PC6\n(RXD) PD0\n(TXD) PD1\n(INT0) PD2(INT1) PD3\n(XCK/T0) PD4\nVCC\nGND\n(XTAL1/TOSC1) PB6(XTAL2/TOSC2) PB7\n(T1) PD5\n(AIN0) PD6(AIN1) PD7\n(ICP1) PB0PC5 (ADC5/SCL)\nPC4 (ADC4/SDA)PC3 (ADC3)PC2 (ADC2)PC1 (ADC1)PC0 (ADC0)GNDAREFAVCCPB5 (SCK)PB4 (MISO)PB3 (MOSI/OC2)PB2 (SS/OC1B)PB1 (OC1A)PDIP\n1234567824\n2322212019181732313029282726259\n10111213141516MLF Top View\n(INT1) PD3\n(XCK/T0) PD4\nGND\nVCC\nGND\nVCC\n(XTAL1/TOSC1) PB6(XTAL2/TOSC2) PB7PC1 (ADC1)\nPC0 (ADC0)ADC7GNDAREFADC6AVCCPB5 (SCK)(T1) PD5\n(AIN0) PD6(AIN1) PD7\n(ICP1) PB0\n(OC1A) PB1\n(SS/OC1B) PB2\n(MOSI/OC2) PB3\n(MISO) PB4PD2 (INT0)\nPD1 (TXD)PD0 (RXD)PC6 (RESET)PC5 (ADC5/SCL)PC4 (ADC4/SDA)PC3 (ADC3)PC2 (ADC2)\nNOTE:\nThe large center pad underneath the MLF packages is made of metal and internally connected to GND. It should be soldered or glued to the PCB to ensure good mechanical stability. If the center pad is left unconneted, the package might loosen from the PCB.\n\n3\n2486Z\u2013AVR\u201302/11ATmega8(L)\nOverview The Atmel\u00aeAVR\u00ae ATmega8 is a low-power CMOS 8-bit microcontroller based on the AVR RISC\narchitecture. By executing powerf ul instructions in a single clock cycle, the ATmega8 achieves\nthroughputs approaching 1MIPS per MHz, allowing the system designer to optimize power con-sumption versus processing speed.\nBlock Diagram Figure 1.  Block Diagram\nINTERNAL\nOSCILLATOROSCILLATOR\nWATCHDOG\nTIMER\nMCU CTRL.\n& TIMINGOSCILLATORTIMERS/\nCOUNTERS\nINTERRUPT\nUNITSTACK\nPOINTER\nEEPROMSRAM\nSTATUS\nREGISTER\nUSARTPROGRAM\nCOUNTER\nPROGRAM\nFLASH\nINSTRUCTION\nREGISTER\nINSTRUCTION\nDECODER\nPROGRAMMING\nLOGICSPIADC\nINTERFACE\nCOMP .\nINTERFACEPORTC DRIVERS/BUFFERS\nPORTC DIGITAL INTERFACE\nGENERAL\nPURPOSE\nREGISTERS\nX\nY\nZ\nALU\n+\n-PORTB DRIVERS/BUFFERS\nPORTB DIGITAL INTERFACE\nPORTD DIGITAL INTERFACE\nPORTD DRIVERS/BUFFERSXTAL1\nXTAL2\nCONTROL\nLINESVCC\nGND\nMUX &\nADC\nAGND\nAREFPC0 - PC6 PB0 - PB7\nPD0 - PD7AVR CPUTWIRESET\n\n4\n2486Z\u2013AVR\u201302/11ATmega8(L)The Atmel\u00aeAVR\u00ae core combines a rich instruction set with 32 general purpose working registers.\nAll the 32 registers are directly connected to the Arithmetic Logic Unit (ALU), allowing two inde-pendent registers to be accessed in one single in struction executed in one clock cycle. The\nresulting architecture is more code efficient wh ile achieving throughputs up to ten times faster\nthan conventional CISC microcontrollers.\nThe ATmega8 provides the following features: 8 Kbytes of In-System Programmable Flash with\nRead-While-Write capabilities, 512 bytes of EEPROM, 1 Kbyte of SRAM, 23 general purposeI/O lines, 32 general purpose working registers, three flexible Timer/Counters with compare\nmodes, internal and external interrupts, a seri al programmable USART, a byte oriented Two-\nwire Serial Interface, a 6-channel ADC (eight channels in TQFP and QFN/MLF packages) with10-bit accuracy, a programmable Watchdog Timer with Internal Os cillator, an SPI serial port,\nand five software selectable power saving modes. The Idle mode stops the CPU while allowingthe SRAM, Timer/Counters, SPI port, and interr upt system to continue functioning. The Power-\ndown mode saves the register contents but freezes the Oscillator, disabling all other chip func-\ntions until the next Interrupt or Hardware Reset. In Power-save mode, the asynchronous timercontinues to run, allowing the user to maintain a timer base while the rest of the device is sleep-ing. The ADC Noise Reduction mode stops the CPU and all I/O modules except asynchronous\ntimer and ADC, to minimize switching noise  during ADC conversions. In Standby mode, the\ncrystal/resonator Oscillator is running while the re st of the device is sleeping. This allows very\nfast start-up combined with low-power consumption.\nThe device is manufactured using Atmel\u2019s high density non-volatile memory technology. The\nFlash Program memory can be reprogrammed In-System through an SPI serial interface, by aconventional non-volatile memory programmer, or by an On-chip boot program running on theAVR core. The boot program can use any interface to download the application program in theApplication Flash memory . Software in the Boot Flash Sect ion will continue to run while the\nApplication Flash Section is updated, providi ng true Read-While-Write operation. By combining\nan 8-bit RISC CPU with In-System Self-Programmable Flash on a monolithic chip, the AtmelATmega8 is a powerful microcontroller that provides a highly-flexible and cost-effective solutionto many embedded control applications.\nThe ATmega8 is supported with a full suite of program and system development tools, including\nC compilers, macro assemblers, program debugger/simulators, In-Circuit Emulators, and evalu-ation kits.\nDisclaimer Typical values contained in this datasheet ar e based on simulations and characterization of\nother AVR microcontrollers manufactured on t he same process technology. Minimum and Maxi-\nmum values will be available afte r the device is characterized.\n\n5\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPin Descriptions\nVCC Digital supply voltage.\nGND Ground.\nPort B (PB7..PB0) \nXTAL1/XTAL2/TOSC1/TOSC2Port B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort B output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port B pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port B pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nDepending on the clock selection fuse settings, PB6 can be used as input to the inverting Oscil-\nlator amplifier and input to the internal clock operating circuit.\nDepending on the clock selection fuse settings, PB7 can be used as output from the inverting\nOscillator amplifier.\nIf the Internal Calibrate d RC Oscillator is used as chip clock source, PB7..6 is used as TOSC2..1\ninput for the Asynch ronous Timer/Counter2 if th e AS2 bit in ASSR is set.\nThe various special features of Port B are elaborated in \u201cAlternate Functions of Port B\u201d on page\n58 and \u201cSystem Clock and Clock Options\u201d on page 25 .\nPort C (PC5..PC0) Port C is an 7-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort C output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port C pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port C pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPC6/RESET\nIf the RSTDISBL Fuse is programmed, PC6 is used as an I/O pin. Note that the electrical char-\nacteristics of PC6 differ from those of the other pins of Port C.\nIf the RSTDISBL Fuse is unprogrammed, PC6 is used as a Reset input. A low level on this pin\nfor longer than the minimum pulse length will generate a Reset, even if the clock is not running.\nThe minimum pulse length is given in Table 15 on page 38 . Shorter pulses are not guaranteed to\ngenerate a Reset.\nThe various special features of Port C are elaborated on page 61 .\nPort D (PD7..PD0) Port D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort D output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port D pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port D pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort D also serves the functions of various special features of the ATmega8 as listed on page\n63.\nRESET\nReset input. A low level on this pin for longer than the minimum pulse length will generate a\nreset, even if the clock is not running. The minimum pulse length is given in Table 15 on page\n38. Shorter pulses are not guaranteed to generate a reset.\n\n6\n2486Z\u2013AVR\u201302/11ATmega8(L)AVCC AVCC is the supply voltage pin for the A/D Converter, Port C (3..0), and ADC (7..6). It should be\nexternally connected to VCC, even if the ADC is not used. If the ADC is used, it should be con-\nnected to VCC through a low-pass filter. Note that Port C (5..4) use digital supply voltage, VCC.\nAREF AREF is the analog reference pin for the A/D Converter.\nADC7..6 (TQFP and \nQFN/MLF Package Only)In the TQFP and QFN/MLF package, ADC7..6 serve as analog inputs to the A/D converter.\nThese pins are powered from the analog supply and serve as 10-bit ADC channels.\n\n7\n2486Z\u2013AVR\u201302/11ATmega8(L)\nResources A comprehensive set of development tools, app lication notes and datasheets are available for\ndownload on http://www.atmel.com/avr .\nNote: 1.\nData Retention Reliability Qualification results show that the pr ojected data retention failure rate is much less\nthan 1 PPM over 20 years at 85\u00b0C or 100 years at 25\u00b0C.\n\n8\n2486Z\u2013AVR\u201302/11ATmega8(L)About Code \nExamplesThis datasheet contains simple code examples that briefly show how to use various parts of the\ndevice. These code examples assume that the part specific header file is included before compi-lation. Be aware that not all C compiler vendors include bit definitions in the header files andinterrupt handling in C is compiler dependent. Please confirm with the C compiler documentationfor more details.\n\n9\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAtmel AVR CPU \nCore\nIntroduction This section discusses the Atmel\u00aeAVR\u00ae core architecture in general. The main function of the\nCPU core is to ensure correct program execution. The CPU must therefore be able to accessmemories, perform calculations, control peripherals, and handle interrupts.\nArchitectural \nOverviewFigure 2.  Block Diagram of the AVR MCU Architecture \nIn order to maximize performance and parallelism, the AVR uses a Harvard architecture \u2013 with\nseparate memories and buses for program and data. Instructions in the Program memory areexecuted with a single level pipelining. While one instruction is being executed, the next instruc-tion is pre-fetched from the Program memory. This  concept enables instructions to be executed\nin every clock cycle. The Program memory is In-System Reprogrammable Flash memory.\nThe fast-access Register File contains 32 \u00d7 8-bit general purpose working registers with a single\nclock cycle access time. This allows single-cycle Ar ithmetic Logic Unit (ALU ) operation. In a typ-\nical ALU operation, two operands are output from the Register File, the operation is executed,and the result is stored back in the Register File \u2013 in one clock cycle.\nSix of the 32 registers can be used as three 16-b it indirect address register pointers for Data\nSpace addressing \u2013 enabling efficient address calculations. One of the these address pointersFlash\nProgram\nMemory\nInstruction\nRegister\nInstruction\nDecoderProgram\nCounter\nControl Lines32 x 8\nGeneral\nPurpose\nRegistrers\nALUStatus\nand Control\nI/O LinesEEPROMData Bus 8-bit \nData\nSRAMDirect Addressing Indirect AddressingInterrupt\nUnit\nSPI\nUnit\nWatchdog\nTimer\nAnalog\nComparator\ni/O Module 2i/O Module1\ni/O Module n\n\n10\n2486Z\u2013AVR\u201302/11ATmega8(L)can also be used as an address pointer for look up tables in Flash Program memory. These\nadded function registers are the 16-bit X-register , Y-register, and Z-register, described later in\nthis section.\nThe ALU supports arithmetic and logic operations between registers or between a constant and\na register. Single register operations can also be executed in the ALU. After an arithmetic opera-tion, the Status Register is updated to reflect information about the result of the operation.\nThe Program flow is provided by conditional and unconditional jump and ca ll instructions, able to\ndirectly address the whole address space. Most AVR instructions have a single 16-bit word for-\nmat. Every Program memory address contains a 16-bit or 32-bit instruction.\nProgram Flash memory space is divided in two sections, the Boot program section and the\nApplication program section. Both sections have dedicated Loc k Bits for write and read/write\nprotection. The SPM instruction that writes into the Application Flash memory section mustreside in the Boot program section.\nDuring interrupts and subroutine calls, the return address Program Counter (PC) is stored on the\nStack. The Stack is effectively allocated in the general data SRAM, and consequently the Stacksize is only limited by the to tal SRAM size and the usage of the SRAM. All user programs must\ninitialize the SP in the reset routine (before subroutines or interrupts are executed). The StackPointer SP is read/write accessible in the I/O space. The data SRAM can easily be accessedthrough the five different addressing modes supported in the AVR architecture.\nThe memory spaces in the AVR  architecture are all linear and regular memory maps.\nA flexible interrupt module has its control registers in the I/O space with an additional global\ninterrupt enable bit in the Status Register. All interrupts have a separate Interrupt Vector in theInterrupt Vector table. The interrupts have priority in accordance with their Interrupt Vector posi-tion. The lower the Interrupt Vector address, the higher the priority.\nThe I/O memory space contains 64 addresses for CPU peripheral functi ons as Control Regis-\nters, SPI, and other I/O functions. The I/O Memory can be accessed directly, or as the DataSpace locations following those of the Register File, 0x20 - 0x5F.\n\n11\n2486Z\u2013AVR\u201302/11ATmega8(L)\nArithmetic Logic \nUnit \u2013 ALUThe high-performance Atmel\u00aeAVR\u00ae ALU operates in direct connection with all the 32 general\npurpose working registers. Within a single cl ock cycle, arithmetic operations between general\npurpose registers or between a register and an immediate are executed. The ALU operationsare divided into three main categories \u2013 arithmetic, logical, and bit-functions. Some implementa-tions of the architecture also provide a powerful multiplier supporting both signed/unsignedmultiplication and fractional format. For a detailed description, see \u201cInstruction Set Summary\u201d on\npage 282 .\nStatus Register The Status Register contains information about the result of the most recently executed arithme-\ntic instruction. This information can be used for altering program flow in order to performconditional operations. Note that the Status Register is updated after all ALU operations, asspecified in the Instruction Set Reference . This will in many cases remove the need for using the\ndedicated compare instructions, resulting in faster and more compact code.\nThe Status Register is not automatically stored when entering an interrupt routine and restored\nwhen returning from an interrupt. This must be handled by software.\nThe AVR Status Register \u2013 SREG \u2013 is defined as:\n\u0081 Bit 7 \u2013 I: Global Interrupt Enable\nThe Global Interrupt Enable bit must be set for th e interrupts to be enabled. The individual inter-\nrupt enable control is then performed in separate control registers. If the Global Interrupt EnableRegister is cleared, none of the interrupts are enabled independent of the individual interruptenable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by\nthe RETI instruction to enable subsequent interrupts. The I-bit can also be set and cleared bythe application with the SEI and CL I instructions, as  described in the Instruction Set Reference .\n\u0081 Bit 6 \u2013 T: Bit Copy Storage\nThe Bit Copy instructions BLD (Bit LoaD) and BST (B it STore) use the T-bit as source or desti-\nnation for the operated bit. A bit from a register in  the Register File can be copied into T by the\nBST instruction, and a bit in T can be copied into a bit in a register in the Register File by theBLD instruction.\n\u0081 Bit 5 \u2013 H: Half Carry Flag\nThe Half Carry Flag H indicates a Half Carry in some arithmetic operation s. Half Carry is useful\nin BCD arithmetic. See the \u201c Instruction Set Description \u201d for detailed information.\n\u0081 Bit 4 \u2013 S: Sign Bit, S = N\n \u2295 V\nThe S-bit is always an exclusive or between the Negative Flag N and the Two\u2019s Complement\nOverflow Flag V. See the \u201c Instruction Set Description \u201d for detailed information.\n\u0081 Bit 3 \u2013 V: Two\u2019s Complement Overflow Flag\nThe Two\u2019s Complement Overflow Flag V suppor ts two\u2019s complement arithmetics. See the\n\u201cInstruction Set Description \u201d for detailed information.\n\u0081 Bit 2 \u2013 N: Negative Flag\nThe Negative Flag N indicates a negative result in an arithmetic or logic operation. See the\n\u201cInstruction Set Description \u201d for detailed information.B i t 76543210\nI T H S V N Z C SREG\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n\n12\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 1 \u2013 Z: Zero Flag\nThe Zero Flag Z indicates a zero result in an arithmetic or logic operation. See the \u201c Instruction\nSet Description \u201d for detailed information.\n\u0081 Bit 0 \u2013 C: Carry Flag\nThe Carry Flag C indicates a Carry in an arithmetic or logic operation. See the \u201c Instruction Set\nDescription \u201d for detailed information.\nGeneral Purpose \nRegister FileThe Register File is optimized for the AVR Enhanc ed RISC instruction set. In order to achieve\nthe required performance and flex ibility, the following in put/output schemes ar e supported by the\nRegister File:\n\u0081 One 8-bit output operand and one 8-bit result input\u0081 Two 8-bit output operands and one 8-bit result input\u0081 Two 8-bit output operands and one 16-bit result input\u0081 One 16-bit output operand and one 16-bit result input\nFigure 3  shows the structure of the 32 general purpose working registers in the CPU.\nFigure 3.  AVR CPU General Purpose Working Registers\nMost of the instructions operating on the Register File have direct access to all registers, and\nmost of them are single cycle instructions.\nAs shown in Figure 3 , each register is also assigned a Data memory address, mapping them\ndirectly into the first 32 locations of the user  Data Space. Although not being physically imple-\nmented as SRAM locations, this memory organization provides great flexibility in access of theregisters, as the X-pointer, Y-pointer, and Z-pointer Registers can be set to index any register inthe file.7 0 Addr.\nR0 0x00\nR1 0x01R2 0x02\n\u2026\nR13 0x0D\nGeneral R14 0x0E\nPurpose R15 0x0F\nWorking R16 0x10\nRegisters R17 0x11\n\u2026\nR26 0x1A X-register Low ByteR27 0x1B X-register High ByteR28 0x1C Y-register Low ByteR29 0x1D Y-register High ByteR30 0x1E Z-register Low ByteR31 0x1F Z-register High Byte\n\n13\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe X-register, Y-\nregister and Z-registerThe registers R26..R31 have some added functions to their general purpose usage. These reg-\nisters are 16-bit address pointers for indirect addressing of the Data Space. The three indirectaddress registers X, Y and Z are defined as described in Figure 4 .\nFigure 4.  The X-register, Y -register and Z-Register\nIn the different addressing modes these address registers have functions as fixed displacement,\nautomatic increment, and automatic decrement (see the Instruction Set Reference  for details).\nStack Pointer The Stack is mainly used for storing temporary data, for storing local variables and for storing\nreturn addresses after interrupts and subroutine calls. The Stack Pointer Register always pointsto the top of the Stack. Note that the Stack is implemented as growing from higher memory loca-tions to lower memory locations. This implies that a Stack PUSH command decreases the StackPointer.\nThe Stack Pointer points to the data SRAM Stack area where the Subroutine and Interrupt\nStacks are located. This Stack space in the data SRAM must be defined by the program beforeany subroutine calls are executed or interrupts are enabled. The Stack Pointer must be set topoint above 0x60. The Stack Pointer is decrement ed by one when data is pushed onto the Stack\nwith the PUSH instruction, and it is decremented by two when the return address is pushed onto\nthe Stack with subroutine call or interrupt. The Stack Pointer is incremented by one when data ispopped from the Stack with the POP instruction, and it is incremented by two when address ispopped from the Stack with return from subroutine RET or return from interrupt RETI.\nThe AVR Stack Pointer is implemented as two 8- bit registers in the I/O space. The number of\nbits actually used is implementation dependent. Note that the data space in some implementa-tions of the AVR architecture is so small that only SPL is needed. In this case, the SPH Register\nwill not be present.\nInstruction \nExecution TimingThis section describes the general access timing concepts for instruction execution. The\nAtmel\u00aeAVR\u00ae CPU is driven by the CPU clock clkCPU, directly generated from the selected clock\nsource for the chip. No intern al clock division is used.15 XH XL 0\nX-register 7 0 7 0\nR27 (0x1B) R26 (0x1A)\n15 YH YL 0\nY-register 7 0 7 0\nR29 (0x1D) R28 (0x1C)\n15 ZH ZL 0\nZ-register 7 0 7 0\nR31 (0x1F) R30 (0x1E)\nB i t 1 51 41 31 21 11 0 9 8\nSP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 SPH\nSP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 SPL\n76543210\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n00000000\n\n14\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 5  shows the parallel instruction fetches and instruction executions enabled by the Har-\nvard architecture and the fast-access Register File concept. This is the basic pipelining conceptto obtain up to 1MIPS per MHz with the corresponding unique results for functions per cost,functions per clocks, and functions per power-unit.\nFigure 5.  The Parallel Instruction Fetches and Instruction Executions \nFigure 6  shows the internal timing concept for the Register File. In a single clock cycle an ALU\noperation using two register operands  is executed, and the result is stored back to the destina-\ntion register.\nFigure 6.  Single Cycle ALU Operation\nReset and \nInterrupt HandlingThe Atmel\u00aeAVR\u00ae provides several different interrupt sources. These interrupts and the separate\nReset Vector each have a separate Program Vector in the Program memory space. All inter-rupts are assigned individual enable bits which must be written logic one together with theGlobal Interrupt Enable bit in the Status Register in order to enable the interrupt. Depending onthe Program Counter value, interrupts may be automatically disabled when Boot Lock Bits\nBLB02 or BLB12 are programmed. This feature improves software security. See the section\u201cMemory Programming\u201d on page 215  for details.\nThe lowest addresses in the Program memory space are by default defined as the Reset and\nInterrupt Vectors. The complete  list of Vectors is shown in \u201cInterrupts\u201d on page 46 . The list also\ndetermines the priority levels of the different interrupts. The lower the address the higher is thepriority level. RESET has the highest priority, and  next is INT0 \u2013 the External Interrupt Request\n0. The Interrupt Vectors can be moved to the start of the boot Flash section by setting the Inter-rupt Vector Select (IVSEL) bit in the General Interrupt Control Register (GICR). Refer to\u201cInterrupts\u201d on page 46  for more information. The Reset Vector can also be moved to the start of\nthe boot Flash section by programming the BOOTRST Fuse, see \u201cBoot Loader Support \u2013 Read-\nWhile-Write Self-Programming\u201d on page 202 .clk\n1st Instruction Fetch\n1st Instruction Execute\n2nd Instruction Fetch\n2nd Instruction Execute\n3rd Instruction Fetch\n3rd Instruction Execute\n4th Instruction FetchT1 T2 T3 T4\nCPU\nTotal Execution Time\nRegister Operands Fetch\nALU Operation Execute\nResult Write BackT1 T2 T3 T4\nclkCPU\n\n15\n2486Z\u2013AVR\u201302/11ATmega8(L)\nWhen an interrupt occurs, the Global Interrupt Enable I-bit is cleared and all interrupts are dis-\nabled. The user software can write logic one to the I-bit to enable nested interrupts. All enabledinterrupts can then interrupt the current interrupt routine. The I-bit is automatically set when aReturn from Interrupt instruction \u2013 RETI \u2013 is executed.\nThere are basically two types of interrupts. The fi rst type is triggered by an event that sets the\nInterrupt Flag. For these interrupts, the Program Counter is vectored to the actual Interrupt Vec-tor in order to execute the interrupt handling routine, and hardware clears the correspondingInterrupt Flag. Interrupt Flags can also be cleared by writing a logic one to the flag bit position(s)to be cleared. If an interrupt condition occurs while the corresponding interrupt enable bit iscleared, the Interrupt Fl ag will be set and remember ed until the interrupt is  enabled, or the flag is\ncleared by software. Similarly, if one or more interrupt conditions occur while the global interruptenable bit is cleared, the corresponding Interrupt Flag(s) will be set and remembered until theglobal interrupt enable bit is set, and will then be executed by order of priority.\nThe second type of interrupts will trigger as long as the interrupt condition is present. These\ninterrupts do not necessarily have Interrupt Flags. If the interrupt condition disappears before theinterrupt is enabled, the in terrupt will not be triggered.\nWhen the AVR exits from an inte rrupt, it will always retu rn to the main pr ogram and execute one\nmore instruction before any pending interrupt is served.\nNote that the Status Register is not automatica lly stored when entering an interrupt routine, nor\nrestored when returning from an interrupt routine. This must be handled by software.\nWhen using the CLI instruction to  disable interrupts, the interrup ts will be immediately disabled.\nNo interrupt will be executed af ter the CLI instruction,  even if it occurs simultaneously with the\nCLI instruction. The following example shows how this can be used to avoid interrupts during thetimed EEPROM write sequence.\nAssembly Code Example\ninr16, SREG ; store SREG value\ncli ; disable interrupts during timed sequence\nsbiEECR, EEMWE ; start EEPROM write\nsbiEECR, EEWE\noutSREG, r16 ; restore SREG value (I-bit)\nC Code Example\nchar cSREG;\ncSREG = SREG; /* store SREG value */\n/* disable interrupts during timed sequence */\n_CLI(); \nEECR |= (1<<EEMWE); /* start EEPROM write */\nEECR |= (1<<EEWE);\nSREG = cSREG; /* restore SREG value (I-bit) */\n\n16\n2486Z\u2013AVR\u201302/11ATmega8(L)When using the SEI instruction to enable interr upts, the instruction following SEI will be exe-\ncuted before any pending interrupts, as shown in the following example.\nInterrupt Response \nTimeThe interrupt execution response for all the enabled Atmel\u00aeAVR\u00ae interrupts is four clock cycles\nminimum. After four clock cycles, the Program Vector address for the actual interrupt handlingroutine is executed. During this 4-clock cycl e period, the Program Counter is pushed onto the\nStack. The Vector is normally a jump to the interrupt routine, and this jump takes three clockcycles. If an interrupt occurs during execution of a multi-cycle instruction, this instruction is com-\npleted before the interrupt is served. If an interrupt occurs when the MCU is in sleep mode, theinterrupt execution response time is increased by four clock cycles. This increase comes in addi-\ntion to the start-up time from the selected sleep mode.\nA return from an interrupt handling routine take s four clock cycles. During these four clock\ncycles, the Program Counter (2 bytes) is popped back from the Stack, the Stack Pointer is incre-mented by 2, and the I-bit in SREG is set.Assembly Code Example\nsei; set global interrupt enable\nsleep; enter sleep, waiting for interrupt\n; note: will enter sleep before any pending \n; interrupt(s)\nC Code Example\n_SEI(); /* set global interrupt enable */\n_SLEEP(); /* enter sleep, waiting for interrupt */\n/* note: will enter sleep before any pending interrupt(s) */\n\n17\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAVR ATmega8  \nMemoriesThis section describes the different memories in the Atmel\u00aeAVR\u00ae ATmega8. The AVR architec-\nture has two main memory spaces, the Data  memory and the Program Memory space. In\naddition, the ATmeg a8 features an EEPROM Memory for da ta storage. All th ree memory spaces\nare linear and regular.\nIn-System \nReprogrammable \nFlash Program \nMemoryThe ATmega8 contains 8Kbytes On-chip In-S ystem Reprogrammable Flash memory for pro-\ngram storage. Since all AVR instructions are 16-bits or 32-bits wide, the Flash is organized as4K \u00d7 16 bits. For software security, the Flash Program memory space is divided into two sec-\ntions, Boot Program section and Application Program section.\nThe Flash memory has an endurance of at leas t 10,000 write/erase cycles. The ATmega8 Pro-\ngram Counter (PC) is 12 bits wide, thus addr essing the 4K Program memory locations. The\noperation of Boot Program section and associat ed Boot Lock Bits for software protection are\ndescribed in detail in \u201cBoot Loader Support \u2013 Read-While-Write Self-Programming\u201d on page\n202. \u201cMemory Programming\u201d on page 215  contains a detailed description on Flash Program-\nming in SPI- or Para llel Programming mode.\nConstant tables can be allocated within the entire Program memory address space (see the\nLPM \u2013 Load Program memory instruction description).\nTiming diagrams for instruction fetch and execution are presented in \u201cInstruction Execution Tim-\ning\u201d on page 13 .\nFigure 7.  Program Memory Map\n$000\n$FFF \nApplication Flash Section\n \nBoot Flash Section\n\n18\n2486Z\u2013AVR\u201302/11ATmega8(L)SRAM Data \nMemoryFigure 8  shows how the Atmel\u00aeAVR\u00ae SRAM Memory is organized.\nThe lower 1120 Data memory locations address the Register File, the I/O Memory, and the inter-\nnal data SRAM. The first 96 locations address the Register File and I/O Memory, and the next1024 locations address the internal data SRAM.\nThe five different addressing modes for the Data memory cover: Direct, Indirect with Displace-\nment, Indirect, Indirect with Pre-decrement, and Indirect with Post-increment. In the Register\nFile, registers R26 to R31 feature the indirect addressing pointer registers.\nThe direct addressing reaches the entire data space.The Indirect with Displacement mode reaches 63 address locations from the base address given\nby the Y-register or Z-register.\nWhen using register indirect addressing modes with automatic pre-decrement and post-incre-\nment, the address registers X, Y and Z are decremented or incremented.\nThe 32 general purpose working registers, 64 I/O Registers, and the 1024 bytes of internal data\nSRAM in the ATmega8 are all accessible through all these addressing modes. The Register Fileis described in \u201cGeneral Purpose Register File\u201d on page 12 .\nFigure 8.  Data Memory Map\nRegister File\nR0\nR1\nR2\nR29\nR30\nR31\nI/O Registers\n$00\n$01$02...\n$3D\n$3E\n$3F...$0000\n$0001\n$0002\n$001D\n$001E\n$001F\n$0020\n$0021$0022...\n$005D\n$005E\n$005F...Data Address Space\n$0060\n$0061\n$045E\n$045F...Internal SRAM\n\n19\n2486Z\u2013AVR\u201302/11ATmega8(L)\nData Memory \nAccess TimesThis section describes the general access timi ng concepts for internal memory access. The\ninternal data SRAM access is performed in two clkCPU cycles as described in Figure 9 .\nFigure 9.  On-chip Data SRAM Access Cycles\nEEPROM Data \nMemoryThe ATmega8 contains 512bytes of data EEPROM memory. It is organized as a separate data\nspace, in which single bytes can be read and written. The EEPROM has an endurance of atleast 100,000 write/erase cycles. The access between the EEPROM and the CPU is described\nbelow, specifying the EEPROM Address Regist ers, the EEPROM Data  Register, and the\nEEPROM Control Register.\n\u201cMemory Programming\u201d on page 215  contains a detailed descri ption on EEPROM Programming\nin SPI- or Parallel Programming mode.\nEEPROM Read/Write \nAccessThe EEPROM Access Registers are accessible in the I/O space.\nThe write access time for the EEPROM is given in Table 1 on page 21 . A self-timing function,\nhowever, lets the user software detect when the nex t byte can be written. If the user code con-\ntains instructions that write the EEPROM, some precautions must be taken. In heavily filtered\npower supplies, V\nCC is likely to rise or fall slowly on Po wer-up/down. This causes the device for\nsome period of time to run at a voltage lower than specified as minimum for the clock frequencyused. See \u201cPreventing EEPROM Corruption\u201d on page 23.  for details on how to avoid problems in\nthese situations.\nIn order to prevent unintentional EEPROM writes, a specific write procedure must be followed.\nRefer to \u201cThe EEPROM Control Regist er \u2013 EECR\u201d on page 20  for details on this.\nWhen the EEPROM is read, the CPU is halted for fo ur clock cycles before the next in struction is\nexecuted. When the EEPROM is written, the CP U is halted for two clock cycles before the next\ninstruction is executed.clk\nWR\nRDData\nDataAddress Address ValidT1 T2 T3\nCompute Address\nReadWriteCPU\nMemory Vccess Instruction Next Instruction\n\n20\n2486Z\u2013AVR\u201302/11ATmega8(L)The EEPROM Address \nRegister \u2013 EEARH and EEARL\n\u0081 Bits 15..9 \u2013 Res: Reserved Bits\nThese bits are reserved bits in the ATmega8 and will always read as zero.\n\u0081 Bits 8..0 \u2013 EEAR8..0: EEPROM Address\nThe EEPROM Address Registers \u2013 EEARH and EEARL \u2013 specify the EEPR OM address in the\n512bytes EEPROM space.  The EEPROM data bytes are addr essed linearly between 0 and 511.\nThe initial value of EEAR is undefined. A proper value must be written before the EEPROM maybe accessed.\nThe EEPROM Data \nRegister \u2013 EEDR\n\u0081 Bits 7..0 \u2013 EEDR7..0: EEPROM Data\nFor the EEPROM write operation, the EEDR Register contains the data to be written to the\nEEPROM in the address given by the EEAR Regi ster. For the EEPROM read operation, the\nEEDR contains the data read out from the EEPROM at the add ress given by EEAR.\nThe EEPROM Control \nRegister \u2013 EECR\n\u0081 Bits 7..4 \u2013 Res: Reserved Bits\nThese bits are reserved bits in the Atmel\n\u00aeAVR\u00ae ATmega8 and will always read as zero.\n\u0081 Bit 3 \u2013 EERIE: EEPROM Ready Interrupt Enable\nWriting EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing\nEERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant inter-rupt when EEWE is cleared.\n\u0081 Bit 2 \u2013 EEMWE: EEPROM Master Write Enable\nThe EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written.\nWhen EEMWE is set, setting EEWE within four cl ock cycles will write data to the EEPROM at\nthe selected address If EEMWE is zero, sett ing EEWE will have no e ffect. When EEMWE has\nbeen written to one by software, hardware clears th e bit to zero after four clock cycles. See the\ndescription of the \u201cBit 1 \u2013 EEWE: EEPROM Write Enable\u201d  for an EEPROM write procedure.\n\u0081 Bit 1 \u2013 EEWE: EEPROM Write Enable\nThe EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address\nand data are correctly set up, the EEWE bit must be written to one to write the value into theEEPROM. The EEMWE bit must be written to one be fore a logical one is written to EEWE, oth-B i t 1 51 41 31 21 11 0 9 8\n\u2013\u2013\u2013\u2013\u2013\u2013\u2013 E E A R 8 E E A R H\nEEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 EEARL\n76543210\nR e a d / W r i t e RRRRRRR R / W\nR/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 0000000X\nXXXXXXXX\nB i t 76543210\nMSB LSB EEDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210\n\u2013 \u2013 \u2013 \u2013 EERIE EEMWE EEWE EERE EECR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 X 0\n\n21\n2486Z\u2013AVR\u201302/11ATmega8(L)\nerwise no EEPROM write takes place. The following procedure should be followed when writing\nthe EEPROM (the order of steps  3 and 4 is not essential):\n1. Wait until EEWE becomes zero2. Wait until SPMEN in SPMCR becomes zero3. Write new EEPROM address to EEAR (optional)4. Write new EEPROM data to EEDR (optional)5. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR\n6. Within four clock cycles after setting EEMWE, write a logical one to EEWE\nThe EEPROM can not be programmed during a CPU write to the Flash memory. The software\nmust check that the Flash programming is co mpleted before initiating a new EEPROM write.\nStep 2 is only relevant if the software contains a boot loader allowing the CPU to program theFlash. If the Flash is never being updated by the CPU, step 2 can be omitted. See \u201cBoot Loader\nSupport \u2013 Read-While-Write Self-Programming\u201d on page 202  for details about boot\nprogramming.\nCaution: An interrupt between step 5 and step 6 will make the write cycle fail, since the\nEEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is\ninterrupting another EEPROM acce ss, the EEAR or EEDR Register  will be modified, causing the\ninterrupted EEPROM access to fail.  It is recommended to have the Global Interrupt Flag cleared\nduring all the steps to avoid these problems.\nWhen the write access time has elapsed, the EEWE bit is cleared by hardware. The user soft-\nware can poll this bit and wait for a zero before writing the next byte. When EEWE has been set,the CPU is halted for two cycles before the next instruction is executed.\n\u0081 Bit 0 \u2013 EERE: EEPROM Read Enable\nThe EEPROM Read Enable Signal EERE is the re ad strobe to the EEPROM. When the correct\naddress is set up in the EEAR Register, the EERE bit must be written to a logic one to trigger theEEPROM read. The EEPROM read access takes one  instruction, and th e requested data is\navailable immediately. When t he EEPROM is read, the CPU is ha lted for four cycles before the\nnext instruction is executed.\nThe user should poll the EEWE bit before starti ng the read operation. If a write operation is in\nprogress, it is neither possi ble to read the EEPROM, nor to change the EEAR Register.\nThe calibrated Oscillator is used to time the EEPROM accesses. Table 1  lists the typical pro-\ngramming time for EEPROM access from the CPU.\nNote: 1. Uses 1MHz clock, independent of CKSEL Fuse settingsTable 1.  EEPROM Programming Time\nSymbolNumber of Calibrated RC \nOscillator Cycles(1)Typ Programming Time\nEEPROM Write (from CPU) 8448 8.5ms\n\n22\n2486Z\u2013AVR\u201302/11ATmega8(L)The following code examples show one assembly and one C function for writing to the\nEEPROM. The examples assume that interrupts are controlled (for example by disabling inter-rupts globally) so that no inte rrupts will occur during execution of these functi ons. The examples\nalso assume that no Flash boot loader is present in the software. If such code is present, theEEPROM write function must also wait fo r any ongoing SPM co mmand to finish.\nAssembly Code Example\nEEPROM_write:\n; Wait for completion of previous write\nsbic EECR,EEWE\nrjmp EEPROM_write    \n; Set up address (r18:r17) in address register\nout EEARH, r18\nout EEARL, r17\n; Write data (r16) to data register\nout EEDR,r16\n; Write logical one to EEMWEsbi EECR,EEMWE\n; Start eeprom write by setting EEWE\nsbi EECR,EEWE\nret\nC Code Example\nvoid EEPROM_write( unsigned int  uiAddress, unsigned char  ucData)\n{\n/* Wait for completion of previous write  */\nwhile(EECR & (1<<EEWE))\n;\n/* Set up address and data registers */\nEEAR = uiAddress;\nEEDR = ucData;/* Write logical one to EEMWE */\nEECR |= (1<<EEMWE);\n/* Start eeprom write by setting EEWE */EECR |= (1<<EEWE);\n}\n\n23\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe next code examples show assembly and C functions for reading the EEPROM. The exam-\nples assume that interrupts are controlled so that no interrupts will occur during execution ofthese functions.\nEEPROM Write during \nPower-down Sleep ModeWhen entering Power-down sleep mode whil e an EEPROM write operation is active, the\nEEPROM write operation will continue, and will complete before the Write Access time has\npassed. However, when the writ e operation is completed, the Oscillator continues running, and\nas a consequence, the device does not enter Power-down entirely. It is therefore recommendedto verify that the EEPROM wr ite operation is completed before entering Power-down.\nPreventing EEPROM \nCorruptionDuring periods of low V\nCC, the EEPROM data can be corrupted because the supply voltage is\ntoo low for the CPU and the EEPROM to operate properly. These issues are the same as forboard level systems using EEPR OM, and the same design so lutions should be applied.\nAn EEPROM data corruption can be caused by two situations when the voltage is too low. First,\na regular write sequence to the EEPROM requires a minimum voltage to operate correctly. Sec-ond, the CPU itself can execute instructions incorrectly, if the supply voltage is too low.\nEEPROM data corruption can ea sily be avoided by followin g this design recommendation:\nKeep the AVR RESET active (low) during periods  of insufficient powe r supply voltage. This\ncan be done by enabling the internal Brown-out Detector (BOD). If the detection level of theinternal BOD does not match the needed detection level, an external low V\nCC Reset Protec-Assembly Code Example\nEEPROM_read:\n; Wait for completion of previous write\nsbic EECR,EEWE\nrjmp EEPROM_read\n; Set up address (r18:r17) in address register\nout EEARH, r18\nout EEARL, r17\n; Start eeprom read by writing EERE\nsbi EECR,EERE\n; Read data from data registerin r16,EEDR\nret\nC Code Example\nunsigned char  EEPROM_read( unsigned int  uiAddress)\n{\n/* Wait for completion of previous write */\nwhile(EECR & (1<<EEWE))\n;\n/* Set up address register */\nEEAR = uiAddress;/* Start eeprom read by writing EERE */\nEECR |= (1<<EERE);\n/* Return data from data register */return EEDR;\n}\n\n24\n2486Z\u2013AVR\u201302/11ATmega8(L)tion circuit can be used. If a reset occurs whil e a write operation is in progress, the write\noperation will be completed prov ided that the po wer supply voltag e is sufficient.\nI/O Memory The I/O space definition of the ATmega8 is shown in \u201cRegister Summary\u201d on page 280 .\nAll Atmel\u00aeAVR\u00ae ATmega8 I/Os and peripherals are placed in the I/O space. The I/O locations\nare accessed by the IN and OUT instructions, transferring data between the 32 general purpose\nworking registers and the I/O space. I/O Registers within the address range 0x00 - 0x1F are\ndirectly bit-accessible using the SBI and CBI instructions. In these registers, the value of singlebits can be checked by using the SBIS and SBIC instructions. Refer to the \u201cInstruction Set Sum-\nmary\u201d on page 282  for more details. When using the I/O specific commands IN and OUT, the I/O\naddresses 0x00 - 0x3F must be used. When addressing I/O Registers as data space using LDand ST instructions, 0x20 must be added to these addresses.\nFor compatibility with future devices, reserved  bits should be written to zero if accessed.\nReserved I/O memory addresses should never be written.\nSome of the Status Flags are cleared by writing a logical one to them. Note that the CBI and SBI\ninstructions will operate on all bi ts in the I/O Register, writi ng a one back into  any flag read as\nset, thus clearing the flag. The CBI and SBI inst ructions work with registers 0x00 to 0x1F only.\nThe I/O and Peripherals Control Registers are explained in later sections.\n\n25\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSystem Clock \nand Clock \nOptions\nClock Systems \nand their \nDistributionFigure 10  presents the principal clock systems in the Atmel\u00aeAVR\u00ae and their distribution. All of\nthe clocks need not be active at a given time. In order to reduce power consumption, the clocks\nto modules not being used can be halted by using different sleep modes, as described in \u201cPower\nManagement and Sleep Modes\u201d on page 33 . The clock systems are detailed Figure 10 .\nFigure 10.  Clock Distribution\nCPU Clock \u2013 clkCPU The CPU clock is routed to parts of the system concerned with operation of the AVR core.\nExamples of such modules are the General Pur pose Register File, the Status Register and the\nData memory holding the Stack Pointer. Halting the CPU clock inhibits the core from performinggeneral operations and calculations.\nI/O Clock \u2013 clk\nI/O The I/O clock is used by the majority of the I/O modules, like Timer/Counters, SPI, and USART.\nThe I/O clock is also used by the External Inte rrupt module, but note that some external inter-\nrupts are detected by asynchronous logic, allowing such interrupts to be detected even if the I/Oclock is halted. Also note that address recognition in the TWI module is carried out asynchro-nously when clk\nI/O is halted, enabling TWI address reception in all sleep modes.\nFlash Clock \u2013 clkFLASH The Flash clock controls operation of the Flash in terface. The Flash clock is usually active simul-\ntaneously with the CPU clock.General I/O\nModulesAsynchronous\nTimer/CounterADC CPU Core RAM\nclkI/O\nclkASYAVR Clock\nControl UnitclkCPUFlash and\nEEPROM\nclkFLASHclkADC\nSource ClockWatchdog  Timer\nWatchdog\nOscillatorReset  Logic\nClock\nMultiplexerWatchdog Clock\nCalibrated RC\nOscillatorTimer/Counter\nOscillatorCrystal\nOscillatorLow-Frequency\nCrystal OscillatorExternal RC\nOscillator External Clock\n\n26\n2486Z\u2013AVR\u201302/11ATmega8(L)Asynchronous Timer \nClock \u2013 clkASYThe Asynchronous Timer clock al lows the Asynchronous Timer/C ounter to be clocked directly\nfrom an external 32kHz clock crystal. The dedica ted clock domain allows using this Timer/Coun-\nter as a real-time counter even when the device is in sleep mode. The Asynchronous\nTimer/Counter uses the same XTAL pins as the CPU main clock but requires a CPU main clockfrequency of more than four times the Oscillator frequency. Thus, asynchronous operation isonly available while the chip is clocked on the Internal Oscillator.\nADC Clock \u2013 clk\nADC The ADC is provided with a dedicated clock domain. This allows halting the CPU and I/O clocks\nin order to reduce noise generated by digital circuitry. This gives more accurate ADC conversionresults.\nClock Sources The device has the following clock source opti ons, selectable by Flash Fuse Bits as shown\nbelow. The clock from the selected source is input to the AVR clock generator, and routed to theappropriate modules.\nNote: 1. For all fuses \u201c1\u201d means unprogrammed while \u201c0\u201d means programmed\nThe various choices for each clocking option is given in the following sections. When the CPUwakes up from Power-down or Power-save, the selected clock source is used to time the start-up, ensuring stable Osc illator operation bef ore instruction execution st arts. When the CPU starts\nfrom reset, there is as an additional delay allowing the power to reach a stable level before com-mencing normal operation. The Watchdog Oscillator is used for timing this real-time part of thestart-up time. The num ber of WDT Oscillator cycles used for each time-out is shown in Table 3 .\nThe frequency of the Watchdog Oscillator is vo ltage dependent as shown in \u201cATmega8 Typical\nCharacteristics\u201d. The device is shipped with CKSEL = \u201c0001\u201d and SUT = \u201c10\u201d (1MHz Internal RCOscillator, slowly rising power).Table 2.  Device Clocking Options Select\n(1)\nDevice Clocking Option  CKSEL3..0\nExternal Crystal/Ceramic Resonator 1111 - 1010\nExternal Low-frequency Crystal 1001\nExternal RC Oscillator 1000 - 0101\nCalibrated Internal RC Oscillator 0100 - 0001\nExternal Clock 0000\nTable 3.  Number of Watchdog Oscillator Cycles\nTypical Time-out (VCC = 5.0V) Typical Time-out (VCC = 3.0V) Number of Cycles\n4.1ms 4.3ms 4K (4,096)\n65ms 69ms 64K (65,536)\n\n27\n2486Z\u2013AVR\u201302/11ATmega8(L)\nCrystal Oscillator XTAL1 and XTAL2 are input and output, respectively, of an inverting amplifier which can be con-\nfigured for use as an On-chip Oscillator, as shown in Figure 11 . Either a quartz crystal or a\nceramic resonator may be used. The CKOPT Fuse selects between two different Oscillatoramplifier modes. When CKOPT is  programmed, the Oscillator outpu t will oscillate a full rail-to-\nrail swing on the output. This mode is suitable when operating in a very noisy environment orwhen the output from XTAL2 drives a second clock buffer. This mode has a wide frequencyrange. When CKOPT is unprogrammed, the Oscillator has a sm aller output swin g. This reduces\npower consumption considerably. This mode has a limited frequency range and it cannot beused to drive other clock buffers.\nFor resonators, the maximum frequency is 8MHz with CKOPT unprogrammed and 16MHz with\nCKOPT programmed. C1 and C2 should always be equal for both crystals and resonators. Theoptimal value of the capacitors depends on the crystal or resonator in use, the amount of straycapacitance, and the electromagnetic noise of the environment. Some initial guidelines for\nchoosing capacitors for use with crystals are given in Table 4 . For ceramic resonators, the\ncapacitor values given by the manufacturer should be used.\nFigure 11.  Crystal Oscillator Connections\nThe Oscillator can operate in three different mo des, each optimized for a specific frequency\nrange. The op erating mode is selected by t he fuses CKSEL3..1 as shown in Table 4 .\nNote: 1. This option should not be used with crystals, only with ceramic resonators\nThe CKSEL0 Fuse together with the SUT1..0 Fuses select the start-up times as shown in Table\n5 on page 28 .Table 4.  Crystal Oscillator Operating Modes\nCKOPT CKSEL3..1 Frequency Range \n(MHz)Recommended Range for Capacitors \nC1 and C2 for Use with Crystals (pF)\n1 101(1)0.4 - 0.9 \u2013\n1 110 0.9 - 3.0 12 - 22\n1 111 3.0 - 8.0 12 - 22\n0 101, 110, 111 1.0 \u2264 12 - 22XTAL2\nXTAL1\nGNDC2\nC1\n\n28\n2486Z\u2013AVR\u201302/11ATmega8(L)Notes: 1. These options should only be used when not  operating close to the maximum frequency of the\ndevice, and only if frequency stability at start- up is not important for the application. These\noptions are not suitable for crystals\n2. These options are intended for use with ceramic resonators and will ensure frequency stability\nat start-up. They can also be used with cryst als when not operating close to the maximum fre-\nquency of the device, and if frequency stability at  start-up is not important for the application\nLow-frequency \nCrystal OscillatorTo use a 32.768kHz watch crystal as the clock source for the device, the Low-frequency Crystal\nOscillator must be selected by setting the CKSEL Fuses to \u201c10 01\u201d. The crystal should be con-\nnected as shown in Figure 11 on page 27 . By programming the CKOPT Fuse, the user can\nenable internal capacitors on XTAL1 and XTAL2, thereby removing the need for external capac-itors. The internal capacitors have a nominal value of 36pF.\nWhen this Oscillator is select ed, start-up times are determined by the SUT Fuses as shown in\nTable 6 .\nNote: 1. These options should only be used if frequen cy stability at start-up is not important for the\napplication\nExternal RC \nOscillatorFor timing insensitive applications, t he external RC configuration shown in Figure 12 on page 29\ncan be used. The frequency is roughly estimated by the equation f = 1/(3RC). C should be atTable 5.  Start-up Times for the Crystal  Oscillator Clock Selection\nCKSEL0 SUT1..0Start-up Time\nfrom Power-down\nand Power-saveAdditional Delay\nfrom Reset\n(VCC = 5.0V) Recommended Usage\n0 00 258 CK(1)4.1msCeramic resonator, fast \nrising power\n0 01 258 CK(1)65msCeramic resonator, slowly \nrising power\n01 0 1 K  C K(2)\u2013Ceramic resonator, BOD \nenabled\n01 1 1 K  C K(2)4.1msCeramic resonator, fast \nrising power\n10 0 1 K  C K(2)65msCeramic resonator, slowly \nrising power\n10 1 1 6 K  C K \u2013Crystal Oscillator, BOD \nenabled\n1 10 16K CK 4.1msCrystal Oscillator, fast \nrising power\n1 11 16K CK 65msCrystal Oscillator, slowly \nrising power\nTable 6.  Start-up Times fo r the Low-frequency Crystal  Oscillator Clock Selection\nSUT1..0Start-up Time from\nPower-down and\nPower-saveAdditional Delay\nfrom Reset\n(VCC = 5.0V) Recommended Usage\n00 1K CK(1)4.1ms Fast rising power or BOD enabled\n01 1K CK(1)65ms Slowly rising power\n10 32K CK 65ms Stable frequency at start-up\n11 Reserved\n\n29\n2486Z\u2013AVR\u201302/11ATmega8(L)\nleast 22pF. By programming the CKOPT Fuse, the user can enable an internal 36pF capacitor\nbetween XTAL1 and GND, thereby removing the need for an external capacitor.\nFigure 12.  External RC Configuration\nThe Oscillator can operat e in four different mo des, each optimized for a specific frequency\nrange. The op erating mode is selected by t he fuses CKSEL3..0 as shown in Table 7 .\nWhen this Oscillator is select ed, start-up times are determined by the SUT Fuses as shown in\nTable 8 .\nNote: 1. This option should not be used when operati ng close to the maximum frequency of the deviceTable 7.  External RC Oscilla tor Operating Modes\n CKSEL3..0  Frequency Range (MHz)\n0101 0.1 - 0.9\n0110 0.9 - 3.0\n0111 3.0 - 8.01000 8.0 - 12.0\nTable 8.  Start-up Times for th e External RC Osc illator Clock Selection\nSUT1..0Start-up Time from\nPower-down and\nPower-saveAdditional Delay\nfrom Reset\n(VCC = 5.0V) Recommended Usage\n00 18 CK \u2013 BOD enabled\n01 18 CK 4.1ms Fast rising power10 18 CK 65ms Slowly rising power\n11 6 CK\n(1)4.1ms Fast rising power or BOD enabledXTAL2\nXTAL1\nGNDCRVCC\nNC\n\n30\n2486Z\u2013AVR\u201302/11ATmega8(L)Calibrated Internal \nRC OscillatorThe calibrated internal RC Oscillator provi des a fixed 1.0MHz, 2.0MHz, 4.0MHz, or 8.0MHz\nclock. All frequencies are nominal values at 5V and 25 \u00b0C. This clock may be selected as the\nsystem clock by programming the CKSEL Fuses as shown in Table 9 . If selected, it will operate\nwith no external components. The CKOPT Fuse should always be unprogrammed when usingthis clock option. During reset, hardware loads the 1MHz calibration byte into the OSCCAL Reg-ister and thereby automatically calibrates the RC Oscillator. At 5V, 25 \u00b0C and 1.0MHz Oscillator\nfrequency selected, this calibration gives a frequency within \u00b13% of the nominal frequency.\nUsing run-time calibration methods as des cribed in application notes available at\nwww.atmel.com/avr it is possible to achieve \u00b11% accuracy at any given V\nCC and Temperature.\nWhen this Oscillator is used as the chip clock,  the Watchdog Oscillator will still be used for the\nWatchdog Timer and for the Reset Time-out. For more information on the pre-programmed cali-bration value, see the section \u201cCalibration Byte\u201d on page 218 .\nNote: 1. The device is shipped with this option selected\nWhen this Oscillator is select ed, start-up times are determined by the SUT Fuses as shown in\nTable 10 . PB6 (XTAL1/TOSC1) and PB7(XTAL2/TOSC2) can be used as either general I/O pins\nor Timer Oscillator pins..\nNote: 1. The device is shipped with this option selectedTable 9.  Internal Calibrated RC O scillator Oper ating Modes\n CKSEL3..0 Nominal Frequency (MHz)\n0001(1)1.0\n0010 2.00011 4.0\n0100 8.0\nTable 10.  Start-up Times for the In ternal Calibrated RC Os cillator Clock Selection\nSUT1..0Start-up Time from \nPower-down and \nPower-saveAdditional Delay \nfrom Reset\n(VCC = 5.0V) Recommended Usage\n00 6 CK \u2013 BOD enabled\n01 6 CK 4.1ms Fast rising power\n10(1)6 CK 65ms Slowly rising power\n11 Reserved\n\n31\n2486Z\u2013AVR\u201302/11ATmega8(L)\nOscillator Calibration \nRegister \u2013 OSCCAL\n\u0081 Bits 7..0 \u2013 CAL7..0: Oscillator Calibration Value\nWriting the calibration byte to th is address will trim the Internal Os cillator to remove process vari-\nations from the Oscillator frequency. During Rese t, the 1MHz calibration value which is located\nin the signature row High byte (address 0x00) is automatically loaded into the OSCCAL Regis-\nter. If the internal RC is used at other frequencies, the calibration values must be loadedmanually. This can be done by first reading the signature row by a programmer, and then storethe calibration values in the Flash or EEPROM. Then the value can be read by software andloaded into the OSCCAL Register. When OSCCAL is zero, the lowest available frequency ischosen. Writing non-zero values to  this register will increase the frequency of the Internal Oscil-\nlator. Writing 0xFF to the regist er gives the highest available fr equency. The calibrated Oscillator\nis used to time EEPROM and Flash access. If EEPR OM or Flash is written, do not calibrate to\nmore than 10% above the nominal frequency. Otherwise, the EEPROM or Flash write may fail.Note that the Osc illator is intended for calibration to 1. 0MHz, 2.0MHz, 4.0MHz, or 8.0MHz. Tun-\ning to other values is not guaranteed, as indicated in Table 11 .B i t 76543210\nCAL7 CAL6 CAL5 CAL4 CAL3 CAL2 CAL1 CAL0 OSCCAL\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value Device Spec ific Calibration Value\nTable 11.  Internal RC Oscillator Frequency Range\nOSCCAL ValueMin Frequency in Percentage of \nNominal Frequency (%)Max Frequency in Percentage of \nNominal Frequency (%)\n0x00 50 100\n0x7F 75 150\n0xFF 100 200\n\n32\n2486Z\u2013AVR\u201302/11ATmega8(L)External Clock To drive the device from an external clock source, XTAL1 should be driven as shown in Figure\n13. To run the device on an exte rnal clock, the CKSEL Fuses mu st be programmed to \u201c0000\u201d.\nBy programming the CKOPT Fuse, the user can enable an internal 36pF capacitor betweenXTAL1 and GND, and XTAL2 and GND.\nFigure 13.  External Clock Drive Configuration\nWhen this clock source is sele cted, start-up times are determined by the SUT Fuses as shown in\nTable 12 .\nWhen applying an external clock, it is required to avoid sudden changes in the applied clock fre-\nquency to ensure stable operation of the MCU. A variation in frequency of more than 2% fromone clock cycle to the next can lead  to unpredictable behavior. It is  required to en sure that the\nMCU is kept in Reset during such changes in the clock frequency.\nTimer/Counter \nOscillatorFor AVR microcontrollers with Timer/Counter Osc illator pins (TOSC1 and TOSC2), the crystal is\nconnected directly between the pins. By programming the CKOPT Fuse, the user can enableinternal capacitors on XTAL1 and XTAL2, thereb y removing the need for external capacitors.\nThe Oscillator is optimized for use with a 32.768k Hz watch crystal. Applying an external clock\nsource to TOSC1 is not recommended.\nNote: The Timer/Counter Oscillator uses the same ty pe of crystal oscillator as Low-Frequency Oscillator\nand the internal capacitors have the same nominal value of 36pFTable 12.  Start-up Times for the External Clock Selection\nSUT1..0Start-up Time from\nPower-down and\nPower-saveAdditional Delay\nfrom Reset\n(VCC = 5.0V) Recommended Usage\n00 6 CK \u2013 BOD enabled01 6 CK 4.1ms Fast rising power\n10 6 CK 65ms Slowly rising power\n11 ReservedEXTERNAL\nCLOCK\nSIGNAL\n\n33\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPower \nManagement \nand Sleep ModesSleep modes enable the application to shut down unused modules in the MCU, thereby saving\npower. The AVR provides various sleep modes allowing the user to tailor the power consump-tion to the application\u2019s requirements.\nTo enter any of the five sleep modes, the SE bit in MCUCR must be wri tten to logic one and a\nSLEEP instruction must be executed. The SM2,  SM1, and SM0 bits in the MCUCR Register\nselect which sleep mode (Idle, ADC Noise Reduction, Power-down, Power-save, or Standby)will be activated by the SLEEP instruction. See Table 13  for a summary. If an enabled interrupt\noccurs while the MCU is in a sleep mode, the MCU wakes up. The MCU is then halted for fourcycles in addition to the start-up time, it executes the interrupt routine, and resumes executionfrom the instruction following SL EEP. The contents of the Register File an d SRAM are unaltered\nwhen the device wakes up from sleep. If a reset occurs during sleep mode, the MCU wakes upand executes from the Reset Vector.\nNote that the Extended Standby mode present in many other AVR MCUs has been removed in\nthe ATmega8, as the TOSC and XTAL inputs share the same physical pins.\nFigure 10 on page 25  presents the different clock systems in the ATmega8, and their distribu-\ntion. The figure is helpful in selecting an appropriate sleep mode.\nMCU Control Register \n\u2013 MCUCRThe MCU Control Register contains control bits for power management.\n\u0081 Bit 7 \u2013 SE: Sleep Enable\nThe SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP\ninstruction is executed. To avoid the MCU enteri ng the sleep mode unless it is the programmer\u2019s\npurpose, it is recommended to set the Sleep Enable (SE) bit just before the execution of theSLEEP instruction.\n\u0081 Bits 6..4 \u2013 SM2..0: Sleep Mode Select Bits 2, 1, and 0\nThese bits select between the five available sleep modes as shown in Table 13 .\nNote: 1. Standby mode is only available with external crystals or resonatorsB i t 76543210\nSE SM2 SM1 SM0 ISC11 ISC10 ISC01 ISC00 MCUCR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nTable 13.  Sleep Mode Select\nSM2 SM1 SM0 Sleep Mode\n000 I d l e\n0 0 1 ADC Noise Reduction010 P o w e r - d o w n\n011 P o w e r - s a v e\n100 R e s e r v e d101 R e s e r v e d\n110 S t a n d b y\n(1)\n\n34\n2486Z\u2013AVR\u201302/11ATmega8(L)Idle Mode When the SM2..0 bits are written to 000, the SLEEP instruction makes the MCU enter Idle\nmode, stopping the CPU but allowing SPI, USART, Analog Comparator, ADC, Two-wire SerialInterface, Timer/Counters, Watchdog, and the interrupt system to continue operating. This sleepmode basically halts clk\nCPU and clkFLASH , while allowing the ot her clocks to run.\nIdle mode enables the MCU to wake up from external triggered interrupts as well as internal\nones like the Timer Overflow and USART Transmit Complete interrupts. If wake-up from theAnalog Comparator interrupt is not required, the Analog Comparator can be powered down bysetting the ACD bit in the Analog Comparator Control and Status Regist er \u2013 ACSR. This will\nreduce power consumption in Idle mode. If t he ADC is enabled, a conversion starts automati-\ncally when this mode is entered.\nADC Noise \nReduction ModeWhen the SM2..0 bits are written to 001, the SLEEP instruction makes the MCU enter ADC\nNoise Reduction mode, stopping the CPU but allowing the ADC, the external interrupts, theTwo-wire Serial Interface address watch, Timer/Counter2 and the Watchdog to continueoperating (if enabled). This sleep mode basically halts clk\nI/O, clkCPU, and clkFLASH , while allowing\nthe other clocks to run.\nThis improves the noise environment for the AD C, enabling higher resolution measurements. If\nthe ADC is enabled, a conversion starts automatically when this mode is entered. Apart form theADC Conversion Complete interrupt, only an External Reset, a Watchdog Reset, a Brown-outReset, a Two-wire Serial Interface address match interrupt, a Timer/Counter2 interrupt, anSPM/EEPROM ready interrupt, or an external level interrupt on INT0 or INT1, can wake up theMCU from ADC Noise Reduction mode.\nPower-down Mode When the SM2..0 bits are written to 010, the SLEEP instruction makes the MCU enter Power-down mode. In this mode, the External Oscillator  is stopped, while the external interrupts, the\nTwo-wire Serial Interface address watch, and the Watchdog continue operating (if enabled).Only an External Reset, a Watchdog Reset, a Brown-out Reset, a Two-wire Serial Interfaceaddress match interrupt, or an external level interrupt on INT0 or INT1, can wake up the MCU.This sleep mode basically  halts all generated clocks, allowi ng operation of asynchronous mod-\nules only.\nNote that if a level triggered interrupt is used for wake-up from Power-down mode, the changed\nlevel must be held for some time to wake up the MCU. Refer to \u201cExternal Interrupts\u201d on page 66\nfor details.\nWhen waking up from Power-down mode, there is a delay from the wake-up condition occurs\nuntil the wake-up becomes effective. This allows the clock to restart and become stable afterhaving been stopped. The wake-up period is defined by the same  CKSEL Fuses that define the\nReset Time-out period, as described in \u201cClock Sources\u201d on page 26 .\nPower-save Mode When the SM2..0 bits are written to 011, the SLEEP instruction makes the MCU enter Power-\nsave mode. This mode is identical to Power-down, with one exception:\nIf Timer/Counter2 is clocked asynchronously, that is, the AS2 bit in ASSR is set,\nTimer/Counter2 will run during slee p. The device can wake up fr om either Timer Overflow or\nOutput Compare event from Timer/Counter2 if the corresponding Timer/Counter2 interruptenable bits are set in TIMSK, and the global interrupt enable bit in SREG is set.\nIf the asynchronous timer is NOT clocked asyn chronously, Power-down mode is recommended\ninstead of Power-save mode because the contents of the registers in the asynchronous timershould be considered undefined after wake-up in Power-save mode if AS2 is 0.\nThis sleep mode basically halts all clocks except clk\nASY, allowing operation only of asynchronous\nmodules, including Timer/Counter 2 if clocked asynchronously.\n\n35\n2486Z\u2013AVR\u201302/11ATmega8(L)\nStandby Mode When the SM2..0 bits are 110 and an external crystal/resonator clock option is selected, the\nSLEEP instruction makes the MCU enter Standby mode. This mode is identical to Power-downwith the exception that the Oscillator is kept running. Fr om Standby mode, the device wakes up\nin 6 clock cycles.\nNotes: 1. External Crystal or re sonator selected as clock source\n2. If AS 2 bit in ASSR is set\n3. Only level interrupt INT1 and INT0\nMinimizing Power \nConsumptionThere are several issues to consider when trying to minimize the power consumption in an AVR\ncontrolled system. In general, sleep modes should be used as much as possible, and the sleepmode should be selected so that as few as possi ble of the device\u2019s functions are operating. All\nfunctions not needed should be disabled. In particular, the following modules may need specialconsideration when trying to achieve th e lowest possible power consumption.\nAnalog-to-Digital \nConverter (ADC)If enabled, the ADC will be enabled in all sleep  modes. To save power, the ADC should be dis-\nabled before entering any sleep mode. When the ADC is turned off and on again, the nextconversion will be an extended conversion. Refer to \u201cAnalog-to-Digital Converter\u201d on page 189\nfor details on ADC operation.\nAnalog Comparator When entering Idle mode, the Analog Comparator should be disabled if not used. When entering\nADC Noise Reduction mode, the Analog Comparat or should be disabled. In the other sleep\nmodes, the Analog Comparator is automatically di sabled. However, if the Analog Comparator is\nset up to use the Internal Voltage Reference as input, the Analog Comparator should be dis-\nabled in all sleep modes. Ot herwise, the Internal Volt age Reference will be enabled,\nindependent of sleep mode. Refer to \u201cAnalog Comparator\u201d on page 186  for details on how to\nconfigure the Analog Comparator.Table 14.  Active Clock Domains and Wake-up Sources in the Different Sleep Modes\nActive Clock Domains Osci llators Wake-up Sources\nSleep\nMode clkCPU clkFLASH clkIOclkADC clkASYMain Clock \nSource EnabledTimer Osc. \nEnabledINT1\nINT0TWI\nAddress\nMatchTimer \n2SPM/\nEEPROM \nReady ADCOther\nI/O\nIdle X X X X X(2)XX X X X X\nADC Noise\nReductionXX X X(2)X(3)XX XX\nPower\nDownX(3)X\nPower\nSaveX(2)X(2)X(3)XX(2)\nStandby(1)XX(3)X\n\n36\n2486Z\u2013AVR\u201302/11ATmega8(L)Brown-out Detector If the Brown-out Detector is not needed in the application, this module should be turned off. If the\nBrown-out Detector is enabled by the BODEN Fuse, it will be enabled in all sleep modes, and\nhence, always consume power. In the deeper slee p modes, this will contribute significantly to\nthe total current consumption. Refer to \u201cBrown-out Detection\u201d on page 40  for details on how to\nconfigure the Brown-out Detector.\nInternal Voltage \nReferenceThe Internal Voltage Referenc e will be enabled when needed by  the Brown-out Detector, the\nAnalog Comparator or the ADC. If these modules are disabled as described in the sectionsabove, the internal voltage refe rence will be disabled and it w ill not be consuming power. When\nturned on again, the user must allow the reference to start up before the output is used. If thereference is kept on in sleep mode, the output can be used immediately. Refer to \u201cInternal Volt-\nage Reference\u201d on page 42  for details on the start-up time.\nWatchdog Timer If the Watchdog Timer is not needed in the application, this module should be turned off. If the\nWatchdog Timer is enabled, it will be enabled in all sleep modes, and hence, always consumepower. In the deeper slee p modes, this will contribute signific antly to the total current consump-\ntion. Refer to \u201cWatchdog Timer\u201d on page 43  for details on how to configure the Watchdog Timer.\nPort Pins When entering a sleep mode, all port pins should be configured to use minimum power. The\nmost important thing is then to ensure that no pins drive resistive loads. In sleep modes wherethe both the I/O clock (clk\nI/O) and the ADC clock (clkADC) are stopped, the input buffers of the\ndevice will be disabled. This ensures that no power is consumed by the input logic when not\nneeded. In some cases, the input logic is needed for detecting wake-up conditions, and it willthen be enabled. Refer to the section \u201cDigital Input Enable and Sleep Modes\u201d on page 55  for\ndetails on which pins are enabled. If the input buffer is enabled and the input signal is left floatingor have an analog signal level close to V\nCC/2, the input buffer will use excessive power.\n\n37\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSystem Control \nand Reset\nResetting the AVR During Reset, all I/O Registers are set to their in itial values, and the program starts execution\nfrom the Reset Vector. If the program never enables an interrupt source, the Interrupt Vectorsare not used, and regular program code can be placed  at these locations. This is also the case if\nthe Reset Vector is in the Application section while the Interrupt Vectors are in the boot sectionor vice versa. The circuit diagram in Figure 14 on page 38  shows the Reset Logic. Table 15 on\npage 38  defines the electrical parameters of the reset circuitry.\nThe I/O ports of the AVR are immediately reset to their initial state when a reset source goes\nactive. This does not require any clock source to be running.\nAfter all reset sources have gone inactive, a delay counter is invoked, stretching the internal\nreset. This allows the power to reach a stable level before normal operation starts. The time-outperiod of the delay counter is defined by the user th rough the CKSEL Fuses. The different selec-\ntions for the delay period are presented in \u201cClock Sources\u201d on page 26 .\nReset Sources The ATmega8 has four sources of Reset:\n\u0081 Power-on Reset. The MCU is reset when the supply voltage is be low the Power-on Reset \nthreshold (V\nPOT)\n\u0081 External Reset. The MCU is reset wh en a low level is present on the RESET  pin for longer \nthan the minimum pulse length\n\u0081 Watchdog Reset. The MCU is reset when the Watchdog Timer period expires and the \nWatchdog is enabled\n\u0081 Brown-out Reset. The MCU is reset when the supply voltage VCC is below the Brown-out \nReset threshold (VBOT) and the Brown-out Detector is enabled\n\n38\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 14.  Reset Logic\nNotes: 1. The Power-on Reset will not work un less the supply voltage has been below VPOT (falling)\n2. VBOT may be below nominal minimum operating voltage for some devices. For devices where\nthis is the case, the devi ce is tested down to VCC = VBOT during the production test. This guar-\nantees that a Brown-out Reset will occur before VCC drops to a voltage where correct\noperation of the microcontroller is no longer  guaranteed. The test is performed using\nBODLEVEL = 1 for ATmega8L and BODLEVEL = 0 for ATmega8. BODLEVEL = 1 is not appli-cable for ATmega8Table 15.  Reset Characteristics\nSymbol Parameter Condition Min Typ Max Units\nVPOTPower-on Reset Threshold \nVoltage (rising)(1) 1.4 2.3\nV\nPower-on Reset Threshold \nVoltage (falling)1.3 2.3\nVRST RESET  Pin Threshold Voltage 0.2 0.9 VCC\ntRSTMinimum pulse width on \nRESET  Pin1.5 \u00b5s\nVBOTBrown-out Reset Threshold \nVoltage(2)BODLEVEL = 1 2.4 2.6 2.9\nV\nBODLEVEL = 0 3.7 4.0 4.5\ntBODMinimum low voltage period for \nBrown-out DetectionBODLEVEL = 1 2\n\u00b5s\nBODLEVEL = 0 2\nVHYST Brown-out Detector hysteresis 130 mVMCU Control and Status\nRegister (MCUCSR)\nBrown-Out\nReset CircuitBODEN\nBODLEVEL\nDelay Counters\nCKSEL[3:0]CK\nTIMEOUTWDRFBORF\nEXTRFPORFDATA BUS\nClock\nGeneratorSPIKE\nFILTERPull-up Resistor\nWatchdog\nOscillator\nSUT[1:0]\n\n39\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPower-on Reset A Power-on Reset (POR) pulse is generated by an On-chip detection circuit. The detection level\nis defined in Table 15 on page 38 . The POR is activated whenever VCC is below the detection\nlevel. The POR circuit can be used to trigger the Start-up Reset, as well as to detect a failure insupply voltage.\nA Power-on Reset (POR) circuit ensures that the device is reset from Power-on. Reaching the\nPower-on Reset threshold voltage invokes the delay counter, which determines how long thedevice is kept in RESET after V\nCC rise. The RESET signal is acti vated again, without any delay,\nwhen VCC decreases below the detection level.\nFigure 15.  MCU Start-up, RESET  Tied to VCC\nFigure 16.  MCU Start-up, RESET  Extended ExternallyV\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTCC\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTVCC\n\n40\n2486Z\u2013AVR\u201302/11ATmega8(L)External Reset An External Reset is generated by a low level on the RESET  pin. Reset pulses longer than the\nminimum pulse width (see Table 15 on page 38 ) will generate a reset, even if the clock is not\nrunning. Shorter pulses are not guaranteed to generate a reset. When the applied signalreaches the Reset Threshold Voltage \u2013 V\nRST on its positive edge, the delay counter starts the\nMCU after the time-out period tTOUT has expired.\nFigure 17.  External Reset During Operation\nBrown-out Detection ATmega8 has an On-chip Brown-out Detection (BOD) circuit for monitoring the VCC level during\noperation by comparing it to a fixed trigger level. The trigger level for the BOD can be selectedby the fuse BODLEVEL to be 2.7V (BODLE VEL unprogrammed), or 4.0V (BODLEVEL pro-\ngrammed). The trigger level has a hysteresis to ensure spike free Brown-out Detection. Thehysteresis on the detection level should be interpreted asV\nBOT+ = VBOT + VHYST/2 and VBOT- = VBOT - VHYST/2.\nThe BOD circuit can be enabled/ disabled by the fuse BODEN. When the BOD is enabled\n(BODEN programmed), and VCC decreases to a value below the trigger level (VBOT- in Figure\n18), the Brown-out Reset is immediately activated. When VCC increases above the trigger level\n(VBOT+ in Figure 18 ), the delay counter starts the MCU after the time-out period tTOUT has\nexpired.\nThe BOD circuit will only detect a drop in VCC if the voltage stays below the trigger level for lon-\nger than tBOD given in Table 15 on page 38 .\nFigure 18.  Brown-out Reset During OperationCC\nVCC\nRESET\nTIME-OUT\nINTERNAL\nRESETVBOT-VBOT+\ntTOUT\n\n41\n2486Z\u2013AVR\u201302/11ATmega8(L)\nWatchdog Reset When the Watchdog times out, it will generate a short rese t pulse of 1 CK cycle duration. On the\nfalling edge of this pulse, the delay timer starts counti ng the time-out period  tTOUT. Refer to page\n43 for details on operation of the Watchdog Timer.\nFigure 19.  Watchdog Reset During Operation\nMCU Control and \nStatus Register \u2013 MCUCSRThe MCU Control and Status Register provides information on which reset source caused an\nMCU Reset.\n\u0081 Bit 7..4 \u2013 Res: Reserved Bits\nThese bits are reserved bits in the ATmega8 and always read as zero.\n\u0081 Bit 3 \u2013 WDRF: Watchdog Reset Flag\nThis bit is set if a Watchdog Re set occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 2 \u2013 BORF: Brown-out Reset Flag\nThis bit is set if a Brown-out Reset occurs. The bi t is reset by a Power-on  Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 1 \u2013 EXTRF: External Reset Flag\nThis bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a\nlogic zero to the flag.\n\u0081 Bit 0 \u2013 PORF: Power-on Reset Flag\nThis bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag.\nTo make use of the Reset Flags to identify a reset condition, the user should read and then reset\nthe MCUCSR as early as possible in the program. If the register is cleared before another reset\noccurs, the source of the reset can be found by examining the Reset Flags.CKCC\nB i t 76543210\n\u2013 \u2013 \u2013 \u2013 WDRF BORF EXTRF PORF MCUCSR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 See Bit Description\n\n42\n2486Z\u2013AVR\u201302/11ATmega8(L)Internal Voltage \nReferenceATmega8 features an internal bandgap reference. This reference is used for Brown-out Detec-\ntion, and it can be used as an input to the Analog Comparator or the ADC. The 2.56V referenceto the ADC is generated from the internal bandgap reference.\nVoltage Reference \nEnable Signals and Start-up TimeThe voltage reference has a start-up time that may influence the way it should be used. The\nstart-up time is given in Table 16 . To save power, the reference is not always turned on. The ref-\nerence is on during the following situations:\n1. When the BOD is enabled (by programming the BODEN Fuse)2. When the bandgap reference is connected to the Analog Comparator (by setting the\nACBG bit in ACSR)\n3. When the ADC is enabled\nThus, when the BOD is not enabled, after setting the ACBG bit or enabling the ADC, the user\nmust always allow the reference to start up before the output from the Analog Comparator orADC is used. To reduce power consumption in Power-down mode, the user can avoid the threeconditions above to ensure that the reference is turned off before entering Power-down mode.\nTable 16.  Internal Voltage Reference Characteristics\nSymbol Parameter Min Typ Max Units\nVBG Bandgap reference voltage 1.15 1.30 1.40 V\ntBG Bandgap reference start-up time 40 70 \u00b5s\nIBG Bandgap reference current consumption 10 \u00b5A\n\n43\n2486Z\u2013AVR\u201302/11ATmega8(L)\nWatchdog Timer The Watchdog Timer is clocked fr om a separate On-chip Oscillato r which runs at 1MHz. This is\nthe typical value at VCC = 5V. See characterization data for typical values at other VCC levels. By\ncontrolling the Watchdog Timer prescaler, the Watchdog Reset interval can be adjusted asshown in Table 17 on page 44 . The WDR \u2013 Watchdog Reset \u2013 instruction resets the Watchdog\nTimer. The Watchdog Timer is also reset when it is disabled and when a Chip Reset occurs.\nEight different clock cycle periods can be selected to determine the reset period. If the resetperiod expires without another Watchdog Reset, the ATmega8 resets and executes from theReset Vector. For timing details on the Watchdog Reset, refer to page 41 .\nTo prevent unintentional disabling of the Watc hdog, a special turn-off sequence must be fol-\nlowed when the Watchdog is disabled. Refer to \u201cWatchdog Timer Control Register \u2013 WDTCR\u201d\nfor details.\nFigure 20.  Watchdog Timer\nWatchdog Timer \nControl Register \u2013 WDTCR\n\u0081 Bits 7..5 \u2013 Res: Reserved Bits\nThese bits are reserved bits in the ATmega8 and will always read as zero.\n\u0081 Bit 4 \u2013 WDCE: Watchdog Change Enable\nThis bit must be set when the WDE bit is writte n to logic zero. Otherwis e, the Watchdog will not\nbe disabled. Once written to o ne, hardware will clear this bit af ter four clock cycles. Refer to \u201cBit\n3 \u2013 WDE: Watchdog Enable\u201d on page 44 for a Watchdog disable procedure. In Safety Level 1\nand 2, this bit must also be set when changing the prescaler bits. See the Code Examples on\npage 45 .WATCHDOG\nOSCILLATOR\nB i t 76543210\n\u2013 \u2013 \u2013 WDCE WDE WDP2 WDP1 WDP0 WDTCR\nRead/Write R R R R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n44\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 3 \u2013 WDE: Watchdog Enable\nWhen the WDE is written to logic one, the Watchdog Timer is enabled, and if the WDE is written\nto logic zero, the Watchdog Timer function is di sabled. WDE can only be cleared if the WDCE bit\nhas logic level one. To disable an enabled Watchdog Timer, the following procedure must befollowed:\n1. In the same operation, write a logic one to WDCE and WDE. A logic one must be written\nto WDE even though it is set to one before the disable operation starts\n2. Within the next four clock cycles, write a logic 0 to WDE. This disables the Watchdog\u0081 Bits 2..0 \u2013 WDP2, WDP1, WDP0: Watchdog Timer Prescaler 2, 1, and 0\nThe WDP2, WDP1, and WDP0 bits determine the Watchdog Timer prescaling when the Watch-\ndog Timer is enabled. The different prescaling values and their corresponding Timeout Periods\nare shown in Table 17 . \nThe following code example shows one assembly  and one C function for turning off the WDT.\nThe example assumes that interrupts are controll ed (for example, by disabling interrupts glob-\nally) so that no interrupts will occu r during execution of these functions.Table 17.  Watchdog Timer Prescale Select\nWDP2 WDP1 WDP0Number of WDT\nOscillator CyclesTypical Time-out\nat VCC = 3.0VTypical Time-out\nat VCC = 5.0V\n0 0 0 16K (16,384) 17.1ms 16.3ms\n0 0 1 32K (32,768) 34.3ms 32.5ms\n0 1 0 64K (65,536) 68.5ms 65ms0 1 1 128K (131,072) 0.14s 0.13s\n1 0 0 256K (262,144) 0.27s 0.26s\n1 0 1 512K (524,288) 0.55s 0.52s1 1 0 1,024K (1,048,576) 1.1s 1.0s\n1 1 1 2,048K (2,097,152) 2.2s 2.1s\n\n45\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTimed Sequences \nfor Changing the \nConfiguration of \nthe Watchdog TimerThe sequence for changing the Watchdog Timer conf iguration differs slightly between the safety\nlevels. Separate procedures are described for each level.  \nSafety Level 1 (WDTON Fuse Unprogrammed)In this mode, the Watchdog Time r is initially disabled, but can be enabled by writing the WDE bit\nto 1 without any restriction. A timed sequence is needed when changing the Watchdog Time-outperiod or disabling an enabled Watchdog Timer. To disable an enabled Watchdog Timer and/orchanging the Watchdog Time-out, the following procedure must be followed:\n1. In the same operation, write a logic one to WDCE and WDE. A logic one must be written\nto WDE regardless of the previous value of the WDE bit\n2. Within the next four clock cycles, in the same operation, write the WDE and WDP bits as\ndesired, but with the WDCE bit cleared\nSafety Level 2 \n(WDTON Fuse Programmed)In this mode, the Watchdog Time r is always enabled, and the WDE bit will always read as one. A\ntimed sequence is needed when changing the Watchdog Time-out period. To change theWatchdog Time-out, the following procedure must be followed:\n1. In the same operation, write a logical one to WDCE and WDE. Even though the WDE\nalways is set, the WDE must be written to one to start the timed sequence\nWithin the next four clock cycles, in the same operation, write the WDP bits as desired, but with\nthe WDCE bit cleared. The value wri tten to the WDE bit is irrelevant.Assembly Code Example\nWDT_off:\n; reset WDT\nWDR; Write logical one to WDCE and WDE\nin r16, WDTCR\nori r16, (1<<WDCE)|(1<<WDE)\nout WDTCR, r16\n; Turn off WDT\nldi r16, (0<<WDE)\nout WDTCR, r16\nret\nC Code Example\nvoid WDT_off( void)\n{\n/* reset WDT */\n_WDR();\n/* Write logical one to WDCE and WDE */\nWDTCR |= (1<<WDCE) | (1<<WDE);/* Turn off WDT */\nWDTCR = 0x00;\n}\n\n46\n2486Z\u2013AVR\u201302/11ATmega8(L)Interrupts This section describes the specifics of the interrupt handling performed by the ATmega8. For a\ngeneral explanation of the AVR interrupt handling, refer to \u201cReset and Interrupt Handling\u201d on\npage 14 .\nInterrupt Vectors \nin ATmega8\nNotes: 1. When the BOOTRST Fuse is programmed, the device will jump to the Boot Loader address at\nreset, see \u201cBoot Loader Support \u2013 Read-While-Write Self-Programming\u201d on page 202\n2. When the IVSEL bit in  GICR is set, Interrupt Vectors will be moved to the start of the boot\nFlash section. The address of each Interrupt Vect or will then be the address in this table added\nto the start address of the boot Flash section\nTable 19 on page 47  shows reset and Interrupt Vectors placement for the various combinations\nof BOOTRST and IVSEL settings. If the program never enables an interrupt source, the InterruptVectors are not used, and regular program code can be placed at these locations. This is alsothe case if the Reset Vector is in the Application section while the Interrupt Vectors are in theboot section or vice versa.Table 18.  Reset and Interrupt Vectors\nVector No.Program\nAddress(2)Source Interrupt Definition\n1 0x000(1)RESET External Pin, Powe r-on Reset, Brown-out \nReset, and Watchdog Reset\n2 0x001 INT0 External Interrupt Request 0\n3 0x002 INT1 External Interrupt Request 1\n4 0x003 TIMER2 COMP Timer/ Counter2 Compare Match\n5 0x004 TIMER2 OVF Timer/Counter2 Overflow\n6 0x005 TIMER1 CAPT Timer/Counter1 Capture Event\n7 0x006 TIMER1 COMPA Timer/Counter1 Compare Match A\n8 0x007 TIMER1 COMPB Timer/Counter1 Compare Match B\n9 0x008 TIMER1 OVF Timer/Counter1 Overflow\n10 0x009 TIMER0 OVF Timer/Counter0 Overflow\n11 0x00A SPI, STC Serial Transfer Complete\n12 0x00B USART, RXC USART, Rx Complete13 0x00C USART, UDRE USART Data Register Empty\n14 0x00D USART, TXC USART, Tx Complete\n15 0x00E ADC ADC Conversion Complete16 0x00F EE_RDY EEPROM Ready\n17 0x010 ANA_COMP Analog Comparator\n18 0x011 TWI Two-wire Serial Interface19 0x012 SPM_RDY Store Program Memory Ready\n\n47\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: 1. The Boot Reset Address is shown in Table 82 on page 213 . For the BOOTRST Fuse \u201c1\u201d\nmeans unprogrammed while \u201c0\u201d means programmed\nThe most typical and general program setup for the Reset and Interrupt Vector Addresses in\nATmega8 is:\naddressLabelsCode Comments\n$000 rjmp RESET ; Reset Handler\n$001 rjmp EXT_INT0 ; IRQ0 Handler\n$002 rjmp EXT_INT1 ; IRQ1 Handler$003 rjmp TIM2_COMP ; Timer2 Compare Handler\n$004 rjmp TIM2_OVF ; Timer2 Overflow Handler\n$005 rjmp TIM1_CAPT ; Timer1 Capture Handler$006 rjmp TIM1_COMPA ; Timer1 CompareA Handler\n$007 rjmp TIM1_COMPB ; Timer1 CompareB Handler\n$008 rjmp TIM1_OVF ; Timer1 Overflow Handler$009 rjmp TIM0_OVF ; Timer0 Overflow Handler\n$00a rjmp SPI_STC ; SPI Transfer Complete Handler\n$00b rjmp USART_RXC ; USART RX Complete Handler$00c rjmp USART_UDRE ; UDR Empty Handler\n$00d rjmp USART_TXC ; USART TX Complete Handler\n$00e rjmp ADC ; ADC Conversion Complete Handler$00f rjmp EE_RDY ; EEPROM Ready Handler\n$010 rjmp ANA_COMP ; Analog Comparator Handler\n$011 rjmp TWSI ; Two-wire Serial Interface Handler$012 rjmp SPM_RDY ; Store Program Memory Ready Handler\n;\n$013 RESET: ldi r16,high(RAMEND); Main program start$014 out SPH,r16 ; Set Stack Pointer to top of RAM\n$015 ldi r16,low(RAMEND)\n$016 out SPL,r16$017 sei ; Enable interrupts\n$018 <instr>  xxx\n... ... ...Table 19.  Reset and Interrupt Vectors Placement\nBOOTRST(1)IVSEL Reset Address Interrupt Vectors Start Address\n1 0 0x000 0x001\n1 1 0x000 Boot Reset Address + 0x001\n0 0 Boot Reset Address 0x001\n0 1 Boot Reset Address Boot Reset Address + 0x001\n\n48\n2486Z\u2013AVR\u201302/11ATmega8(L)When the BOOTRST Fuse is unprogrammed, the boot section size set to 2Kbytes and the\nIVSEL bit in the GICR Register is set before any interrupts are enabled, the most typical andgeneral program setup for the Reset and Interrupt Vector Addresses is:\nAddressLabelsCode Comments\n$000 rjmp RESET ; Reset handler\n;\n$001 RESET:ldi r16,high(RAMEND); Main program start\n$002 out SPH,r16 ; Set Stack Pointer to top of RAM\n$003 ldi r16,low(RAMEND)\n$004 out SPL,r16$005 sei ; Enable interrupts\n$006 <instr>  xxx\n;.org $c01\n$c01 rjmp EXT_INT0 ; IRQ0 Handler\n$c02 rjmp EXT_INT1 ; IRQ1 Handler... ... ...; \n$c12 rjmp SPM_RDY ; Store Program Memory Ready Handler\nWhen the BOOTRST Fuse is programmed and the boot section size set to 2Kbytes, the most\ntypical and general program setup for the Reset and Interrupt Vector Addresses is:\nAddressLabelsCode Comments\n.org $001\n$001 rjmp EXT_INT0 ; IRQ0 Handler\n$002 rjmp EXT_INT1 ; IRQ1 Handler... ... ... ; \n$012 rjmp SPM_RDY ; Store Program Memory Ready Handler\n;.org $c00\n$c00 rjmp RESET ; Reset handler\n;\n$c01 RESET:ldi r16,high(RAMEND); Main program start\n$c02 out SPH,r16 ; Set Stack Pointer to top of RAM\n$c03 ldi r16,low(RAMEND)$c04 out SPL,r16\n$c05 sei ; Enable interrupts\n$c06 <instr>  xxx\n\n49\n2486Z\u2013AVR\u201302/11ATmega8(L)\nWhen the BOOTRST Fuse is programmed, the boot section size set to 2Kbytes, and the IVSEL\nbit in the GICR Register is set before any in terrupts are enabled, the most typical and general\nprogram setup for the Reset and Interrupt Vector Addresses is:\nAddressLabels Code Comments\n;.org $c00\n$c00 rjmp RESET ; Reset handler\n$c01 rjmp EXT_INT0 ; IRQ0 Handler\n$c02 rjmp EXT_INT1 ; IRQ1 Handler\n... ... ...; $c12 rjmp SPM_RDY ; Store Program Memory Ready Handler\n$c13 RESET: ldi r16,high(RAMEND); Main program start\n$c14 out SPH,r16 ; Set Stack Pointer to top of RAM$c15 ldi r16,low(RAMEND)\n$c16 out SPL,r16\n$c17 sei ; Enable interrupts$c18 <instr>  xxx\nMoving Interrupts \nBetween Application and Boot SpaceThe General Interrupt Control Register controls the placement of the Interrupt Vector table.\nGeneral Interrupt \nControl Register \u2013 GICR\n\u0081 Bit 1 \u2013 IVSEL: Interrupt Vector Select\nWhen the IVSEL bit is cleared (z ero), the Interrupt Vectors are pl aced at the star t of the Flash\nmemory. When this bit is set (one), the Interrupt Vectors are moved to the beginning of the BootLoader section of the Flash. The actual address of  the start of the boot Flash section is deter-\nmined by the BOOTSZ Fuses. Refer to the section \u201cBoot Loader Support \u2013 Read-While-Write\nSelf-Programming\u201d on page 202  for details. To avoid unintentional changes of Interrupt Vector\ntables, a special write procedure must be followed to change the IVSEL bit:\n1. Write the Interrupt Vector Change Enable (IVCE) bit to one2. Within four cycles, write the desired valu e to IVSEL while writing a zero to IVCE\nInterrupts will automatically be di sabled while this sequence is executed. Interrupts are disabled\nin the cycle IVCE is set, and they remain disabl ed until after the instru ction following the write to\nIVSEL. If IVSEL is not written, interrupts remain disabled for four cycles. The I-bit in the StatusRegister is unaffected by the automatic disabling.\nNote: If Interrupt Vectors are placed in the Boot Loader section and Boot Lock bit BLB02 is pro-\ngrammed, interrupts are disabled while executing from the Application section. If InterruptVectors are placed in the Application section and Boot Lock bit BLB12 is programed, interrupts\nare disabled while executing from the Boot Loader section. Refer to the section \u201cBoot Loader\nSupport \u2013 Read-While-Write Self-Programming\u201d on page 202  for details on Boot Lock Bits.B i t 76543210\nINT1 INT0 \u2013 \u2013 \u2013 \u2013 IVSEL IVCE GICR\nRead/Write R/W R/W R R R R R/W R/WInitial Value 0 0 0 0 0 0 0 0\n\n50\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 0 \u2013 IVCE: Interrupt Vector Change Enable\nThe IVCE bit must be written to  logic one to enable change of the IVSEL bit. IVCE is cleared by\nhardware four cyc les after it is written or when IVSEL is written. Sett ing the IVCE bit will disable\ninterrupts, as explained in the IVSEL description above. See Code Example below.\nAssembly Code Example\nMove_interrupts:\n; Enable change of Interrupt Vectors\nldi r16, (1<<IVCE)\nout GICR, r16\n; Move interrupts to boot Flash section\nldi r16, (1<<IVSEL)\nout GICR, r16\nret\nC Code Example\nvoid Move_interrupts( void)\n{\n/* Enable change of Interrupt Vectors */\nGICR = (1<<IVCE);\n/* Move interrupts to boot Flash section */GICR = (1<<IVSEL);\n}\n\n51\n2486Z\u2013AVR\u201302/11ATmega8(L)\nI/O Ports\nIntroduction All AVR ports have true Read-Modi fy-Write functionality when used as general digital I/O ports.\nThis means that the direction of one port pin can be changed without unintentionally changing\nthe direction of any other pin with the SBI and CBI instructions. The same applies when chang-ing drive value (if configured as output) or enabling/disabling of pull-up resistors (if configured asinput). Each output buffer has symmetrical drive characteristics with both high sink and sourcecapability. The pin driver is stro ng enough to drive LED displays directly. All port pins have indi-\nvidually selectable pull-up resistors with a suppl y-voltage invariant resistance. All I/O pins have\nprotection diodes to both V\nCC and Ground as indicated in Figure 21 . Refer to \u201cElectrical Charac-\nteristics\u201d on page 235  for a complete list of parameters.\nFigure 21.  I/O Pin Equivalent Schematic\nAll registers and bit references in this section are written in general form. A lower case \u201cx\u201d repre-\nsents the numbering letter for the port, and a lower case \u201cn\u201d represents the bit number. However,\nwhen using the register or bit defines in a program, the precise form must be used (that is,\nPORTB3 for bit 3 in Port B, here documented generally as PORTxn). The physical I/O Registersand bit locations are listed in \u201cRegister Description for I/O Ports\u201d on page 65 .\nThree I/O memory address locations are allocated for each port, one each for the Data Register\n\u2013 PORTx, Data Direction Register \u2013 DDRx, and the Port Input Pins \u2013 PINx. The Port Input PinsI/O location is read only, while the Data Register and the Data Direction Register are read/write.In addition, the Pull-up Disable \u2013 PUD bit in SFIOR di sables the pull-up function for all pins in all\nports when set.\nUsing the I/O port as General Digital I/O is described in \u201cPorts as General Digital I/O\u201d . Most port\npins are multiplexed with alternate functions for the peripheral features on the device. How each\nalternate function interferes with the port pin is described in \u201cAlternate Port Functions\u201d on page\n56. Refer to the individual module sections for a full description of the alternate functions.\nNote that enabling the alternate function of some of the port pins does not affect the use of the\nother pins in the port as general digital I/O.CpinLogicRpu\nSee Figure\n\"General Digital I/O\" for\nDetailsPxn\n\n52\n2486Z\u2013AVR\u201302/11ATmega8(L)Ports as General \nDigital I/OThe ports are bi-directional I/O ports with optional internal pull-ups. Figure 22 on page 52  shows\na functional description of one I/O port pin, here generically called Pxn.\nFigure 22.  General Digital I/O(1)\nNote: 1. WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP ,\nand PUD are common to all ports\nConfiguring the Pin Each port pin consists of 3 Register bits : DDxn, PORTxn, and PINxn. As shown in \u201cRegister\nDescription for I/O Ports\u201d on page 65 , the DDxn bits are accessed at the DDRx I/O address, the\nPORTxn bits at the PORTx I/O address, and the PINxn bits at the PINx I/O address.\nThe DDxn bit in the DDRx Register selects the direct ion of this pin. If DDxn is written logic one,\nPxn is configured as an output pin. If DDxn is written logic zero, Pxn is configured as an input\npin.\nIf PORTxn is written logic one when the pin is c onfigured as an input pin, the pull-up resistor is\nactivated. To switch the pull-up resistor off, PORTxn has to be written logic zero or the pin has tobe configured as an output pin. The port pins are tri-stated when a reset condition becomes\nactive, even if no clocks are running.\nIf PORTxn is written logic one when the pin is conf igured as an output pin, the port pin is driven\nhigh (one). If PORTxn is written logic zero when the pin is configured as an output pin, the portpin is driven low (zero).clkRPxRRxWPxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWPx: WRITE PORTx\nRRx: READ PORTx REGISTERRPx: READ PORTx PINPUD: PULLUP DISABLE\nclk\nI/O: I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQD\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/O\n\n53\n2486Z\u2013AVR\u201302/11ATmega8(L)\nWhen switching between tri-state ({DDxn, PORTxn} = 0b00) and output high ({DDxn, PORTxn}\n= 0b11), an intermediate state with either pull-up enabled ({DDxn, PORTxn} = 0b01) or outputlow ({DDxn, PORTxn} = 0b10) must occur. Norma lly, the pull-up enabled state is fully accept-\nable, as a high-impedant enviro nment will not notice the differenc e between a strong high driver\nand a pull-up. If this is not the case, the PUD bit in the SFIOR Register can be set to disable allpull-ups in all ports.\nSwitching between input with pull-up and output low generates the same problem. The user\nmust use either the tri-state ({DDxn, PORTxn} = 0b00) or the output high state ({DDxn, PORTxn}= 0b11) as an intermediate step.\nTable 20  summarizes the control signals for the pin value.\nReading the Pin Value Independent of the setting of Data Direction bit DDxn, the port pin can be read through the\nPINxn Register Bit. As shown in Figure 22 on page 52 , the PINxn Register bit and the preceding\nlatch constitute a synchronizer. This is needed to av oid metastability if the physical pin changes\nvalue near the edge of the internal clock, but it also introduces a delay. Figure 23  shows a timing\ndiagram of the synchronization when reading an externally applied pin value. The maximum andminimum propagation delays are denoted t\npd,max  and tpd,min , respectively.\nFigure 23.  Synchronization when Reading an  Externally Applied Pin Value\nConsider the clock period starting shortly after the first falling edge of th e system clock. The latch\nis closed when the clock is low, and goes transpa rent when the clock is high, as indicated by the\nshaded region of the \u201cSYNC LATCH\u201d signal. The signal value is latched when the system clockTable 20.  Port Pin Configurations\nDDxn PORTxnPUD\n(in SFIOR) I/O Pull-up Comment\n0 0 X Input No Tri-state (Hi-Z)\n0 1 0 Input YesPxn will source current if external \npulled low.\n0 1 1 Input No Tri-state (Hi-Z)\n1 0 X Output No Output Low (Sink)\n1 1 X Output No Output High (Source)\nXXX in r17, PINx\n0x00 0xFFINSTRUCTIONS\nSYNC LATCH\nPINxn\nr17XXXSYSTEM CLK\ntpd, max\ntpd, min\n\n54\n2486Z\u2013AVR\u201302/11ATmega8(L)goes low. It is clocked into the PINxn Register  at the succeeding positive clock edge. As indi-\ncated by the two arrows tpd,max  and tpd,min , a single signal transiti on on the pin will be delayed\nbetween \u00bd and 1-\u00bd system clock period depending upon the time of assertion.\nWhen reading back a software assigned pin value, a  nop instruction must be inserted as indi-\ncated in Figure 24 . The out instruction sets the \u201cSYNC LATCH\u201d signal at the positive edge of the\nclock. In this case, the delay tpd through the synchronizer is 1 system clock period.\nFigure 24.  Synchronization when Reading a Software Assigned Pin Value\nout PORTx, r16 nop in r17, PINx0xFF\n0x00 0xFFSYSTEM CLK\nr16\nINSTRUCTIONS\nSYNC LATCH\nPINxn\nr17\ntpd\n\n55\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe following code example shows how to set port B pins 0 and 1 high, 2 and 3 low, and define\nthe port pins from 4 to 7 as input with pull-ups assigned to port pins 6 and 7. The resulting pinvalues are read back again, but as previously discussed, a nop instruction is included to be able\nto read back the value recently assigned to some of the pins.\nNote: 1. For the assembly program, two temporary re gisters are used to minimize the time from pull-\nups are set on pins 0, 1, 6, and 7, until the di rection bits are correctly  set, defining bit 2 and 3\nas low and redefining bits 0 and 1 as strong high drivers\nDigital Input Enable \nand Sleep ModesAs shown in Figure 22 on page 52 , the digital input signal can be clamped to ground at the input\nof the Schmitt-trigger. The signa l denoted SLEEP in the figure, is set by the MCU Sleep Control-\nler in Power-down mode, Power-save mode, and Standby mode to avoid high powerconsumption if some input signals are left floating, or have an analog signal level close to V\nCC/2.\nSLEEP is overridden for port pins enabled as Exte rnal Interrupt pins. If the External Interrupt\nRequest is not enabled, SLEEP is active also fo r these pins. SLEEP is also overridden by vari-\nous other alternate functions as described in \u201cAlternate Port Functions\u201d on page 56 .\nIf a logic high level (\u201cone\u201d) is present on an Asynchronous External Interrupt pin configured as\n\u201cInterrupt on Rising Edge, Falling Edge, or Any Logic Change on Pin\u201d while the external interruptis not enabled, the corresponding External Interrupt Flag will be set when resuming from the\nabove mentioned sleep modes, as the clamping in these sleep modes produces the requestedlogic change.Assembly Code Example\n(1)\n...\n; Define pull-ups and set outputs high\n; Define directions for port pins\nldir16,(1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0)\nldir17,(1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0)\noutPORTB,r16\noutDDRB,r17\n; Insert nop for synchronization\nnop\n; Read port pins\ninr16,PINB\n...\nC Code Example(1)\nunsigned char i;\n.../* Define pull-ups and set outputs high */\n/* Define directions for port pins */\nPORTB = (1<<PB7)|(1<<PB6)|(1<<PB1)|(1<<PB0);DDRB = (1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0);\n/* Insert nop for synchronization */\n_NOP();/* Read port pins */\ni = PINB;\n...\n\n56\n2486Z\u2013AVR\u201302/11ATmega8(L)Unconnected pins If some pins are unused, it is recommended to ens ure that these pins have a defined level. Even\nthough most of the digital inputs are disabled in  the deep sleep modes as described above, float-\ning inputs should be avoided to reduce current consumption in all other modes where the digitalinputs are enabled (Reset, Active mode and Idle mode).\nThe simplest method to ensure a defined level of an unused pin, is to enable the internal pull-up.\nIn this case, the pull-up will be  disabled during reset. If low po wer consumption during reset is\nimportant, it is recommended to use an external pull-up or pull-down. Connecting unused pinsdirectly to V\nCC or GND is not recommended, since this ma y cause excessive curr ents if the pin is\naccidentally configured as an output.\nAlternate Port \nFunctionsMost port pins have alternate functions in addition to being general digital I/Os. Figure 25  shows\nhow the port pin control signals from the simplified Figure 22 on page 52  can be overridden by\nalternate functions. The overriding signals may not be present in all port pins, but the figureserves as a generic description applicable to all port pins in the AVR microcontroller family.\nFigure 25.  Alternate Port Functions\n(1)\nNote: 1. WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP ,\nand PUD are common to all ports. All other signals are unique for each pinclkRPxRRxWPxRDxWDxPUD\nSYNCHRONIZER\nWDx:     WRITE DDRx\nWPx:     WRITE PORTxRRx:     READ PORTx REGISTER\nRPx:     READ PORTx PINPUD:     PULLUP DISABLE\nclkI/O:     I/O CLOCKRDx:     READ DDRxD\nLQ\nQSET\nCLR01\n0101\nDIxn\nAIOxnDIEOExnPVOVxnPVOExnDDOVxnDDOExnPUOExn\nPUOVxn\nPUOExn: Pxn PULL-UP OVERRIDE ENABLE\nPUOVxn: Pxn PULL-UP OVERRIDE VALUE\nDDOExn: Pxn DATA DIRECTION OVERRIDE ENABLE\nDDOVxn: Pxn DATA DIRECTION OVERRIDE VALUE\nPVOExn: Pxn PORT VALUE OVERRIDE ENABLE\nPVOVxn: Pxn PORT VALUE OVERRIDE VALUE\nDIxn:     DIGITAL INPUT PIN n ON PORTx\nAIOxn:     ANALOG INPUT/OUTPUT PIN n ON PORTxRESETRESETQQ D\nCLR\nQQ D\nCLR\nQQ D\nCLRPINxnPORTxnDDxn\nDATA BUS\n01DIEOVxn\nSLEEP\nDIEOExn: Pxn DIGITAL INPUT -ENABLE OVERRIDE ENABLE\nDIEOVxn: Pxn DIGITAL INPUT -ENABLE OVERRIDE VALUESLEEP: SLEEP CONTROLPxn\nI/O\n\n57\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTable 21  summarizes the function of the overriding signals. The pin and port indexes from Fig-\nure 25 on page 56  are not shown in the succeeding tables. The overriding signals are generated\ninternally in the modules having the alternate function.\nThe following subsections shortly describe the alternate functions for each port, and relate the\noverriding signals to the alternate function. Refer to the alternate function description for furtherdetails.Table 21.  Generic Description of Overriding Signals for Alternate Functions\nSignal Name Full Name Description\nPUOE Pull-up Override\nEnableIf this signal is set, the pull-up enable is controlled by \nthe PUOV signal. If this signal is cleared, the pull-up is enabled when {DDxn, PORTxn, PUD} = 0b010. \nPUOV Pull-up Override\nValueIf PUOE is set, the pull-up is enabled/disabled when \nPUOV is set/cleared, regardless of the setting of the DDxn, PORTxn, and PUD Register bits.\nDDOE Data Direction\nOverride EnableIf this signal is set, the Output Driver Enable is \ncontrolled by the DDOV signal. If this signal is cleared, the Output driver is enabled  by the DDxn Register bit. \nDDOV Data Direction\nOverride ValueIf DDOE is set, the Output Driver is enabled/disabled \nwhen DDOV is set/cleared, regardless of the setting of the DDxn Register bit.\nPVOE Port Value\nOverride EnableIf this signal is set and the Output Driver is enabled, \nthe port value is controlled by the PVOV signal. If PVOE is cleared, and the Outp ut Driver is enabled, the \nport Value is controlled by the PORTxn Register bit.\nPVOV Port Value\nOverride ValueIf PVOE is set, the port value is set to PVOV, \nregardless of the setting of the PORTxn Register bit.\nDIEOE Digital Input Enable\nOverride EnableIf this bit is set, the Digital Input Enable is controlled by \nthe DIEOV signal. If this si gnal is cleared, the Digital \nInput Enable is determined  by MCU-state (Normal \nmode, sleep modes).\nDIEOV Digital Input Enable\nOverride ValueIf DIEOE is set, the Digital Input is enabled/disabled \nwhen DIEOV is set/cleared, regardless of the MCU \nstate (Normal mode, sleep modes).\nDI Digital Input This is the Digital Input to alternate functions. In the \nfigure, the signal is connected to the output of the \nschmitt trigger but before the synchronizer. Unless the \nDigital Input is used as a clock source, the module with the alternate function will use its own synchronizer.\nAIO Analog Input/output This is the Anal og Input/output to/from alternate \nfunctions. The signal is connected directly to the pad, and can be used bi-directionally.\n\n58\n2486Z\u2013AVR\u201302/11ATmega8(L)Special Function IO \nRegister \u2013 SFIOR\n\u0081 Bit 2 \u2013 PUD: Pull-up Disable\nWhen this bit is written to one, the pull-ups in the I/O ports are disabled even if the DDxn and\nPORTxn Registers are configured to enable the pull-ups ({DDxn, PORTxn} = 0b01). See \u201cCon-\nfiguring the Pin\u201d on page 52  for more details about this feature.\nAlternate Functions of \nPort BThe Port B pins with alternate functions are shown in Table 22 .\nThe alternate pin configuration is as follows:\n\u0081 XTAL2/TOSC2 \u2013 Port B, Bit 7\nXTAL2: Chip clock Oscillator pin 2. Used as clock pin for crystal Oscillator or Low-frequency\ncrystal Oscillator. When used as a clock pi n, the pin can not be used as an I/O pin.\nTOSC2: Timer Oscillator pin 2. Used only if inte rnal calibrated RC Oscillato r is selected as chip\nclock source, and the asynchronous timer is enabl ed by the correct setting in ASSR. When the\nAS2 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter2, pin PB7 is dis-connected from the port, and becomes the invertin g output of the Oscillator amplifier. In this\nmode, a crystal Oscillator is con nected to this pin, and the pin cannot be used as an I/O pin.\nIf PB7 is used as a clock pin, DDB 7, PORTB7 and PINB7 will all read 0.\n\u0081 XTAL1/TOSC1 \u2013 Port B, Bit 6\nXTAL1: Chip clock Oscillator pin 1. Used for all chip clock sources except  internal calibrated RC\nOscillator. When used as a clock pin, the pin can not be used as an I/O pin. \nTOSC1: Timer Oscillator pin 1. Used only if inte rnal calibrated RC Oscillato r is selected as chip\nclock source, and the asynchronous timer is enabl ed by the correct setting in ASSR. When the\nAS2 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter2, pin PB6 is dis-connected from the port, and becomes the input of the inverting Oscillator amplifier. In thismode, a crystal Oscillator is con nected to this pin, and the pin can not be used as an I/O pin.\nIf PB6 is used as a clock pin, DDB 6, PORTB6 and PINB6 will all read 0.Bit 7 6 5 4 3 2 1 0\nACME PUD PSR2 PSR10 SFIOR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\nTable 22.  Port B Pins Alternate Functions\nPort Pin Alternate Functions\nPB7XTAL2 ( Chip Clock Oscillator pin 2 )\nTOSC2 ( Timer Oscillator pin 2 )\nPB6XTAL1 ( Chip Clock Oscillator pin 1 or External clock input )\nTOSC1 ( Timer Oscillator pin 1 )\nPB5 SCK (SPI Bus Master clock Input)\nPB4 MISO (SPI Bus Master  Input/Slave Output)\nPB3MOSI (SPI Bus Master Output/Slave Input)\nOC2 (Timer/Counter2 Output  Compare Match Output)\nPB2SS (SPI Bus Master Slave select)\nOC1B (Timer/Counter1 Output  Compare Match B Output)\nPB1 OC1A (Timer/Counter1 Outp ut Compare Match A Output)\nPB0 ICP1 (Timer/Counter1 Input Capture Pin)\n\n59\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 SCK \u2013 Port B, Bit 5\nSCK: Master Clock output, Slave Clock input pin for SPI channel. When the SPI is enabled as a\nSlave, this pin is configured as an input r egardless of the setting of DDB5. When the SPI is\nenabled as a Master, the data direction of this pi n is controlled by DDB5. When the pin is forced\nby the SPI to be an input, the pull-up can still be controlled by the PORTB5 bit.\n\u0081 MISO \u2013 Port B, Bit 4\nMISO: Master Data input, Slave Data output pin for SPI channel. When the SPI is enabled as a\nMaster, this pin is configured as an input r egardless of the setting of DDB4. When the SPI is\nenabled as a Slave, the data direction of this pi n is controlled by DDB4. When the pin is forced\nby the SPI to be an input, the pull-up can still be controlled by the PORTB4 bit.\n\u0081 MOSI/OC2 \u2013 Port B, Bit 3\nMOSI: SPI Master Data output, Slave Data input for SPI channel. When the SPI is enabled as a\nSlave, this pin is configured as an input r egardless of the setting of DDB3. When the SPI is\nenabled as a Master, the data direction of this pi n is controlled by DDB3. When the pin is forced\nby the SPI to be an input, the pull-up can still be controlled by the PORTB3 bit.\nOC2, Output Compare Match Output: The PB3 pin can serve as an external output for the\nTimer/Counter2 Compare Match. The PB3 pin has to be configured as an output (DDB3 set(one)) to serve this function. The OC2 pin is also the output pin for the PWM mode timerfunction.\n\u0081S S\n/OC1B \u2013 Port B, Bit 2\nSS: Slave Select input. When the SPI is enabled as a Slave, this pin is configured as an input\nregardless of the setting of DDB2. As a Slave, the SPI is activated when this pin is driven low.When the SPI is enabled as a Master, the data di rection of this pin is controlled by DDB2. When\nthe pin is forced by the SPI to be an input, th e pull-up can still be cont rolled by the PORTB2 bit.\nOC1B, Output Compare Match output: The PB2 pin can serve as an external output for the\nTimer/Counter1 Compare Match B. The PB2 pin has to be configured as an output (DDB2 set(one)) to serve this function. The OC1B pin is also the output pin for the PWM mode timer\nfunction.\n\u0081 OC1A \u2013 Port B, Bit 1\nOC1A, Output Compare Match output: The PB1 pin can serve as an external output for the\nTimer/Counter1 Compare Match A. The PB1 pin has to be configured as an output (DDB1 set(one)) to serve this function. The OC1A pin is also the output pin for the PWM mode timer\nfunction.\n\u0081 ICP1 \u2013 Port B, Bit 0\nICP1 \u2013 Input Capture Pin: The PB0 pin can act as an Input Capture Pin for Timer/Counter1.Table 23 on page 60  and Table 24 on page 60  relate the alternate functions of Port B to the\noverriding signals shown in Figure 25 on page 56 . SPI MSTR INPUT and SPI SLAVE OUTPUT\nconstitute the MISO signal, while MOSI is divided into SPI MSTR OUTPUT and SPI SLAVEINPUT.\n\n60\n2486Z\u2013AVR\u201302/11ATmega8(L)Notes: 1. INTRC means that the internal RC Oscillator is selected (by the CKSEL Fuse)\n2. EXT means that the external RC  Oscillator or an external clock is selected (by the CKSEL\nFuse)Table 23.  Overriding Signals for Alternate Functions in PB7..PB4\nSignal\nNamePB7/XTAL2/\nTOSC2(1)(2)PB6/XTAL1/TOSC1\n(1)PB5/SCK PB4/MISO\nPUOE EXT  \u0081 (INTRC  + \nAS2)INTRC  + AS2 SPE \u0081 MSTR SPE \u0081 MSTR\nPUO 0 0 PORTB5 \u0081 PUD PORTB4 \u0081 PUD\nDDOE EXT  \u0081 (INTRC  + \nAS2)INTRC  + AS2 SPE \u0081 MSTR SPE \u0081 MSTR\nDDOV 0 0 0 0\nPVOE 0 0 SPE \u0081 MSTR SPE \u0081 MSTR\nPVOV 0 0 SCK OUTPUT SPI SLAVE OUTPUT\nDIEOE EXT  \u0081 (INTRC  + \nAS2)INTRC  + AS2 0 0\nDIEOV 0 0 0 0\nDI \u2013 \u2013 SCK INPUT SPI MSTR INPUT\nAIO Oscillator Output Oscillator/Clock \nInput\u2013\u2013\nTable 24.  Overriding Signals for Alternate Functions in PB3..PB0\nSignal \nName PB3/MOSI/OC2 PB2/SS /OC1B PB1/OC1A PB0/ICP1\nPUOE SPE \u0081 MSTR SPE \u0081 MSTR 00\nPUO PORTB3 \u0081 PUD PORTB2 \u0081 PUD 00\nDDOE SPE \u0081 MSTR SPE \u0081 MSTR 00\nDDOV 0 0 0 0\nPVOE SPE \u0081 MSTR + \nOC2 ENABLEOC1B ENABLE OC1A ENABLE 0\nPVOV SPI MSTR OUTPUT + OC2 OC1B OC1A 0\nD I E O E 0 000\nD I E O V 0 000DI SPI SLAVE INPUT SPI SS\n\u2013I C P 1  I N P U T\nA I O \u2013 \u2013\u2013\u2013\n\n61\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAlternate Functions of \nPort CThe Port C pins with alternate functions are shown in Table 25 .\nThe alternate pin configuration is as follows:\n\u0081 RESET  \u2013 Port C, Bit 6\nRESET , Reset pin: When the RSTDISBL Fuse is programmed, this pin functions as a normal I/O\npin, and the part will have to re ly on Power-on Reset and Brown- out Reset as its reset sources.\nWhen the RSTDISBL Fuse is unprogrammed, the reset circuitry is connected to the pin, and thepin can not be used as an I/O pin.\nIf PC6 is used as a reset pin, DDC6, PORTC6 and PINC6 will all read 0.\n\u0081 SCL/ADC5 \u2013 Port C, Bit 5\nSCL, Two-wire Serial Interface Clock: When the TWEN bit in TWCR is set (one) to enable the\nTwo-wire Serial Interface, pin PC5 is disconnec ted from the port and bec omes the Serial Clock\nI/O pin for the Two-wire Serial Interface. In this mode, there is a spike filter on the pin to sup-press spikes shorter than 50 ns on the input signal , and the pin is driven by an open drain driver\nwith slew-rate limitation.\nPC5 can also be used as ADC input Channel 5. Note that ADC input channel 5 uses digital\npower.\n\u0081 SDA/ADC4 \u2013 Port C, Bit 4\nSDA, Two-wire Serial Interface Data: When the TWEN bit in TWCR is set (one) to enable the\nTwo-wire Serial Interface, pin PC4 is disconnected from the port and becomes the Serial DataI/O pin for the Two-wire Serial Interface. In this mode, there is a spike filter on the pin to sup-press spikes shorter than 50 ns on the input signal , and the pin is driven by an open drain driver\nwith slew-rate limitation.\nPC4 can also be used as ADC input Channel 4. Note that ADC input channel 4 uses digital\npower.\n\u0081 ADC3 \u2013 Port C, Bit 3\nPC3 can also be used as ADC input Channel 3. Note that ADC input channel 3 uses analog\npower.\n\u0081 ADC2 \u2013 Port C, Bit 2\nPC2 can also be used as ADC input Channel 2. Note that ADC input channel 2 uses analog\npower.Table 25.  Port C Pins Alternate Functions\nPort Pin Alternate Function\nPC6 RESET  (Reset pin)\nPC5ADC5 (ADC Input Channel 5)\nSCL (Two-wire Serial Bus Clock Line)\nPC4ADC4 (ADC Input Channel 4)\nSDA (Two-wire Serial Bus Data Input/Output Line)\nPC3 ADC3 (ADC Input Channel 3)\nPC2 ADC2 (ADC Input Channel 2)PC1 ADC1 (ADC Input Channel 1)\nPC0 ADC0 (ADC Input Channel 0)\n\n62\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 ADC1 \u2013 Port C, Bit 1\nPC1 can also be used as ADC input Channel 1. Note that ADC input channel 1 uses analog\npower.\n\u0081 ADC0 \u2013 Port C, Bit 0\nPC0 can also be used as ADC input Channel 0. Note that ADC input channel 0 uses analog\npower.\nTable 26  and Table 27  relate the alternate functions of Port C to the overriding signals shown in\nFigure 25 on page 56 . \nNote: 1. When enabled, the Two-wire Serial Interf ace enables slew-rate controls on the output pins\nPC4 and PC5. This is not shown in the figure. In addition, spike filters are connected between\nthe AIO outputs shown in the port figure and the digital logic of the TWI moduleTable 26.  Overriding Signals for Alternate Functions in PC6..PC4\nSignal Name PC6/RESET PC5/SCL/ADC5 PC4/SDA/ADC4\nPUOE RSTDISBL TWEN TWEN\nPUOV 1 PORTC5 \u0081 PUD PORTC4 \u0081 PUD\nDDOE RSTDISBL TWEN TWEN\nDDOV 0 SCL_OUT SDA_OUT\nPVOE 0 TWEN TWENPVOV 0 0 0\nDIEOE RSTDISBL\n00\nDIEOV 0 0 0DI \u2013 \u2013 \u2013\nAIO RESET INPUT ADC5 INPUT / SCL INPUT ADC4 INPUT / SDA INPUT\nTable 27.  Overriding Signals for Alternate Functions in PC3..PC0(1)\nSignal Name PC3/ADC3 PC 2/ADC2 PC1/ADC1 PC0/ADC0\nP U O E 0000P U O V 0000\nD D O E 0000\nD D O V 0000P V O E 0000\nP V O V 0000\nD I E O E 0000D I E O V 0000\nD I \u2013\u2013\u2013\u2013\nAIO ADC3 INPUT ADC2 INPUT ADC1 INPUT ADC0 INPUT\n\n63\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAlternate Functions of \nPort DThe Port D pins with alternate functions are shown in Table 28 .\nThe alternate pin configuration is as follows:\n\u0081 AIN1 \u2013 Port D, Bit 7\nAIN1, Analog Comparator Negative Input. Configure the port pin as input with the internal pull-up\nswitched off to avoid the digital port function fr om interfering with the function of the Analog\nComparator.\n\u0081 AIN0 \u2013 Port D, Bit 6\nAIN0, Analog Comparator Positive Input. Configure the port pin as input with the internal pull-up\nswitched off to avoid the digital port function fr om interfering with the function of the Analog\nComparator.\n\u0081 T1 \u2013 Port D, Bit 5\nT1, Timer/Counter1 counter source.\n\u0081 XCK/T0 \u2013 Port D, Bit 4\nXCK, USART external clock.\nT0, Timer/Counter0 counter source.\n\u0081 INT1 \u2013 Port D, Bit 3\nINT1, External Interrupt source 1: The PD3 pin can serve as an external interrupt source.\n\u0081 INT0 \u2013 Port D, Bit 2\nINT0, External Interrupt source 0: The PD2 pin can serve as an external interrupt source.\n\u0081T X D  \u2013  P o r t  D ,  B i t  1\nTXD, Transmit Data (Data output pin for the US ART). When the USART Transmitter is enabled,\nthis pin is configured as an out put regardless of the value of DDD1.\n\u0081 RXD \u2013 Port D, Bit 0\nRXD, Receive Data (Data input pin for the USART). When the USART Receiver is enabled this\npin is configured as an input regardless of the value of DDD0. When the USART forces this pin\nto be an input, the pull-up can still be controlled by the PORTD0 bit.\nTable 29 on page 64  and Table 30 on page 64  relate the alternate functions of Port D to the\noverriding signals shown in Figure 25 on page 56 . Table 28.  Port D Pins Alternate Functions\nPort Pin Alternate Function\nPD7 AIN1 (Analog Comparator Negative Input)\nPD6 AIN0 (Analog Comparator Positive Input)\nPD5 T1 (Timer/Counter 1 External Counter Input)\nPD4XCK (USART External Clock Input/Output)\nT0 (Timer/Counter 0 External Counter Input)\nPD3 INT1 (External Interrupt 1 Input)\nPD2 INT0 (External Interrupt 0 Input)PD1 TXD (USART Output Pin)\nPD0 RXD (USART Input Pin)\n\n64\n2486Z\u2013AVR\u201302/11ATmega8(L)Table 29.  Overriding Signals for Alternate Functions PD7..PD4\nSignal Name PD7/AIN1 PD 6/AIN0 PD5/T1 PD4/XCK/T0\nP U O E 000 0\nP U O 000 0\nO O E 000 0\nO O 000 0\nPVOE 0 0 0 UMSELPVO 0 0 0 XCK OUTPUT\nD I E O E 000 0\nD I E O 000 0DI \u2013 \u2013 T1 INPUT XCK INPUT / T0 INPUT\nAIO AIN1 INPUT AIN0 INPUT \u2013 \u2013\nTable 30.  Overriding Signals for Alternate Functions in PD3..PD0\nSignal Name PD 3/INT1 PD2/INT0 PD1/TXD PD0/RXD\nPUOE 0 0 TXEN RXENPUO 0 0 0 PORTD0 \u0081 PUD\nOOE 0 0 TXEN RXENO O 001 0PVOE 0 0 TXEN 0\nPVO 0 0 TXD 0\nDIEOE INT1 ENABLE INT0 ENABLE 0 0D I E O 110 0\nDI INT1 INPUT INT0 INPUT \u2013 RXD\nA I O \u2013\u2013\u2013 \u2013\n\n65\n2486Z\u2013AVR\u201302/11ATmega8(L)\nRegister Description for I/O Ports\nThe Port B Data \nRegister \u2013 PORTB\nThe Port B Data \nDirection Register \u2013 DDRB\nThe Port B Input Pins \nAddress \u2013 PINB\nThe Port C Data \nRegister \u2013 PORTC\nThe Port C Data \nDirection Register \u2013 DDRC\nThe Port C Input Pins \nAddress \u2013 PINC\nThe Port D Data \nRegister \u2013 PORTD\nThe Port D Data \nDirection Register \u2013 DDRD\nThe Port D Input Pins \nAddress \u2013 PINDB i t 76543210\nPORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 PORTB\nR e a d / W r i t e R / WR / WR / WR / WR / WR / WR / WR / W\nI n i t i a l  V a l u e 00000000\nB i t 76543210\nDDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 DDRB\nR e a d / W r i t e R / WR / WR / WR / WR / WR / WR / WR / WI n i t i a l  V a l u e 00000000\nB i t 76543210\nPINB7 PINB6 PINB5 PINB4 PI NB3 PINB2 PINB1 PINB0 PINB\nR e a d / W r i t e RRRRRRRRInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210\n\u2013 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 PORTC\nR e a d / W r i t e R R / WR / WR / WR / WR / WR / WR / WI n i t i a l  V a l u e 00000000\nB i t 76543210\n\u2013 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 DDRC\nR e a d / W r i t e R R / WR / WR / WR / WR / WR / WR / WI n i t i a l  V a l u e 00000000\nB i t 76543210\n\u2013 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 PINC\nR e a d / W r i t e RRRRRRRRInitial Value 0 N/A N/A N/A N/A N/A N/A N/A\nB i t 76543210\nPORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 PORTD\nR e a d / W r i t e R / WR / WR / WR / WR / WR / WR / WR / WI n i t i a l  V a l u e 00000000\nB i t 76543210\nDDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 DDRD\nR e a d / W r i t e R / WR / WR / WR / WR / WR / WR / WR / WI n i t i a l  V a l u e 00000000\nB i t 76543210\nPIND7 PIND6 PIND5 PIND4 PI ND3 PIND2 PIND1 PIND0 PIND\nR e a d / W r i t e RRRRRRRRInitial Value N/A N/A N/A N/A N/A N/A N/A N/A\n\n66\n2486Z\u2013AVR\u201302/11ATmega8(L)External \nInterruptsThe external interrupts are triggered by the INT0 , and INT1 pins. Observe that, if enabled, the\ninterrupts will trigger even if the INT0..1 pins are configured as ou tputs. This feature provides a\nway of generating a softwa re interrupt. The external  interrupts can be trigge red by a falling or ris-\ning edge or a low level. This is set up as in dicated in the specificat ion for the MCU Control\nRegister \u2013 MCUCR. When the external interrupt is enabled and is configured as level triggered,the interrupt will trigger as long as the pin is held  low. Note that recognition of falling or rising\nedge interrupts on INT0 and INT1 requires the presence of an I/O clock, described in \u201cClock\nSystems and their Distribution\u201d on page 25 . Low level interrupts on INT0/INT1 are detected\nasynchronously. This implies that these interrupts can be used for waking the part also fromsleep modes other than Idle mode. The I/O clock is halted in all sleep modes except Idle mode.\nNote that if a level triggered interrupt is used for wake-up from Power-down mode, the changed\nlevel must be held for some time to wake up  the MCU. This makes the MCU less sensitive to\nnoise. The changed level is sampled twice by the Watchdog Oscillator clock. The period of theWatchdog Oscillator is 1 \u00b5s (nominal) at 5.0V and 25 \u00b0C. The frequency of the Watchdog Oscilla-\ntor is voltage dependent as shown in \u201cElectrical Characteristics\u201d on page 235 . The MCU will\nwake up if the input has the required level during this sampling or if it is held until the end of thestart-up time. The start-up time is defined by the SUT Fuses as described in \u201cSystem Clock and\nClock Options\u201d on page 25 . If the level is sampled twice by the Watchdog Oscillator clock but\ndisappears before the end of th e start-up time, the MCU will stil l wake up, but no interrupt will be\ngenerated. The required level must be held long enough for the MCU to complete the wake up to\ntrigger the level interrupt.\nMCU Control Register \n\u2013 MCUCRThe MCU Control Register contains control bi ts for interrupt sense control and general MCU\nfunctions.\n\u0081 Bit 3, 2 \u2013 ISC11, ISC10: Interrupt Sense Control 1 Bit 1 and Bit 0\nThe External Interrupt 1 is activated by the exte rnal pin INT1 if the SREG I-bit and the corre-\nsponding interrupt mask in the GICR are set. The level and edges on the external INT1 pin thatactivate the interrupt are defined in Table 31 . The value on the INT1 pin is sampled before\ndetecting edges. If edge or toggle interrupt is selected, pulses that last longer than one clockperiod will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. Iflow level interrupt is selected, the low level must be held until the completion of the currentlyexecuting instruction to generate an interrupt.B i t 76543210\nSE SM2 SM1 SM0 ISC11 ISC10 ISC01 ISC00 MCUCR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nTable 31.  Interrupt 1 Sense Control\nISC11 ISC10 Description\n0 0 The low level of INT1 generates an interrupt request\n0 1 Any logical change on INT1 generates an interrupt request1 0 The falling edge of INT1 generates an interrupt request\n1 1 The rising edge of INT1 generates an interrupt request\n\n67\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 1, 0 \u2013 ISC01, ISC00: Interrupt Sense Control 0 Bit 1 and Bit 0\nThe External Interrupt 0 is activated by the exte rnal pin INT0 if the SREG I-flag and the corre-\nsponding interrupt mask are set. The level and edges  on the external INT0 pin that activate the\ninterrupt are defined in Table 32 . The value on the INT0 pin is sampled before detecting edges.\nIf edge or toggle interrupt is selected, pulses that last longer than one clock period will generatean interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt isselected, the low level must be held until the completion of the currently executing instruction to\ngenerate an interrupt.\nGeneral Interrupt \nControl Register \u2013 GICR\n\u0081 Bit 7 \u2013 INT1: External Interrupt Request 1 Enable\nWhen the INT1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the exter-\nnal pin interrupt is enabled. The Interrupt Sense Control1 bits 1/0 (ISC11 and ISC10) in the MCUgeneral Control Register (MCUCR) define whether the external interrupt is activated on risingand/or falling edge of the INT1 pin or level sens ed. Activity on the pin will cause an interrupt\nrequest even if INT1 is configured as an output. The corresponding interrupt of External InterruptRequest 1 is executed from the INT1 Interrupt Vector.\n\u0081 Bit 6 \u2013 INT0: External Interrupt Request 0 Enable\nWhen the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the exter-\nnal pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCUgeneral Control Register (MCUCR) define whether the external interrupt is activated on risingand/or falling edge of the INT0 pin or level sens ed. Activity on the pin will cause an interrupt\nrequest even if INT0 is configured as an output. The corresponding interrupt of External InterruptRequest 0 is executed from the INT0 Interrupt Vector.\nGeneral Interrupt Flag \nRegister \u2013 GIFR\n\u0081 Bit 7 \u2013 INTF1: External Interrupt Flag 1\nWhen an event on the INT1 pin triggers an interrupt request, INTF1 becomes set (one). If the I-\nbit in SREG and the INT1 bit in GICR are set (one), the MCU will jump  to the corresponding\nInterrupt Vector. The flag is cleared when the inte rrupt routine is executed. Alternatively, the flag\ncan be cleared by writing a logical one to it. Th is flag is always cleared when INT1 is configured\nas a level interrupt.Table 32.  Interrupt 0 Sense Control\nISC01 ISC00 Description\n0 0 The low level of INT0 generates an interrupt request0 1 Any logical change on INT0 generates an interrupt request\n1 0 The falling edge of INT0 generates an interrupt request\n1 1 The rising edge of INT0 generates an interrupt request\nB i t 76543210\nINT1 INT0 \u2013 \u2013 \u2013 \u2013 IVSEL IVCE GICR\nRead/Write R/W R/W R R R R R/W R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210\nINTF1 INTF0 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013G I F R\nR e a d / W r i t e R / W R / W RRRRRRInitial Value 0 0 0 0 0 0 0 0\n\n68\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 6 \u2013 INTF0: External Interrupt Flag 0\nWhen an event on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-\nbit in SREG and the INT0 bit in GICR are set (one), the MCU will jump  to the corresponding\nInterrupt Vector. The flag is cleared when the inte rrupt routine is executed. Alternatively, the flag\ncan be cleared by writing a logical one to it. Th is flag is always cleared when INT0 is configured\nas a level interrupt.\n\n69\n2486Z\u2013AVR\u201302/11ATmega8(L)\n8-bit \nTimer/Counter0Timer/Counter0 is a general purpose, single channel, 8-bit Timer/Counter module. The main\nfeatures are:\n\u0081Single Channel Counter\n\u0081Frequency Generator\n\u0081External Event Counter\n\u008110-bit Clock Prescaler\nOverview A simplified block diagram of the 8-bit Timer/Counter is shown in Figure 26 . For the actual place-\nment of I/O pins, refer to \u201cPin Configurations\u201d on page 2 . CPU accessible I/O Registers,\nincluding I/O bits and I/O pins, are shown in bold. The device-specific I/O Register and bit loca-tions are listed in the \u201c8-bit Timer/Counter Register Description\u201d on page 71 .\nFigure 26.  8-bit Timer/Counter Block Diagram \nRegisters The Timer/Counter (TCNT0) is an 8-bit register. Inte rrupt request (abbreviated to Int. Req. in the\nfigure) signals are all visible in the Timer Interrupt Flag Register (TIFR). All interrupts are individ-ually masked with the Timer Interrupt Mask Register (TIMSK). TIFR and TIMSK are not shown inthe figure since these registers are shared by other timer units.\nThe Timer/Counter can be clocked internally or vi a the prescaler, or by an external clock source\non the T0 pin. The Clock Select logic block controls which clock source and edge theTimer/Counter uses to increment its value. The Timer/Counter is inactive when no clock sourceis selected. The output from the clock select logic is referred to as the timer clock (clk\nT0).\nDefinitions Many register and bit references in this document are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case  0. However, when using the register or bit\ndefines in a program, the precise form must be used, that is, TCNT0 for accessingTimer/Counter0 counter value and so on.\nThe definitions in Table 33  are also used extensively throughout this datasheet.Timer/CounterDATA BUS\nTCNTnControl Logic\n= 0xFFcountTOVn\n(Int.Req.)TCCRn\nClock Select\nTnEdge\nDetector\n( From Prescaler )clkTn\nTable 33.  Definitions\nBOTTOM The counter reaches the BOTTOM when it becomes 0x00\nMAX The counter reaches its MAXimum when it becomes 0xFF (decimal 255)\n\n70\n2486Z\u2013AVR\u201302/11ATmega8(L)Timer/Counter \nClock SourcesThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the clock select logic which is co ntrolled by the clock select (CS02:0) bits located\nin the Timer/Counter Control Regi ster (TCCR0). For details on clock sources and prescaler, see\n\u201cTimer/Counter0 and Timer/Counter1 Prescalers\u201d on page 73 .\nCounter Unit The main part of the 8-bit Timer/Counter is the programmable counter unit. Figure 27  shows a\nblock diagram of the counter and its surroundings.\nFigure 27.  Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment TCNT0 by 1\nclkTn Timer/Counter clock, referred to as clkT0 in the following\nmax Signalize that TCNT0 has reached maximum value\nThe counter is incremented at each timer clock (clkT0). clkT0 can be generated from an external\nor internal clock source, selected by the clock select bits (CS02:0). When no clock source isselected (CS02:0 = 0) the timer is stopped. However, the TCNT0 value can be accessed by theCPU, regardless of whether clk\nT0 is present or not. A CPU write overrides (has priority over) all\ncounter clear or count operations.\nOperation The counting direction is always up (incrementing), and no counter clear is performed. Thecounter simply overruns when it passes its maximum 8-bit value (MAX = 0xFF) and then restarts\nfrom the bottom (0x00). In normal operation the Timer/Counter Overflow Flag (TOV0) will be setin the same timer clock cycle as the TCNT0 beco mes zero. The TOV0 Flag in this case behaves\nlike a ninth bit, except that it is only set, not cleared. However, combined with the timer overflowinterrupt that automatically clears the TOV0 Flag, the timer resolution can be increased by soft-ware. A new counter value can be written anytime.\nTimer/Counter \nTiming DiagramsThe Timer/Counter is a synchronous design and the timer clock (clkT0) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when InterruptFlags are set. Figure 28 on page 71  contains timing data for basic Timer/Counter operation. The\nfigure shows the count sequence close to the MAX value.DATA BUS\nTCNTn Control LogiccountTOVn\n(Int. Req.)\nClock Select\nmaxTnEdge\nDetector\n( From Prescaler )clkTn\n\n71\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 28.  Timer/Counter Timing Diagram, No Prescaling\nFigure 29  shows the same timing data, but with the prescaler enabled.\nFigure 29.  Timer/Counter Timing Diagram, with Prescaler (fclk_I/O /8)\n8-bit \nTimer/Counter \nRegister Description\nTimer/Counter Control \nRegister \u2013 TCCR0\n\u0081 Bit 2:0 \u2013 CS02:0: Clock Select\nThe three clock select bits select the clock source to be used by the Timer/Counter.clkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\nTOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nB i t 76543210\n\u2013 \u2013 \u2013 \u2013 \u2013 CS02 CS01 CS00 TCCR0\nRead/Write R R R R R R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n72\n2486Z\u2013AVR\u201302/11ATmega8(L)If external pin modes are used for the Timer/Counter0, transitions on the T0 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of thecounting.\nTimer/Counter \nRegister \u2013 TCNT0\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter.\nTimer/Counter \nInterrupt Mask Register \u2013 TIMSK\n\u0081 Bit 0 \u2013 TOIE0: Timer/Counter0 Overflow Interrupt Enable\nWhen the TOIE0 bit is written to one, and the I-bit in the Status Register is set (one), the\nTimer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter0 occurs, that is, when the TOV0 bit is set in the Timer/Counter Inter-rupt Flag Register \u2013 TIFR.\nTimer/Counter \nInterrupt Flag Register \u2013 TIFR\n\u0081 Bit 0 \u2013 TOV0: Timer/Counter0 Overflow Flag\nThe bit TOV0 is set (one) when an overflow occu rs in Timer/Counter0. TOV0 is cleared by hard-\nware when executing the corresponding interrupt  Handling Vector. Alternatively, TOV0 is\ncleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 OverflowInterrupt Enable), and TOV0 are set (one), the Timer/Counter0 Overflow interrupt is executed.Table 34.  Clock Select Bit Description \nCS02 CS01 CS00 Description\n0 0 0 No clock source (Timer/Counter stopped)001 c l k\nI/O/(No prescaling)\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on T0 pin. Clock on falling edge\n1 1 1 External clock source on T0 pin. Clock on rising edge\nB i t 76543210\nTCNT0[7:0] TCNT0\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 \u2013 TOIE0 TIMSK\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCF2 TOV2 ICF1 OCF1A OCF1B TOV1 \u2013 TOV0 TIFR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n73\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTimer/Counter0 \nand \nTimer/Counter1 PrescalersTimer/Counter1 and Timer/Counter0 share the same prescaler module, but the Timer/Counters\ncan have different prescaler settings. The description below applies to both Timer/Counter1 andTimer/Counter0.\nInternal Clock Source The Timer/Counter can be clocked directly by the system clock (by setting the CSn2:0 = 1). This\nprovides the fastest operation, with a maximum Timer/Counter clock frequency equal to system\nclock frequency (f\nCLK_I/O ). Alternatively, one of four taps from the prescaler can be used as a\nclock source. The prescaled clock has a frequency of either fCLK_I/O /8, fCLK_I/O /64, fCLK_I/O /256, or\nfCLK_I/O /1024.\nPrescaler Reset The prescaler is free running (that is, operates independently of the clock select logic of the\nTimer/Counter) and it is shared by Timer/Counter1 and Timer/Counter0. Since the prescaler isnot affected by the Timer/Counter\u2019 s clock select, the state of t he prescaler will have implications\nfor situations where a prescaled clock is used. One example of prescaling artifacts occurs when\nthe timer is enabled and clocked by the presca ler (6 > CSn2:0 > 1). The nu mber of system clock\ncycles from when the timer is enabled to the first count occurs can be from 1 to N+1 systemclock cycles, where N equals the prescaler divisor (8, 64, 256, or 1024).\nIt is possible to use the prescaler reset for synchronizing the Timer/Counter to program execu-\ntion. However, care must be taken if the other Timer/Counter that shares the same prescaleralso uses prescaling. A prescaler reset will affect the prescaler period for all Timer/Coun ters it is\nconnected to.\nExternal Clock Source An external clock source applied to the T1/T0 pin can be used as Timer/Counter clock\n(clk\nT1/clkT0). The T1/T0 pin is sampled once every system clock cycle by the pin synchronization\nlogic. The synchronized (sampled) signal is then passed through the edge detector. Figure 30\nshows a functional equivalent block diagram of  the T1/T0 synchronization and edge detector\nlogic. The registers are clocked at the po sitive edge of the internal system clock ( clkI/O). The latch\nis transparent in the high period of the internal system clock.\nThe edge detector generates one clkT1/clkT0 pulse for each positive (CSn2:0 = 7) or negative\n(CSn2:0 = 6) edge it detects.\nFigure 30.  T1/T0 Pin Sampling\nThe synchronization and e dge detector logic introduces a de lay of 2.5 to 3.5 system clock cycles\nfrom an edge has been applied to the T1/T0 pin to the counter is updated.\nEnabling and disabling of the clock input must be done when T1/T0 has been stable for at least\none system clock cycle, otherwise it is a risk t hat a false Timer/Counter clock pulse is generated.\nEach half period of the external clock applie d must be longer than one system clock cycle to\nensure correct sampling. The external clock must be guaranteed to have less than half the sys-tem clock frequency (f\nExtClk < fclk_I/O /2) given a 50/50% duty cycle. Since the edge detector usesTn_sync\n(To ClockSelect Logic)\nEdge Detector SynchronizationDQ DQ\nLEDQ Tn\nclkI/O\n\n74\n2486Z\u2013AVR\u201302/11ATmega8(L)sampling, the maximum frequency of an external clock it can detect is half the sampling fre-\nquency (Nyquist sampling theorem). However, due to variation of the system clock frequencyand duty cycle caused by Oscillator source (crystal, resonator, and capacitors) tolerances, it isrecommended that maximum frequency of an external clock source is less than f\nclk_I/O /2.5.\nAn external clock source  can not be prescaled.\nFigure 31.  Prescaler for Timer/Counter0 and Timer/Counter1(1)\nNote: 1. The synchronization logic on the input pins ( T1/T0) is shown in Figure 30 on page 73\nSpecial Function IO \nRegister \u2013 SFIOR\n\u0081 Bit 0 \u2013 PSR10: Prescaler Reset Timer/Counter1 and Timer/Counter0\nWhen this bit is written to one, the Timer/Counter1 and Timer/Counter0 prescaler will be reset.\nThe bit will be cleared by ha rdware after the operation  is performed. Writing a zero to this bit will\nhave no effect. Note that Timer/Counter1 and Timer/Counter0 share the same prescaler and areset of this prescaler will a ffect both timers. This bit will always be read as zero.PSR10Clear\nclkT1clkT0T1T0clkI/O\nSynchronizationSynchronization\nBit 7 6 5 4 3 2 1 0\n\u2013 \u2013 \u2013 \u2013 ACME PUD PSR2 PSR10 SFIOR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n\n75\n2486Z\u2013AVR\u201302/11ATmega8(L)\n16-bit \nTimer/Counter1The 16-bit Timer/Counter unit allows accurate program execution timing (event management),\nwave generation, and signal timing measurement. The main features are:\n\u0081True 16-bit Design (that is, allows 16-bit PWM)\n\u0081Two Independent Output Compare Units\n\u0081Double Buffered Out put Compare Registers\n\u0081One Input Capture Unit\n\u0081Input Capture Noise Canceler\n\u0081Clear Timer on Compar e Match (Auto Reload)\n\u0081Glitch-free, Phase Correct Pu lse Width Modulator (PWM)\n\u0081Variable PWM Period\n\u0081Frequency Generator\n\u0081External Event Counter\n\u0081Four Independent Interrupt Sources (TOV1, OCF1A, OCF1B, and ICF1)\nOverview Most register and bit references in this sect ion are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, and a lower case \u201cx\u201d replaces the Output Compare unitchannel. However, when using the register or bit defines in a program, the precise form must beused, that is, TCNT1 for accessing Timer/Counter1 counter value and so on.\nA simplified block diagram of the 16-bit Timer/Counter is shown in Figure 32 on page 76 . For the\nactual placement of I/O pins, refer to \u201cPin Configurations\u201d on page 2 . CPU accessible I/O Regis-\nters, including I/O bits and I/O pins, are shown in bold. The device-specific I/O Register and bit\nlocations are listed in the \u201c16-bit Timer/Counter Register Description\u201d on page 96 .\n\n76\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 32.  16-bit Timer/Counter Block Diagram(1)\nNote: 1. Refer to \u201cPin Configurations\u201d on page 2 , Table 22 on page 58 , and Table 28 on page 63  for\nTimer/Counter1 pin placement and description\nRegisters The Timer/Counter  (TCNT1), Output Compare Registers  (OCR1A/B), and Input Capture Regis-\nter (ICR1) are all 16-bit registers. Special procedures must be followed when accessing the 16-\nbit registers. These procedures are described in the section \u201cAccessing 16-bit Registers\u201d on\npage 77 . The Timer/Counter Control Registers  (TCCR1A/B) are 8-bit registers and have no CPU\naccess restrictions. Interrupt requests (abbreviated to Int.Req. in the figure) signals are all visiblein the Timer Interrupt Flag Register  (TIFR). All interrupts are in dividually masked with the Timer\nInterrupt Mask Register  (TIMSK). TIFR and TIMSK are not shown in the figure since these regis-\nters are shared by other timer units.\nThe Timer/Counter can be clocked internally, via the prescaler, or by an external clock source on\nthe T1 pin. The Clock Select logic block controls which clock source and edge the Timer/Counter\nuses to increment (or decrement) its value. The Timer/Counter is inactive when no clock source\nis selected. The output from the clock select logic is referred to as the timer clock (clk\nT1).\nThe double buffered Output Compare Registers (OCR1A/B) are compared with the Timer/Coun-\nter value at all time. The result of the compare can be used by the waveform generator togenerate a PWM or variable frequency output on the Output Compare Pin (OC1A/B). See \u201cOut-\nput Compare Units\u201d on page 83.  The Compare Match event will also set the Compare Match\nFlag (OCF1A/B) which can be used to generate an Output Compare interrupt request.Clock Select\nTimer/Counter\nDATA BUSOCRnA\nOCRnB\nICRn=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB\nNoise\nCanceler\nICPn=\nFixed\nTOP\nValues\nEdge\nDetectorControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int. Req.)\nOCFnA(Int. Req.)\nOCFnB(Int.Req.)\nICFn (Int.Req.)\nTCCRnA TCCRnB( From Analog\nComparator Ouput )TnEdge\nDetector\n( From Prescaler )clkTn\n\n77\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe Input Capture Register can capture the Timer/ Counter value at a given external (edge trig-\ngered) event on either the Input Capture Pin (ICP 1) or on the Analog Comparator pins (see\n\u201cAnalog Comparator\u201d on page 186 ). The Input Capture unit includes a digital filtering unit (Noise\nCanceler) for reducing the chance of capturing noise spikes.\nThe TOP value, or maximum Timer/Counter value, can in some modes of operation be defined\nby either the OCR1A Register, the ICR1 Regist er, or by a set of fixed values. When using\nOCR1A as TOP value in a PWM mode, the OCR1A Register can not be used for generating aPWM output. However, the TOP value will in this case be do uble buffered allowing the TOP\nvalue to be changed in run time. If a fixed TOP value is required, the ICR1 Register can be usedas an alternative, freeing the OCR1A to be used as PWM output.\nDefinitions The following definitions are used extensively throughout the document:\nCompatibility The 16-bit Timer/Counter has been updated and impr oved from previous versions of the 16-bit\nAVR Timer/Counter. This 16-bit Timer/Counter is fully compatible with the earlier versionregarding:\n\u0081 All 16-bit Timer/Counter related I/O Register address locations, including Timer Interrupt \nRegisters\n\u0081 Bit locations inside all 16-bit  Timer/Counter Registers, including Timer Interrupt Registers\n\u0081 Interrupt Vectors\nThe following control bits have changed name, but have same functionality and register location:\n\u0081 PWM10 is changed to WGM10\u0081 PWM11 is changed to WGM11\u0081 CTC1 is changed to WGM12\nThe following bits are added to the 16-bit Timer/Counter Control Registers:\n\u0081 FOC1A and FOC1B are added to TCCR1A\u0081 WGM13 is added to TCCR1B\nThe 16-bit Timer/Counter has improvements that will affect the compatibility in some special\ncases.\nAccessing 16-bit \nRegistersThe TCNT1, OCR1A/B, and ICR1 are 16-bit registers that can be accessed by the AVR CPU via\nthe 8-bit data bus. The 16-bit register must be byte accessed using two read or write operations.The 16-bit timer has a single 8-bit register for temporary storing of the High byte of the 16-bitaccess. The same temporary register is shared between all 16-bit registers within the 16-bittimer. Accessing the Low byte triggers the 16-bit read or write operation. When the Low byte of a16-bit register is written by the CPU, the High byte stored in the temporary register, and the Lowbyte written are both copied into the 16-bit register in the same clock cycle. When the Low byteTable 35.  Definitions\nBOTTOM The counter reaches the BOTTOM  when it becomes 0x0000.\nMAX The counter reaches its MAX imum when it becomes 0xFFFF (decimal\n65535).\nTOP The counter reaches the TOP  when it becomes equal to the highest\nvalue in the count sequence. The TOP value can be assigned to be oneof the fixed values: 0x00FF, 0x01FF, or 0x03FF, or to the value stored inthe OCR1A or ICR1 Register. The assignment is dependent of the modeof operation.\n\n78\n2486Z\u2013AVR\u201302/11ATmega8(L)of a 16-bit register is read by the CPU, the High byte of the 16-bit register is copied into the tem-\nporary register in the same clock cycle as the Low byte is read.\nNot all 16-bit accesses uses the temporary register for the High byte. Reading the OCR1A/B 16-\nbit registers does not involve using the temporary register.\nTo do a 16-bit write, the High byte must be written before the Low byte. For a 16-bit read, the\nLow byte must be read before the High byte.\nThe following code examples show  how to access the 16-bit Timer Registers assuming that no\ninterrupts updates the temporary register. The same principle can be used directly for accessingthe OCR1A/B and ICR1 Registers. Note that when using \u201cC\u201d, the compiler handles the 16-bitaccess.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe assembly code example returns the TCNT1 value in the r17:r16 Register pair.\nIt is important to notice that accessing 16-bit registers are atomic operations. If an interrupt\noccurs between the two instructions accessing the 16-bit register, and the interrupt codeupdates the temporary register by accessing the same or any other of the 16-bit Timer Regis-ters, then the result of the a ccess outside the interrupt will be corrupted. Theref ore, when both\nthe main code and the interrupt code update the temporary register, the main code must disablethe interrupts during the 16-bit access.\nThe following code examples show how to do an atomic read of the TCNT1 Register contents.\nReading any of the OCR1A/B or ICR1 Registers can be done by using the same principle.Assembly Code Example\n(1)\n...\n; Set TCNT1 to 0x01FF\nldir17,0x01\nldir16,0xFF\noutTCNT1H,r17\noutTCNT1L,r16\n; Read TCNT1 into r17:r16inr16,TCNT1L\ninr17,TCNT1H\n...\nC Code Example(1)\nunsigned int  i;\n...\n/* Set TCNT1 to 0x01FF */\nTCNT 1 = 0x1FF;\n/* Read TCNT1 into i */\ni = TCNT 1;\n...\n\n79\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe assembly code example returns the TCNT1 value in the r17:r16 Register pair.Assembly Code Example(1)\nTIM16_ReadTCNT1:\n; Save Global Interrupt Flag\ninr18,SREG\n; Disable interrupts\ncli\n; Read TCNT1 into r17:r16\ninr16,TCNT1L\ninr17,TCNT1H\n; Restore Global Interrupt Flag\noutSREG,r18\nret\nC Code Example(1)\nunsigned int TIM16_ReadTCNT1( void )\n{\nunsigned char  sreg;\nunsigned int  i;\n/* Save Global Interrupt Flag  */\nsreg = SREG;\n/* Disable interrupts  */\n_CLI();/* Read TCNT1 into i */\ni = TCNT 1;\n/* Restore Global Interrupt Flag  */\nSREG = sreg;\nreturn i;\n}\n\n80\n2486Z\u2013AVR\u201302/11ATmega8(L)The following code examples show how to do an atomic write of the TCNT1 Register contents.\nWriting any of the OCR1A/B or ICR1 Register s can be done by using the same principle.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe assembly code example requires that the r17:r16 Register pair contains the value to be writ-\nten to TCNT1.\nReusing the \nTemporary High Byte RegisterIf writing to more than one 16-bit register where the High byte is the same for all registers writ-\nten, then the High byte only needs to be written once. However, note that the same rule ofatomic operation described previously also applies in this case.\nTimer/Counter \nClock SourcesThe Timer/Counter can be clocked by an internal  or an external clock source. The clock source\nis selected by the clock select logic which is controlled by the clock select  (CS12:0) bits located\nin the Timer/Counter Control Register B  (TCCR1B). For details on cl ock sources an d prescaler,\nsee \u201cTimer/Counter0 and Timer/Counter1 Prescalers\u201d on page 73 .\nCounter Unit The main part of the 16-bit Timer/Counter is th e programmable 16-bit bi-directional counter unit.\nFigure 33 on page 81  shows a block diagram of the counter and its surroundings.Assembly Code Example(1)\nTIM16_WriteTCNT1:\n; Save Global Interrupt Flag\ninr18,SREG\n; Disable interrupts\ncli\n; Set TCNT1 to r17:r16\noutTCNT1H,r17\noutTCNT1L,r16\n; Restore Global Interrupt Flag\noutSREG,r18\nret\nC Code Example(1)\nvoid TIM16_WriteTCNT1( unsigned int i )\n{\nunsigned char  sreg;\nunsigned int  i;\n/* Save Global Interrupt Flag  */\nsreg = SREG;\n/* Disable interrupts  */\n_CLI();/* Set TCNT1 to i */\nTCNT 1 = i;\n/* Restore Global Interrupt Flag  */\nSREG = sreg;\n}\n\n81\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 33.  Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment or decrement TCNT1 by 1\ndirection Select between increment and decrement\nclear Clear TCNT1 (set all bits to zero)\nclkT1 Timer/Counter clock\nTOP Signalize that TCNT1 has reached maximum value\nBOTTOM Signalize that TCNT1 has re ached minimum value (zero)\nThe 16-bit counter is mapped into two 8-bit I/O memory locations: counter high  (TCNT1H) con-\ntaining the upper eight bits of the counter, and Counter Low  (TCNT1L) containing the lower eight\nbits. The TCNT1H Register can only be indirect ly accessed by the CPU. When the CPU does an\naccess to the TCNT1H I/O location, the CP U accesses the High byte temporary register\n(TEMP). The temporary register is updated with the TCNT1H value when the TCNT1L is read,and TCNT1H is updated with the temporary register value when TCNT1L is written. This allowsthe CPU to read or write the entire 16-bit counter value within one clock cycle via the 8-bit databus. It is important to notice that there are special cases of writing to the TCNT1 Register whenthe counter is counting that will give unpredictable results. The special cases are described inthe sections where they are of importance.\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock  (clk\nT1). The clkT1 can be generated from an external or internal clock source,\nselected by the clock select  bits (CS12:0). When no clock source is selected (CS12:0 = 0) the\ntimer is stopped. However, the TCNT1 value can be accessed by the CPU, independent ofwhether clk\nT1 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the Waveform Generation mode  bits\n(WGM13:0) located in the Timer/Counter Control Registers  A and B (TCCR1A and TCCR1B).\nThere are close connections between how the counter behaves (counts) and how waveformsare generated on the Output Compare Outputs OC1x. For more details about advanced count-ing sequences and waveform generation, see \u201cModes of Operation\u201d on page 87 .\nThe Timer/Counter Overflow  (TOV1) fLag is set according to the mode of operation selected by\nthe WGM13:0 bits. TOV1 can be used for generating a CPU interrupt.\nInput Capture Unit The Timer/Counter incorporates an Input Capture unit that can capture external events and givethem a time-stamp indicating time of occurrence. The external signal indicating an event, or mul-tiple events, can be applied via the ICP1 pin or alternatively, via the Analog Comparator unit.TEMP  (8-bit)DATA BUS (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nControl Logiccount\nclear\ndirectionTOVn\n(Int. Req.)\nClock Select\nTOP BOTTOMTnEdge\nDetector\n( From Prescaler )clkTn\n\n82\n2486Z\u2013AVR\u201302/11ATmega8(L)The time-stamps can then be used to calculate frequency, duty-cycle, and other features of the\nsignal applied. Alternatively the time-stamps can be used for creating a log of the events.\nThe Input Capture unit is illustrated by the block diagram shown in Figure 34 . The elements of\nthe block diagram that are not directly a part of the Input Capture unit are gray shaded. Thesmall \u201cn\u201d in register and bit names indicates the Timer/Counter number.\nFigure 34.  Input Capture Unit Block Diagram\nWhen a change of the logic level (an event) occurs on the Input Capture Pin  (ICP1), alternatively\non the Analog Comparator Output  (ACO), and this change confirms to the setting of the edge\ndetector, a capture will be triggered. When a captur e is triggered, the 16-bit value of the counter\n(TCNT1) is written to the Input Capture Register  (ICR1). The Input Capture Flag  (ICF1) is set at\nthe same system clock as the TCNT1 value is c opied into ICR1 Register. If enabled (TICIE1 =\n1), the Input Capture Flag generates an Input Capture interrupt. The ICF1 Flag is automaticallycleared when the interrupt is executed. Alternatively the ICF1 Flag can be cleared by softwareby writing a logical one to its I/O bit location.\nReading the 16-bit value in the Input Capture Register  (ICR1) is done by first reading the Low\nbyte (ICR1L) and then the High byte (ICR1H). When the Low byte is read the High byte is copiedinto the High byte temp orary register (TEMP). Wh en the CPU reads the IC R1H I/O location it will\naccess the TEMP Register.\nThe ICR1 Register can only be written when us ing a Waveform Generation mode that utilizes\nthe ICR1 Register for defining the counter\u2019s TOP value. In these cases the Waveform Genera-\ntion mode  (WGM13:0) bits must be set before the TOP value can be written to the ICR1\nRegister. When writing the ICR1 Register the Hi gh byte must be written to the ICR1H I/O loca-\ntion before the Low byte is written to ICR1L.\nFor more information on how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 77 .\nInput Capture Pin \nSourceThe main trigger source for the Input Capture unit is the Input Capture Pin  (ICP1). Timer/Counter\n1 can alternatively use the Analog Comparator Output as trigger source for the Input CaptureICFn  (Int. Req.)Analog\nComparatorWRITE ICRn (16-bit Register)ICRnH (8-bit)\nNoise\nCanceler\nICPnEdge\nDetectorTEMP  (8-bit)DATA BUS (8-bit)\nICRnL (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nACIC* ICNC ICES ACO*\n\n83\n2486Z\u2013AVR\u201302/11ATmega8(L)\nunit. The Analog Comparator is selected  as trigger source by setting the Analog Comparator\nInput Capture  (ACIC) bit in the Analog Comparator Control and Status Register  (ACSR). Be\naware that changing trigger source can trigger a capture. The Input Capture Flag must thereforebe cleared after the change.\nBoth the Input Capture Pin  (ICP1) and the Analog Comparator Output  (ACO) inputs are sampled\nusing the same technique as for the T1 pin ( Figure 30 on page 73 ). The edge detector is also\nidentical. However, when the noise canceler is enabled, additional logic is inserted before the\nedge detector, which increases t he delay by four system clock cycles. Note that the input of the\nnoise canceler and edge detector is always enabl ed unless the Timer/Counter is set in a Wave-\nform Generation mode that uses ICR1 to define TOP.\nAn Input Capture can be trigger ed by software by controlling the port of the ICP1 pin.\nNoise Canceler The noise canceler improves noise immunity by  using a simple digital filtering scheme. The\nnoise canceler input is monitored over four samples, and all four must be equal for changing theoutput that in turn is used by the edge detector.\nThe noise canceler is enabled by setting the Input Capture Noise Canceler  (ICNC1) bit in\nTimer/Counter Control Register B  (TCCR1B). When enabled the noise canceler introduces addi-\ntional four system clock cycles of delay from a change applied to the input, to the update of theICR1 Register. The noise canceler uses the sy stem clock and is therefore not affected by the\nprescaler.\nUsing the Input \nCapture UnitThe main challenge when using the Input Capture unit is to assign enough processor capacity\nfor handling the incoming events. The time between two events is critical. If the processor hasnot read the captured value in th e ICR1 Register before the nex t event occurs, the ICR1 will be\noverwritten with a new value. In this case the result of the ca pture will be incorrect.\nWhen using the Input Capture interrupt, the ICR1 Register should be read as early in the inter-\nrupt handler routine as possible. Even though the Input Capture interrupt has relatively highpriority, the maximum interrupt response time is dependent on the maximum number of clockcycles it takes to handle any of the other interrupt requests.\nUsing the Input Capture unit in any mode of  operation when the TOP value (resolution) is\nactively changed during operation, is not recommended.\nMeasurement of an external signal\u2019s duty cycle requires that the trigger edge is changed after\neach capture. Changing the edge sensing must be done as early as possible after the ICR1Register has been read. After a change of the edge, the Input Capture Flag (ICF1) must becleared by software (writing a logical one to the I/O bit location). For measuring frequency only,the clearing of the ICF1 Flag is not required (if an interrupt handler is used).\nOutput Compare \nUnitsThe 16-bit comparator continuously compares TCNT1 with the Output Compare Register\n(OCR1x). If TCNT equals OCR1x the comparator signals a match. A match will set the Output\nCompare Flag  (OCF1x) at the next timer clock cycle . If enabled (OCIE1x = 1), the Output Com-\npare Flag generates an Output Compare interrupt. The OCF1x Flag is automatically clearedwhen the interrupt is executed. Alternatively the OCF1x Flag can be cleared by software by writ-ing a logical one to its I/O bit location. The waveform generator uses the match signal togenerate an output according to operating mode set by the Waveform Generation mode\n(WGM13:0) bits and Compare Output mode  (COM1x1:0) bits. The TOP and BOTTOM signals\nare used by the waveform generator for handling the special cases of the extreme values insome modes of operation (see \u201cModes of Operation\u201d on page 87 ).\nA special feature of Output Compare unit A allows it to define the Timer/Counter TOP value (that\nis counter resolution). In addition to the counter resolution, the TOP value defines the periodtime for waveforms generated by the waveform generator.\n\n84\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 35  shows a block diagram of the Output Compare unit. The small \u201cn\u201d in the register and\nbit names indicates the device number (n = 1  for Timer/Counter 1), and the \u201cx\u201d indicates Output\nCompare unit (A/B). The elements of the block diagram that are not directly a part of the OutputCompare unit are gray shaded.\nFigure 35.  Output Compare Unit, Block Diagram\nThe OCR1x Register is double buffered when using any of the twelve Pulse Width Modulation\n(PWM) modes. For the normal and Clear Timer on Compare  (CTC) modes of operation, the dou-\nble buffering is disabled. The double buffering synchronizes the update of the OCR1x CompareRegister to either TOP or BOTTOM of the counting sequence. The synchronization prevents theoccurrence of odd-length, non-symmetrical PWM pulses, thereby making the output glitch-free.\nThe OCR1x Register access may seem complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR1x Buffer Register, and if double buffering is dis-abled the CPU will access the OCR1x directly. The content of the OCR1x (Buffer or Compare)\nRegister is only changed by a write operation (the Timer/Counter does not update this registerautomatically as the TCNT1 and ICR1 Register). Therefore OCR1x is not read via the High bytetemporary register (TEMP). However, it is a good practice to read the Low byte first as whenaccessing other 16-bit registers. Writing the OCR1x Registers must be done via the TEMP Reg-ister since the compare of all 16-bit is done continuously. The High byte (OCR1xH) has to bewritten first. When the High byte I/O location is  written by the CPU, the TEMP Register will be\nupdated by the value written. Then when the Low byte (OCR1xL) is written to the lower eightbits, the High byte will be copied in to the upper 8-bits of either the OCR1x buffer or OCR1x Com-\npare Register in the same system clock cycle.\nFor more information of how to access the 16-bit registers refer to \u201cAccessing 16-bit Registers\u201d\non page 77 .OCFnx  (Int.Req.)= (16-bit Comparator )OCRnx  Buffer (16-bit Register)OCRnxH Buf. (8-bit)\nOCnxTEMP  (8-bit)DATA BUS (8-bit)\nOCRnxL Buf. (8-bit)\nTCNTn (16-bit Counter)TCNTnH (8-bit) TCNTnL (8-bit)\nCOMnx1:0 WGMn3:0OCRnx (16-bit Register)OCRnxH (8-bit) OCRnxL (8-bit)\nWaveform GeneratorTOP\nBOTTOM\n\n85\n2486Z\u2013AVR\u201302/11ATmega8(L)\nForce Output \nCompareIn non-PWM Waveform Generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Output Compare  (FOC1x) bit. Forcing Compare Match will not set the\nOCF1x Flag or reload/clear the timer, but the OC1x pin will be updated as if a real Compare\nMatch had occurred (the COM1x1:0 bits settings de fine whether the OC1x pin is set, cleared or\ntoggled).\nCompare Match \nBlocking by TCNT1 WriteAll CPU writes to the TCNT1 Register will block an y Compare Match that occurs in the next timer\nclock cycle, even when the timer is stopped. This  feature allows OCR1x to  be initialized to the\nsame value as TCNT1 without triggering an inte rrupt when the Timer/Counter clock is enabled.\nUsing the Output \nCompare UnitSince writing TCNT1 in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNT1 when using any of the Output Comparechannels, independent of whether the Timer/Counter is running or not. If the value written to\nTCNT1 equals the OCR1x value, t he Compare Match will be missed, resulting in incorrect wave-\nform generation. Do not write the TCNT1 equal to TOP in PWM modes with variable TOPvalues. The Compare Match for the TOP w ill be ignored and the counter will continue to\n0xFFFF. Similarly, do not write the TCNT1 value equal to BOTTOM when the counter is\ndowncounting.\nThe setup of the OC1x should be performed before setting the Data Direction Register for the\nport pin to output. The easiest way of setting the OC1x value is to use the Force Output Com-pare (FOC1x) strobe bits in Normal mode. The OC1x Register keeps its value even whenchanging between Waveform Generation modes.\nBe aware that the COM1x1:0 bits are not doubl e buffered together with the compare value.\nChanging the COM1x1:0 bits will take effect immediately.\nCompare Match \nOutput UnitThe Compare Output mode  (COM1x1:0) bits have two functions. The waveform generator uses\nthe COM1x1:0 bits for defining the Output Compare (OC1x) state at the next Compare Match.Secondly the COM1x1:0 bits control the OC1x pin output source. Figure 36 on page 86  shows a\nsimplified schematic of the logic affected by the COM1x1:0 bit setting. The I/O Registers, I/Obits, and I/O pins in the figure are shown in bold.  Only the parts of the general I/O Port Control\nRegisters (DDR and PORT) that are affected by the COM1x1:0 bits are shown. When referring\nto the OC1x state, the reference is for the internal OC1x Register, not the OC1x pin. If a SystemReset occur, the OC1x Register is reset to \u201c0\u201d.\n\n86\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 36.  Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC1x) from the waveform\ngenerator if either of the COM1x1:0 bits are set. However, the OC1x pin direction (input or out-put) is still controlled by the Data Direction Register  (DDR) for the port pin. The Data Direction\nRegister bit for the OC1x pin (DDR_OC1x) must be set as output before the OC1x value is visi-\nble on the pin. The port override  function is generally independent of the Waveform Generation\nmode, but there are some exceptions. Refer to Table 36 on page 96 , Table 37 on page 96  and\nTable 38 on page 97  for details.\nThe design of the Output Compare Pin logic allows initialization of the OC1x state before the\noutput is enabled. Note that some COM1x1:0 bit settings are reserved for certain modes of oper-ation. See \u201c16-bit Timer/Counter Register Description\u201d on page 96.\nThe COM1x1:0 bits have no effect on the Input Capture unit.PORT\nDDRDQDQOCnx\nPin OCnxDQWaveform\nGeneratorCOMnx1\nCOMnx0\n01\nDATABUSFOCnx\nclkI/O\n\n87\n2486Z\u2013AVR\u201302/11ATmega8(L)\nCompare Output Mode \nand Waveform GenerationThe waveform generator uses the COM1x1:0 bits differently in normal, CTC, and PWM modes.\nFor all modes, setting the COM1x1:0 = 0 tells the waveform generator that no action on theOC1x Register is to be performed on the next Compare Match. For compare output actions in\nthe non-PWM modes refer to Table 36 on page 96 . For fast PWM mode refer to Table 37 on\npage 96 , and for phase correct and phase and frequency correct PWM refer to Table 38 on page\n97.\nA change of the COM1x1:0 bits state will have effe ct at the first Compare Match after the bits are\nwritten. For non-PWM modes, the action can be fo rced to have immediate effect by using the\nFOC1x strobe bits.\nModes of \nOperationThe mode of operation (that is, the behavior of the Timer/Counter and the Output Compare pins)\nis defined by the combination of the Waveform Generation mode  (WGM13:0) and Compare Out-\nput mode  (COM1x1:0) bits. The Compare Output mode bits do not affect the counting sequence,\nwhile the Waveform Generation mode bits do. The COM1x1:0 bits control whether the PWM out-put generated should be inverted or not (inverted or non-inverted PWM). For non-PWM modesthe COM1x1:0 bits control whether the output should be set, cleared or toggle at a Compare\nMatch. See \u201cCompare Match Output Unit\u201d on page 85.\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 94 .\nNormal Mode The simplest mode of operation is the Normal  mode (WGM13:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 16-bit value (MAX = 0xFFFF) and then restarts from theBOTTOM (0x0000). In normal operation the Timer/Counter Overflow Flag  (TOV1) will be set in\nthe same timer clock cycle as the TCNT1 become s zero. The TOV1 Flag in this case behaves\nlike a 17th bit, except that it is only set, not cleared. However, combined with the timer overflowinterrupt that automatically clears the TOV1 Flag, the timer resolution can be increased by soft-ware. There are no special cases to consider in the Normal mode, a new counter value can bewritten anytime.\nThe Input Capture unit is easy to use in Normal mode. However, observe that the maximum\ninterval between the external events must not exceed the resolution of the counter. If the intervalbetween events are too long, the timer overflow interrupt or the prescaler must be used toextend the resolution for the capture unit.\nThe Output Compare units can be used to generat e interrupts at some given time. Using the\nOutput Compare to gene rate waveforms in Norm al mode is not recommended, since this will\noccupy too much of the CPU time.\nClear Timer on \nCompare Match (CTC) ModeIn Clear Timer on Compare  or CTC mode (WGM13:0 = 4 or 12), the OCR1A or ICR1 Register\nare used to manipulate the counter resolution. In CTC mode the counter is cleared to zero when\nthe counter value (TCNT1) matches either the OCR1A (WGM13:0 = 4) or the ICR1 (WGM13:0 =12). The OCR1A or ICR1 define the top value for the counter, hence also its resolution. This\nmode allows greater control of the Compare Match output frequency. It also simplifies the oper-ation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 37 on page 88 . The counter value\n(TCNT1) increases until a Compare Match occurs with either OCR1A or ICR1, and then counter(TCNT1) is cleared.\n\n88\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 37.  CTC Mode, Timing Diagram\nAn interrupt can be generated at each time the counter value reaches the TOP value by either\nusing the OCF1A or ICF1 Flag according to the register used to define the TOP value. If theinterrupt is enabled, the interrupt handler routine can be used for updating the TOP value. How-ever, changing the TOP to a value close to BOTTOM when the counter is running with none or alow prescaler value must be done with care since the CTC mode does not have the double buff-ering feature. If the new value written to OCR1A or ICR1 is lower than the current value ofTCNT1, the counter will miss the Compare Match. The counter will then have  to count to its max-\nimum value (0xFFFF) and wrap around starting at 0x0000 before the Compare Match can occur.In many cases this feature is no t desirable. An alternative will th en be to use the fast PWM mode\nusing OCR1A for defining TOP (W GM13:0 = 15) since the OCR1A then will be doub le buffered.\nFor generating a waveform output in CTC mode, the OC1A output can be set to toggle its logical\nlevel on each Compare Match by setting the Compare Output mode bits to toggle mode(COM1A1:0 = 1). The OC1A value will not be visible on the port pin unless the data direction for\nthe pin is set to output (DDR_OC1A = 1). Th e waveform generated will have a maximum fre-\nquency of f\nOC1A = fclk_I/O /2 when OCR1A is set to zero (0x0000). The waveform frequency is\ndefined by the following equation:\nThe N variable represents the prescaler factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOV1 Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x0000.\nFast PWM Mode The fast Pulse Width Modulation or fast PWM mode (WGM13:0 = 5, 6, 7, 14, or 15) provides a\nhigh frequency PWM waveform generation option. The fast PWM differs from the other PWMoptions by its single-slope operation. The counter counts from BOTTOM to TOP then restartsfrom BOTTOM. In non-inverting Compare Output mode, the Output Compare (OC1x) is clearedon the Compare Match between TCNT1 and OCR1x, and set at BOTTOM. In inverting CompareOutput mode output is set on Compare Match and cleared at BOTTOM. Due to the single-slopeoperation, the operating frequency of the fast PWM mode can be twice as high as the phase cor-rect and phase and frequency correct PWM modes that use dual-slope operation. This high\nfrequency makes the fast PWM mode  well suited for power regula tion, rectification, and DAC\napplications. High frequency allows physically sm all sized external com ponents (coils, capaci-\ntors), hence reduces total system cost.\nThe PWM resolution for fast PWM can be fixed to 8-bit, 9-bit, or 10-bit, or defined by either ICR1\nor OCR1A. The minimum resolution allowed is 2-bit (ICR1 or OCR1A set to 0x0003), and theTCNTn\nOCnA\n(Toggle)OCnA Interrupt Flag Setor ICFn Interrupt Flag Set(Interrupt on TOP)\n1 4 Period 2 3(COMnA1:0 = 1)\nfOCnAfclk_I/O\n2N1OCRnA+() \u22c5\u22c5-------------------------------------------------- - =\n\n89\n2486Z\u2013AVR\u201302/11ATmega8(L)\nmaximum resolution is 16-bit (ICR1 or OCR1A set to MAX). The PWM resolution in bits can be\ncalculated by using the following equation:\nIn fast PWM mode the counter is incremented until the counter value matches either one of the\nfixed values 0x00FF, 0x01FF, or 0x03FF (WGM13:0 = 5, 6, or 7), the value in ICR1 (WGM13:0 =14), or the value in OCR1A (WGM13:0 = 15). The counter is then cleared at the following timerclock cycle. The timing diagram for the fast PWM mode is shown in Figure 38 . The figure shows\nfast PWM mode when OCR1A or ICR1  is used to define TOP. The TCNT1 value is in the timing\ndiagram shown as a histogram for illustrating t he single-slope operation. The diagram includes\nnon-inverted and inverted PWM outputs. The small horizontal line marks on the TCNT1 slopesrepresent compare matches between OCR1x and TCNT1. The OC1x Interrupt Flag will be setwhen a Compare Match occurs.\nFigure 38.  Fast PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV1) is set each time the counter reaches TOP. In addition\nthe OCF1A or ICF1 Flag is set at the same timer clock cycle as TOV1 is set when either OCR1Aor ICR1 is used for defining the TOP value. If one of the interrupts are enabled, the interrupt han-dler routine can be used for updating the TOP and compare values.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a Compare Match will neve r occur between the TCNT1 and the OCR1x.\nNote that when using fixed TOP values the unused bits are masked to zero when any of theOCR1x Registers are written.\nThe procedure for updating ICR1 differs from updating OCR1A when used for defining the TOP\nvalue. The ICR1 Register is not double buffered. This means that if ICR1 is changed to a lowvalue when the counter is running with none or a low prescaler value, there is a risk that the newICR1 value written is lower than the current va lue of TCNT1. The result will then be that the\ncounter will miss the Compare Match at the TOP value. The coun ter will then have to count to\nthe MAX value (0xFFFF) and wrap around starting at 0x0000 before the Compare Match canoccur. The OCR1A Register, however, is double buffered. This feature allows the OCR1A I/Olocation to be written anytime. When the OCR1A I/O location is written the value written will beput into the OCR1A Buffer Register. The OCR1A Compare Register  will then be updated with\nthe value in the Buffer Register at the next timer clock cycle the TCNT1 matches TOP. The\nupdate is done at the same timer clock cycle as the TCNT1 is cleared and the TOV1 Flag is set.RFPWMTOP 1+ ()log\n2()log---------------------------------- - =\nTCNTnOCRnx / TOP Update \nand TOVn Interrupt Flag Set and OCnA Interrupt Flag Set or ICFn Interrupt Flag Set (Interrupt on TOP)\n1 7 Period 2 3 4 56 8OCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n90\n2486Z\u2013AVR\u201302/11ATmega8(L)Using the ICR1 Register for defining TOP work s well when using fixed TOP values. By using\nICR1, the OCR1A Register is free to be used for generating a PWM output on OC1A. However,if the base PWM frequency is actively change d (by changing the TOP value), using the OCR1A\nas TOP is clearly a better choice due to its double buffer feature.\nIn fast PWM mode, the compare units allow generation of PWM waveforms on the OC1x pins.\nSetting the COM1x1:0 bits to 2 will produce a non-inverted PWM and an inverted PWM outputcan be generated by setting the COM1x1:0 to 3. See Table 37 on page 96 . The actual OC1x\nvalue will only be visible on the port pin if the data direction for the port pin is set as output\n(DDR_OC1x). The PWM waveform is generated by setting (or clearing) the OC1x Register atthe Compare Match between OCR1x and TCNT1, and clearing (or setting) the OC1x Register atthe timer clock cycle the counter is cleared (changes from TOP to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR1x Register represents special cases when generating a PWM\nwaveform output in the fast PWM mode. If the OCR1x is set equal to BOTTOM (0x0000) the out-put will be a narrow spike for eac h TOP+1 timer clock cycle. Se tting the OCR1x equal to TOP\nwill result in a const ant high or low output (depending on the polarity of the output set by the\nCOM1x1:0 bits).\nA frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by set-\nting OC1A to toggle its logical level on each Compare Match (COM1A1:0 = 1). This applies onlyif OCR1A is used to define the TOP value (WGM 13:0 = 15). The wave form generated will have\na maximum frequency of f\nOC1A = fclk_I/O /2 when OCR1A is set to zero (0x0000). This feature is\nsimilar to the OC1A toggle in CTC mode, except the double buffer feature of the Output Com-pare unit is enabled in the fast PWM mode.\nPhase Correct PWM \nModeThe phase correct Pulse Width Modulation or phase correct PWM mode (WGM13:0 = 1, 2, 3,\n10, or 11) provides a high resolution phase correct PWM waveform generation option. Thephase correct PWM mode is, like the phase and frequency correct PWM mode, based on a dual-\nslope operation. The counter counts repeatedly from BOTTOM (0x0000) to TOP and then fromTOP to BOTTOM. In non-inverting Compare Output mode, the Output Compare (OC1x) iscleared on the Compare Match between TCNT1 and OCR1x while upcounting, and set on theCompare Match while downcounting. In inverting Output Compare mode, the operation isinverted. The dual-slope operation has lower maximum operation frequency than single slope\noperation. However, due to the symmetric feat ure of the dual-slope PWM modes, these modes\nare preferred for motor control applications.\nThe PWM resolution for the phase correct PWM mode can be fixed to 8-bit, 9-bit, or 10-bit, or\ndefined by either ICR1 or OCR1A. The minimum resolution allowed is 2-bit (ICR1 or OCR1A setto 0x0003), and the maximum resolution is 16-bit (ICR1 or OCR1A set to MAX). The PWM reso-lution in bits can be calculated by using the following equation:\nIn phase correct PWM mode the counter is incremented until the counter value matches either\none of the fixed values 0x00FF, 0x01FF, or 0x03FF (WGM13:0 = 1, 2, or 3), the value in ICR1(WGM13:0 = 10), or the value in OCR1A (WGM13:0 = 11). The counter has then reached theTOP and changes the count direct ion. The TCNT1 value will be equa l to TOP for one timer clock\ncycle. The timing diagram for the phase correct PWM mode is shown on Figure 39 on page 91 .\nThe figure shows phase correct PWM mode when OC R1A or ICR1 is used to define TOP. The\nTCNT1 value is in the timing diagram shown as a histogram for illustrati ng the dual-s lope opera-fOCnxPWMfclk_I/O\nN1TOP+()\u22c5---------------------------------- - =\nRPCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n91\n2486Z\u2013AVR\u201302/11ATmega8(L)\ntion. The diagram includes non-inverted and inverted PWM outputs. The small horizontal line\nmarks on the TCNT1 slopes represent compare matches between OCR1x and TCNT1. TheOC1x Interrupt Flag will be set when a Compare Match occurs.\nFigure 39.  Phase Correct PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV1) is set each time the counter reaches BOTTOM. When\neither OCR1A or ICR1 is used for defining the TOP value, the OC1A or ICF1 Flag is set accord-ingly at the same timer clock cycle as the OCR1x Registers are updated with the double buffer\nvalue (at TOP). The Interrupt Flags can be used to  generate an interrupt each time the counter\nreaches the TOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a Compare Match will neve r occur between the TCNT1 and the OCR1x.\nNote that when using fixed TOP values, the unus ed bits are masked to zero when any of the\nOCR1x Registers are written. As the third period shown in Figure 39  illustrates, changing the\nTOP actively while the Timer/Counter is running in the Phase Correct mode can result in anunsymmetrical output. The reason for this can be found in the time of update of the OCR1x Reg-ister. Since the OCR1x update occurs at TOP, the PWM period starts and ends at TOP. Thisimplies that the length of the falling slope is determined by the previous TOP value, while thelength of the rising slope is determined by th e new TOP value. When these two values differ the\ntwo slopes of the period will differ in length. The difference in length gives the unsymmetricalresult on the output.\nIt is recommended to use the Phase and Frequency Correct mode instead of the Phase Correct\nmode when changing the TOP value while the Timer/Counter is running. When using a staticTOP value there are practically no differences between the two modes of operation.\nIn phase correct PWM mode, the compare units allow generation of PWM waveforms on the\nOC1x pins. Setting the COM1x1:0 bits to 2 will produce a non-inverted PWM and an invertedPWM output can be generated by setting the COM1x1:0 to 3. See Table 38 on page 97 . The\nactual OC1x value will only be visible on the port pi n if the data direction for the port pin is set as\noutput (DDR_OC1x). The PWM waveform is generated by setting (or clearing) the OC1x Regis-ter at the Compare Match between OCR1x and TCNT1 when the counter increments, andclearing (or setting) the OC1x Register at  Compare Match between OCR1x and TCNT1 whenOCRnx / TOP Update and\nOCnA Interrupt Flag Setor ICFn Interrupt Flag Set(Interrupt on TOP)\n1 2 3 4TOVn Interrupt Flag Set\n(Interrupt on Bottom)\nTCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\n\n92\n2486Z\u2013AVR\u201302/11ATmega8(L)the counter decrements. The PWM frequency for the output when using phase correct PWM can\nbe calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR1x Register represent special cases when generating a PWM\nwaveform output in the phase correct PWM mode. If the OCR1x is set equal to BOTTOM theoutput will be continuously low and if set equal to TOP the output will be continuously high for\nnon-inverted PWM mode. For in verted PWM the output  will have the opposite logic values.\nIf OCR1A is used to define the TOP value (WMG13:0 = 11) and COM1A1:0 = 1, the OC1A out-\nput will toggle with a 50% duty cycle.\nPhase and Frequency \nCorrect PWM ModeThe phase and frequency correct Pulse Width Modulation, or phase and frequency correct PWM\nmode (WGM13:0 = 8 or 9) provides a high reso lution phase and frequency correct PWM wave-\nform generation option. The phase and frequency correct PWM mode is, like the phase correctPWM mode, based on a dual-slope operation. The counter counts repeatedly from BOTTOM(0x0000) to TOP and then from TOP to BOTTOM. In non-inverting Compare Output mode, theOutput Compare (OC1x) is cleared on the Compare Match between TCNT1 and OCR1x whileupcounting, and set on the Compare Match while downcounting. In inverting Compare Outputmode, the operation is inverted. The dual-slope operation gives a lower maximum operation fre-quency compared to the single-slope operation. Howe ver, due to the symmetric feature of the\ndual-slope PWM modes, these modes are preferred for motor control applications.\nThe main difference between the phase correct, and the phase and frequency correct PWM\nmode is the time the OCR1x Register is updated by the OCR1x Buffer Register, (see Figure 39\non page 91  and Figure 40 on page 93 ).\nThe PWM resolution for the phase and frequency correct PWM mode can be defined by either\nICR1 or OCR1A. The minimum resolution allowed is 2-bit (ICR1 or OCR1A set to 0x0003), andthe maximum resolution is 16-bit (ICR1 or OCR1 A set to MAX). The PWM resolution in bits can\nbe calculated using the following equation:\nIn phase and frequency correct PWM mode the counter is incremented until the counter value\nmatches either the value in ICR1 (WGM13:0 = 8), or the value in OCR1A (WGM13:0 = 9). The\ncounter has then reac hed the TOP and ch anges the count di rection. The TCNT1 value will be\nequal to TOP for one timer clock cycle. The timing diagram for the phase correct and frequencycorrect PWM mode is shown on Figure 40 on page 93 . The figure shows phase and frequency\ncorrect PWM mode when OCR1A or ICR1 is used to define TOP. The TCNT1 value is in thetiming diagram shown as a histogram for illustrating the dual-slope operation. The diagramincludes non-inverted and inverted PWM outputs. The small horizontal line marks on the TCNT1slopes represent compare matches between OCR1x and TCNT1. The OC1x Interrupt Flag willbe set when a Compare Match occurs.fOCnxPCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\nRPFCPWMTOP 1+ ()log\n2()log---------------------------------- - =\n\n93\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 40.  Phase and Frequency Correct PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV1) is set at the same timer clock cycle as the OCR1x\nRegisters are updated with the double buffer value (at BOTTOM). When either OCR1A or ICR1is used for defining the TOP value, the OC1A or ICF1 Flag set when TCNT1 has reached TOP.\nThe Interrupt Flags can then be used to generate an interrupt each time the counter reaches the\nTOP or BOTTOM value.\nWhen changing the TOP value the program must ensure that the new TOP value is higher or\nequal to the value of all of the Compare Registers. If the TOP value is lower than any of theCompare Registers, a Compare Match will neve r occur between the TCNT1 and the OCR1x.\nAs Figure 40  shows the output generated is, in contrast to the Phase Correct mode, symmetrical\nin all periods. Since the OCR1x Registers are updated at BOTTOM, the length of the rising andthe falling slopes will always be equal. This gives sy mmetrical output pulses  and is therefore fre-\nquency correct.\nUsing the ICR1 Register for defining TOP work s well when using fixed TOP values. By using\nICR1, the OCR1A Register is free to be used for generating a PWM output on OC1A. However,if the base PWM frequency is actively changed by changing the TOP value, using the OCR1A asTOP is clearly a better choice due to its double buffer feature.\nIn phase and frequency correct PWM mode, the compare units allow generation of PWM wave-\nforms on the OC1x pins. Setting the COM1x1:0 bits to 2 will produce a non-inverted PWM andan inverted PWM output can be generated by setting the COM1x1:0 to 3. See Table 38 on page\n97. The actual OC1x value will only be  visible on the port pin if the data direction for the port pin\nis set as output (DDR_OC1x). The PWM wavefo rm is generated by setting (or clearing) the\nOC1x Register at the Compare Match between OCR1x and TCNT1 when the counter incre-ments, and clearing (or setting) the OC1x Register at Compare Match between OCR1x andTCNT1 when the counter decrements. The PW M frequency for the output when using phase\nand frequency correct PWM can be calculated by the following equation:\nThe N variable represents the prescaler divider (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR1x Register represents special cases when generating a PWM\nwaveform output in the phase correct PWM mode. If the OCR1x is set equal to BOTTOM theOCRnx / TOP Update and\nTOVn Interrupt Flag Set(Interrupt on Bottom)OCnA Interrupt Flag Set orICFn Interrupt Flag Set(Interrupt on TOP)\n1 2 3 4TCNTn\nPeriodOCnx\nOCnx(COMnx1:0 = 2)\n(COMnx1:0 = 3)\nfOCnxPFCPWMfclk_I/O\n2NT O P\u22c5\u22c5--------------------------- - =\n\n94\n2486Z\u2013AVR\u201302/11ATmega8(L)output will be continuously low and if set equal to TOP the output will be set to high for non-\ninverted PWM mode. For inverted PWM the output will have the opposite logic values.\nIf OCR1A is used to define the TOP value (WGM13:0 = 9) and COM1A1:0 = 1, the OC1A output\nwill toggle with a 50% duty cycle.\nTimer/Counter \nTiming DiagramsThe Timer/Counter is a synchronous design and the timer clock (clkT1) is therefore shown as a\nclock enable signal in the following figures. The figures include information on when Interrupt\nFlags are set, and when the OCR1x Register is updated with the OCR1x buffer value (only formodes utilizing doub le buffering). Figure 41  shows a timing diagram for the setting of OCF1x. \nFigure 41.  Timer/Counter Timing Diagram, Setting of OCF1x, no Prescaling\nFigure 42  shows the same timing data, but with the prescaler enabled. \nFigure 42.  Timer/Counter Timing Diagram, Setting of OCF1x, with Prescaler (f\nclk_I/O /8)\nFigure 43 on page 95  shows the count sequence close to TOP in various modes. When using\nphase and frequency correct PWM mode the OCR1 x Register is updated at BOTTOM. The tim-clkTn\n(clkI/O/1)\nOCFnxclkI/O\nOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2\nOCFnxOCRnxTCNTn\nOCRnx ValueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\n\n95\n2486Z\u2013AVR\u201302/11ATmega8(L)\ning diagrams will be the same, but TOP should be replaced by BOTTO M, TOP-1 by BOTTOM+1\nand so on. The same renaming applies for modes that set the TOV1 Flag at BOTTOM.\nFigure 43.  Timer/Counter Timing Diagram, no Prescaling\nFigure 44  shows the same timing data, but with the prescaler enabled. \nFigure 44.  Timer/Counter Timing Diagram, with Prescaler (fclk_I/O /8)TOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkTn\n(clkI/O/1)clkI/O\nTOVn (FPWM)\nand ICFn (if used\nas TOP)\nOCRnx\n(Update at TOP)TCNTn\n(CTC and FPWM)\nTCNTn\n(PC and PFC PWM)TOP - 1 TOP TOP - 1 TOP - 2\nOld OCRnx Value New OCRnx ValueTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\n\n96\n2486Z\u2013AVR\u201302/11ATmega8(L)16-bit \nTimer/Counter \nRegister \nDescription\nTimer/Counter 1 \nControl Register A \u2013 TCCR1A\n\u0081 Bit 7:6 \u2013 COM1A1:0: Compare Output Mode for channel A\n\u0081 Bit 5:4 \u2013 COM1B1:0: Compare Output Mode for channel B\nThe COM1A1:0 and COM1B1:0 control the Output Compare Pins (OC1A and OC1B respec-\ntively) behavior. If one or both of the COM1A1:0 bits are written to one, the OC1A outputoverrides the normal port functionality of the I/O pin it is connected to. If one or both of theCOM1B1:0 bit are written to one, the OC1B output overrides the normal port functionality of theI/O pin it is connected to. However, note that the Data Direction Register  (DDR) bit correspond-\ning to the OC1A or OC1B pin must be set in order to enable the output driver.\nWhen the OC1A or OC1B is connected to the pin,  the function of the COM1x1:0 bits is depen-\ndent of the WGM13:0 bits setting. Table 36  shows the COM1x1:0 bit functionality when the\nWGM13:0 bits are set to a normal or a CTC mode (non-PWM).\nTable 37  shows the COM1x1:0 bit functionality when the WGM13:0 bits are set to the fast PWM\nmode.\nNote: 1. A special case occurs when OCR1A/OC R1B equals TOP and COM1A1/COM1B1 is set. In\nthis case the Compare Match is ignored, bu t the set or clear is done at BOTTOM. See \u201cFast\nPWM Mode\u201d on page 88  for more detailsB i t 76543 2 1 0\nCOM1A1 COM1A0 COM1B1 COM1B0 FOC1A FOC1B WGM11 WGM10 TCCR1A\nRead/Write R/W R/W R/W R/W W W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\nTable 36.  Compare Output Mode, Non-PWM\nCOM1A1/\nCOM1B1COM1A0/\nCOM1B0 Description\n0 0 Normal port operation, OC1A/OC1B disconnected.0 1 Toggle OC1A/OC1B on Compare Match\n1 0 Clear OC1A/OC1B on Compare Match (Set output to low level)\n1 1 Set OC1A/OC1B on Compare Match (Set output to high level)\nTable 37.  Compare Output Mode, Fast PWM(1)\nCOM1A1/\nCOM1B1COM1A0/\nCOM1B0 Description\n0 0 Normal port operation, OC1A/OC1B disconnected.0 1 WGM13:0 = 15: Toggle OC1A on Compare Match, OC1B \ndisconnected (normal port operation). For all other WGM1 \nsettings, normal port operation, OC1A/OC1B disconnected.\n1 0 Clear OC1A/OC1B on Compare Match, set OC1A/OC1B at \nBOTTOM, (non-inverting mode)\n1 1 Set OC1A/OC1B on Compare Match, clear OC1A/OC1B at \nBOTTOM, (inverting mode)\n\n97\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTable 38  shows the COM1x1:0 bit functionality when the WGM13:0 bits are set to the phase cor-\nrect or the phase and frequency correct, PWM mode.\nNote: 1. A special case occurs when OCR1A/OCR1 B equals TOP and COM1A1/COM1B1 is set. See\n\u201cPhase Correct PWM Mode\u201d on page 90  for more details\n\u0081 Bit 3 \u2013 FOC1A: Force Output Compare for channel A\n\u0081 Bit 2 \u2013 FOC1B: Force Output Compare for channel B\nThe FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode.\nHowever, for ensuring compatibility with future devices, these bits must be set to zero when\nTCCR1A is written when operating in a PWM mode. When writing a logical one to theFOC1A/FOC1B bit, an immediate Compare Match is forced on the waveform generation unit.The OC1A/OC1B output is changed according to its COM1x1:0 bits setting. Note that theFOC1A/FOC1B bits are implemented as strobes. Therefore it is the value present in theCOM1x1:0 bits that determine the effect of the forced compare.\nA FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer\non Compare Match (CTC) mode using OCR1A as TOP.\nThe FOC1A/FOC1B bits are always read as zero.\n\u0081 Bit 1:0 \u2013 WGM11:0: Waveform Generation Mode\nCombined with the WGM13:2 bits found in the TCCR1B Register, these bits control the counting\nsequence of the counter, the source for maximum (TOP) counter value, and what type of wave-form generation to be used, see Table 39 . Modes of operation supported by the Timer/Counter\nunit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and three typesof Pulse Width Modulation (PWM) modes (see \u201cModes of Operation\u201d on page 87 ).Table 38.  Compare Output Mode, Phase Correct and Phase and Frequency Correct PWM\n(1)\nCOM1A1/\nCOM1B1COM1A0/\nCOM1B0 Description\n0 0 Normal port operation, OC1A/OC1B disconnected.\n0 1 WGM13:0 = 9 or 14: Toggle OC 1A on Compare Match, OC1B \ndisconnected (normal port operation). For all other WGM1 settings, normal port operation, OC1A/OC1B disconnected.\n1 0 Clear OC1A/OC1B on Compare Match when up-counting. Set \nOC1A/OC1B on Compare Match when downcounting.\n1 1 Set OC1A/OC1B on Compare Match when up-counting. Clear \nOC1A/OC1B on Compare Match when downcounting.\nTable 39.  Waveform Generation Mode Bit Description\nMode WGM13WGM12\n(CTC1)WGM11\n(PWM11)WGM10\n(PWM10)Timer/Counter Mode of \nOperation(1)TOPUpdate of \nOCR1 xTOV1 Flag Set on\n0 0 0 0 0 Normal 0xFFFF Immediate MAX\n1 0 0 0 1 PWM, Phase Correct, 8-bit 0x00FF TOP BOTTOM2 0 0 1 0 PWM, Phase Correct, 9-bit 0x01FF TOP BOTTOM\n3 0 0 1 1 PWM, Phase Correct, 10-bit 0x03FF TOP BOTTOM\n4 0 1 0 0 CTC OCR1A Immediate MAX\n5 0 1 0 1 Fast PWM, 8-bit 0x00FF BOTTOM TOP\n6 0 1 1 0 Fast PWM, 9-bit 0x01FF BOTTOM TOP\n\n98\n2486Z\u2013AVR\u201302/11ATmega8(L)Note: 1. The CTC1 and PWM11:0 bit defin ition names are obsolete. Use the WGM 12:0 definitions. However, the functionality and\nlocation of these bits are compatible  with previous versions of the timer\nTimer/Counter 1 \nControl Register B \u2013 TCCR1B\n\u0081 Bit 7 \u2013 ICNC1: Input Capture Noise Canceler\nSetting this bit (to one) activates the Input Capt ure Noise Canceler. When the noise canceler is\nactivated, the input from the Input Capture Pin (ICP1) is filtered. The filter function requires foursuccessive equal valued samples of the ICP1 pin for changing its output. The Input Capture istherefore delayed by four Oscillator cycles when the noise canceler is enabled.\n\u0081 Bit 6 \u2013 ICES1: Input Capture Edge Select\nThis bit selects which edge on the Input Capture Pin (ICP1) that is used to trigger a capture\nevent. When the ICES1 bit is written to zero, a falling (negative) edge is used as trigger, and\nwhen the ICES1 bit is written to one, a risi ng (positive) edge w ill trigger the capture.\nWhen a capture is triggered according to the ICES1 setting, the counter value is copied into the\nInput Capture Register (ICR1). The event will also set the Input Capture Flag (ICF1), and this\ncan be used to cause an Input Capture Interrupt, if this interrupt is enabled.\nWhen the ICR1 is used as TOP value (see description of the WGM13:0 bits located in the\nTCCR1A and the TCCR1B Register), the ICP1 is disconnected and consequently the Input Cap-ture function is disabled.\n\u0081 Bit 5 \u2013 Reserved Bit\nThis bit is reserved for future use. For ensuring  compatibility with future de vices, this bit must be\nwritten to zero when TCCR1B is written.\n\u0081 Bit 4:3 \u2013 WGM13:2: Waveform Generation Mode\nSee TCCR1A Register description.\n\u0081 Bit 2:0 \u2013 CS12:0: Clock Select\nThe three clock select bits select the clock source to be used by the Timer/Counter, see Figure\n41 on page 94  and Figure 42 on page 94 .7 0 1 1 1 Fast PWM, 10-bit 0x03FF BOTTOM TOP\n8 1 0 0 0 PWM, Phase and Frequency Correct ICR1 BOTTOM BOTTOM\n9 1 0 0 1 PWM, Phase and Frequency Correct OCR1A BOTTOM BOTTOM\n10 1 0 1 0 PWM, Phase Correct ICR1 TOP BOTTOM\n11 1 0 1 1 PWM, Phase Correct OCR1A TOP BOTTOM12 1 1 0 0 CTC ICR1 Immediate MAX\n13 1 1 0 1 (Reserved) \u2013 \u2013 \u2013\n14 1 1 1 0 Fast PWM ICR1 BOTTOM TOP15 1 1 1 1 Fast PWM OCR1A BOTTOM TOPTable 39.  Waveform Generation Mode Bit Description (Continued)\nMode WGM13WGM12\n(CTC1)WGM11\n(PWM11)WGM10\n(PWM10)Timer/Counter Mode of \nOperation(1)TOPUpdate of \nOCR1 xTOV1 Flag Set on\nB i t 76543210\nICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 TCCR1B\nRead/Write R/W R/W R R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n99\n2486Z\u2013AVR\u201302/11ATmega8(L)\nIf external pin modes are used for the Timer/Counter1, transitions on the T1 pin will clock the\ncounter even if the pin is configured as an output. This feature allows software control of thecounting.\nTimer/Counter 1 \u2013 \nTCNT1H and TCNT1L\nThe two Timer/Counter  I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct\naccess, both for read and for write operations, to the Timer/Counter unit 16-bit counter. Toensure that both the high and Low bytes are read and written simultaneously when the CPUaccesses these registers, the access is perfo rmed using an 8-bit temporary High byte Register\n(TEMP). This temporary register is shared by all the other 16-bit registers. See \u201cAccessing 16-bit\nRegisters\u201d on page 77.\nModifying the counter (TCNT1) while the counter is running introduces a risk of missing a Com-\npare Match between TCNT1 and one of the OCR1x Registers.\nWriting to the TCNT1 Register blocks (removes) the Compare Match on th e following timer clock\nfor all compare units.\nOutput Compare \nRegister 1 A \u2013 OCR1AH and OCR1AL\nOutput Compare \nRegister 1 B \u2013 OCR1BH and OCR1BLTable 40.  Clock Select Bit Description\nCS12 CS11 CS10 Description\n0 0 0 No clock source. (Timer/Counter stopped)\n001 c l kI/O/1 (No prescaling)\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on T1 pin. Clock on falling edge1 1 1 External clock source on T1 pin. Clock on rising edge\nB i t 76543210\nTCNT1[15:8] TCNT1H\nTCNT1[7:0] TCNT1L\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCR1A[15:8] OCR1AH\nOCR1A[7:0] OCR1AL\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCR1B[15:8] OCR1BH\nOCR1B[7:0] OCR1BL\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n100\n2486Z\u2013AVR\u201302/11ATmega8(L)The Output Compare Registers contain a 16-bit value that is continuously compared with the\ncounter value (TCNT1). A match can be used to generate an Output Compare Interrupt, or togenerate a waveform output on the OC1x pin.\nThe Output Compare Registers are 16-bit in size. To ensure that both the high and Low bytes\nare written simultaneously when the CPU writes to these registers, the access is performed\nusing an 8-bit temporary High byte Register (TEMP). This temporary register is shared by all theother 16-bit registers. See \u201cAccessing 16-bit Registers\u201d on page 77.\nInput Capture Register \n1 \u2013 ICR1H and ICR1L\nThe Input Capture is updated with the counter (TCNT1) value each time an event occurs on the\nICP1 pin (or optionally on the Analog Comparator Output for Timer/Counter1). The Input Cap-ture can be used for defining the counter TOP value.\nThe Input Capture Register is 16-bit in size. To ensure that both the high and Low bytes are read\nsimultaneously when the CPU accesses these regi sters, the access is performed using an 8-bit\ntemporary High byte Register (TEMP). This temporary register is shared by all the other 16-bitregisters. See \u201cAccessing 16-bit Registers\u201d on page 77.\nTimer/Counter \nInterrupt Mask Register \u2013 TIMSK\n(1)\nNote: 1. This register contains interrupt control bits for several Timer/Counters, but only Timer1 bits are\ndescribed in this section. The remaining bits are described in their respective timer sections\n\u0081 Bit 5 \u2013 TICIE1: Timer/Counter1, Input Capture Interrupt Enable\nWhen this bit is written to one, and the I-flag in the Status Register is set (interrupts globally\nenabled), the Timer/Counter1 Input Capture Interrupt is enabled. The corresponding InterruptVector (see \u201cInterrupts\u201d on page 46 ) is executed when the ICF1 Flag, located in TIFR, is set.\n\u0081 Bit 4 \u2013 OCIE1A: Timer/Counter1, Output Compare A Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in the Status Register is set (interrupts globally\nenabled), the Timer/Counter1 Output Compare A match interrupt is enabled. The correspondingInterrupt Vector (see \u201cInterrupts\u201d on page 46 ) is executed when the OCF1A Flag, located in\nTIFR, is set.\n\u0081 Bit 3 \u2013 OCIE1B: Timer/Counter1, Output Compare B Match Interrupt Enable\nWhen this bit is written to one, and the I-flag in the Status Register is set (interrupts globally\nenabled), the Timer/Counter1 Output Compare B match interrupt is enabled. The correspondingInterrupt Vector (see \u201cInterrupts\u201d on page 46 ) is executed when the OCF1B Flag, located in\nTIFR, is set.\n\u0081 Bit 2 \u2013 TOIE1: Timer/Counter1, Overflow Interrupt Enable\nWhen this bit is written to one, and the I-flag in the Status Register is set (interrupts globally\nenabled), the Timer/Counter1 Overflow Interrupt is enabled. The corresponding Interrupt Vector(see \u201cInterrupts\u201d on page 46 ) is executed when the TOV1 Flag, located in TIFR, is set.B i t 76543210\nICR1[15:8] ICR1H\nICR1[7:0] ICR1L\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 \u2013 TOIE0 TIMSK\nRead/Write R/W R/W R/W R/W R/W R/W R R/WI n i t i a l  V a l u e 00000000\n\n101\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTimer/Counter \nInterrupt Flag Register \u2013 TIFR\n(1)\nNote: 1. This register contains flag bits for severa l Timer/Counters, but only Timer1 bits are described\nin this section. The remaining bits are de scribed in their respective timer sections\n\u0081 Bit 5 \u2013 ICF1: Timer/Count er1, Input Capture Flag\nThis flag is set when a capture event occurs on  the ICP1 pin. When the Input Capture Register\n(ICR1) is set by the WGM13:0 to be used as the TOP value, the ICF1 Flag is set when the coun-ter reaches the TOP value.\nICF1 is automatically cleared when the Input Capt ure Interrupt Vector is executed. Alternatively,\nICF1 can be cleared by writing a logic one to its bit location.\n\u0081 Bit 4 \u2013 OCF1A: Timer/Counter1, Output Compare A Match Flag\nThis flag is set in the timer clock cycle afte r the counter (TCNT1) value matches the Output\nCompare Register A (OCR1A).\nNote that a Forced Output Compare (FOC 1A) strobe will not set the OCF1A Flag.\nOCF1A is automatically cleared when the Output Compare Match A Interrupt Vector is exe-\ncuted. Alternatively, OCF1A can be cleared by writing a logic one to its bit location.\n\u0081 Bit 3 \u2013 OCF1B: Timer/Counter1, Output Compare B Match Flag\nThis flag is set in the timer clock cycle afte r the counter (TCNT1) value matches the Output\nCompare Register B (OCR1B).\nNote that a Forced Output Compare (FOC 1B) strobe will not set the OCF1B Flag.\nOCF1B is automatically cleared when the Output Compare Match B Interrupt Vector is exe-\ncuted. Alternatively, OCF1B can be cleared by writing a logic one to its bit location.\n\u0081 Bit 2 \u2013 TOV1: Timer/Counter1, Overflow Flag\nThe setting of this flag is dependent of the WGM13:0 bits setting. In normal and CTC modes, the\nTOV1 Flag is set when the timer overflows. Refer to Table 39 on page 97  for the TOV1 Flag\nbehavior when using another WGM13:0 bit setting.\nTOV1 is automatically cleared when the Timer/C ounter1 Overflow Interrupt Vector is executed.\nAlternatively, TOV1 can be cleared by writing a logic one to its bit location.B i t 76543210\nOCF2 TOV2 ICF1 OCF1A OCF1B TOV1 \u2013 TOV0 TIFR\nRead/Write R/W R/W R/W R/W R/W R/W R R/WI n i t i a l  V a l u e 00000000\n\n102\n2486Z\u2013AVR\u201302/11ATmega8(L)8-bit \nTimer/Counter2 \nwith PWM and Asynchronous \nOperationTimer/Counter2 is a general purpose, single channel, 8-bit Timer/Counter module. The main\nfeatures are:\n\u0081Single Channel Counter\n\u0081Clear Timer on Compar e Match (Auto Reload)\n\u0081Glitch-free, phase Correct Pulse Width Modulator (PWM)\n\u0081Frequency Generator\n\u008110-bit Clock Prescaler\n\u0081Overflow and Compare Match Interrupt Sources (TOV2 and OCF2)\n\u0081Allows Clocking from External 32kHz Watc h Crystal Independent of the I/O Clock\nOverview A simplified block diagram of the 8-bit Timer/Counter is shown in Figure 45 . For the actual place-\nment of I/O pins, refer to \u201cPin Configurations\u201d on page 2 . CPU accessible I/O Registers,\nincluding I/O bits and I/O pins, are shown in bold. The device-specific I/O Register and bit loca-tions are listed in the \u201c8-bit Timer/Counter Register Description\u201d on page 114 .\nFigure 45.  8-bit Timer/Counter Block Diagram \nTimer/Counter\nDATA BUS=TCNTn\nWaveform\nGenerationOCn= 0Control Logic\n= 0xFFTOP BOTTOMcount\nclear\ndirectionTOVn\n(Int. Req.)\nOCn(Int. Req.)\nSynchronization UnitOCRnTCCRn\nASSRnStatus FlagsclkI/O\nclkASYSynchronized Status Flags\nasynchronous Mode\nSelect (ASn)TOSC1\nT/C\nOscillator\nTOSC2PrescalerclkTn\nclkI/O\n\n103\n2486Z\u2013AVR\u201302/11ATmega8(L)\nRegisters The Timer/Counter (TCNT2) and Output Compare Register (OCR2) are 8-bit registers. Interrupt\nrequest (shorten as Int.Req.) signals are all visible in the Timer Interrupt Flag Register (TIFR).All interrupts are individually masked with the Timer Interrupt Mask Register (TIMSK). TIFR andTIMSK are not shown in the figure since these registers are shared by other timer units.\nThe Timer/Counter can be clocked internally, via the prescaler, or asynchronously clocked from\nthe TOSC1/2 pins, as detailed later in this section. The asynchronous operation is controlled bythe Asynchronous Status Regist er (ASSR). The Clock Select lo gic block controls which clock\nsource the Timer/Counter uses to increment (or de crement) its value. The Timer/Counter is inac-\ntive when no clock source is selected. The output from the clock select logic is referred to as thetimer clock (clk\nT2).\nThe double buffered Output Compare Register (OCR2) is compared with the Timer/Counter\nvalue at all times. The result of the compare can be used by the waveform generator to generatea PWM or variable frequency output on the Output Compare Pin (OC2). For details, see \u201cOutput\nCompare Unit\u201d on page 105 . The Compare Match event will also  set the Compare Flag (OCF2)\nwhich can be used to generate an Output Compare interrupt request.\nDefinitions Many register and bit references in this document are written in general form. A lower case \u201cn\u201d\nreplaces the Timer/Counter number, in this case  2. However, when using the register or bit\ndefines in a program, the precise form must be used (that is, TCNT2 for accessingTimer/Counter2 counter value and so on).\nThe definitions in Table 41  are also used extensively throughout the document.\nTimer/Counter \nClock SourcesThe Timer/Counter can be clocked by an internal synchronous or an external asynchronous\nclock source. The clock source clkT2 is by default equal to the MCU clock, clkI/O. When the AS2\nbit in the ASSR Register is written to logic one, the clock source is taken from the Timer/CounterOscillator connecte d to TOSC1 and TOSC2. For details on asynchronous operation, see \u201cAsyn-\nchronous Status Register \u2013 ASSR\u201d on page 117 . For details on clock so urces and prescaler, see\n\u201cTimer/Counter Prescaler\u201d on page 120 .Table 41.  Definitions\nBOTTOM The counter reaches the BOTT OM when it becomes zero (0x00).\nMAX The counter reaches its MAXimum wh en it becomes 0xFF (decimal 255).\nTOP The counter reaches the TOP when it becomes equal to the highest value in the\ncount sequence. The TOP value can be assigned to be the fixed value 0xFF\n(MAX) or the value stor ed in the OCR2 Register. The assignment is dependent\non the mode of operation.\n\n104\n2486Z\u2013AVR\u201302/11ATmega8(L)Counter Unit The main part of the 8-bit Timer/Counter is the programmable bi-directional counter unit. Figure\n46 shows a block diagram of the counter and its surrounding environment.\nFigure 46.  Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment or decrement TCNT2 by 1\ndirection Selects between increment and decrement\nclear Clear TCNT2 (set all bits to zero)\nclkT2 Timer/Counter clock\nTOP Signalizes that TCNT2 has reached maximum value\nBOTTOM Signalizes that TCNT2 has reached minimum value (zero)\nDepending on the mode of operation used, the counter is cleared, incremented, or decremented\nat each timer clock (clkT2). clkT2 can be generated from an external or internal clock source,\nselected by the clock select bits (CS22:0). When no clock source is selected (CS22:0 = 0) thetimer is stopped. However, the TCNT2 value can be accessed by the CPU, regardless ofwhether clk\nT2 is present or not. A CPU write overrides (has priority over) all counter clear or\ncount operations.\nThe counting sequence is determined by the setting of the WGM21 and WGM20 bits located in\nthe Timer/Counter Control Register (TCCR2).  There are close connections between how the\ncounter behaves (counts) and how waveforms are generated on the Output Compare OutputOC2. For more details about advanced counting sequences and waveform generation, see\u201cModes of Operation\u201d on page 108 .\nThe Timer/Counter Overflow (TOV2) Flag is set according to the mode of operation selected by\nthe WGM21:0 bits. TOV2 can be used for generating a CPU interrupt.DATA BUS\nTCNTn Control LogiccountTOVn\n(Int. Req.)\nTOP BOTTOMdirectionclearTOSC1\nT/C\nOscillator\nTOSC2Prescaler\nclkI/OclkTn\n\n105\n2486Z\u2013AVR\u201302/11ATmega8(L)\nOutput Compare \nUnitThe 8-bit comparator continuously compares TCNT2 with the Output Compare Register\n(OCR2). Whenever TCNT2 equals OCR2, the comparator signals a match. A match will set theOutput Compare Flag (OCF2) at the next timer clock cycle. If enabled (OCIE2 = 1), the OutputCompare Flag generates an Output Compare interrupt. The OCF2 Flag is automatically clearedwhen the interrupt is executed. Alternatively, th e OCF2 Flag can be cleared by software by writ-\ning a logical one to its I/O bit location. The waveform generator uses the match signal togenerate an output according to operating mode set by the WGM21:0 bits and Compare Outputmode (COM21:0) bits. The max and bottom signals are used by the waveform generator for han-dling the special cases of the extreme values in some modes of operation (see \u201cModes of\nOperation\u201d on page 108 ).\nFigure 47  shows a block diagram of the Output Compare unit. \nFigure 47.  Output Compare Unit, Block Diagram\nThe OCR2 Register is double buffered when us ing any of the Pulse Width Modulation (PWM)\nmodes. For the normal and Clear Timer on Compare (CTC) modes of operation, the double buff-ering is disabled. The double buffering synchron izes the update of the OCR2 Compare Register\nto either top or bottom of the counting sequenc e. The synchronization prevents the occurrence\nof odd-length, non-symmetrical PWM pulses, thereby making the output glitch-free.\nThe OCR2 Register access may seem complex, but this is not case. When the double buffering\nis enabled, the CPU has access to the OCR2 Buff er Register, and if double buffering is disabled\nthe CPU will access the OCR2 directly.OCFn  (Int. Req.)= (8-bit Comparator )OCRn\nOCxyDATA BUS\nTCNTn\nWGMn1:0Waveform GeneratorTOP\nFOCn\nCOMn1:0BOTTOM\n\n106\n2486Z\u2013AVR\u201302/11ATmega8(L)Force Output \nCompareIn non-PWM Waveform Generation modes, the match output of the comparator can be forced by\nwriting a one to the Force Output  Compare (FOC2) bit. Forcing Compare Match will not set the\nOCF2 Flag or reload/clear the timer, but the OC2 pin will be updated as if a real Compare Match\nhad occurred (the COM21:0 bits settings define whether the OC2 pin is set, cleared or toggled).\nCompare Match \nBlocking by TCNT2 WriteAll CPU write operations to the TCNT2 Register will block any Comp are Match that occurs in the\nnext timer clock cycle, even when the timer is st opped. This feature allows OCR2 to be initialized\nto the same value as TCNT2 without triggering an interrupt when the Timer/Counter clock isenabled.\nUsing the Output \nCompare UnitSince writing TCNT2 in any mode  of operation will block all comp are matches for one timer clock\ncycle, there are risks involved when changing TCNT2 when using the Output Compare channel,independently of whether the Timer/Counter is running or not. If the value written to TCNT2equals the OCR2 value, the Compare Match will be  missed, resulting in incorrect waveform gen-\neration. Similarly, do not write the TCNT2 value equal to BOTTOM when the counter isdowncounting.\nThe setup of the OC2 should be performed before setting the Data Direction Register for the port\npin to output. The easiest way of setting the OC2 value is to use the Force Output Compare(FOC2) strobe bit in Normal mode. The OC2 R egister keeps its value even when changing\nbetween waveform generation modes.\nBe aware that the COM21:0 bits are not double buffered together with the compare value.\nChanging the COM21:0 bits will take effect immediately.\n\n107\n2486Z\u2013AVR\u201302/11ATmega8(L)\nCompare Match \nOutput UnitThe Compare Output mode (COM21:0) bits have two functions. The waveform generator uses\nthe COM21:0 bits for defining the Output Compare (OC2) state at the next Compare Match.Also, the COM21:0 bits control the OC2 pin output source. Figure 48  shows a simplified sche-\nmatic of the logic affected by the COM21:0 bit setting. The I/O Registers, I/O bits, and I/O pins inthe figure are shown in bold. Only the parts of the general I/O Port Control Registers (DDR andPORT) that are affected by the COM21:0 bits are shown. When referring to the OC2 state, thereference is for the internal OC2 Register, not the OC2 pin.\nFigure 48.  Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Output Compare (OC2) from the waveform\ngenerator if either of the COM21:0 bits are set. However, the OC2 pin direction (input or output)is still controlled by the Data Direction Register (DDR) for the port pin. The Data Direction Regis-\nter bit for the OC2 pin (DDR_OC2) must be set as output before the OC2 value is visible on thepin. The port override function is independent of the Waveform Generation mode.\nThe design of the Output Compare Pin logic allows initialization of the OC2 state before the out-\nput is enabled. Note that some COM21:0 bit settings are reserved for certain modes ofoperation. See \u201c8-bit Timer/Counter Register Description\u201d on page 114.PORT\nDDRDQDQOCn\nPin OCnDQWaveform\nGeneratorCOMn1\nCOMn0\n01\nDATABUSFOCn\nclkI/O\n\n108\n2486Z\u2013AVR\u201302/11ATmega8(L)Compare Output Mode \nand Waveform GenerationThe Waveform Generator uses the COM21:0 bits differently in normal, CTC, and PWM modes.\nFor all modes, setting the COM21:0 = 0 tells the waveform generator that no action on the OC2Register is to be performed on the next Compare Match. For compare output actions in the non-PWM modes refer to Table 43 on page 115 . For fast PWM mode, refer to Table 44 on page 115 ,\nand for phase correct PWM refer to Table 45 on page 116 .\nA change of the COM21:0 bits state will have effect  at the first Compare Match after the bits are\nwritten. For non-PWM modes, the action can be fo rced to have immediate effect by using the\nFOC2 strobe bits.\nModes of \nOperationThe mode of operation (that is, the behavior of the Timer/Counter and the Output Compare pins)\nis defined by the combination of the Waveform Generation mode (WGM21:0) and Compare Out-put mode (COM21:0) bits. The Compare Output mode bits do not affect the counting sequence,while the Waveform Generation mode bits do. The COM21:0 bits control whether the PWM out-put generated should be inverted or not (inverted or non-inverted PWM). For non-PWM modesthe COM21:0 bits control whether the output should be set, cleared, or toggled at a CompareMatch (see \u201cCompare Match Output Unit\u201d on page 107 ).\nFor detailed timing information refer to \u201cTimer/Counter Timing Diagrams\u201d on page 112 .\nNormal Mode The simplest mode of operation is the Normal mode (WGM21:0 = 0). In this mode the counting\ndirection is always up (incrementing), and no counter clear is performed. The counter simply\noverruns when it passes its maximum 8-bit value (TOP = 0xFF) and then restarts from the bot-tom (0x00). In normal o peration the Timer/Counter Overflow Flag (TOV2) will be set in the same\ntimer clock cycle as the TCNT2 becomes zero. The TOV2 Flag in this case behaves like a ninth\nbit, except that it is only set, not cleared. However, combined with the timer overflow interruptthat automatically clears the TOV2 Flag, the timer resolution can be increased by software.There are no special cases to consider in the Normal mode, a new counter value can be writtenanytime.\nThe Output Compare unit can be used to generate interrupts at some given time. Using the Out-\nput Compare to generate waveforms in Normal mode is not recommended, since this willoccupy too much of the CPU time.\n\n109\n2486Z\u2013AVR\u201302/11ATmega8(L)\nClear Timer on \nCompare Match (CTC) ModeIn Clear Timer on Compare or CTC mode (WGM21:0 = 2), the OCR2 Register is used to manip-\nulate the counter resolution. In CTC mode the counter is cleared to zero when the counter value(TCNT2) matches the OCR2. The OCR2 defines the top value for the counter, hence also itsresolution. This mode allows greater control of the Compare Match output frequency. It also sim-plifies the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 49 . The counter value (TCNT2)\nincreases until a Compare Match occurs between TCNT2 and OCR2, and then counter (TCNT2)is cleared.\nFigure 49.  CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter value reaches the TOP value by using the\nOCF2 Flag. If the interrupt is enabled, the interrupt handler routine can be used for updating theTOP value. However, changing the TOP to a va lue close to BOTTOM when the counter is run-\nning with none or a low prescaler value must be done with care since the CTC mode does nothave the double buffering feature. If the new value written to OCR2 is lower than the currentvalue of TCNT2, the counter will miss the Compar e Match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starting at 0x00 before the Compare Match canoccur.\nFor generating a waveform output in CTC mode, the OC2 output can be set to toggle its logical\nlevel on each Compare Match by setting the Compare Output mode bits to toggle mode\n(COM21:0 = 1). The OC2 value will no t be visible on the port pin unl ess the data direction for the\npin is set to output. The waveform generated will have a maximum frequency of f\nOC2 = fclk_I/O /2\nwhen OCR2 is set to zero (0x00). The waveform frequency is defined by the following equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nAs for the Normal mode of operation, the TOV2 Flag is set in the same timer clock cycle that the\ncounter counts from MAX to 0x00.TCNTn\nOCn\n(Toggle)OCn Interrupt Flag Set\n1 4 Period 2 3(COMn1:0 = 1)\nfOCnfclk_I/O\n2N1OCRn+() \u22c5\u22c5---------------------------------------------- - =\n\n110\n2486Z\u2013AVR\u201302/11ATmega8(L)Fast PWM Mode The fast Pulse Width Modulation or fast PWM mode (WGM21:0 = 3) provides a high frequency\nPWM waveform generation option. The fast PWM di ffers from the other PWM option by its sin-\ngle-slope operation. The counter counts from BOTTOM to MAX then restarts from BOTTOM. Innon-inverting Compare Output mode, the Output Compare (OC2) is cleared on the CompareMatch between TCNT2 and OCR2, and set at BOTTOM. In inverting Compare Output mode, theoutput is set on Compare Match and cleared at BOTTOM. Due to the single-slope operation, theoperating frequency of the fast PWM mode can be twice as high as the phase correct PWMmode that uses dual-slope operation. This high frequency makes the fast PWM mode well suitedfor power regulation, rectification, and DAC app lications. High frequency a llows physically small\nsized external components (coils, capacitors), and therefore reduces total system cost.\nIn fast PWM mode, the counter is incremented until the counter value matches the MAX value.\nThe counter is then cleared at the following timer clock cycle. The timing diagram for the fastPWM mode is shown in Figure 50 . The TCNT2 value is in the timing diagram shown as a histo-\ngram for illustrating the single-s lope operation. The diagram includes non- inverted and inverted\nPWM outputs. The small horizontal line ma rks on the TCNT2 slopes represent compare\nmatches between OCR2 and TCNT2.\nFigure 50.  Fast PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches MAX. If the inter-\nrupt is enabled, the interrupt handler routine can be used for updating the compare value.\nIn fast PWM mode, the compare unit allows generation of PWM waveforms on the OC2 pin. Set-\nting the COM21:0 bits to 2 will produce a non-inverted  PWM and an inverted PWM output can\nbe generated by setting the COM21:0 to 3 (see Table 44 on page 115 ). The actual OC2 value\nwill only be visible on the port pin if the data direction for the port  pin is set as output. The PWM\nwaveform is generated by setting (or clearing) the OC2 Register at the Compare Match betweenOCR2 and TCNT2, and clearing (or setting) the OC2 Register at the timer clock cycle the coun-ter is cleared (changes from MAX to BOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).TCNTnOCRn Upd ate\nand\nTOVn Interr upt Flag Set\n1 Period 2 3OCn\nOCn(COMn1:0 = 2)\n(COMn1:0 = 3)OCRn Interr upt Flag Set\n4 5 6 7\nfOCnPWMfclk_I/O\nN256\u22c5------------------=\n\n111\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe extreme values for the OCR2 Register represent special cases when generating a PWM\nwaveform output in the fast PWM mode. If the OCR2 is set equal to BOTTOM, the output will bea narrow spike for each MAX+1 ti mer clock cycle. Setting the OCR2  equal to MAX will result in a\nconstantly high or low output (depending on the polarity of the output set by the COM21:0 bits.)\nA frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by set-\nting OC2 to toggle its logical level on each Compare Match (COM21:0 = 1). The waveformgenerated will have a ma ximum frequency of f\noc2 = fclk_I/O /2 when OCR2 is set to zero. This fea-\nture is similar to the OC2 toggle in CTC mode, except the double buffer feature of the OutputCompare unit is enabled in the fast PWM mode.\nPhase Correct PWM \nModeThe phase correct PWM mode (WGM21:0 = 1) pr ovides a high resolution phase correct PWM\nwaveform generation option. The phase correct PWM mode is based on a dual-slope operation.\nThe counter counts repeatedly from BOTTOM to MAX and then from MAX to BOTTOM. In non-inverting Compare Output mode, the Output Compare (OC2) is cleared on the Compare Matchbetween TCNT2 and OCR2 while upcounting, and set on the Compare Match while downcount-ing. In inverting Output Compare mode, the operation is inverted. The dual-slope operation haslower maximum operation frequency than single slope operation. However, due to the symmet-ric feature of the dual-slope PWM modes, these modes are preferred for motor controlapplications.\nThe PWM resolution for the phase correct PWM m ode is fixed to eight bits. In phase correct\nPWM mode the counter is incremented until the counter value matches MAX. When the counterreaches MAX, it changes  the count direction. The TCNT2 value will be equal to MAX for one\ntimer clock cycle. The timing diagram fo r the phase correct PWM mode is shown on Figure 51 .\nThe TCNT2 value is in the timing diagram shown as a histogram for illustrating the dual-slope\noperation. The diagram includes non-inverted and inverted PWM outputs. The small horizontalline marks on the TCNT2 slopes represent compare matches between OCR2 and TCNT2.\nFigure 51.  Phase Correct PWM Mode, Timing Diagram\nTOVn Interrupt Flag SetOCn Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCn\nOCn(COMn1:0 = 2)\n(COMn1:0 = 3)OCRn Update\n\n112\n2486Z\u2013AVR\u201302/11ATmega8(L)The Timer/Counter Overflow Flag (TOV2) is set each time the counter reaches BOTTOM. The\nInterrupt Flag can be used to generate an interrupt each time the counter reaches the BOTTOMvalue.\nIn phase correct PWM mode, the compare unit allows generation of PWM waveforms on the\nOC2 pin. Setting the COM21:0 bi ts to 2 will produce a non-invert ed PWM. An inverted PWM out-\nput can be generated by setting the COM21:0 to 3 (see Table 45 on page 116 ). The actual OC2\nvalue will only be visible on the port  pin if the data direction for the port pin is set as output. The\nPWM waveform is generated by clearing (or setting) the OC2 Register at the Compare Matchbetween OCR2 and TCNT2 when the counter increments, and setting (or clearing) the OC2Register at Compare Match between OCR2 and TCNT2 when the counter decrements. ThePWM frequency for the output when using phase correct PWM can be calculated by the follow-\ning equation:\nThe N variable represents the prescale factor (1, 8, 32, 64, 128, 256, or 1024).\nThe extreme values for the OCR2 Register represent special cases when generating a PWM\nwaveform output in the phase correct PWM mode. If the OCR2 is set equal to BOTTOM, the out-put will be continuously low and if  set equal to MAX the output will be continuously high for non-\ninverted PWM mode. For inverted PWM the output will have the opposite logic values.\nAt the very start of period 2 in Figure 51 on page 111  OCn has a transition from high to low even\nthough there is no Compare Match. The point of this transition is to guarantee symmetry aroundBOTTOM. There are two cases that give a transition without Compare Match:\n\u0081 OCR2A changes its value from MAX, like in Figure 51 on page 111 . When the OCR2A value \nis MAX the OCn pin value is the same as the result of a down-counting Compare Match. To ensure symmetry around BOTTOM the OCn value at MAX must correspond to the result of an up-counting Compare Match\n\u0081 The timer starts counting from a value higher than the one in OCR2A, and for that reason \nmisses the Compare Match and hence the OCn change that would have happened on the way up\nTimer/Counter \nTiming DiagramsThe following figures show the Timer/Counter in  Synchronous mode, and the timer clock (clkT2)\nis therefore shown as a clock enable  signal. In Asynchronous mode, clkI/O should be replaced by\nthe Timer/Counter Oscillator clock. The figures include information on when Interrupt Flags areset. Figure 52  contains timing data for basic Timer/ Counter operation. The figure shows the\ncount sequence close to the MAX value in all modes other than phase correct PWM mode.\nFigure 52.  Timer/Counter Timing Diagram, no PrescalingfOCnPCPWMfclk_I/O\nN510\u22c5------------------=\nclkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\n\n113\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 53  shows the same timing data, but with the prescaler enabled.\nFigure 53.  Timer/Counter Timing Diagram, with Prescaler (fclk_I/O /8)\nFigure 54  shows the setting of OCF2 in all modes except CTC mode.\nFigure 54.  Timer/Counter Timing Diagram, Setting of OCF2, with Prescaler (fclk_I/O /8)TOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nOCFnOCRnTCNTn\nOCRn ValueOCRn - 1 OCRn OCRn + 1 OCRn + 2clkI/O\nclkTn\n(clkI/O/8)\n\n114\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 55  shows the setting of OCF2 and the clearing of TCNT2 in CTC mode.\nFigure 55.  Timer/Counter Timing Diagram, Clear Ti mer on Compare Match Mode, with Pres-\ncaler (fclk_I/O /8)\n8-bit \nTimer/Counter Register \nDescription\nTimer/Counter Control \nRegister \u2013 TCCR2\n\u0081 Bit 7 \u2013 FOC2: Force Output Compare\nThe FOC2 bit is only active when the WGM bits  specify a non-PWM mode. However, for ensur-\ning compatibility with future devices, this bit must be set to zero when TCCR2 is written whenoperating in PWM mode. When writing a logical one to the FOC2 bit, an immediate CompareMatch is forced on the waveform generation unit. The OC2 output is changed according to itsCOM21:0 bits setting. Note that the FOC2 bit is implemented as a strobe. Therefore it is thevalue present in the COM21:0 bits that determines the effect of the forced compare.\nA FOC2 strobe will not generate any interrupt, nor will it clear the timer in CTC mode using\nOCR2 as TOP.\nThe FOC2 bit is always read as zero.\n\u0081 Bit 6:3 \u2013 WGM21:0: Waveform Generation Mode\nThese bits control the counting sequence of the counter, the source for the maximum (TOP)\ncounter value, and what type of waveform generation to be used. Modes of operation supportedby the Timer/Counter unit are: Normal mode, Clear Timer on Compare Match (CTC) mode, andtwo types of Pulse Width Modulation (PWM) modes. See Table 42 on page 115  and \u201cModes of\nOperation\u201d on page 108 .OCFnOCRnTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nB i t 76543210\nFOC2 WGM20 COM21 COM20 WGM21 CS22 CS21 CS20 TCCR2\nRead/Write W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n\n115\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: 1. The CTC2 and PWM2 bit definition names are now obsolete. Use the WGM21:0 definitions.\nHowever, the functionality and location of these bits are compatible with previous versions of\nthe timer\n\u0081 Bit 5:4 \u2013 COM21:0: Compare Match Output Mode\nThese bits control the Output Compare Pin (OC2) behavior. If one or both of the COM21:0 bits\nare set, the OC2 output overrides the normal port functionality of the I/O pin it is connected to.However, note that the Data Direction Register (DDR) bit corresponding to OC2 pin must be setin order to enable the output driver.\nWhen OC2 is connected to the pin, the function of the COM21:0 bits depends on the WGM21:0\nbit setting.\nTable 43  shows the COM21:0 bit functionality when the WGM21:0 bits are set to a normal or\nCTC mode (non-PWM).\nTable 44  shows the COM21:0 bit functionality when the WGM21:0 bits are set to fast PWM\nmode.\nNote: 1. A special case occurs when OCR2 equals TO P and COM21 is set. In this case, the Compare\nMatch is ignored, but the set or clear is done at BOTTOM. See \u201cFast PWM Mode\u201d on page 110\nfor more detailsTable 42.  Waveform Generation Mode Bit Description\nModeWGM21\n(CTC2)WGM20\n(PWM2)Timer/Counter Mode \nof Operation(1)TOPUpdate of\nOCR2TOV2 Flag\nSet\n0 0 0 Normal 0xFF Immediate MAX\n1 0 1 PWM, Phase Correct 0xFF TOP BOTTOM\n2 1 0 CTC OCR2 Immediate MAX3 1 1 Fast PWM 0xFF BOTTOM MAX\nTable 43.  Compare Output Mode, Non-PWM Mode\nCOM21 COM20 Description\n0 0 Normal port operation, OC2 disconnected\n0 1 Toggle OC2 on Compare Match\n1 0 Clear OC2 on Compare Match1 1 Set OC2 on Compare Match\nTable 44.  Compare Output Mode, Fast PWM Mode(1)\nCOM21 COM20 Description\n0 0 Normal port operation, OC2 disconnected\n01 R e s e r v e d1 0 Clear OC2 on Compare Match, set OC2 at BOTTOM, \n(non-inverting mode)\n1 1 Set OC2 on Compare Match, clear OC2 at BOTTOM,\n(inverting mode)\n\n116\n2486Z\u2013AVR\u201302/11ATmega8(L)Table 45  shows the COM21:0 bit functionality when the WGM21:0 bits are set to phase correct\nPWM mode.\nNote: 1. A special case occurs when OCR2 equals TO P and COM21 is set. In this case, the Compare\nMatch is ignored, but the set or clear is done at TOP . See \u201cPhase Correct PWM Mode\u201d on page\n111 for more details\n\u0081 Bit 2:0 \u2013 CS22:0: Clock Select\nThe three clock select bits select the clock source to be used by the Timer/Counter, see Table\n46.\nTimer/Counter \nRegister \u2013 TCNT2\nThe Timer/Counter Register gives direct ac cess, both for read and write operations, to the\nTimer/Counter unit 8-bit counter. Writing to the TCNT2 Register blocks (removes) the CompareMatch on the following timer clock. Modifying the counter (TCNT2) while the counter is running,introduces a risk of missing a Compare Match between TCNT2 and the OCR2 Register.\nOutput Compare \nRegister \u2013 OCR2\nThe Output Compare Register contains an 8-bit value that is continuously compared with the\ncounter value (TCNT2). A match can be used to generate an Output Compare interrupt, or togenerate a waveform output on the OC2 pin.Table 45.  Compare Output Mode, Phase Correct PWM Mode\n(1)\nCOM21 COM20 Description\n0 0 Normal port operation, OC2 disconnected\n01 R e s e r v e d\n10Clear OC2 on Compare Match when up-counting. Set OC2 on Compare \nMatch when downcounting\n11Set OC2 on Compare Match when up-counting. Clear OC2 on Compare \nMatch when downcounting\nTable 46.  Clock Select Bit Description\nCS22 CS21 CS20 Description\n0 0 0 No clock source (Timer/Counter stopped)\n001 c l kT2S/(No prescaling)\n010 c l kT2S/8 (From prescaler)\n011 c l kT2S/32 (From prescaler)\n100 c l kT2S/64 (From prescaler)\n101 c l kT2S/128 (From prescaler)\n110 c l kT2S/256 (From prescaler)\n111 c l kT2S/1024 (From prescaler)\nB i t 76543210\nTCNT2[7:0] TCNT2\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCR2[7:0] OCR2\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n117\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAsynchronous \nOperation of the \nTimer/Counter\nAsynchronous Status \nRegister \u2013 ASSR\n\u0081 Bit 3 \u2013 AS2: Asynchronous Timer/Counter2\nWhen AS2 is written to zero , Timer/Counter 2 is clocked from the I/O clock, clkI/O. When AS2 is\nwritten to one, Timer/C ounter 2 is clocked from a crystal Os cillator connected to the Timer Oscil-\nlator 1 (TOSC1) pin. When the value of AS2 is changed, the contents of TCNT2, OCR2, andTCCR2 might be corrupted.\n\u0081 Bit 2 \u2013 TCN2UB: Timer/Counter2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set.\nWhen TCNT2 has been updated from the temporary storage register, this bit is cleared by hard-ware. A logical zero in this bit indicates that TCNT2 is ready to be updated with a new value.\n\u0081 Bit 1 \u2013 OCR2UB: Output Co mpare Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and OCR2 is written, this bit becomes set.\nWhen OCR2 has been updated from the temporary storage register, this bit is cleared by hard-ware. A logical zero in this bit indicates that OCR2 is ready to be updated with a new value.\n\u0081 Bit 0 \u2013 TCR2UB: Timer/Counter Control Register2 Update Busy\nWhen Timer/Counter2 operates asynchronously and TCCR2 is written, this bit becomes set.\nWhen TCCR2 has been updated from the temporary storage register, this bit is cleared by hard-ware. A logical zero in this bit indicates that  TCCR2 is ready to be updated with a new value.\nIf a write is performed to any of the three Timer/Counter2 Registers while its update busy flag is\nset, the updated value might get corrupted and cause an unintentional interrupt to occur.\nThe mechanisms for reading TCNT2, OCR2, and TCCR2 are different. When reading TCNT2,\nthe actual timer value is read. When reading OC R2 or TCCR2, the value in the temporary stor-\nage register is read.\nAsynchronous \nOperation of Timer/Counter2When Timer/Counter2 operates asynchronously, some considerations must be taken.\n\u0081 Warning: When switching between asynchronous and synchronous clocking of \nTimer/Counter2, the Timer Registers TCNT2, OCR2, and TCCR2 might be corrupted. A safe procedure for switching clock source is:\n1. Disable the Timer/Counter2 interrupts by clearing OCIE2 and TOIE22. Select clock source by setting AS2 as appropriate3. Write new values to TCNT2, OCR2, and TCCR24. To switch to asynchronous operatio n: Wait for TCN2UB, OCR2UB, and TCR2UB\n5. Clear the Timer/Counter2 Interrupt Flags6. Enable interrupts, if needed\n\u0081 The Oscillator is optimized fo r use with a 32.768kHz watch crys tal. Applying an external \nclock to the TOSC1 pin may result in incorrect Timer/Counter2 operation. The CPU main clock frequency must be more than four times the Oscillator frequency\n\u0081 When writing to one of the r egisters TCNT2, OCR2, or TCCR2, the value is transferred to a \ntemporary register, and latched after two positive edges on TOSC1. The user should not B i t 76543 2 1 0\n\u2013 \u2013 \u2013 \u2013 AS2 TCN2UB OCR2UB TCR2UB ASSR\nR e a d / W r i t e RRRR R / W R R R\nInitial Value 0 0 0 0 0 0 0 0\n\n118\n2486Z\u2013AVR\u201302/11ATmega8(L)write a new value before the contents of the temporary register have been transferred to its \ndestination. Each of the three mentioned registers have their individual temporary register, which means that, for example, writing to TCNT2 does not disturb an OCR2 write in progress. To detect that a transfer to the destination register has taken place, the Asynchronous Status  Register \u2013 ASSR has been implemented\n\u0081 When entering Power-save mode after having written to TCNT2, OCR2, or TCCR2, the user \nmust wait until the written register has been updated if Timer/Counter2 is used to wake up the device. Otherwise, the MCU will enter sleep m ode before the changes are effective. This \nis particularly important if the Output Compare2 interrupt is used to wake up the device, since the Output Compare function is disabled during writing to OCR2 or TCNT2. If the write cycle is not finished, and the MCU enters sleep mode before the OCR2UB bit returns to zero, the device will never receive a Compare Match interrupt, and the MCU will not wake up\n\u0081 If Timer/Counter2 is used to wake the device up from Power-save mode, precautions must \nbe taken if the user wants to re-enter one of these modes: The interrupt logic needs one TOSC1 cycle to be reset. If the time between wake-up and re-entering sleep mode is less than one TOSC1 cycle, the interrupt will not occur,  and the device will fail to wake up. If the \nuser is in doubt whether the time before re-entering Power-save or Extended Standby mode is sufficient, the following algorithm can be used to ensure that one TOSC1 cycle has elapsed:\n1. Write a value to TCCR2, TCNT2, or OCR22. Wait until the corresponding Update Busy Flag in ASSR returns to zero3. Enter Power-save or Extended Standby mode\n\u0081 When the asynchronous operati on is selected, the 32.768kH Z Oscillator for Timer/Counter2 \nis always running, except in Power-down and Standby modes. After a Power-up Reset or Wake-up from Power-down or Standby mode, the user should be aware of the fact that this Oscillator might take as long as  one second to stabilize. The us er is advised to wait for at \nleast one second before using Timer/Counter2 after Power-up or Wake-up from Power-down or Standby mode. The contents of all Timer/Counter2 Registers must be considered lost after a wake-up from Power-down or Standby mode due to unstable clock signal upon start-up, no matter whether the Oscillator is in use or a clock signal is applied to the TOSC1 pin\n\u0081 Description of wake up from Power-save or Extended Standby mode when the timer is \nclocked asynchronously: When the interrupt condit ion is met, the wake up process is started \non the following cycle of the timer clock, that is, the timer is always advanced by at least one before the processor can read the counter value. After wake-up, the MCU is halted for four cycles, it executes the interrupt routine, and resumes execution from the instruction \nfollowing SLEEP\n\u0081 Reading of the TCNT2 Register shortly after wake-up from Power-save may give an \nincorrect result. Since TCNT2 is clocked on the asynchronous TOSC clock, reading TCNT2 must be done through a register synchronized to the internal I/O clock domain. Synchronization takes place for every rising TOSC1 edge. When waking up from Power-save mode, and the I/O clock (clk\nI/O) again becomes active, TCNT2 will read as the previous \nvalue (before entering sleep) until the next rising TOSC1 edge. The phase of the TOSC clock after waking up from Power-save mode is essentially unpredictable, as it depends on the wake-up time. The recommended procedure for reading TCNT2 is thus as follows:\n1. Write any value to either of the registers OCR2 or TCCR22. Wait for the corresponding Update Busy Flag to be cleared3. Read TCNT2\n\n119\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 During asynchronous operation, the synchronization of the Interrupt Flags for the \nasynchronous timer takes three p rocessor cycles plus one timer cycle. The timer is therefore \nadvanced by at least one before the processo r can read the timer value causing the setting \nof the Interrupt Flag. The Output Compare Pin is changed on the timer clock and is not synchronized to the processor clock\nTimer/Counter \nInterrupt Mask Register \u2013 TIMSK\n\u0081 Bit 7 \u2013 OCIE2: Timer/Counter2 Output Compare Match Interrupt Enable\nWhen the OCIE2 bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Compare Match interrupt is enabled. The corresponding interrupt is executed ifa Compare Match in Timer/Counter2 occurs (that is, when the OCF2 bit is set in theTimer/Counter Interrupt Flag Register \u2013 TIFR).\n\u0081 Bit 6 \u2013 TOIE2: Timer/Counter2 Overflow Interrupt Enable\nWhen the TOIE2 bit is written to one and the I-bit in the Status Register is set (one), the\nTimer/Counter2 Overflow interrupt is enabled. The corresponding interrupt is executed if an\noverflow in Timer/Counter2 occurs (that is, when the TOV2 bit is set in the Timer/Counter Inter-rupt Flag Register \u2013 TIFR).\nTimer/Counter \nInterrupt Flag Register \u2013 TIFR\n\u0081 Bit 7 \u2013 OCF2: Output Compare Flag 2\nThe OCF2 bit is set (one) when a Compare Match occurs between the Timer/Counter2 and the\ndata in OCR2 \u2013 Output Compare Register2. OCF2 is cleared by hardware when executing thecorresponding interrupt Handling Vector. Alternatively, OCF2 is cleared by writing a logic one tothe flag. When the I-bit in SREG, OCIE2 (Timer/Counter2 Compare Match Interrupt Enable), andOCF2 are set (one), the Timer/Counter2  Compare Match Interrupt is executed.\n\u0081 Bit 6 \u2013 TOV2: Timer/Counter2 Overflow Flag\nThe TOV2 bit is set (one) when an overflow occu rs in Timer/Counter2. TOV2 is cleared by hard-\nware when executing the corresponding interrupt  Handling Vector. Alternatively, TOV2 is\ncleared by writing a logic one to the flag. When the SREG I-bit, TOIE2 (Timer/Counter2 OverflowInterrupt Enable), and TOV2 are set (one), the Timer/Counter2 Overflow interrupt is executed. InPWM mode, this bit is set when Timer/Coun ter2 changes counting direction at 0x00.B i t 76543210\nOCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 \u2013 TOIE0 TIMSK\nRead/Write R/W R/W R/W R/W R/W R/W R R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210\nOCF2 TOV2 ICF1 OCF1A OCF1B TOV1 \u2013 TOV0 TIFR\nRead/Write R/W R/W R/W R/W R/W R/W R R/WI n i t i a l  V a l u e 00000000\n\n120\n2486Z\u2013AVR\u201302/11ATmega8(L)Timer/Counter \nPrescalerFigure 56.  Prescaler for Timer/Counter2\nThe clock source for Timer/Counter2 is named clkT2S. clkT2S is by default connected to the main\nsystem I/O clock clkI/O. By setting the AS2 bit in ASSR , Timer/Counter2 is asynchronously\nclocked from the TOSC1 pin. This enables us e of Timer/Counter2 as a Real Time Counter\n(RTC). When AS2 is set, pins TOSC1 and TOSC2 are disconnected from Port B. A crystal can\nthen be connected between the TOSC1 and TOSC2 pins to serve as an independent clocksource for Timer/Counter2. The Oscillator is optimized for use with a 32.768kHz crystal. Apply-\ning an external clock source to TOSC1 is not recommended.\nFor Timer/Counter2, the possible prescaled selections are: clk\nT2S/8, clkT2S/32, clkT2S/64,\nclkT2S/128, clkT2S/256, and clkT2S/1024. Additionally, clkT2S as well as 0 (stop) may be selected.\nSetting the PSR2 bit in SFIOR resets the prescale r. This allows the user to operate with a pre-\ndictable prescaler.\nSpecial Function IO \nRegister \u2013 SFIOR\n\u0081 Bit 1 \u2013 PSR2: Prescaler Reset Timer/Counter2\nWhen this bit is written to on e, the Timer/Coun ter2 prescaler will be reset. The bit will be cleared\nby hardware after the operation is performed. Writing a zero to this  bit will have no effect. This bit\nwill always be read as zero if Timer/Counter2 is clocked by the internal CPU clock. If this bit iswritten when Timer/Counter2 is operating in Asynchronous mode, the bit will remain one untilthe prescaler has been reset.10-BIT T/C PRESCALER\nTIMER/COUNTER2 CLOCK SOURCEclkI/O clkT2S\nTOSC1\nAS2\nCS20\nCS21\nCS22clkT2S/8\nclkT2S/64\nclkT2S/128\nclkT2S/1024\nclkT2S/256\nclkT2S/32\n0PSR2Clear\nclkT2\nBit 7 6 5 4 3 2 1 0\n\u2013 \u2013 \u2013 \u2013 ACME PUD PSR2 PSR10 SFIOR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n\n121\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSerial \nPeripheral \nInterface \u2013 SPIThe Serial Peripheral Interface (SPI) allows hi gh-speed synchronous data transfer between the\nATmega8 and peripheral devices or between several AVR devices. The ATmega8 SPI includesthe following features:\n\u0081\nFull-duplex, Three-wire Synchronous Data Transfer\n\u0081Master or Slave Operation\n\u0081LSB First or MSB First Data Transfer\n\u0081Seven Programmable Bit Rates\n\u0081End of Transmission Interrupt Flag\n\u0081Write Collision Flag Protection\n\u0081Wake-up from Idle Mode\n\u0081Double Speed (CK/2) Master SPI Mode\nFigure 57.  SPI Block Diagram(1)\nNote: 1. Refer to \u201cPin Configurations\u201d on page 2 , and Table 22 on page 58  for SPI pin placement\nThe interconnection between Master and Slave CPUs with SPI is shown in Figure 58 on page\n122. The system consists of two Shift Registers,  and a Master clock ge nerator. The SPI Master\ninitiates the communication cycle wh en pulling low the Slave Select SS  pin of the desired Slave.\nMaster and Slave prepare the data to be sent in their respective Shift Registers, and the Mastergenerates the required clock pulses on the SCK line to interchange data. Data is always shifted\nfrom Master to Slave on the Master Out \u2013 Slave In, MOSI, line, and from Slave to Master on theMaster In \u2013 Slave Out, MISO, line. After each data packet, the Master will synchronize the Slave\nby pulling high the Slave Select, SS\n, line.\nWhen configured as a Master, the SPI interface has no automatic control of the SS  line. This\nmust be handled by user software before communication can start. When this is done, writing a\nSPI2XSPI2XDIVIDER\n/2/4/8/16/32/64/128\n\n122\n2486Z\u2013AVR\u201302/11ATmega8(L)byte to the SPI Data Register starts the SPI clock generator, and the hardware shifts the eight\nbits into the Slave. After shifting one byte , the SPI clock generator stops, setting the end of\nTransmission Flag (SPIF). If the SPI interrupt enable bit (SPIE) in the SPCR Register is set, aninterrupt is requested. The Master may continue to shift the next byte by writing it into SPDR, orsignal the end of packet by pulling high the Slave Select, SS\n line. The last incoming byte will be\nkept in the Buffer Register for later use.\nWhen configured as a Slave, the SPI interface will remain  sleeping with MISO tri-stated as long\nas the SS  pin is driven high. In this state, software may update the contents of the SPI Data\nRegister, SPDR, but the data will not be shifted out by incoming clock pulses on the SCK pinuntil the SS\n pin is driven low. As one byte has been completely shifted, the end of Transmission\nFlag, SPIF is set. If the SPI interrupt enable bit, SPIE, in the SPCR Register is set, an interrupt isrequested. The Slave may continue to place new data to be sent into SPDR before reading theincoming data. The last incomi ng byte will be kept in the Buffer Register  for later use.\nFigure 58.  SPI Master-Slave Interconnection\nThe system is single buffered in the transmit di rection and double buffered in the receive direc-\ntion. This means that bytes to be transmitted cannot be written to the SPI Data Register beforethe entire shift cycle is complet ed. When receiving data, however,  a received character must be\nread from the SPI Data Register before the next character has been completely shifted in. Oth-erwise, the first byte is lost.\nIn SPI Slave mode, the control logic will sample  the incoming signal of the SCK pin. To ensure\ncorrect sampling of the clock signal, the minimum low and high periods should be:\nLow period : longer than 2 CPU clock cycles\nHigh period : longer than 2 CPU clock cycles\nWhen the SPI is enabled, the data direction of the MOSI, MISO, SCK, and SS\n pins is overridden\naccording to Table 47 . For more details on automatic port overrides, refer to \u201cAlternate Port\nFunctions\u201d on page 56 .\nNote: 1. See \u201cPort B Pins Alternate Functions\u201d on page 58  for a detailed description of how to define\nthe direction of the user defined SPI pinsTable 47.  SPI Pin Overrides(1)\nPin Direction, Master SPI Direction, Slave SPI\nMOSI User Defined InputMISO Input User Defined\nSCK User Defined Input\nSS\nUser Defined InputMSB MASTER LSB\n8 BIT SHIFT REGISTERMSB SLAVE LSB\n8 BIT SHIFT REGISTERMISO\nMOSI\nSPI\nCLOCK GENERATORSCK\nSSMISO\nMOSI\nSCK\nSS\nVCCSHIFT\nENABLE\n\n123\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe following code examples show how to initialize the SPI as a Master and how to perform a\nsimple transmission. DDR_SPI in the examples mu st be replaced by the actual Data Direction\nRegister controlling the SPI pins. DD_MOSI, DD_MISO and DD_SCK must be replaced by theactual data direction bits for these pins. For example if MOSI is placed on pin PB5, replace\nDD_MOSI with DDB5 and DDR_SPI with DDRB.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8Assembly Code Example(1)\nSPI_MasterInit:\n; Set MOSI and SCK output, all others input\nldir17,(1<<DD_MOSI)|(1<<DD_SCK)\noutDDR_SPI,r17\n; Enable SPI, Master, set clock rate fck/16\nldir17,(1<<SPE)|(1<<MSTR)|(1<<SPR0)\noutSPCR,r17\nret\nSPI_MasterTransmit:\n; Start transmission of data (r16)\noutSPDR,r16\nWait_Transmit:\n; Wait for transmission complete\nsbisSPSR,SPIF\nrjmpWait_Transmit\nret\nC Code Example(1)\nvoid SPI_MasterInit( void)\n{\n/* Set MOSI and SCK output, all others input */\nDDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);\n/* Enable SPI, Master, set clock rate fck/16 */SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);\n}\nvoid SPI_MasterTransmit( char cData)\n{\n/* Start transmission */SPDR = cData;\n/* Wait for transmission complete */\nwhile(!(SPSR & (1<<SPIF)))\n;\n}\n\n124\n2486Z\u2013AVR\u201302/11ATmega8(L)The following code examples show how to initialize the SPI as a Slave and how to perform a\nsimple reception.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8Assembly Code Example(1)\nSPI_SlaveInit:\n; Set MISO output, all others input\nldir17,(1<<DD_MISO)\noutDDR_SPI,r17\n; Enable SPI\nldir17,(1<<SPE)\noutSPCR,r17\nret\nSPI_SlaveReceive:\n; Wait for reception complete\nsbisSPSR,SPIF\nrjmpSPI_SlaveReceive\n; Read received data and return\ninr16,SPDR\nret\nC Code Example(1)\nvoid SPI_SlaveInit( void)\n{\n/* Set MISO output, all others input */\nDDR_SPI = (1<<DD_MISO);\n/* Enable SPI */SPCR = (1<<SPE);\n}\nchar SPI_SlaveReceive( void)\n{\n/* Wait for reception complete */while(!(SPSR & (1<<SPIF)))\n;\n/* Return data register */return SPDR;\n}\n\n125\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSS Pin \nFunctionality\nSlave Mode When the SPI is configured as a Slave, the Slave Select (SS)  pin is always input. When SS  is\nheld low, the SPI is activated, and MISO becomes  an output if configured so by the user. All\nother pins are inputs. When SS  is driven high, all pins are inputs except MISO which can be user\nconfigured as an output, and the SPI is passive, which means that it will not receive incoming\ndata. Note that the SPI lo gic will be reset once the SS  pin is driven high.\nThe SS  pin is useful for packet/byte synchronizat ion to keep the Slave bit counter synchronous\nwith the master clock generator. When the SS  pin is driven high, the SPI Slave will immediately\nreset the send and receive logic, and drop any partially received data in the Shift Register.\nMaster Mode When the SPI is configured as a Master (MSTR in SPCR is set), the user can determine the\ndirection of the SS  pin.\nIf SS  is configured as an output, the pin is a general output pin which does not affect the SPI\nsystem. Typically, the pin will be driving the SS  pin of the SPI Slave.\nIf SS  is configured as an input, it must be held high to ensure Master SPI operation. If the SS  pin\nis driven low by peripheral circuitry when the SPI is configured as a Master with the SS  pin\ndefined as an input, the SPI syst em interprets this as another Master selecting the SPI as a\nSlave and starting to send data to it. To avoid bus contention, the SPI system takes the followingactions:\n1. The MSTR bit in SPCR is cleared and the SPI system becomes a Slave. As a result of\nthe SPI becoming a Slave, the MOSI and SCK pins become inputs\n2. The SPIF Flag in SPSR is set, and if the SPI interrupt is enabled, an d the I-bit in SREG is\nset, the interrupt routine will be executed\nThus, when interrupt-driven SPI transmission is used in Master mode, and there exists a possi-\nbility that SS\n is driven low, the interrup t should always check that the MSTR bit is still set. If the\nMSTR bit has been cleared by a Slave Select, it must be set by the user to re-enable SPI Mastermode.\nSPI Control Register \u2013 \nSPCR\n\u0081 Bit 7 \u2013 SPIE: SPI  Interrupt Enable\nThis bit causes the SPI in terrupt to be executed if SPIF bit in the SPSR Register is set and the if\nthe global interrupt enable bit in SREG is set.\n\u0081 Bit 6 \u2013 SPE: SPI Enable\nWhen the SPE bit is written to one, the SPI is enabled. This bit must be set to enable any SPI\noperations.\n\u0081 Bit 5 \u2013 DORD: Data Order\nWhen the DORD bit is written to one, the LSB of the data word is transmitted first.\nWhen the DORD bit is written to zero, the MSB of the data word is transmitted first.B i t 76543210\nSPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 SPCR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n126\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 4 \u2013 MSTR: Master/Slave Select\nThis bit selects Master SPI mode when written to one, and Slave SPI mode when written logic\nzero. If SS  is configured as an input and is driven low while MSTR is set, MSTR will be cleared,\nand SPIF in SPSR will become set. The user will th en have to set MSTR to re-enable SPI Mas-\nter mode.\n\u0081 Bit 3 \u2013 CPOL: Clock Polarity\nWhen this bit is written to one,  SCK is high when idle. When CPOL is written to zero, SCK is low\nwhen idle. Refer to Figure 59 on page 128  and Figure 60 on page 128  for an example. The\nCPOL functionality is summarized below:\n\u0081 Bit 2 \u2013 CPHA: Clock Phase\nThe settings of the clock phase bit (CPHA) determine if data is sampled on the leading (first) or\ntrailing (last) edge of SCK. Refer to Figure 59 on page 128  and Figure 60 on page 128  for an\nexample. The CPHA functionality is summarized below:\n\u0081 Bits 1, 0 \u2013 SPR1, SPR0: SPI Clock Rate Select 1 and 0\nThese two bits control the SCK rate of the dev ice configured as a Master. SPR1 and SPR0 have\nno effect on the Slave. The relationship between SCK and the Oscillator Clock frequency fosc is\nshown in the following table:\nSPI Status Register \u2013 \nSPSRTable 48.  CPOL Functionality\nCPOL Leading Edge Trailing Edge\n0 Rising Falling\n1 Falling Rising\nTable 49.  CPHA Functionality\nCPHA Leading Edge Trailing Edge\n0 Sample Setup\n1S e t u p S a m p l e\nTable 50.  Relationship Between SCK an d the Oscillator Frequency \nSPI2X SPR1 SPR0 SCK Frequency\n00 0 fosc/4\n00 1 fosc/16\n01 0 fosc/64\n01 1 fosc/128\n10 0 fosc/2\n10 1 fosc/8\n11 0 fosc/32\n11 1 fosc/64\nB i t 76543210\nS P I F W C O L \u2013\u2013\u2013\u2013\u2013 S P I 2 X S P S R\nR e a d / W r i t e RRRRRRR R / WI n i t i a l  V a l u e 00000000\n\n127\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 7 \u2013 SPIF: SPI Interrupt Flag\nWhen a serial transfer is complete, the SPIF Flag is set. An interrupt is generated if SPIE in\nSPCR is set and global interrupts are enabled. If SS  is an input and is dr iven low when the SPI is\nin Master mode, this will also set the SPIF Flag. SPIF is cleared by hardwa re when executing the\ncorresponding interrupt Handling Vector. Alternativel y, the SPIF bit is cleared by first reading the\nSPI Status Register with SPIF set, then accessing the SPI Data Register (SPDR).\n\u0081 Bit 6 \u2013 WCOL: Write COLlision Flag\nThe WCOL bit is set if the SPI Data Register (SPDR) is written during a data transfer. The\nWCOL bit (and the SPIF bit) are cleared by first reading the SPI Status Register with WCOL set,and then accessing the SPI Data Register.\n\u0081 Bit 5..1 \u2013 Res: Reserved Bits\nThese bits are reserved bits in the ATmega8 and will always read as zero.\n\u0081 Bit 0 \u2013 SPI2X: Double SPI Speed Bit\nWhen this bit is written logi c one the SPI speed (SCK Freque ncy) will be doubled when the SPI\nis in Master mode (see Table 50 on page 126 ). This means th at the minimum SCK period will be\n2 CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work atf\nosc/4 or lower.\nThe SPI interface on the ATmega8 is also used for Program memory and EEPROM download-\ning or uploading. See page 230  for Serial Programming and verification.\nSPI Data Register \u2013 \nSPDR\nThe SPI Data Register is a Read/Write Register used for data transfer between the Register File\nand the SPI Shift Register. Writing to the register initiates data transmission. Reading the regis-ter causes the Shift Register Receive buffer to be read.\nData Modes There are four combinations of SCK phase and polarity with respect to serial data, which aredetermined by control bits CPHA and CPOL. The SPI data transfer formats are shown in Figure\n59 on page 128  and Figure 60 on page 128 . Data bits are shifted out and latched in on opposite\nedges of the SCK signal, ensuring sufficient time fo r data signals to stabilize. This is clearly seen\nby summarizing Table 48 on page 126  and Table 49 on page 126 , as done below:B i t 76543210\nMSB LSB SPDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value X X X X X X X X Undefined\nTable 51.  CPOL and CPHA Functionality\nLeading Edge Trailing Edge SPI Mode\nCPOL = 0, CPHA = 0 Sample (Rising) Setup (Falling) 0\nCPOL = 0, CPHA = 1 Setup (Rising) Sample (Falling) 1CPOL = 1, CPHA = 0 Sample (Falling) Setup (Rising) 2\nCPOL = 1, CPHA = 1 Setup (Falling) Sample (Rising) 3\n\n128\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 59.  SPI Transfer Format with CPHA = 0\nFigure 60.  SPI Transfer Format with CPHA = 1Bit 1\nBit 6LSB\nMSBSCK (CPOL = 0)\nmode 0\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 2\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5MSB first (DORD = 0)\nLSB first (DORD = 1)\nSCK (CPOL = 0)\nmode 1\nSAMPLE I\nMOSI/MISO\nCHANGE 0\nMOSI PIN\nCHANGE 0\nMISO PINSCK (CPOL = 1)\nmode 3\nSS\nMSB\nLSBBit 6\nBit 1Bit 5\nBit 2Bit 4\nBit 3Bit 3\nBit 4Bit 2\nBit 5Bit 1\nBit 6LSB\nMSBMSB first (DORD = 0)\nLSB first (DORD = 1)\n\n129\n2486Z\u2013AVR\u201302/11ATmega8(L)\nUSART The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a\nhighly-flexible serial communication device. The main features are:\n\u0081Full Duplex Operation (I ndependent Serial Receive  and Transmit Registers)\n\u0081Asynchronous or Synchronous Operation\n\u0081Master or Slave Clocked Synchronous Operation\n\u0081High Resolution Baud Rate Generator\n\u0081Supports Serial Frames with 5, 6, 7, 8, or 9 Databits and 1 or 2 Stop Bits\n\u0081Odd or Even Parity Generation and Parity Check Supported by Hardware\n\u0081Data OverRun Detection\n\u0081Framing Error Detection\n\u0081Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter\n\u0081Three Separate Interrupts on TX Complete , TX Data Register Empty and RX Complete\n\u0081Multi-processor Communication Mode\n\u0081Double Speed Asynchronous Communication Mode\nOverview A simplified block diagram of the USART Transmitter is shown in Figure 61 . CPU accessible I/O\nRegisters and I/O pins are shown in bold.\nFigure 61.  USART Block Diagram(1)\nNote: 1. Refer to \u201cPin Configurations\u201d on page 2 , Table 30 on page 64 , and Table 29 on page 64  for\nUSART pin placementPARITY\nGENERATORUBRR[H:L]\nUDR  (Transmit)\nUCSRA UCSRB UCSRCBAUD RATE GENERATOR\nTRANSMIT SHIFT REGISTER\nRECEIVE SHIFT REGISTER RxDTxDPIN\nCONTROL\nUDR (Receive)PIN\nCONTROLXCK\nDATA\nRECOVERYCLOCK\nRECOVERYPIN\nCONTROL\nTX\nCONTROL\nRX\nCONTROL\nPARITY\nCHECKERDATABUSOSC\nSYNC LOGICClock Generator\nTransmitter\nReceiver\n\n130\n2486Z\u2013AVR\u201302/11ATmega8(L)The dashed boxes in the block diagram separate the three main parts of the USART (listed from\nthe top): Clock generator, Transmitter and Receiver. Control Registers are shared by all units.The clock generation logic consists of synchronizati on logic for external clock input used by syn-\nchronous slave operation, and the baud rate generator. The XCK (transfer clock) pin is onlyused by synchronous transfer mode. The Transmitter consists of a single write buffer, a serial\nShift Register, Parity Generator and control logic for handling different serial frame formats. Thewrite buffer allows a continuous transfer of  data without any delay between frames. The\nReceiver is the most complex part of the USART module due to its clock and data recoveryunits. The recovery units are used for asynchronous data reception. In addition to the recoveryunits, the Receiver includes a parity checker, control logic, a Shift Register and a two levelreceive buffer (UDR). The Receiver supports the same frame formats as the Transmitter, andcan detect Frame Error, Data OverRun and Parity Errors.\nAVR USART vs. AVR \nUART \u2013 CompatibilityThe USART is fully compatible  with the AVR UART regarding:\n\u0081 Bit locations inside all USART Registers\u0081 Baud Rate Generation\u0081 Transmitter Operation\u0081 Transmit Buffer Functionality\u0081 Receiver Operation\nHowever, the receive bu ffering has two improvements that will affect the comp atibility in some\nspecial cases:\n\u0081 A second Buffer Register has been added. The two Buffer Registers operate as a circular \nFIFO buffer. Therefore the UDR must only be read once for each incoming data! More important is the fact that the Error Flags (FE and DOR) and the ninth data bit (RXB8) are buffered with the data in the receive buffer. Therefore the status bits must always be read before the UDR Register is read.  Otherwise the error status will be  lost since the buffer state \nis lost\n\u0081 The Receiver Shift Register can now act as a th ird buffer level. This is done by allowing the \nreceived data to remain in the serial Shift Register (see Figure 61 on page 129 ) if the Buffer \nRegisters are full, until a new start bit is detected. The USART is therefore more resistant to Data OverRun (DOR) error conditions\nThe following control bits have changed name, but have same functionality and register location:\n\u0081 CHR9 is changed to UCSZ2\u0081 OR is changed to DOR\nClock Generation The clock generation logic generates the base  clock for the Transmitter and Receiver. The\nUSART supports four modes of clock operation: normal asynchronous, double speed asynchro-\nnous, Master synchronous and Slave Synchron ous mode. The UMSEL bit in USART Control\nand Status Register C (UCSRC) selects between asynchronous and synchronous operation.Double speed (Asynchronous mode only) is cont rolled by the U2X found in the UCSRA Regis-\nter. When using Synchronous mode (UMSEL = 1), the Data Direction Register for the XCK pin(DDR_XCK) controls whether the clock source is  internal (Master mode) or external (Slave\nmode). The XCK pin is only active when using Synchronous mode.\nFigure 62 on page 131  shows a block diagram of the clock generation logic.\n\n131\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 62.  Clock Generation Logic, Block Diagram\nSignal description:\ntxclk Transmitter clock. (Internal Signal)\nrxclk Receiver base clock. (Internal Signal)\nxcki Input from XCK pin (internal Signal). Used for synchronous slave operation\nxcko Clock output to XCK pin (Internal Signal). Used for synchronous master\noperation\nfosc XTAL pin frequency (System Clock)\nInternal Clock \nGeneration \u2013 The Baud Rate GeneratorInternal clock generation is used for the asyn chronous and the Synchronous Master modes of\noperation. The description in this section refers to Figure 62 .\nThe USART Baud Rate Register (UBRR) and the down-counter connected to it function as a\nprogrammable prescaler or baud rate generator. The down-counter, running at system clock\n(fosc), is loaded with the UBRR value each time the counter has counted down to zero or when\nthe UBRRL Register is written. A clock is gener ated each time the counter reaches zero. This\nclock is the baud rate generator clock output (= fosc/(UBRR+1)). The Transmitter divides the\nbaud rate generator clock output by 2, 8, or 16 depending on mode. The baud rate generatoroutput is used directly by the Receiver\u2019s clock and data recovery units. However, the recoveryunits use a state machine that uses 2, 8, or 16 states depending on mode set by the state of theUMSEL, U2X and DDR_XCK bits.\nTable 52 on page 132  contains equations for calculating the baud rate (in bits per second) and\nfor calculating the UBRR value for each mode of operation using an internally generated clocksource.Prescaling\nDown-Counter/ 2UBRR\n/ 4 / 2fosc\nUBRR+1\nSync\nRegisterOSC\nXCK\nPintxclkU2X\nUMSELDDR_XCK0\n1\n01\nxcki\nxcko\nDDR_XCK\nrxclk\n0110Edge\nDetector\nUCPOL\n\n132\n2486Z\u2013AVR\u201302/11ATmega8(L)Note: 1. The baud rate is defined to be the transfer rate in bit per second (bps)\nBAUD Baud rate (in bits per second, bps)\nfOSC System Oscillator clock frequency\nUBRR Contents of the UBRRH and UBRRL Registers (0 - 4095)\nSome examples of UBRR values for some  system clock frequencies are found in Table 60 on\npage 153 .\nDouble Speed \nOperation (U2X)The transfer rate can be doubled by setting the U2X bit in UCSRA. Setting this bit only has effect\nfor the asynchronous operation. Set this bi t to zero when using synchronous operation.\nSetting this bit will reduce the divisor of the baud rate divider from 16 to 8, effectively doubling\nthe transfer rate for asynchronous communication. Note however that the Receiver will in thiscase only use half the number of samples (reduced from 16 to 8) for data sampling and clockrecovery, and therefore a more accurate baud rate setting and system clock are required whenthis mode is used. For the Transmitter, there are no downsides.\nExternal Clock External clocking is used by the Synchronous Slave modes of operation. The description in this\nsection refers to Figure 62 on page 131  for details.\nExternal clock input from the XCK pin is sampled by a synchronization register to minimize the\nchance of meta-stability. The output from the synchronization register must then pass through\nan edge detector before it can be used by the Transmitter and Receiver. This process intro-duces a two CPU clock period delay and theref ore the maximum external XCK clock frequency\nis limited by the following equation:\nNote that f\nosc depends on the stability of the system clock source. It is therefore recommended to\nadd some margin to avoid possible loss of data due to frequency variations.\nSynchronous Clock \nOperationWhen Synchronous mode is used (UMSEL = 1), the XCK pin will be used as either clock input\n(Slave) or clock output (Master). The dependency between the clock edges and data samplingor data change is the same. The basic principle is that data input (on RxD) is sampled at theopposite XCK clock edge of the edge the data output (TxD) is changed.Table 52.  Equations for Calculating Baud Rate Register Setting\nOperating ModeEquation for Calculating \nBaud Rate(1)Equation for Calculating \nUBRR Value\nAsynchronous Normal mode \n(U2X = 0)\nAsynchronous Double Speed \nMode (U2X = 1)\nSynchronous Master ModeBAUDfOSC\n16UBRR 1+ ()-------------------------------------- - = UBRRfOSC\n16BAUD----------------------- -1\u2013 =\nBAUDfOSC\n8UBRR 1+ ()-----------------------------------= UBRRfOSC\n8BAUD-------------------- 1\u2013 =\nBAUDfOSC\n2UBRR 1+ ()-----------------------------------= UBRRfOSC\n2BAUD-------------------- 1\u2013 =\nfXCKfOSC\n4-----------<\n\n133\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 63.  Synchronous Mode XCK Timing\nThe UCPOL bit UCRSC selects which XCK clock edge  is used for data sampling and which is\nused for data change. As Figure 63  shows, when UCPOL is zero the data will be changed at ris-\ning XCK edge and sampled at falling XCK edge. If UCPOL is set, the data will be changed atfalling XCK edge and sampl ed at rising XCK edge.\nFrame Formats A serial frame is defined to be one character of da ta bits with synchronizat ion bits (start and stop\nbits), and optionally a parity bi t for error checking. The USART accepts all 30 combinations of\nthe following as valid frame formats:\n\u0081 1 start bit\u0081 5, 6, 7, 8, or 9 data bits\u0081 no, even or odd parity bit\u0081 1 or 2 stop bits\nA frame starts with the start bit followed by the least significant data bit. Then the next data bits,\nup to a total of nine, are succeeding, ending with t he most significant bit. If enabled, the parity bit\nis inserted after the data bits, before the stop bits. When a complete frame is transmitted, it canbe directly followed by a new frame, or the communication line can be set to an idle (high) state.Figure 64  illustrates the possible combinations of the frame formats. Bits inside brackets are\noptional.\nFigure 64.  Frame Formats\nSt Start bit, always low\n(n) Data bits (0 to 8)\nP Parity bit. Can be odd or even\nSp Stop bit, always high\nIDLE No transfers on the communication line (RxD or TxD). An IDLE line must be high\nThe frame format used by the USART is set by  the UCSZ2:0, UPM1:0 and USBS bits in UCSRB\nand UCSRC. The Receiver and Transmitter use the same setting. Note that changing the settingof any of these bits will corrup t all ongoing communicati on for both the Rece iver and Transmitter. RxD / TxDXCK\nRxD / TxDXCK UCPOL = 0UCPOL = 1\nSample\nSample\n1 0 2 3 4 [5] [6] [7] [8] [P] St Sp1 [Sp2] (St / IDLE) (IDLE)FRAME\n\n134\n2486Z\u2013AVR\u201302/11ATmega8(L)The USART Character SiZe (UCSZ2:0) bits select the number of data bits in the frame. The\nUSART Parity mode (UPM1:0) bits enable and set the type of parity bit. The selection betweenone or two stop bits is done by  the USART Stop Bit Select (USBS)  bit. The Receiver ignores the\nsecond stop bit. An FE (Frame Error) will therefor e only be detected in the cases where the first\nstop bit is zero.\nParity Bit Calculation The parity bit is calculated by do ing an exclusive-or of all the data bits. If odd parity is used, the\nresult of the exclusive or is inverted. The re lation between the parity bit and data bits is as\nfollows:\nP\neven Parity bit using even parity\nPodd Parity bit using odd parity\ndn Data bit n of the character\nIf used, the parity bit is located between the last data bit and first stop bit of a serial frame.\nUSART \nInitializationThe USART has to be initialized before any communication can take place. The initialization pro-\ncess normally consists of setting the baud rate, setting frame format and enabling theTransmitter or the Receiver depending on the usage. For interrupt driven USART operation, theGlobal Interrupt Flag should be cleared (and interrupts globally disabled) when doing the\ninitialization.\nBefore doing a re-initialization with changed baud rate or frame format, be sure that there are no\nongoing transmissions during the period the re gisters are changed. The TXC Flag can be used\nto check that the Transmitter has completed all transfers, and the RXC Flag can be used tocheck that there are no unread data in the receive buffer. Note that the TXC Flag must becleared before each transmission (before UDR is written) if it is used for this purpose.\nThe following simple USART initialization code examples show one assembly and one C func-\ntion that are equal in functionality. The exampl es assume asynchronous  operation using polling\n(no interrupts enabled) and a fixed frame format. The baud rate is given as a function parameter.For the assembly code, the baud rate parameter is assumed to be stored in the r17:r16 Regis-ters. When the function writes to the UCSRC Re gister, the URSEL bit (MSB) must be set due to\nthe sharing of I/O location by UBRRH and UCSRC.Pevendn1\u2013\u2026 d3d2d1d00\nPodd\u2295\u2295\u2295\u2295\u2295\u2295\ndn1\u2013\u2026 d3d2d1d01 \u2295\u2295\u2295\u2295\u2295\u2295=\n=\n\n135\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nMore advanced initialization routines can be made that include frame format as parameters, dis-\nable interrupts and so on. However, many applications use a fixed setting of the Baud andControl Registers, and for these types of appl ications the initialization code can be placed\ndirectly in the main routine, or be combined with initialization code for other I/O modules.Assembly Code Example\n(1)\nUSART_Init:\n; Set baud rate\noutUBRRH, r17\noutUBRRL, r16\n; Enable receiver and transmitter\nldir16, (1<<RXEN)|(1<<TXEN)\noutUCSRB,r16\n; Set frame format: 8data, 2stop bit\nldir16, (1<<URSEL)|(1<<USBS)|(3<<UCSZ0)\noutUCSRC,r16\nret\nC Code Example(1)\n#define FOSC 1843200// Clock Speed\n#define BAUD 9600\n#define MYUBRR FOSC/16/BAUD-1void main( void )\n{\n...\nUSART_Init ( MYUBRR );\n...\n}\nvoid USART_Init( unsigned int  ubrr)\n{\n/* Set baud rate  */\nUBRRH = ( unsigned char )(ubrr>>8);\nUBRRL = ( unsigned char )ubrr;\n/* Enable receiver and transmitter  */\nUCSRB = (1<<RXEN)|(1<<TXEN);\n/* Set frame format: 8data, 2stop bit  */\nUCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);\n}\n\n136\n2486Z\u2013AVR\u201302/11ATmega8(L)Data Transmission \n\u2013 The USART \nTransmitterThe USART Transmitter is enabled by setting the Transmit Enable  (TXEN) bit in the UCSRB\nRegister. When the Transmitter is enabled, the no rmal port operation of the TxD pin is overrid-\nden by the USART and given the function as t he Transmitter\u2019s serial output. The baud rate,\nmode of operation and frame format must be set up once before doing any transmissions. If syn-chronous operation is used, the clock on the XCK pin will be overridden and used as\ntransmission clock.\nSending Frames with \n5 to 8 Data BitsA data transmission is initiated by loading the transmit buffer with the data to be transmitted. The\nCPU can load the transmit buffer by writing to the UDR I/O location. The buffered data in thetransmit buffer will be moved to the Shift Register wh en the Shift Register is ready to send a new\nframe. The Shift Register is loaded with new data if it is in idle state (no ongoing transmission) orimmediately after the last stop bit of the previous frame is transmitted. When the Shift Register isloaded with new data, it will transf er one complete frame at the ra te given by the Baud Register,\nU2X bit or by XCK depending on mode of operation.\nThe following code examples show a simple USART transmit function based on polling of the\nData Register Empty  (UDRE) Flag. When using frames with less than eight bits, the most signif-\nicant bits written to the UDR are ignored. The USART has to be initialized before the function\ncan be used. For the assembly code, the data to be sent is assumed to be stored in RegisterR16\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe function simply waits for the transmit buffer  to be empty by checking the UDRE Flag, before\nloading it with new data to be transmitted. If the Data Register Empty Interrupt is utilized, the\ninterrupt routine writes the data into the buffer.Assembly Code Example(1)\nUSART_Transmit:\n; Wait for empty transmit buffer\nsbisUCSRA,UDRE\nrjmpUSART_Transmit\n; Put data (r16) into buffer, sends the data\noutUDR,r16\nret\nC Code Example(1)\nvoid USART_Transmit( unsigned char  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRA & (1<<UDRE)) )\n;\n/* Put data into buffer, sends the data  */\nUDR = data;\n}\n\n137\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSending Frames with \n9 Data BitsIf 9-bit characters are used (UCSZ = 7), the nint h bit must be written to the TXB8 bit in UCSRB\nbefore the Low byte of the character is writte n to UDR. The following code examples show a\ntransmit function that handles 9-bit characters. For the assembly code, the data to be sent is\nassumed to be stored in registers R17:R16.\nNote: 1. These transmit functions are written to be gen eral functions. They can be optimized if the con-\ntents of the UCSRB is static. Th at is, only the TXB8 bit of t he UCSRB Register is used after\ninitialization\nThe ninth bit can be used for indicating an address frame when using multi processor communi-\ncation mode or for other protocol handling as for example synchronization.\nTransmitter Flags and \nInterruptsThe USART Transmitter has two flags that indi cate its state: USART Data Register Empty\n(UDRE) and Transmit Complete (TXC). Both flags can be used for generating interrupts.\nThe Data Register Empty (UDRE) Fl ag indicates whether the transmit  buffer is ready to receive\nnew data. This bit is set when the transmit buffer is empty, and cleared when the transmit buffercontains data to be transmitted that has not yet be en moved into the Shift Register. For compat-\nibility with future devices, alwa ys write this bit to zero w hen writing the UCSRA Register.\nWhen the Data Register empty Interrupt Enable (UDRIE) bit in UCSRB is writte n to one, the\nUSART Data Register Empty Interrupt will be ex ecuted as long as UDRE is set (provided that\nglobal interrupts are enabled). UDRE is cleared by writing UDR. When interrupt-driven datatransmission is used, the Data Register empty Interrupt routine must either write new data toAssembly Code Example\n(1)\nUSART_Transmit:\n; Wait for empty transmit buffer\nsbisUCSRA,UDRE\nrjmpUSART_Transmit\n; Copy ninth bit from r17 to TXB8\ncbiUCSRB,TXB8\nsbrcr17,0\nsbiUCSRB,TXB8\n; Put LSB data (r16) into buffer, sends the data\noutUDR,r16\nret\nC Code Example(1)\nvoid USART_Transmit( unsigned int  data )\n{\n/* Wait for empty transmit buffer  */\nwhile ( !( UCSRA & (1<<UDRE)) )\n;\n/* Copy ninth bit to TXB8 */\nUCSRB &= ~(1<<TXB8);\nif ( data & 0x0100 )\nUCSRB |= (1<<TXB8);\n/* Put data into buffer, sends the data  */\nUDR = data;\n}\n\n138\n2486Z\u2013AVR\u201302/11ATmega8(L)UDR in order to clear UDRE or disable the Data Register empty Interrupt, otherwise a new inter-\nrupt will occur once the inte rrupt routine terminates.\nThe Transmit Complete (TXC) Flag bit is set one when the entire frame in the transmit Shift Reg-\nister has been shifted out and there are no new data currently present in the transmit buffer. TheTXC Flag bit is automatically cleared when a transmit complete interrupt is executed, or it can becleared by writing a one to its bit location. Th e TXC Flag is useful in half-duplex communication\ninterfaces (like the RS485 standard), where a transmitting application must enter Receive modeand free the communication bus immediately after completing the transmission.\nWhen the Transmit Compete Interrupt Enable (T XCIE) bit in UCSRB is set, the USART Transmit\nComplete Interrupt will be executed when the TXC Fl ag becomes set (provid ed that global inter-\nrupts are enabled). When the transmit complete interrupt is used, the interrupt handling routinedoes not have to clear the TXC Flag, this is done automatically when the interrupt is executed.\nParity Generator The Parity Generator calculates the parity bit for the serial frame data. When parity bit is enabled\n(UPM1 = 1), the Transmitter control logic inserts the parity bit between the last data bit and thefirst stop bit of the frame that is sent.\nDisabling the \nTransmitterThe disabling of the Tran smitter (setting the TXEN to zero ) will not become effective until ongo-\ning and pending transmissions are completed (that is, when the Transmit Shift Register andTransmit Buffer Register do not contain data to be transmitted). When disabled, the Transmitterwill no longer override the TxD pin.\nData Reception \u2013 \nThe USART ReceiverThe USART Receiver is enabled by writing the Receive Enable (RXEN) bit in the UCSRB Regis-\nter to one. When the Receiver is enabled, the normal pin operation of the RxD pin is overridden\nby the USART and given the function as the Re ceiver\u2019s serial input. The baud rate, mode of\noperation and frame format must be set up once before any serial reception can be done. If syn-chronous operation is used, the clock on the XCK pin will be used as transfer clock.\nReceiving Frames with \n5 to 8 Data BitsThe Receiver starts data reception when it detects a valid start bit. Each bit that follows the start\nbit will be sampled at the ba ud rate or XCK clock, and shifted into the Receive Shift Register until\nthe first stop bit of a frame is received. A seco nd stop bit will be ignored  by the Receiver. When\nthe first stop bit is received (that is, a complete  serial frame is present in the Receive Shift Reg-\nister), the contents of the Shift Register will be mo ved into the receive bu ffer. The receive buffer\ncan then be read by reading the UDR I/O location.\nThe following code example shows a simple US ART receive function based on polling of the\nReceive Complete (RXC) Flag. When  using frames with less than eight bits the most significant\n\n139\n2486Z\u2013AVR\u201302/11ATmega8(L)\nbits of the data read from t he UDR will be masked to zero. T he USART has to be initialized\nbefore the function can be used.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe function simply waits for data to be present in the receive buffer by checking the RXC Flag,\nbefore reading the buffer and returning the value.\nReceiving Frames with \n9 Data BitsIf 9-bit characters are used (UCSZ=7) the ninth bit must be read from the RXB8 bit in UCSRB\nbefore  reading the low bits from the UDR. This rule applies to the FE, DOR and PE Status Flags\nas well. Read status from UC SRA, then data from UDR. R eading the UDR I/O location will\nchange the state of the receive buffer FIFO an d consequently the TXB8, FE, DOR, and PE bits,\nwhich all are stored in  the FIFO, will change.Assembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nsbisUCSRA, RXC\nrjmpUSART_Receive\n; Get and return received data from buffer\ninr16, UDR\nret\nC Code Example(1)\nunsigned char  USART_Receive( void )\n{\n/* Wait for data to be received  */\nwhile ( !(UCSRA & (1<<RXC)) )\n;\n/* Get and return received data from buffer  */\nreturn UDR;\n}\n\n140\n2486Z\u2013AVR\u201302/11ATmega8(L)The following code example shows a simple USART receive function that handles both 9-bit\ncharacters and the status bits.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe receive function example reads all the I/O R egisters into the Register File before any com-\nputation is done. This gives an optimal receive buffer utilization since the bu ffer location read will\nbe free to accept new data as early as possible.Assembly Code Example(1)\nUSART_Receive:\n; Wait for data to be received\nsbisUCSRA, RXC\nrjmpUSART_Receive\n; Get status and ninth bit, then data from buffer\ninr18, UCSRA\ninr17, UCSRB\ninr16, UDR\n; If error, return -1\nandir18,(1<<FE)|(1<<DOR)|(1<<PE)\nbreqUSART_ReceiveNoError\nldir17, HIGH(-1)\nldir16, LOW(-1)\nUSART_ReceiveNoError:\n; Filter the ninth bit, then return\nlsrr17\nandir17, 0x01\nret\nC Code Example(1)\nunsigned int  USART_Receive( void )\n{\nunsigned char  status, resh, resl;\n/* Wait for data to be received  */\nwhile ( !(UCSRA & (1<<RXC)) )\n;\n/* Get status and ninth bit, then data  */\n/* from buffer  */\nstatus = UCSRA;\nresh = UCSRB;resl = UDR;\n/* If error, return -1  */\nif ( status & (1<<FE)|(1<<DOR)|(1<<PE) )\nreturn -1;\n/* Filter the ninth bit, then return  */\nresh = (resh >> 1) & 0x01;return ((resh << 8) | resl);\n}\n\n141\n2486Z\u2013AVR\u201302/11ATmega8(L)\nReceive Compete Flag \nand InterruptThe USART Receiver has one flag that indicates the Receiver state.\nThe Receive Complete (RXC) Flag indicates if there are unread data present in the receive buf-\nfer. This flag is one when unread data exist in the receive buffer, and zero when the receivebuffer is empty (that is, does not contain any unread data). If the Receiver is disabled (RXEN =0), the receive bu ffer will be flushed and consequently  the RXC bit will become zero.\nWhen the Receive Complete Interrupt Enable (RXCIE) in UCSRB is set, the USART Receive\nComplete Interrupt will be executed as long as the RXC Flag is se t (provided that  global inter-\nrupts are enabled). When interrupt-driven data reception is used, the receive complete routinemust read the received data from UDR in order to clear the RXC Flag, otherwise a new interruptwill occur once the interr upt routine terminates.\nReceiver Error Flags The USART Receiver has three error flags: Frame Error (FE), Data OverRun (DOR) and Parity\nError (PE). All can be accessed by reading UCSRA. Common for the error flags is that they arelocated in the receive buffer together with the frame for which they indicate the error status. Dueto the buffering of the error flags, the UCSRA must be read before the receive buffer (UDR),since reading the UDR I/O location changes the buffer read location. Another equality for theerror flags is that they can not be altered by software doing a write to the flag location. However,all flags must be set to zero  when the UCSRA is written for upward compatibility of future\nUSART implementations. None of the error flags can generate interrupts.\nThe Frame Error (FE) Flag indicates the state of the first stop bit of the next readable frame\nstored in the receive buffer. The FE Flag is ze ro when the stop bit was correctly read (as one),\nand the FE Flag will be one when the stop bit was incorrect (zero). This flag can be used for\ndetecting out-of-sync conditions, detecting break conditions and protocol handling. The FE Flagis not affected by the setting of  the USBS bit in UCSRC since the Re ceiver ignores all, except for\nthe first, stop bits. For co mpatibility with future device s, always set this bit to zero when writing to\nUCSRA.\nThe Data OverRun (DOR) Flag indicates data loss due to a Receiver buffe r full condition. A Data\nOverRun occurs when the receive buffer is full (two  characters), it is a new character waiting in\nthe Receive Shift Register, and a new start bit is detected. If the DOR Flag is set there was oneor more serial frame lost between the frame last read from UDR, and the next frame read fromUDR. For compatibility with future devices, always write this bit to zero when writing to UCSRA.\nThe DOR Flag is cleared when the frame received  was successfully moved from the Shift Regis-\nter to the receive buffer.\nThe Parity Error (PE) Flag indicates that the next frame in the receive buffer had a parity error\nwhen received. If parity check is not enabled the PE bit will alwa ys be read zero. For compatibil-\nity with future devices, always set this bit to zero when writing to UCSRA. For more details see\n\u201cParity Bit Calculation\u201d on page 134  and \u201cParity Checker\u201d .\nParity Checker The Parity Checker is active when the high USART Parity mode (UPM1) bit is set. Type of parity\ncheck to be performed (odd or even) is selected by the UPM0 bit. When enabled, the ParityChecker calculates the parity of the data bits in incoming frames and compares the result withthe parity bit from the serial frame. The result of the check is stored in the receive buffer togetherwith the received data and stop bits. The Parity Error (PE) Flag can then be read by software tocheck if the frame had a parity error.\nThe PE bit is set if the next character that can be read from the receive buffer had a parity error\nwhen received and the parity checking was enabled at that point (UPM1 = 1). This bit is validuntil the receive buff er (UDR) is read.\n\n142\n2486Z\u2013AVR\u201302/11ATmega8(L)Disabling the Receiver In contrast to the Transmitter, disabling of the Receiver will be immediate. Data from ongoing\nreceptions will therefore be lost. When disabled (that is, the RXEN is set to zero) the Receiverwill no longer override the normal function of th e RxD port pin. The Rece iver buffer FIFO will be\nflushed when the Receiver is disabled. Remaining data in the buffer will be lost\nFlushing the Receive \nBufferThe Receiver buffer FIFO will be flushed when the Receiver is di sabled (that is, the buffer will be\nemptied of its contents). Unread data will be lost . If the buffer has to be flushed during normal\noperation, due to for instance an error condition, read the UDR I/O location until the RXC Flag iscleared. The following code example shows how to flush the receive buffer.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nAsynchronous \nData ReceptionThe USART includes a clock recovery and a data  recovery unit for handling asynchronous data\nreception. The clock recovery logic is used fo r synchronizing the internally generated baud rate\nclock to the incoming asynchronous serial frames at the RxD pin. The data recovery logic sam-ples and low pass filters each incoming bit, ther eby improving the noise immunity of the\nReceiver. The asynchronous reception operational range depends on the accuracy of the inter-nal baud rate clock, the rate of the incoming frames, and the frame size in number of bits.\nAsynchronous Clock \nRecoveryThe clock recovery logic sync hronizes internal clock to the incoming serial frames. Figure 65\nillustrates the sampling process of th e start bit of an incoming frame.  The sample rate is 16 times\nthe baud rate for Normal mode, and eight times the baud rate for Double Speed mode. The hor-izontal arrows illustrate the sy nchronization variation due to t he sampling process. Note the\nlarger time variation when using the Double Speed mode (U2X = 1) of operation. Samples\ndenoted zero are samples done when the RxD line is idle (that is, no communication activity).\nFigure 65.  Start Bit Sampling\nWhen the clock recovery logic detects a high (idle) to low (start) transition on the RxD line, the\nstart bit detection sequence is initiated. Let sample 1 denote the first zero-sample as shown inAssembly Code Example\n(1)\nUSART_Flush:\nsbisUCSRA, RXC\nret\ninr16, UDR\nrjmpUSART_Flush\nC Code Example(1)\nvoid USART_Flush( void )\n{\nunsigned char  dummy;\nwhile ( UCSRA & (1<<RXC) ) dummy = UDR;\n}\n1234567 8 9 10 11 12 13 14 15 16 12START IDLE\n0 0BIT 0\n3\n123 4 5 678 12 0RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n\n143\n2486Z\u2013AVR\u201302/11ATmega8(L)\nthe figure. The clock recovery logic then uses samples 8, 9 and 10 for Normal mode, and\nsamples 4, 5 and 6 for Double Speed mode (indicated with sample numbers inside boxes on thefigure), to decide if a valid start bit is received. If two or more of these three samples have logicalhigh levels (the majority wins), the start bit is rejected as a noise spike and the Receiver startslooking for the next high to low-transition. If however, a valid start bit is detected, the clockrecovery logic is synchronized and the data recovery can begin. The synchronization process isrepeated for each start bit.\nAsynchronous Data \nRecoveryWhen the Receiver clock is synchronized to the start bit, the data recovery can begin. The data\nrecovery unit uses a state machine that has  16 states for each bit in Normal mode and eight\nstates for each bit in Double Speed mode. Figure 66  shows the sampling of the data bits and the\nparity bit. Each of the samples is given a number that is equal to the state of the recovery unit.\nFigure 66.  Sampling of Data and Parity Bit\nThe decision of the logic level of the received bit is taken by doing a majori ty voting of the logic\nvalue to the three samples in the center of the received bit. The center samples are emphasizedon the figure by having the sample number inside boxes. The majority voting process is done asfollows: If two or all three samples have high levels, the received bit is registered to be a logic 1.If two or all three samples have low levels, the received bit is registered to be a logic 0. Thismajority voting process acts as a low pass filter for the incoming signal on the RxD pin. Therecovery process is then repeated until a complete frame is received. Including the first stop bit.Note that the Receiver only uses the first stop bit of a frame.\nFigure 67  shows the sampling of the stop bit and the earliest possible beginning of the start bit of\nthe next frame.\nFigure 67.  Stop Bit Sampling and Ne xt Start Bit Sampling\nThe same majority voting is done to the stop bit as done for the other bits in the frame. If the stop\nbit is registered to have a logic 0 valu e, the Frame Error (F E) Flag will be set.\nA new high to low transition indicating the start bit of a new frame can come right after the last of\nthe bits used for majority voting. For Normal Speed mode, the first low level sample can be at\npoint marked (A) in Figure 67 . For Double Speed mode the first low level must be delayed to (B).\n(C) marks a stop bit of full length. The early start bit detection influences the operational range ofthe Receiver.1234567 8 9 10 11 12 13 14 15 16 1BIT n\n123 4 5 678 1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)\n1234567 8 9 10 0/1 0/1 0/1STOP 1\n123 4 5 6 0/1RxD\nSample\n(U2X = 0)\nSample\n(U2X = 1)(A) (B) (C)\n\n144\n2486Z\u2013AVR\u201302/11ATmega8(L)Asynchronous \nOperational RangeThe operational range of the Receiver is dependent on the mismatch between the received bit\nrate and the internally generated baud rate. If the Transmitter is sending frames at too fast or tooslow bit rates, or the internally generated baud rate of the Receiver does not have a similar (seeTable 53 ) base frequency, the Receiver will not be able to synchronize the fram es to the start bit.\nThe following equations can be used to calculate the ratio of the incoming data rate and internal\nReceiver baud rate.\nD Sum of character size and parity size (D = 5-bit to 10-bit)\nS Samples per bit. S = 16 for Normal Speed mode and S = 8 for Double Speed mode\nS\nFFirst sample number used for majority voting. SF = 8 for Normal Speed and SF = 4 for\nDouble Speed mode\nSMMiddle sample number used for majority voting. SM = 9 for Normal Speed and SM = 5 for\nDouble Speed mode\nRslow is the ratio of the slowest incoming data ra te that can be accepted in relation to the\nReceiver baud rate. Rfast is the ratio of the fastest incoming data rate that can be\naccepted in relation to the Receiver baud rate\nTable 53  and Table 54  list the maximum Receiver baud rate error that can be tolerated. Note\nthat Normal Speed mode has higher toleration of baud rate variations.\nTable 53.  Recommended Maximum Receiver Baud Rate Error for Normal Speed Mode\n(U2X = 0)\nD#\n(Data + Parity Bit)Rslow \n(%)Rfast \n(%)Max Total \nError (%)Recommended Max \nReceiver Error (%)\n5 93.20 106.67 +6.67/-6.8 \u00b13.0\n6 94.12 105.79 +5.79/-5.88 \u00b12.07 94.81 105.11 +5.11/-5.19 \u00b12.0\n8 95.36 104.58 +4.58/-4.54 \u00b12.0\n9 95.81 104.14 +4.14/-4.19 \u00b11.5\n10 96.17 103.78 +3.78/-3.83 \u00b11.5\nTable 54.  Recommended Maximum Receiver Baud Rate Error for Double Speed Mode\n(U2X = 1)\nD#\n(Data + Parity Bit)Rslow\n(%)Rfast \n(%)Max Total \nError (%)Recommended Max \nReceiver Error (%)\n5 94.12 105.66 +5.66/-5.88 \u00b12.56 94.92 104.92 +4.92/-5.08 \u00b12.0\n7 95.52 104.35 +4.35/-4.48 \u00b11.5\n8 96.00 103.90 +3.90/-4.00 \u00b11.59 96.39 103.53 +3.53/-3.61 \u00b11.5\n10 96.70 103.23 +3.23/-3.30 \u00b11.0RslowD1+() S\nS1\u2013 DS\u22c5SF++------------------------------------------ - = RfastD2+() S\nD1+() SSM+-----------------------------------=\n\n145\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe recommendations of the maximum Receiver baud rate error was made under the assump-\ntion that the Receiver and Transmitter equally divides the maximum total error.\nThere are two possible sources for the Receivers Baud Rate error. The Re ceiver\u2019s system clock\n(XTAL) will always have some minor instabilit y over the supply voltage range and the tempera-\nture range. When using a crystal to generate the system clock, this is rarely a problem, but for aresonator the system clock may differ more than 2% depending of the resonators tolerance. Thesecond source for the error is more controllable. The baud rate generator can not always do anexact division of the system frequency to get the b aud rate wanted. In this case an UBRR value\nthat gives an acceptable low error can be used if possible.\nMulti-processor \nCommunication ModeSetting the Multi-processor Communication mode (MPCM) bit in UCSRA enables a filtering\nfunction of incoming frames received by the USART Receiver. Frames that do not containaddress information will be ignored and not put in to the receive buffer. This effectively reduces\nthe number of incoming frames that has to be handled by the CPU, in a system with multipleMCUs that communicate via the same serial bus. The Transmitter is unaffected by the MPCM\nsetting, but has to be used diffe rently when it is a part of a system utilizing the Multi-processor\nCommunication mode.\nIf the Receiver is set up to receive frames that contain 5 to 8 data bits, then the first stop bit indi-\ncates if the frame contains data or address information. If the Receiver is set up for frames withnine data bits, then the ninth bit (RXB8) is  used for identifying address and data frames. When\nthe frame type bit (the first stop or the ninth bit) is one, the frame contains an address. When theframe type bit is zero the frame is a data frame.\nThe Multi-processor Communication mode enables se veral Slave MCUs to receive data from a\nMaster MCU. This is done by first decoding an address frame to find out which MCU has beenaddressed. If a particular Slave MCU has been addressed, it will receive the following dataframes as normal, while the other Slave MCUs will ignore the received frames until another\naddress frame is received.\nUsing MPCM For an MCU to act as a Master MCU, it can use a 9-bit character frame format (UCSZ = 7). The\nninth bit (TXB8) must be set when an address frame (TXB8 = 1) or cleared when a data frame(TXB = 0) is being transmitted. The Slave MCUs must in this case be set to use a 9-bit characterframe format.\nThe following procedure should be used to exchange data in Multi-processor Communication\nmode:\n1. All Slave MCUs are in Multi-processor Co mmunication mode (MPCM in UCSRA is set)\n2. The Master MCU sends an address frame, and all slaves receive and read this frame. In\nthe Slave MCUs, the RXC Flag in UCSRA will be set as normal\n3. Each Slave MCU reads the UDR Register and determines if it has been selected. If so, it\nclears the MPCM bit in UCSRA, otherwise it waits for the next address byte and keepsthe MPCM setting\n4. The addressed MCU will receive all data fram es until a new address frame is received.\nThe other Slave MCUs, which still have th e MPCM bit set, will ignore the data frames\n5. When the last data frame is received by the addressed MCU, the addressed MCU sets\nthe MPCM bit and waits for a new address frame from Master. The process then repeatsfrom 2\nUsing any of the 5-bit to 8-bit character frame formats is possible, but impractical since the\nReceiver must change between using n and n+1 character frame formats. This makes full-duplex operation difficult since the Transmitter a nd Receiver uses the same character size set-\nting. If 5-bit to 8-bit character frames are used, the Transmitter must be set to use two stop bit(USBS = 1) since the first stop bit is used for indicating the frame type.\n\n146\n2486Z\u2013AVR\u201302/11ATmega8(L)Do not use Read-Modify-Write instructions (SBI  and CBI) to set or clear the MPCM bit. The\nMPCM bit shares the same I/O location as the TXC Flag and this might accidentally be cleared\nwhen using SBI or CBI instructions.\nAccessing \nUBRRH/UCSRC \nRegistersThe UBRRH Register shares the same I/O location as the UCSRC Register. Therefore some\nspecial consideration must be taken when accessing this I/O location.\nWrite Access When doing a write access of this I/O location, the high bit of the value written, the USART Reg-\nister Select (URSEL) bit, controls  which one of the two registers that will be written. If URSEL is\nzero during a write operation, the UBRRH valu e will be updated. If URSEL is one, the UCSRC\nsetting will be updated.\nThe following code examples show how to access the two registers.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nAs the code examples illustrate, write accesses of  the two registers are relatively unaffected of\nthe sharing of I/O location.Assembly Code Examples(1)\n...\n; Set UBRRH to 2\nldir16,0x02\noutUBRRH,r16\n...\n; Set the USBS and the UCSZ1 bit to one, and\n; the remaining bits to zero.\nldir16,(1<<URSEL)|(1<<USBS)|(1<<UCSZ1)\noutUCSRC,r16\n...\nC Code Examples(1)\n.../* Set UBRRH to 2  */\nUBRRH = 0x02;\n...\n/* Set the USBS and the UCSZ1 bit to one, and  */\n/* the remaining bits to zero.  */\nUCSRC = (1<<URSEL)|(1<<USBS)|(1<<UCSZ1);\n...\n\n147\n2486Z\u2013AVR\u201302/11ATmega8(L)\nRead Access Doing a read access to the UBRRH or the UCS RC Register is a more complex operation. How-\never, in most applications, it is rarely necessary to read any of these registers.\nThe read access is controlled by a timed sequence. Reading the I/O location once returns the\nUBRRH Register contents. If the regi ster location was read in prev ious system clock cycle, read-\ning the register in the current clock cycle will return the UCSRC contents. Note that the timedsequence for reading the UCSRC is an atomic operation. Interrupts must therefore be controlled(for example, by disabling interrupts globally) during the read operation.\nThe following code example shows how to read the UCSRC Register contents.\nNote: 1. See \u201cAbout Code Examples\u201d on page 8\nThe assembly code example returns the UCSRC value in r16.\nReading the UBRRH contents is not an atomic operation and therefore it can be read as an ordi-\nnary register, as long as the previous inst ruction did not access the register location.Assembly Code Example(1)\nUSART_ReadUCSRC:\n; Read UCSRC\ninr16,UBRRH\ninr16,UCSRC\nret\nC Code Example(1)\nunsigned char  USART_ReadUCSRC( void )\n{\nunsigned char  ucsrc;\n/* Read UCSRC  */\nucsrc = UBRRH;ucsrc = UCSRC;\nreturn ucsrc;\n}\n\n148\n2486Z\u2013AVR\u201302/11ATmega8(L)USART Register \nDescription\nUSART I/O Data \nRegister \u2013 UDR\nThe USART Transmit Data Buffer Register and USART Receive Data Buffer Registers share the\nsame I/O address referred to as USART Data Register or UDR. The Transmit Data Buffer Reg-ister (TXB) will be the destination for data wri tten to the UDR Register location. Reading the\nUDR Register location will return  the contents of the Receive Data Bu ffer Register (RXB).\nFor 5-bit, 6-bit, or 7-bit characters the upper  unused bits will be ignored by the Transmitter and\nset to zero by the Receiver.\nThe transmit buffer can only be written when the UDRE Flag in the UCSRA Register is set. Data\nwritten to UDR when the UDRE Flag is not set, will be ignored by the U SART Transmitter. When\ndata is written to the tr ansmit buffer, and the Transmitter is enabled, the Transm itter will load the\ndata into the Transmit Shift Register when the Shift Register is empty. Then the data will be seri-ally transmitted on the TxD pin.\nThe receive buffer consists of a two level FIFO . The FIFO will change its state whenever the\nreceive buffer is accessed. Due to this behavior of the receive buffer, do not use Read-Modify-Write instructions (SBI and CBI) on this location. Be careful when using bit test instructions(SBIC and SBIS), since these also will change the state of the FIFO.\nUSART Control and \nStatus Register A \u2013 UCSRA\n\u0081 Bit 7 \u2013 RXC: USAR T Receive Complete\nThis flag bit is set when there are unread data in the receive buffer and cleared when the receive\nbuffer is empty (that is, does not contain any unread data). If the Receiver is disabled, thereceive buffer will be flushed an d consequently the RXC bit will become zero. The RXC Flag can\nbe used to generate a Receive Complete interrupt (see description of the \u201cBit 7 \u2013 RXCIE: RX\nComplete Interrupt Enable\u201d on page 149 ).\n\u0081 Bit 6 \u2013 TXC: USART Transmit Complete\nThis flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and\nthere are no new data currently present in the transmit buffer (UDR). The TXC Flag bit is auto-\nmatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing\na one to its bit location. The TXC Flag can generate a Transmit Complete interrupt (see descrip-tion of the \u201cBit 6 \u2013 TXCIE: TX Complete Interrupt Enable\u201d on page 149 ).\n\u0081 Bit 5 \u2013 UDRE: USART Data Register Empty\nThe UDRE Flag indicates if the transmit buffer (UDR) is ready to receive new data. If UDRE is\none, the buffer is empty, and th erefore ready to be written. The UDRE Flag can generate a Data\nRegister Empty interrupt (see description of the \u201cBit 5 \u2013 UDRIE: USART Data Register Empty\nInterrupt Enable\u201d on page 149 ).\nUDRE is set after a reset to indicate that the Transmitter is ready.B i t 76543210\nRXB[7:0] UDR (Read)\nTXB[7:0] UDR (Write)\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\nB i t 76543210\nRXC TXC UDRE FE DOR PE U2X MPCM UCSRA\nRead/Write R R/W R R R R R/W R/WI n i t i a l  V a l u e 00100000\n\n149\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 4 \u2013 FE: Frame Error\nThis bit is set if the next character in the receive buffer had a Frame Error when received (that is,\nwhen the first stop bit of the next character in the receive buffer is zero). This bit is valid until thereceive buffer (UDR) is  read. The FE bit is zero when the stop  bit of received da ta is one. Always\nset this bit to zero when writing to UCSRA.\n\u0081 Bit 3 \u2013 DOR: Data OverRun\nThis bit is set if a Data OverRun condition is detected. A Data OverRun occurs when the receive\nbuffer is full (two characters), it is a new char acter waiting in the Receive Shift Register, and a\nnew start bit is detected. This bit is valid until the receive buffer (U DR) is read. Always set this bit\nto zero when writing to UCSRA.\n\u0081 Bit 2 \u2013 PE: Parity Error\nThis bit is set if the next character in the receive buffer had a Parity Error when received and the\nparity checking was enabled at that point (UPM1 = 1). This bit is valid until the receive buffer(UDR) is read. Always set this bit to zero when writing to UCSRA.\n\u0081 Bit 1 \u2013 U2X: Double the USART transmission speed\nThis bit only has effect for the asynchronous operation. Write this bit to zero when using syn-\nchronous operation.\nWriting this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively dou-\nbling the transfer rate for asynchronous communication.\n\u0081 Bit 0 \u2013 MPCM: Multi-processor Communication Mode\nThis bit enables the Multi-processor Communication mode. When the MPCM bit is written to\none, all the incoming frames received by the USART Receiver that do not contain address infor-\nmation will be ignored. The Transmitter is unaffe cted by the MPCM setting. For more detailed\ninformation see \u201cMulti-processor Communication Mode\u201d on page 145 .\nUSART Control and \nStatus Register B \u2013 UCSRB\n\u0081 Bit 7 \u2013 RXCIE: RX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the RXC Flag. A US ART Receive Complete interrupt\nwill be generated only if the RXCIE bi t is written to one, the Global Interrupt Flag in SREG is writ-\nten to one and the RXC bit in UCSRA is set.\n\u0081 Bit 6 \u2013 TXCIE: TX Complete Interrupt Enable\nWriting this bit to one enables interrupt on the TXC Flag. A USART Transmit Complete interrupt\nwill be generated only if the TXCIE bit is written to one, the Glo bal Interrupt Flag in SREG is writ-\nten to one and the TXC bit in UCSRA is set.\n\u0081 Bit 5 \u2013 UDRIE: USART Data Register Empty Interrupt Enable\nWriting this bit to one enables interrupt on the UDRE Flag. A Da ta Register Empty interrupt will\nbe generated only if  the UDRIE bit is written to one, the Glob al Interrupt Flag in SREG is written\nto one and the UDRE bit in UCSRA is set.\n\u0081 Bit 4 \u2013 RXEN: Receiver Enable\nWriting this bit to one enables the USART Receiv er. The Receiver will override normal port oper-\nation for the RxD pin when enabled. Disabling the Receiver  will flush the receive buffer\ninvalidating the FE, DOR and PE Flags.B i t 76543210\nRXCIE TXCIE UDRIE RXEN TXEN UCSZ2 RXB8 TXB8 UCSRB\nRead/Write R/W R/W R/W R/W R/W R/W R R/WI n i t i a l  V a l u e 00000000\n\n150\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 3 \u2013 TXEN: Transmitter Enable\nWriting this bit to one enables the USART Tr ansmitter. The Transmitter will override normal port\noperation for the TxD pin when enabled. The disabling of the Transmitter (writing TXEN to zero)will not become effective until ongoing and pending transmissions are completed (that is, when\nthe Transmit Shift Register and Transmit Buffer Register do not contain data to be transmitted).When disabled, the Transmitter will no longer override the TxD port.\n\u0081 Bit 2 \u2013 UCSZ2: Character Size\nThe UCSZ2 bits combined with the UCSZ1:0 bit in UCSRC sets the number of data bits (Char-\nacter Size) in a frame the Receiver and Transmitter use.\n\u0081 Bit 1 \u2013 RXB8: Receive Data Bit 8\nRXB8 is the ninth data bit of the received charac ter when operating with serial frames with nine\ndata bits. Must be read before reading the low bits from UDR.\n\u0081 Bit 0 \u2013 TXB8: Transmit Data Bit 8\nTXB8 is the ninth data bit in the character to  be transmitted when operating with serial frames\nwith nine data bits. Must be writte n before writing the low bits to UDR.\nUSART Control and \nStatus Register C \u2013 UCSRC\nThe UCSRC Register shares the same I/O location as the UBRRH Register. See the \u201cAccessing\nUBRRH/UCSRC Registers\u201d on page 146  section which describes ho w to access this register.\n\u0081 Bit 7 \u2013 URSEL: Register Select\nThis bit selects between accessing the UCSRC or  the UBRRH Register. It is read as one when\nreading UCSRC. The URSEL must be  one when writ ing the UCSRC.\n\u0081 Bit 6 \u2013 UMSEL: USART Mode Select\nThis bit selects between Asynchronous  and Synchronous mode of operation.B i t 76543210\nURSEL UMSEL UPM1 UPM0 USBS UCSZ1 UCSZ0 UCPOL UCSRC\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 10000110\nTable 55.  UMSEL Bit Settings\nUMSEL Mode\n0 Asynchronous Operation\n1 Synchronous Operation\n\n151\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 5:4 \u2013 UPM1:0: Parity Mode\nThese bits enable and set type of Parity Generati on and Check. If enabled, the Transmitter will\nautomatically generate and send the parity of th e transmitted data bits within each frame. The\nReceiver will generate a parity va lue for the incoming data and co mpare it to th e UPM0 setting.\nIf a mismatch is detected, the PE Flag in UCSRA will be set.\n\u0081 Bit 3 \u2013 USBS: Stop Bit Select\nThis bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores\nthis setting.\n\u0081 Bit 2:1 \u2013 UCSZ1:0: Character Size\nThe UCSZ1:0 bits combined with the UCSZ2 bit in UCSRB sets the number of data bits (Char-\nacter Size) in a frame the Receiver and Transmitter use.Table 56.  UPM Bits Settings\nUPM1 UPM0 Parity Mode\n0 0 Disabled01 R e s e r v e d\n1 0 Enabled, Even Parity\n1 1 Enabled, Odd Parity\nTable 57.  USBS Bit Settings\nUSBS Stop Bit(s)\n01 - b i t\n12 - b i t\nTable 58.  UCSZ Bits Settings \nUCSZ2 UCSZ1 UCSZ0 Character Size\n000 5 - b i t\n001 6 - b i t010 7 - b i t\n011 8 - b i t\n100 R e s e r v e d101 R e s e r v e d\n110 R e s e r v e d\n111 9 - b i t\n\n152\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 0 \u2013 UCPOL: Clock Polarity\nThis bit is used for Synchronous mode only. Write this bit to zero when Asynchronous mode is\nused. The UCPOL bit sets the relationship between data output change and data input sample,and the synchronous clock (XCK).\nUSART Baud Rate \nRegisters \u2013 UBRRL and UBRRHs\nThe UBRRH Register shares the same I/O location as the UCSRC Register. See the \u201cAccessing\nUBRRH/UCSRC Registers\u201d on page 146  section which describes ho w to access this register.\n\u0081 Bit 15 \u2013 URSEL: Register Select\nThis bit selects between accessing the UBRRH or the UCSRC Register. It is read as zero when\nreading UBRRH. The URSEL must be  zero when writing the UBRRH.\n\u0081 Bit 14:12 \u2013 Reserved Bits\nThese bits are reserved for future use. For compatibility with future devices, these bit must be\nwritten to zero when UBRRH is written.\n\u0081 Bit 11:0 \u2013 UBRR11:0: USART Baud Rate Register\nThis is a 12-bit register which contains the USART baud rate. The UBRRH contains the four\nmost significant bits, and the UBRRL contains th e eight least significant bits of the USART baud\nrate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if th e baud rate is\nchanged. Writing UBRRL will tr igger an immediate update of  the baud rate prescaler.Table 59.  UCPOL Bit Settings\nUCPOLTransmitted Data Changed\n(Output of TxD Pin)Received Data Sampled\n(Input on RxD Pin)\n0 Rising XCK Edge Falling XCK Edge\n1 Falling XCK Edge Rising XCK Edge\nB i t 1 51 41 31 21 11 0 9 8\nURSEL \u2013 \u2013 \u2013 UBRR[11:8] UBRRH\nUBRR[7:0] UBRRL\n76543210\nRead/Write R/W R R R R/W R/W R/W R/W\nR/W R/W R/W R/W R/W R/W R/W R/W\nI n i t i a l  V a l u e 00000000\n00000000\n\n153\n2486Z\u2013AVR\u201302/11ATmega8(L)\nExamples of Baud \nRate SettingFor standard crystal and resonator frequencies, the most commonly used baud rates for asyn-\nchronous operation can be generated by using the UBRR settings in Table 60 . UBRR values\nwhich yield an actual baud rate differing less than  0.5% from the target baud rate, are bold in the\ntable. Higher error ratings are acceptable, but the Receiver will have less noise resistance when\nthe error ratings are high, especially for large serial frames (see \u201cAsynchronous Operational\nRange\u201d on page 144 ). The error values are calculated using the following equation:\nError[%]BaudRateClosest Match\nBaudRate-------------------------------------------------------- 1\u2013\u239d\u23a0\u239b\u239e100%\u2022 =\nTable 60.  Examples of UBRR Settings for Co mmonly Used Oscillator Frequencies\nBaud \nRate (bps)f\nosc = 1.0000MHz fosc = 1.8432MHz fosc = 2.0000MHz\nU2X = 0 U2X = 1 U2X = 0 U2X = 1 U2X = 0 U2X = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 25 0.2% 51 0.2% 47 0.0% 95 0.0% 51 0.2% 103 0.2%\n4800 12 0.2% 25 0.2% 23 0.0% 47 0.0% 25 0.2% 51 0.2%\n9600 6 -7.0% 12 0.2% 11 0.0% 23 0.0% 12 0.2% 25 0.2%\n14.4k 3 8.5% 8 -3.5% 70 . 0 % 1 5 0 . 0 % 8 -3.5% 16 2.1%\n19.2k 2 8.5% 6 -7.0% 50 . 0 % 1 1 0 . 0 % 6 -7.0% 12 0.2%\n28.8k 1 8.5% 3 8.5% 3 0.0% 7 0.0% 38 . 5 %8 - 3 . 5 %\n38.4k 1 -18.6% 2 8.5% 2 0.0% 5 0.0% 28 . 5 %6 - 7 . 0 %\n57.6k 0 8.5% 1 8.5% 1 0.0% 3 0.0% 18 . 5 %38 . 5 %\n76.8k \u2013 \u2013 1 -18.6% 1 -25.0% 20 . 0 % 1 -18.6% 2 8.5%\n115.2k \u2013 \u2013 0 8.5% 0 0.0% 1 0.0% 08 . 5 %18 . 5 %\n230.4k \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 00 . 0 % \u2013-\u2013\u2013\n2 5 0 k \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 00 . 0 %\nMax (1)62.5kbps 125kbps 115.2kbps 230.4kbps 125kbps 250kbps\n1. UBRR = 0, Error = 0.0%\n\n154\n2486Z\u2013AVR\u201302/11ATmega8(L)Table 61.  Examples of UBRR Settings for Commonl y Used Oscillator Frequencies (Continued)\nBaud \nRate \n(bps)fosc = 3.6864MHz fosc = 4.0000MHz fosc = 7.3728MHz\nU2X = 0 U2X = 1 U2X = 0 U2X = 1 U2X = 0 U2X = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 95 0.0% 191 0.0% 103 0.2% 207 0.2% 191 0.0% 383 0.0%\n4800 47 0.0% 95 0.0% 51 0.2% 103 0.2% 95 0.0% 191 0.0%\n9600 23 0.0% 47 0.0% 25 0.2% 51 0.2% 47 0.0% 95 0.0%\n14.4k 15 0.0% 31 0.0% 16 2.1% 34 -0.8% 31 0.0% 63 0.0%\n19.2k 11 0.0% 23 0.0% 12 0.2% 25 0.2% 23 0.0% 47 0.0%\n28.8k 7 0.0% 15 0.0% 8 -3.5% 16 2.1% 15 0.0% 31 0.0%\n38.4k 5 0.0% 11 0.0% 6 -7.0% 12 0.2% 11 0.0% 23 0.0%\n57.6k 3 0.0% 7 0.0% 38 . 5 %8 - 3 . 5 % 70 . 0 % 1 5 0 . 0 %\n76.8k 2 0.0% 5 0.0% 28 . 5 %6 - 7 . 0 % 50 . 0 % 1 1 0 . 0 %\n115.2k 1 0.0% 3 0.0% 1 8.5% 3 8.5% 30 . 0 %70 . 0 %\n230.4k 0 0.0% 1 0.0% 0 8.5% 1 8.5% 10 . 0 %30 . 0 %\n250k 0 -7.8% 1 -7.8% 0 0.0% 1 0.0% 1 -7.8% 3 -7.8%\n0.5M \u2013 \u2013 0 -7.8% \u2013 \u2013 00 . 0 % 0 -7.8% 1 -7.8%\n1 M \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u20130 - 7 . 8 %\nMax (1)230.4kbps 460.8kbps 250kbps 0.5Mbps 460.8kbps 921.6kbps\n1. UBRR = 0, Error = 0.0%\n\n155\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTable 62.  Examples of UBRR Settings for Commonl y Used Oscillator Frequencies (Continued)\nBaud \nRate \n(bps)fosc = 8.0000MHz fosc = 11.0592 MHz fosc = 14.7456MHz\nU2X = 0 U2X = 1 U2X = 0 U2X = 1 U2X = 0 U2X = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 207 0.2% 416 -0.1% 287 0.0% 575 0.0% 383 0.0% 767 0.0%\n4800 103 0.2% 207 0.2% 143 0.0% 287 0.0% 191 0.0% 383 0.0%\n9600 51 0.2% 103 0.2% 71 0.0% 143 0.0% 95 0.0% 191 0.0%\n14.4k 34 -0.8% 68 0.6% 47 0.0% 95 0.0% 63 0.0% 127 0.0%\n19.2k 25 0.2% 51 0.2% 35 0.0% 71 0.0% 47 0.0% 95 0.0%\n28.8k 16 2.1% 34 -0.8% 23 0.0% 47 0.0% 31 0.0% 63 0.0%\n38.4k 12 0.2% 25 0.2% 17 0.0% 35 0.0% 23 0.0% 47 0.0%\n57.6k 8 -3.5% 16 2.1% 11 0.0% 23 0.0% 15 0.0% 31 0.0%\n76.8k 6 -7.0% 12 0.2% 8 0.0% 17 0.0% 11 0.0% 23 0.0%\n115.2k 3 8.5% 8 -3.5% 5 0.0% 11 0.0% 7 0.0% 15 0.0%\n230.4k 1 8.5% 3 8.5% 2 0.0% 5 0.0% 3 0.0% 7 0.0%\n250k 1 0.0% 3 0.0% 2 -7.8% 5 -7.8% 3 -7.8% 6 5.3%\n0.5M 0 0.0% 1 0.0% \u2013 \u2013 2 -7.8% 1 -7.8% 3 -7.8%\n1M \u2013 \u2013 00 . 0 % \u2013 \u2013 \u2013 \u2013 0 -7.8% 1 -7.8%\nMax (1)0.5Mbps 1Mbps 691.2kbps 1.3824Mbps 921.6kbps 1.8432Mbps\n1. UBRR = 0, Error = 0.0%\n\n156\n2486Z\u2013AVR\u201302/11ATmega8(L)Table 63.  Examples of UBRR Settings for Commonl y Used Oscillator Frequencies (Continued)\nBaud \nRate \n(bps)fosc = 16.0000MHz fosc = 18.4320MHz fosc = 20.0000MHz\nU2X = 0 U2X = 1 U2X = 0 U2X = 1 U2X = 0 U2X = 1\nUBRR Error UBRR Error UBRR Error UBRR Error UBRR Error UBRR Error\n2400 416 -0.1% 832 0.0% 479 0.0% 959 0.0% 520 0.0% 1041 0.0%\n4800 207 0.2% 416 -0.1% 239 0.0% 479 0.0% 259 0.2% 520 0.0%\n9600 103 0.2% 207 0.2% 119 0.0% 239 0.0% 129 0.2% 259 0.2%\n14.4k 68 0.6% 138 -0.1% 79 0.0% 159 0.0% 86 -0.2% 173 -0.2%\n19.2k 51 0.2% 103 0.2% 59 0.0% 119 0.0% 64 0.2% 129 0.2%\n28.8k 34 -0.8% 68 0.6% 39 0.0% 79 0.0% 42 0.9% 86 -0.2%\n38.4k 25 0.2% 51 0.2% 29 0.0% 59 0.0% 32 -1.4% 64 0.2%\n57.6k 16 2.1% 34 -0.8% 19 0.0% 39 0.0% 21 -1.4% 42 0.9%\n76.8k 12 0.2% 25 0.2% 14 0.0% 29 0.0% 15 1.7% 32 -1.4%\n115.2k 8 -3.5% 16 2.1% 90 . 0 % 1 9 0 . 0 % 10 -1.4% 21 -1.4%\n230.4k 3 8.5% 8 -3.5% 4 0.0% 9 0.0% 4 8.5% 10 -1.4%\n250k 3 0.0% 7 0.0% 4 -7.8% 8 2.4% 40 . 0 %90 . 0 %\n0.5M 1 0.0% 3 0.0% \u2013 \u2013 4 -7.8% \u2013 \u2013 40 . 0 %\n1M 0 0.0% 1 0.0% \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013\nMax (1)1Mbps 2Mbps 1.152Mbps 2.304Mbps 1.25Mbps 2.5Mbps\n1. UBRR = 0, Error = 0.0%\n\n157\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTwo-wire Serial \nInterface\nFeatures \u0081Simple Yet Powerful and Flexible Communi cation Interface, only two Bus Lines Needed\n\u0081Both Master and Slave Operation Supported\n\u0081Device can Operate as Transmitter or Receiver\n\u00817-bit Address Space Allows up to  128 Different Slave Addresses\n\u0081Multi-master Arbitration Support\n\u0081Up to 400kHz Data Transfer Speed\n\u0081Slew-rate Limited Output Drivers\n\u0081Noise Suppression Circuitry Re jects Spikes on Bus Lines\n\u0081Fully Programmable Slave Addr ess with General Call Support\n\u0081Address Recognition Causes Wake-up  When AVR is in Sleep Mode\nTwo-wire Serial \nInterface Bus \nDefinitionThe Two-wire Serial Interface (TWI) is ideally suited for typical microcontroller applications. The\nTWI protocol allows the systems designer to in terconnect up to 128 diffe rent devices using only\ntwo bi-directional bus lines, one for clock (SCL) and one for data (SDA). The only external hard-\nware needed to implement the bus is a single pull- up resistor for each of the TWI bus lines. All\ndevices connected to the bus have individual addresses, and mechanisms for resolving buscontention are inherent in the TWI protocol.\nFigure 68.  TWI Bus Interconnection\nTWI Terminology The following definitions are frequently encountered in this section.Device 1 Device 2 Device 3 Device n\nSDA\nSCL........ R1 R2VCC\nTable 64.  TWI Terminology\nTerm Description\nMaster The device that initiates and terminates a transmission. The Master also \ngenerates the SCL clock\nSlave The device addressed by a MasterTransmitter The device placing data on the bus\nReceiver The device reading data from the bus\n\n158\n2486Z\u2013AVR\u201302/11ATmega8(L)Electrical \nInterconnectionAs depicted in Figure 68 on page 157 , both bus lines are connected to the positive supply volt-\nage through pull-up resistors. The bus drivers of all TWI-compliant devices are open-drain oropen-collector. This implements a wired-AND function which is essential to the operation of theinterface. A low level on a TWI bus line is generated when one or more TWI devices output azero. A high level is output when all TWI devices tri-state their outputs, allowing the pull-up resis-tors to pull the line high. Note that all AVR devices connected to the TWI bus must be poweredin order to allow any bus operation.\nThe number of devices that can be connected to the bus is only limited by the bus capacitance\nlimit of 400pF and the 7-bit slave address space. A detailed specification of the electrical charac-\nteristics of the TWI is given in \u201cTwo-wire Serial Interface Characteristics\u201d on page 238 . Two\ndifferent sets of specificati ons are presented there, one relev ant for bus speeds below 100kHz,\nand one valid for bus speeds up to 400kHz.\nData Transfer and \nFrame Format\nTransferring Bits Each data bit transferred on the TWI bus is accompanied by a pulse on the clock line. The level\nof the data line must be stable when the clock line is  high. The only exception to this rule is for\ngenerating start and stop conditions.\nFigure 69.  Data Validity\nSTART and STOP \nConditionsThe Master initiates and terminates a data transmi ssion. The transmission is initiated when the\nMaster issues a START condition on the bus, and it is terminated when the Master issues aSTOP condition. Between a START and a STOP condition, the bus is considered busy, and noother master should try to seize control of the bus. A special case occurs when a new STARTcondition is issued between a START and STOP condition. This  is referred to as a REPEATED\nSTART condition, and is used when the Master wis hes to initiate a new transfer without relin-\nquishing control of  the bus. After a REPEATED START, the bus is considered busy until the next\nSTOP. This is identical to the START behavior, and therefore START is used to describe bothSTART and REPEATED START for the remainder of this datasheet, unless otherwise noted. Asdepicted below, START and STOP conditions are signalled by changing the level of the SDAline when the SCL line is high.SDA\nSCL\nData Stable Data Stable\nData Change\n\n159\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 70.  START, REPEATED START and STOP conditions\nAddress Packet \nFormatAll address packets transmitted on the TWI bus ar e 9 bits long, consisti ng of 7 address bits, one\nREAD/WRITE control bit and an acknowledge bit. If the READ/WRITE bit is set, a read opera-tion is to be performed, otherwise a write operation should be performed. When a Slaverecognizes that it is being a ddressed, it should acknowledge by  pulling SDA low in the ninth SCL\n(ACK) cycle. If the addressed Slave is busy, or  for some other reason can not service the Mas-\nter\u2019s request, the SDA line should be left high in the ACK clock cycle. The Master can then\ntransmit a STOP condition, or a REPEATED START condition to initiate a new transmission. An\naddress packet consisting of a slave address and a READ or a WRITE bit is called SLA+R orSLA+W, respectively.\nThe MSB of the address byte is transmitted first. Slave addresses can freely be allocated by the\ndesigner, but the address 0000 000 is reserved for a general call.\nWhen a general call is issued, all slaves should  respond by pulling the SDA line low in the ACK\ncycle. A general call is used when a Master wi shes to transmit the same message to several\nslaves in the system. When the general call address followed by a Write bit is transmitted on thebus, all slaves set up to ackn owledge the general call will pull th e SDA line low in the ack cycle.\nThe following data packets will then  be received by all the slaves  that acknowle dged the general\ncall. Note that transmitting the general call add ress followed by a Read bit is meaningless, as\nthis would cause contention if several slaves started transmitting different data.\nAll addresses of the format 1111 xxx should be reserved for future purposes.\nFigure 71.  Address Packet FormatSDA\nSCL\nSTART STOP REPEATED START STOP START\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\n\n160\n2486Z\u2013AVR\u201302/11ATmega8(L)Data Packet Format All data packets transmitted on the TWI bus are nine bits long, consisting of one data byte and\nan acknowledge bit. During a data transfer, the Master generates the clock and the START andSTOP conditions, while the Receiver is res ponsible for acknowledging the reception. An\nAcknowledge (ACK) is signalled by the Receiver pulling the SDA line low during the ninth SCL\ncycle. If the Receiver leaves the SDA line high, a NACK is signalled. When the Receiver hasreceived the last byte, or for some reason cannot receive any more bytes, it should inform theTransmitter by sending a NACK after the final byte. The MSB of the data byte is transmitted first. \nFigure 72.  Data Packet Format\nCombining Address \nand Data Packets into a TransmissionA transmission basically consists of a START co ndition, a SLA+R/W, one or more data packets\nand a STOP condition. An empty message, consisting of a START followed by a STOP condi-tion, is illegal. Note that the Wired-AN Ding of the SCL line can be used to implement\nhandshaking between the Master and the Slave. The Slave can extend the SCL low period bypulling the SCL line low. This is useful if the cloc k speed set up by the Master is too fast for the\nSlave, or the Slave needs extra time for proces sing between the data transmissions. The Slave\nextending the SCL low period will not affect t he SCL high period, which is determined by the\nMaster. As a consequence, the Slave can reduce the TWI data transfer speed by prolonging theSCL duty cycle.\nFigure 73  shows a typical data transmission. Note that several data bytes can be transmitted\nbetween the SLA+R/W and the STOP condition, depending on the software protocol imple-mented by the application software.\nFigure 73.  Typical Data Transmission12 789Data MSB Data LSB ACK\nAggregate\nSDA\nSDA from\nTransmitter\nSDA from\nReceiver\nSCL from\nMaster\nSLA+R/W Data ByteSTOP , REPEATED\nSTART or Next\nData Byte\n12 789\nData ByteData MSB Data LSB ACK\nSDA\nSCL\nSTART12 789Addr MSB Addr LSB R/W ACK\nSLA+R/W STOP\n\n161\n2486Z\u2013AVR\u201302/11ATmega8(L)\nMulti-master Bus \nSystems, \nArbitration and \nSynchronizationThe TWI protocol allows bus systems with seve ral masters. Special concerns have been taken\nin order to ensure that transmis sions will proceed as normal, even if two or more masters initiate\na transmission at the same time. Two problems arise in multi-master systems:\n\u0081 An algorithm must be implemented allowing only one of the masters to complete the \ntransmission. All other masters should cease tr ansmission when they discover that they \nhave lost the selection process. This selection process is called arbitration. When a contending master discovers that it has lost the arbitration process, it should immediately \nswitch to Slave mode to check whether it is being addressed by the winning master. The fact that multiple masters have started transmission at the same time should not be detectable to the slaves, that is, the data being transferred on the bus must not be corrupted\n\u0081 Different masters may use different SCL frequencies. A scheme must be devised to \nsynchronize the serial clocks from all masters, in order to let the transmission proceed in a lockstep fashion. This will fac ilitate the arbitration process\nThe wired-ANDing of the bus lines is used to solv e both these problems. The serial clocks from\nall masters will be wired-ANDed, yielding a co mbined clock with a high period equal to the one\nfrom the Master with the shortest high period. The low period of the combined clock is equal tothe low period of the Master with the longest low period. Note that all masters listen to the SCLline, effectively starting to count their SCL high and low time-out periods when the combined\nSCL line goes high or low, respectively.\nFigure 74.  SCL Synchronization Between Multiple Masters\nArbitration is carried out by all masters cont inuously monitoring the SDA line after outputting\ndata. If the value read from the SDA line does not match the value the Master had output, it haslost the arbitration. Note that a Master can only lose arbitration when it outputs a high SDA valuewhile another Master outputs a low value. The losing Master should immediately go to Slave\nmode, checking if it is being addressed by the winning Master. The SDA line should be left high,but losing masters are allowed to generate a clock signal until the end of the current data oraddress packet. Arbitration will cont inue until only one Master re mains, and this may take many\nbits. If several masters are trying to address th e same Slave, arbitratio n will continue into the\ndata packet.TAlowTAhigh\nSCL from\nMaster A\nSCL from\nMaster B\nSCL Bus\nLine\nTBlowTBhigh\nMasters Start\nCounting Low PeriodMasters Start\nCounting High Period\n\n162\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 75.  Arbitration Between Two Masters\nNote that arbitration is not allowed between:\n\u0081 A REPEATED START cond ition and a data bit\n\u0081 A STOP condition and a data bit\u0081 A REPEATED START and a STOP condition\nIt is the user software\u2019s responsibility to ensur e that these illegal arbitration conditions never\noccur. This implies that  in multi-master systems, all data transfers must use the same composi-\ntion of SLA+R/W and data packets. In other words: All transmissions must contain the samenumber of data packets, otherwise the result of the arbitration is undefined.SDA from\nMaster A\nSDA from\nMaster B\nSDA Line\nSynchronized\nSCL LineSTARTMaster A Loses\nArbitration, SDAA   SDA\n\n163\n2486Z\u2013AVR\u201302/11ATmega8(L)\nOverview of the \nTWI ModuleThe TWI module is comprised of several submodules, as shown in Figure 76 . All registers drawn\nin a thick line are accessible through the AVR data bus.\nFigure 76.  Overview of the TWI Module\nSCL and SDA Pins These pins interface the AVR TWI with the rest of the MCU system. The output drivers contain a\nslew-rate limiter in order to conform to the TWI specification. The input stages contain a spike\nsuppression unit removing spikes shorter than 50ns. Note that the internal pull-ups in the AVRpads can be enabled by setting the PORT bits corresponding to the SCL and SDA pins, asexplained in the I/O Port section. The internal pull-ups can in some systems eliminate the needfor external ones.\nTWI UnitAddress Register\n(TWAR)Address Match Unit\nAddress ComparatorControl Unit\nControl Register\n(TWCR)Status Register\n(TWSR)\nState Machine and\nStatus controlSCL\nSlew-rate\nControlSpike\nFilterSDA\nSlew-rate\nControlSpike\nFilter\nBit Rate Generator\nBit Rate Register\n(TWBR)PrescalerBus Interface Unit\nSTART / STOP\nControl\nArbitration detection AckSpike Suppression\nAddress/Data Shift\nRegister (TWDR)\n\n164\n2486Z\u2013AVR\u201302/11ATmega8(L)Bit Rate Generator \nUnitThis unit controls the period of SCL when oper ating in a Master mode. The SCL period is con-\ntrolled by settings in the TWI Bit Rate Register (TWBR) and the Prescaler bits in the TWI StatusRegister (TWSR). Slave operation does not depend on Bit Rate or Prescaler settings, but theCPU clock frequency in the Slave must be at l east 16 times higher than the SCL frequency. Note\nthat slaves may prolong the SCL low period, thereby reducing the average TWI bus clockperiod. The SCL frequency is generated according to the following equation:\n\u0081 TWBR = Value of the TWI Bit Rate Register\n\u0081 TWPS = Value of the prescaler bits in the TWI Status Register\nNote: Pull-up resistor values should be selected according to the SCL frequency and the capacitive bus\nline load. See Table 101 on page 238  for value of pull-up resistor\nBus Interface Unit This unit contains the Data and Address Shif t Register (TWDR), a START/STOP Controller and\nArbitration detection hardware. The TWDR contains the address or data bytes to be transmitted,or the address or data bytes received. In addition to the 8-bit TWDR, the Bus Interface Unit alsocontains a register containing the (N)ACK bit to be transmitted or receiv ed. This (N)ACK Regis-\nter is not directly accessible by the application software. However, when re ceiving, it can be set\nor cleared by manipulating the TWI Control R egister (TWCR). When in Transmitter mode, the\nvalue of the received (N)ACK bit can be determined by the value in the TWSR.\nThe START/STOP Controller is responsible for gene ration and detection of START, REPEATED\nSTART, and STOP conditions. The START/STOP controller is able to detect START and STOPconditions even when the AVR MCU is in one of  the sleep modes, enabling the MCU to wake up\nif addressed by a Master.\nIf the TWI has initiated a transmission as Master, the Arbitration Detection hardware continu-\nously monitors the transmission trying to determine if arbitration is in process. If the TWI has lostan arbitration, the Control Unit is informed. Correct action can then be taken and appropriatestatus codes generated.\nAddress Match Unit The Address Match unit checks if received address bytes match the seven-bit address in the\nTWI Address Register (TWAR). If the TWI General Call Recognition Enable (TWGCE) bit in the\nTWAR is written to one, all incoming address bits will also be compared against the General Call\naddress. Upon an address match, the Control Unit is informed, allowing correct action to betaken. The TWI may or may not acknowledge it s address, depending on settings in the TWCR.\nThe Address Match unit is able to compare addresses even when the AVR MCU is in sleepmode, enabling the MCU to wake up if addressed by a Master. If another interrupt (for example,INT0) occurs during TWI Power-down address match and wakes up the CPU, the TWI abortsoperation and return to it\u2019s idle state. If this cause any problems, ensure that TWI Address Matchis the only enabled interrupt when entering Power-down.\nControl Unit The Control unit monitors the TWI bus and generates responses corresponding to settings in the\nTWI Control Register (TWCR). When an event requiring the attention of the application occurson the TWI bus, the TWI Interrupt Flag (TWINT) is asserted. In the next clock cycle, the TWI Sta-tus Register (TWSR) is updated with a stat us code identifying the event. The TWSR only\ncontains relevant status information when the TW I Interrupt Flag is asserted. At all other times,\nthe TWSR contains a special stat us code indicating that no relevant status information is avail-\nable. As long as the TWINT Flag is set, the SCL line is held low. This allows the application\nsoftware to complete its tasks before allowing the TWI transmission to continue.SCL frequencyCPU Clock frequency\n16 2(TWBR) 4TWPS\u22c5 +-----------------------------------------------------------=\n\n165\n2486Z\u2013AVR\u201302/11ATmega8(L)\nThe TWINT Flag is set in the following situations:\n\u0081 After the TWI has transmitted a START/REPEATED START condition\n\u0081 After the TWI has transmitted SLA+R/W\u0081 After the TWI has transmitted an address byte\u0081 After the TWI has lost arbitration\u0081 After the TWI has been addressed by own slave address or general call\u0081 After the TWI has received a data byte\u0081 After a STOP or REPEATED START has been received while still add ressed as a Slave\n\u0081 When a bus error has occurred due to  an illegal START or STOP condition\nTWI Register \nDescription\nTWI Bit Rate Register \n\u2013 TWBR\n\u0081 Bits 7..0 \u2013 TWI Bit Rate Register\nTWBR selects the division factor for the bit rate  generator. The bit rate generator is a frequency\ndivider which generates the SCL clock frequency in the Master modes. See \u201cBit Rate Generator\nUnit\u201d on page 164  for calculating bit rates.\nTWI Control Register \u2013 \nTWCR\nThe TWCR is used to control the operation of the TWI. It is used to enable the TWI, to initiate a\nMaster access by applying a START condition to the bus, to generate a Receiver acknowledge,to generate a stop condition, and to control halting of the bus while the data to be written to thebus are written to the TWDR. It also indicates a write collision if data is attempted written to\nTWDR while the regist er is inaccessible.\n\u0081 Bit 7 \u2013 TWINT: TWI Interrupt Flag\nThis bit is set by hardware when the TWI has  finished its current job and expects application\nsoftware response. If the I-bit in  SREG and TWIE in TWCR are set, the MCU will jump to the\nTWI Interrupt Vector. While the TWINT Flag is set, the SCL low period is stretched. The TWINTFlag must be cleared by software by writing a logic one to it. Note that this flag is not automati-\ncally cleared by hardware when executing the interr upt routine. Also note that clearing this flag\nstarts the operation of the TWI, so all accesses to the TWI Address Register (TWAR), TWI Sta-tus Register (TWSR), and TWI Data Register (TWDR) must be complete before clearing thisflag.B i t 76543210\nTWBR7 TWBR6 TWBR5 TWBR4 TWBR3 TWBR2 TWBR1 TWBR0 TWBR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 76543210\nTWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE TWCR\nRead/Write R/W R/W R/W R/W R R/W R R/WI n i t i a l  V a l u e 00000000\n\n166\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bit 6 \u2013 TWEA: TWI Enable Acknowledge Bit\nThe TWEA bit controls the generation of the acknowledge pulse. If the TWEA bit is written to\none, the ACK pulse is generated on the TWI bus if the following conditions are met:\n1. The device\u2019s own slave address has been received2. A general call has been received, while the TWGCE bit in the TWAR is set3. A data byte has been received in Master Receiver or Slave Receiver mode\nBy writing the TWEA bit to zero, the device can be virtually disconnected from the Two-wire\nSerial Bus temporarily. Address recognition can then be resumed by writing the TWEA bit to oneagain.\n\u0081 Bit 5 \u2013 TWSTA: TWI START Condition Bit\nThe application writes the TWSTA bit to one when it desires to become a Master on the Two-\nwire Serial Bus. The TWI hardware checks if the bus is available, and generates a START con-dition on the bus if it is free. However, if the bus is not free, t he TWI waits until a STOP condition\nis detected, and then generates a new START condition to claim the bus Master status. TWSTAmust be cleared by software when the START condition has been transmitted.\n\u0081 Bit 4 \u2013 TWSTO: TWI STOP Condition Bit\nWriting the TWSTO bit to one in Master mode will generate a STOP condition on the Two-wire\nSerial Bus. When the STOP condition is exec uted on the bus, the TWSTO bit is cleared auto-\nmatically. In Slave mode, setting the TWSTO bit can be used to recover from an error condition.This will not generate a STOP co ndition, but the TWI returns to a well-defined unaddressed\nSlave mode and releases the SCL and SDA lines to a high impedance state.\n\u0081 Bit 3 \u2013 TWWC: TWI Write Collision Flag\nThe TWWC bit is set when attempting to write to the TWI Data Register \u2013 TWDR when TWINT is\nlow. This flag is cleared by writing the TWDR Register when TWINT is high.\n\u0081 Bit 2 \u2013 TWEN: TWI Enable Bit\nThe TWEN bit enables TWI operation and activate s the TWI interface. When TWEN is written to\none, the TWI takes control over the I/O pins connected to the SCL and SDA pins, enabling the\nslew-rate limiters and spike filters. If this bit is written to zero, the TWI is switched off and all TWI\ntransmissions are terminated, regardless of any ongoing operation.\n\u0081 Bit 1 \u2013 Res: Reserved Bit\nThis bit is a reserved bit an d will always read as zero.\n\u0081 Bit 0 \u2013 TWIE: TWI Interrupt Enable\nWhen this bit is written to one, and the I-bit in SREG is set, th e TWI interrupt request will be acti-\nvated for as long as the TWINT Flag is high.\nTWI Status Register \u2013 \nTWSR\n\u0081 Bits 7..3 \u2013 TWS: TWI Status\nThese 5 bits reflect the status of the TWI logic and the Two-wire Serial Bus. The different status\ncodes are described later in this section. Note that the value read from TWSR contains both the5-bit status value and the 2-bit prescaler value. The application designer should mask the pres-caler bits to zero when checking the Status bits. This makes status checking independent ofprescaler setting. This approach is used in this datasheet, unless otherwise noted.B i t 76543210\nTWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 TWSR\nR e a d / W r i t e RRRRRR R / W R / WI n i t i a l  V a l u e 11111000\n\n167\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 2 \u2013 Res: Reserved Bit\nThis bit is reserved and will always read as zero.\n\u0081 Bits 1..0 \u2013 TWPS: TWI Prescaler Bits\nThese bits can be read and written, and control the bit rate prescaler.\nTo calculate bit rates, see \u201cBit Rate Generator Unit\u201d on page 164 . The value of TWPS1..0 is\nused in the equation.\nTWI Data Register \u2013 \nTWDR\nIn Transmit mode, TWDR contains the next byte to be transmitted. In Receive mode, the TWDR\ncontains the last byte received. It is writable while  the TWI is not in the process of shifting a byte.\nThis occurs when the TWI Interrupt Flag (TWINT) is set by hardware. Note that the Data Regis-\nter cannot be initialized by the user before the first interrupt occurs. The data in TWDR remainsstable as long as TWINT is se t. While data is shifted out, data on the bus is simultaneously\nshifted in. TWDR always contains the last byte present on the bus, except after a wake up froma sleep mode by the TWI interrupt. In this case, the contents of TWDR is undefined. In the caseof a lost bus arbitration, no data is lost in the transition from Master to Slave. Handling of theACK bit is controlled automatically  by the TWI logic, the CPU cannot access the ACK bit directly.\n\u0081 Bits 7..0 \u2013 TWD: TWI Data Register\nThese eight bits constitute the next data byte to be transmitted, or the latest data byte received\non the Two-wire Serial Bus.\nTWI (Slave) Address \nRegister \u2013 TWAR\nThe TWAR should be loaded with the 7-bit Slave address (in the seven most significant bits of\nTWAR) to which the TWI will respond when programmed as a Slave Transmitter or Receiver,and not needed in the Master modes. In multimaster systems, TWAR must be set in masterswhich can be addressed as Slaves by other Masters.\nThe LSB of TWAR is used to enable recognition of the general call address (0x00). There is an\nassociated address comparator that looks for the slave address (or general call address ifenabled) in the received serial address. If a match is found, an interrupt request is generated.Table 65.  TWI Bit Rate Prescaler\nTWPS1 TWPS0 Prescaler Value\n001014\n101 6\n116 4\nB i t 76543210\nTWD7 TWD6 TWD5 TWD4 TWD3 TWD2 TWD1 TWD0 TWDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 11111111\nB i t 76543210\nTWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE TWAR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 11111110\n\n168\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Bits 7..1 \u2013 TWA: TWI (Slave) Address Register\nThese seven bits constitute th e slave address of the TWI unit.\n\u0081 Bit 0 \u2013 TWGCE: TWI General Call Recognition Enable Bit\nIf set, this bit enables the recognition of a General Call given over the Two-wire Serial Bus.\nUsing the TWI The AVR TWI is byte-oriented and interrupt based. Interrupts are issued after all bus events, like\nreception of a byte or transmission of a START condition. Because the TWI is interrupt-based,the application software is free to carry on other operations during a TWI byte transfer. Note thatthe TWI Interrupt Enable (TWIE) bit in TWCR to gether with the Global Interrupt Enable bit in\nSREG allow the application to decide whether or not assertion of the TWINT Flag should gener-ate an interrupt request. If the TWIE bit is clear ed, the application must poll the TWINT Flag in\norder to detect actions on the TWI bus.\nWhen the TWINT Flag is asserted, the TWI has  finished an operation and awaits application\nresponse. In this case, the TWI Status Register (TWSR) contains a value indicating the currentstate of the TWI bus. The application software can then decide how the TWI should behave inthe next TWI bus cycle by manipulating the TWCR and TWDR Registers.\nFigure 77  is a simple example of how the application can interface to the TWI hardware. In this\nexample, a Master wishes to transmit a single data byte to a Slave. This description is quiteabstract, a more detailed explanation follows later in this section. A simple code example imple-menting the desired behavior is also presented.\nFigure 77.  Interfacing the Application to the TWI in a Typical Transmission\n1. The first step in a TWI transmission is to  transmit a START condition. This is done by\nwriting a specific value into TWCR, instru cting the TWI hardware to transmit a START\ncondition. Which value to write is described later on. However, it is important that the\nTWINT bit is set in the value written. Writin g a one to TWINT clears the flag. The TWI will\nnot start any operation as long as the TWINT bit in TWCR is set. Immediately after theapplication has cleared TWINT, the TWI will init iate transmission of the START condition\n2. When the START condition has been transmitted, the TWINT Flag in TWCR is set, and\nTWSR is updated with a status code indicating that the START condition has success-fully been sentSTART SLA+W A Data A STOP1. Application\nwrites to TWCR to\ninitiate\ntransmission of\nSTART\n2. TWINT set.\nStatus code indicates\nSTART condition sent4. TWINT set.\nStatus code indicates\nSLA+W sent, ACK\nreceived6. TWINT set.\nStatus code indicates\ndata sent, ACK received3. Check TWSR to see if START was \nsent. Application loads SLA+W into \nTWDR, and loads appropriate control \nsignals into TWCR, makin sure that \nTWINT is written to one, \nand TWSTA is written to zero.5. Check TWSR to see if SLA+W was\nsent and ACK received.\nApplication loads data into TWDR, and\nloads appropriate control signals into\nTWCR, making sure that TWINT is\nwritten to one7. Check TWSR to see if data was sent\nand ACK received.\nApplication loads appropriate control\nsignals to send STOP into TWCR,\nmaking sure that TWINT is written to one\nTWI bus\nIndicates\nTWINT setApplication\nAction TWI\nHardware\nAction\n\n169\n2486Z\u2013AVR\u201302/11ATmega8(L)\n3. The application software should now examine the value of TWSR, to make sure that the\nSTART condition was successfully transmitted. If TWSR indicates otherwise, the applica-tion software might take some  special action, like calling an  error routine. Assuming that\nthe status code is as expected, the application must load SLA+W into TWDR. Rememberthat TWDR is used both for address and data. After TWDR has been loaded with thedesired SLA+W, a specific value must be written to TWCR, instructing the TWI hardwareto transmit the SLA+W present in TWDR. Whic h value to write is described later on.\nHowever, it is important that the TWINT bit is set in the value written. Writing a one to\nTWINT clears the flag. The TWI will not start any operation as long as the TWINT bit in\nTWCR is set. Immediately after the applicat ion has cleared TWINT,  the TWI will initiate\ntransmission of the address packet\n4. When the address packet has been transmitted, the TWINT Flag in TWCR is set, and\nTWSR is updated with a status code indicating that the address packet has successfullybeen sent. The status code will also reflec t whether a Slave acknowledged the packet or\nnot\n5. The application software should now examine the value of TWSR, to make sure that the\naddress packet was successfully transmitted, and that the value of the ACK bit was asexpected. If TWSR indicates otherwise, the application software might take some specialaction, like calling an erro r routine. Assuming that the st atus code is as expected, the\napplication must load a data packet into TWDR. Subsequently, a specific value must bewritten to TWCR, instructing the TWI hardwa re to transmit the data packet present in\nTWDR. Which value to write is described late r on. However, it is important that the\nTWINT bit is set in the value written. Writin g a one to TWINT clears the flag. The TWI will\nnot start any operation as long as the TWINT bit in TWCR is set. Immediately after theapplication has cleared TWINT, the TWI will in itiate transmission of the data packet\n6. When the data packet has been transmitted, the TWINT Flag in TWCR is set, and TWSR\nis updated with a status code indicating that the data packet has successfully been sent.The status code will also re flect whether a Slave ackno wledged the packet or not\n7. The application software should now examine the value of TWSR, to make sure that the\ndata packet was successfully transmitted, and that the value of the ACK bit was asexpected. If TWSR indicates otherwise, the application software might take some specialaction, like calling an erro r routine. Assuming that the st atus code is as expected, the\napplication must write a specific value to TW CR, instructing the TWI hardware to transmit\na STOP condition. Which value to write is described later on. However, it is important thatthe TWINT bit is set in the value written. Writing a one to TWINT clears the flag. The TWIwill not start any operation as long as the TW INT bit in TWCR is set. Immediately after\nthe application has cleared TWINT, the TWI will initiate transmission of the STOP condi-tion. Note that TWINT is NOT set after a STOP condition has been sent\nEven though this example is simple, it shows t he principles involved in all TWI transmissions.\nThese can be summarized as follows:\n\u0081 When the TWI has finished an operation and expects application response, the TWINT Flag \nis set. The SCL line is pulled low until TWINT is cleared\n\u0081 When the TWINT Flag is set, the user must update all TWI Registers with the value relevant \nfor the next TWI bus cycle. As an example, TWDR must be loaded with the value to be transmitted in the next bus cycle\n\u0081 After all TWI Register updates and other pending application software tasks have been \ncompleted, TWCR is written. When writing TWCR, the TWINT bit should be set. Writing a \none to TWINT clears the flag. The TWI will then commence executing whatever operation \nwas specified by the TWCR setting\nIn the following an assembly and C implementation  of the example is given. Note that the code\nbelow assumes that several definitions have been made, for example by using include-files.\n\n170\n2486Z\u2013AVR\u201302/11ATmega8(L)Assembly Code Example C Example Comments\n1ldir16, (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN)\noutTWCR, r16TWCR = (1<<TWINT)|(1<<TWSTA)|\n(1<<TWEN)Send START condition\n2wait1:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait1while (!(TWCR & (1<<TWINT)))\n;Wait for TWINT Flag set. This \nindicates that the START condition \nhas been transmitted\n3inr16,TWSR\nandir16, 0xF8\ncpir16, START\nbrneERRORif ((TWSR & 0xF8) != START)\nERROR();Check value of TWI Status \nRegister. Mask prescaler bits. If status different from START go to \nERROR\nldir16, SLA_W\noutTWDR, r16 \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = SLA_W;\nTWCR = (1<<TWINT) | (1<<TWEN);Load SLA_W into TWDR Register. \nClear TWINT bit in TWCR to start \ntransmission of address\n4wait2:\ninr16,TWCR\nsbrsr16,TWINT\nrjmpwait2while (!(TWCR & (1<<TWINT)))\n;Wait for TWINT Flag set. This \nindicates that the SLA+W has been \ntransmitted, and ACK/NACK has \nbeen received.\n5inr16,TWSR\nandir16, 0xF8\ncpir16, MT_SLA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_SLA_ACK)\nERROR();Check value of TWI Status \nRegister. Mask prescaler bits. If status different from MT_SLA_ACK \ngo to ERROR\nldir16, DATA\noutTWDR, r16       \nldir16, (1<<TWINT) | (1<<TWEN)\noutTWCR, r16TWDR = DATA;\nTWCR = (1<<TWINT) | (1<<TWEN);Load DATA into TWDR Register. \nClear TWINT bit in TWCR to start \ntransmission of data\n6wait3:\ninr16,TWCR\nsbrs\nr16,TWINT\nrjmpwait3while (!(TWCR & (1<<TWINT)))\n;Wait for TWINT Flag set. This \nindicates that the DATA has been \ntransmitted, and ACK/NACK has \nbeen received.\n7inr16,TWSR\nandir16, 0xF8\ncpir16, MT_DATA_ACK\nbrneERRORif ((TWSR & 0xF8) != \nMT_DATA_ACK)\nERROR();Check value of TWI Status \nRegister. Mask prescaler bits. If status different from \nMT_DATA_ACK go to ERROR\nldir16, (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO)\noutTWCR, r16 TWCR = (1<<TWINT)|(1<<TWEN)|\n(1<<TWSTO);Transmit STOP condition\n\n171\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTransmission \nModesThe TWI can operate in one of four major modes. These are named Master Transmitter (MT),\nMaster Receiver (MR), Slave Transmitter (ST)  and Slave Receiver (SR). Several of these\nmodes can be used in the same application. As  an example, the TWI can use MT mode to write\ndata into a TWI EEPROM, MR mode  to read the data back from the EEPROM. If other masters\nare present in the system, some of these might transmit data to the TWI, and then SR modewould be used. It is the application softw are that decides which modes are legal.\nThe following sections describe each of these modes. Possible status codes are described\nalong with figures detailing data transmission in  each of the modes. These figures contain the\nfollowing abbreviations:\nS: START condition\nRs: REPEATED START condition\nR: Read bit (high level at SDA)\nW: Write bit (low level at SDA)\nA: Acknowledge bit (low level at SDA)\nA\n: Not acknowledge bit (high level at SDA)\nData : 8-bit data byte\nP: STOP condition\nSLA: Slave Address\nIn Figure 79 on page 174  to Figure 85 on page 183 , circles are used to indicate that the TWINT\nFlag is set. The numbers in the circles show the status code held in TWSR, with the prescalerbits masked to zero. At these points, actions must be taken by the application to continue orcomplete the TWI transfer. The TWI transfer is suspended until the TWINT Flag is cleared bysoftware.\nWhen the TWINT Flag is set, the status code in  TWSR is used to determine the appropriate soft-\nware action. For each status code, the required software action and details of the following serialtransfer are given in Table 66 on page 173  to Table 69 on page 182 . Note that the prescaler bits\nare masked to zero in these tables.\nMaster Transmitter \nModeIn the Master Transmitter mode, a number of data bytes are transmitted to a Slave Receiver\n(see Figure 78 on page 172 ). In order to enter a Master mode, a START condition must be\ntransmitted. The format of the following address packet determines whether Master Transmitteror Master Receiver mode is to be entered. If SLA+W is transmitted, MT mode is entered, ifSLA+R is transmitted, MR mode is entered. All the status codes mentioned in this sectionassume that the prescaler bits are zero or are masked to zero.\n\n172\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 78.  Data Transfer in Ma ster Transmitter Mode\nA START condition is sent by wr iting the following value to TWCR:\nTWEN must be set to enable the Two-wire Serial Interface, TWSTA must be written to one to\ntransmit a START condition and TWINT must be written to one to clear the TWINT Flag. TheTWI will then test the Two-wire Serial Bus and ge nerate a START condition as soon as the bus\nbecomes free. After a START condition has been transmitted, the TWINT Flag is set by hard-\nware, and the status code in TWSR will be 0x08 (see Table 66 on page 173 ). In order to enter\nMT mode, SLA+W must be transmitted. This is done by writing SLA+W to TWDR. Thereafter theTWINT bit should be cleared (by writing it to one) to continue the transfer. This is accomplishedby writing the following value to TWCR:\nWhen SLA+W have been transmitted and an acknowledgement bit has been received, TWINT is\nset again and a number of status codes in TWSR are possible. Possible status codes in Mastermode are 0x18, 0x20, or 0x38. The appropriate action to be taken for each of these status codesis detailed in Table 66 on page 173 .\nWhen SLA+W has been successfully transmitted, a data packet should be transmitted. This is\ndone by writing the data byte to TWDR. TWDR must only be written when TWINT is high. If not,the access will be discarded, and  the Write Collision bit (TWWC) will be set in the TWCR Regis-\nter. After updating TWDR, the TWINT bit should be cleared (by writing it to one) to continue thetransfer. This is acco mplished by writing the following value to TWCR:\nThis scheme is repeated until the last byte has been sent and the transfer is ended by generat-\ning a STOP condition or a repeated START condition. A STOP condition is generated by writingthe following value to TWCR:\nA REPEATED START condition is generated by writing the following value to TWCR:\nAfter a repeated START condition (state 0x10) the Two-wire Serial Interface can access the\nsame Slave again, or a new Slave without trans mitting a STOP condition. Repeated STARTTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 XDevice 1\nMASTER\nTRANSMITTERDevice 2\nSLAVE\nRECEIVERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n173\n2486Z\u2013AVR\u201302/11ATmega8(L)\nenables the Master to switch between Slaves, Master Transmitter mode and Master Receiver\nmode without losing control of the bus.\nTable 66.  Status codes for Master Transmitter Mode\nStatus Code\n(TWSR)\nPrescaler Bits\nare 0Status of the Two-wire Serial\nBus and Two-wire Serial Inter-\nface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDR To TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+W 0 0 1 X SLA+W will be transmitted;\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+W or \nLoad SLA+R0\n00\n01\n1X\nXSLA+W will be transmitted;\nACK or NOT ACK will be received\nSLA+R will be transmitted;\nLogic will switch to Master Receiver mode\n0x18 SLA+W has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x20 SLA+W has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe receivedRepeated START will be transmitted\nSTOP condition will be transmitted and\nTWSTO Flag will be resetSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x28 Data byte has been transmitted;\nACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n11X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmitted\nSTOP condition will be transmitted andTWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n0x30 Data byte has been transmitted;\nNOT ACK has been receivedLoad data byte or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n1\n0\n10\n0\n1\n11\n1\n1\n1X\nX\nX\nXData byte will be transmitted and ACK or NOT ACK will \nbe received\nRepeated START will be transmittedSTOP condition will be transmitted and\nTWSTO Flag will be reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x38 Arbitration lost in SLA+W or data\nbytesNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nXTwo-wire Serial Bus will be released and not addressed \nSlave mode enteredA START condition will be transmitted when the bus be-\ncomes free\n\n174\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 79.  Formats and States in the Master Transmitter Mode \nS SLA W A DATA A P\n$08 $18 $28\nR SLA W\n$10\nAP\n$20\nP\n$30\nA or A\n$38A\nOther master\ncontinues A or A\n$38Other master\ncontinuesR\nA\n$68Other master\ncontinues\n$78 $B0To correspondingstates in slave modeMT\nMRSuccessfull\ntransmissionto a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nNot acknowledge\nreceived after a databyte\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. Theprescaler bits are zero or masked to zeroS\n\n175\n2486Z\u2013AVR\u201302/11ATmega8(L)\nMaster Receiver Mode In the Master Receiver mode, a number of data bytes are received from a Slave Transmitter\n(see Figure 80 ). In order to enter a Master mode, a START condition must be transmitted. The\nformat of the following address packet determines whether Master Transmitter or MasterReceiver mode is to be entered. If SLA+W is transmitted, MT mode is entered, if SLA+R is trans-mitted, MR mode is entered. All the status codes mentioned in this section assume that theprescaler bits are zero or are masked to zero.\nFigure 80.  Data Transfer in Master Receiver Mode\nA START condition is sent by wr iting the following value to TWCR:\nTWEN must be written to one to enable the Two-wire Serial Interface, TWSTA must be written to\none to transmit a START condition and TWINT must be set to clear the TWINT Flag. The TWIwill then test the Two-wire Serial Bus and gene rate a START condition as soon as the bus\nbecomes free. After a START condition has been transmitted, the TWINT Flag is set by hard-\nware, and the status code in TWSR will be 0x08 (see Table 66 on page 173 ). In order to enter\nMR mode, SLA+R must be transmitted. This is done by writing SLA+R to TWDR. Thereafter the\nTWINT bit should be cleared (by writing it to one) to continue the transfer. This is accomplishedby writing the following value to TWCR:\nWhen SLA+R have been transmitted and an acknowledgement bit has been received, TWINT is\nset again and a number of status codes in TWSR are possible. Possible status codes in Mastermode are 0x38, 0x40, or 0x48. The appropriate action to be taken for each of these status codesis detailed in Table 67 on page 176 . Received data can be read from the TWDR Register when\nthe TWINT Flag is set high by hardware. This  scheme is repeated until the last byte has been\nreceived. After the last byte has been received, the MR should inform the ST by sending aNACK after the last received data byte. The transfer is ended by generating a STOP condition ora repeated START condition. A STOP condition is generated by writing the following value toTWCR:\nA REPEATED START condition is generated by writing the following value to TWCR:TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X00 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X01 X1 0 X\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 1 X10 X1 0 XDevice 1\nMASTER\nRECEIVERDevice 2\nSLAVE\nTRANSMITTERDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\n\n176\n2486Z\u2013AVR\u201302/11ATmega8(L)After a repeated START condition (state 0x10) the Two-wire Serial Interface can access the\nsame Slave again, or a new Slave without trans mitting a STOP condition. Repeated START\nenables the Master to switch between Slaves, Master Transmitter mode and Master Receivermode without losing control over the bus.\nTable 67.  Status codes for Master Receiver Mode\nStatus Code\n(TWSR)\nPrescaler Bits\nare 0Status of the Two-wire Serial\nBus and Two-wire Serial Inter-\nface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x08 A START condition has been\ntransmittedLoad SLA+R 0 0 1 X SLA+R will be transmitted\nACK or NOT ACK will be received\n0x10 A repeated START condition\nhas been transmittedLoad SLA+R or \nLoad SLA+W0\n00\n01\n1X\nXSLA+R will be transmitted\nACK or NOT ACK will be received\nSLA+W will be transmitted\nLogic will switch to Master Transmitter mode\n0x38 Arbitration lost in SLA+R or NOT\nACK bitNo TWDR action or\nNo TWDR action0\n10\n01\n1X\nXTwo-wire Serial Bus will be released and not addressed \nSlave mode will be entered\nA START condition will be transmitted when the busbecomes free\n0x40 SLA+R has been transmitted;\nACK has been receivedNo TWDR action or\nNo TWDR action0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x48 SLA+R has been transmitted;\nNOT ACK has been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will \nbe reset\nSTOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset\n0x50 Data byte has been received;\nACK has been returnedRead data byte or\nRead data byte0\n00\n01\n10\n1Data byte will be received and NOT ACK will be \nreturnedData byte will be received and ACK will be returned\n0x58 Data byte has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte1\n0\n10\n1\n11\n1\n1X\nX\nXRepeated START will be transmitted\nSTOP condition will be transmitted and TWSTO Flag will be reset\nSTOP condition followed by a START condition will be \ntransmitted and TWSTO Flag will be reset\n\n177\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 81.  Formats and States in the Master Receiver Mode\nSlave Receiver Mode In the Slave Receiver mode, a number of data bytes are received from a Master Transmitter\n(see Figure 82 ). All the status codes mentioned in this section assume that the prescaler bits are\nzero or are masked to zero.\nFigure 82.  Data transfer in Slave Receiver mode\nTo initiate the Slave Receiver mode, TWAR  and TWCR must be initialized as follows:S SLA R A DATA A\n$08 $40 $50\nSLA R\n$10\nAP\n$48\nA or A\n$38Other master\ncontinues\n$38Other master\ncontinuesW\nA\n$68Other master\ncontinues\n$78 $B0To correspondingstates in slave modeMR\nMTSuccessfull\nreceptionfrom a slavereceiver\nNext transfer\nstarted with arepeated startcondition\nNot acknowledge\nreceived after theslave address\nArbitration lost in slave\naddress or data byte\nArbitration lost and\naddressed as slave\nDATA A\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP DATA A\n$58\nARS\nTWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave AddressDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nTRANSMITTERDevice 1\nSLAVE\nRECEIVER\n\n178\n2486Z\u2013AVR\u201302/11ATmega8(L)The upper 7 bits are the address to which the Two-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the TWI will respond to the general call address (0x00),otherwise it will ignore the general call address.\nTWEN must be written to one to enable the TWI. The TWEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. TWSTAand TWSTO must be written to zero.\nWhen TWAR and TWCR have been initialized, the TWI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If thedirection bit is \u201c0\u201d (write), the TWI will operate in SR mode, otherwise ST  mode is entered. After\nits own slave address and the write bit have been received, the TWINT Flag is set and a validstatus code can be read from TWSR. The status c ode is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 68 on\npage 179 . The Slave Receiver mode may also be entere d if arbitration is lo st while the TWI is in\nthe Master mode (see states 0x68 and 0x78).\nIf the TWEA bit is reset during a transfer, the TW I will return a \u201cNot Acknowledge\u201d (\u201c1\u201d) to SDA\nafter the next received data byte. This can be used to indicate that the Slave is not able toreceive any more bytes. While TWEA is zero, the TWI does not acknowledge its own slaveaddress. However, the Two-wire Serial Bus is still monitored and address recognition may\nresume at any time by setting TWEA. This implies that the TWEA bit may be used to temporarilyisolate the TWI from the Two-wire Serial Bus.\nIn all sleep modes other than Idle mode, the clock system to the TWI is turned off. If the TWEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the Two-wire Serial Bus clock as a clock source. The part will then wake up from sleepand the TWI will hold the SCL cl ock low during the wake up and until the TWINT Flag is cleared\n(by writing it to one). Further data reception will be carri ed out as normal, with the AVR clocks\nrunning as normal. Observe that if the AVR is set up with a long start-up time, the SCL line maybe held low for a long time, blocking other data transmissions.\nNote that the Two-wire Serial Interface Data Register \u2013 TWDR does not reflect the last byte\npresent on the bus when waking up from these Sleep modes.TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 X\n\n179\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTable 68.  Status Codes for Slave Receiver Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the Two-wire Serial Bus\nand Two-wire Serial Interface\nHardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0x60 Own SLA+W has been received;\nACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x68 Arbitration lost in SLA+R/W as\nMaster; own SLA+W has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x70 General call address has been \nreceived; ACK has been returnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x78 Arbitration lost in SLA+R/W as\nMaster; General call address has\nbeen received; ACK has been \nreturnedNo TWDR action or\nNo TWDR actionX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x80 Previously addressed with own\nSLA+W; data has been received;\nACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x88 Previously addressed with own\nSLA+W; data has been received;\nNOT ACK has been returnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;no recognition of own SLA or GCA;\na START condition will be transmitted when the bus \nbecomes freeSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0x90 Previously addressed with \ngeneral call; data has been re-\nceived; ACK has been returnedRead data byte or\nRead data byteX\nX0\n01\n10\n1Data byte will be received and NOT ACK will be re-\nturned\nData byte will be received and ACK will be returned\n0x98 Previously addressed with \ngeneral call; data has been \nreceived; NOT ACK has been \nreturnedRead data byte or\nRead data byte or\nRead data byte or\nRead data byte0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;a START condition will be transmitted when the bus \nbecomes free\n0xA0 A STOP condition or repeated\nSTART condition has been \nreceived while still addressed as\nSlaveNo action 0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus becomes free\n\n180\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 83.  Formats and States in the Slave Receiver Mode\nS SLA W A DATA A\n$60 $80\n$88\nA\n$68Reception of the own\nslave address and one ormore data bytes.  All areacknowledged\nLast data byte received\nis not acknowledged\nArbitration lost as master\nand addressed as slave\nReception of the general call\naddress and one or more databytes\nLast data byte received is\nnot acknowledged\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA A\n$80 $A0\nP or S A\nA DATA A\n$70 $90\n$98\nA\n$78P or S DATA A\n$90 $A0\nP or S AGeneral Call\nArbitration lost as master and\naddressed as slave by general call\nDATA A\n\n181\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSlave Transmitter \nModeIn the Slave Transmitter mode, a number of data bytes are transmitted to a Master Receiver\n(see Figure 84 ). All the status codes mentioned in this section assume that the prescaler bits are\nzero or are masked to zero.\nFigure 84.  Data Transfer in Slave Transmitter Mode\nTo initiate the Slave Transmitter mode, TWAR  and TWCR must be in itialized as follows:\nThe upper seven bits are the address to which t he Two-wire Serial Interface will respond when\naddressed by a Master. If the LSB is set, the TWI will respond to the general call address (0x00),otherwise it will ignore the general call address.\nTWEN must be written to one to enable the TWI. The TWEA bit must be written to one to enable\nthe acknowledgement of the device\u2019s own slave address or the general call address. TWSTAand TWSTO must be written to zero.\nWhen TWAR and TWCR have been initialized, the TWI waits until it is addressed by its own\nslave address (or the general call address if enabled) followed by the data direction bit. If thedirection bit is \u201c1\u201d (read), the TWI will operate in ST mode, otherw ise SR mode is entered. After\nits own slave address and the write bit have been received, the TWINT Flag is set and a validstatus code can be read from TWSR. The status c ode is used to determine the appropriate soft-\nware action. The appropriate action to be taken for each status code is detailed in Table 69 on\npage 182 . The Slave Transmitter mode may also be entered if arbitration is lost while the TWI is\nin the Master mode (see state 0xB0).\nIf the TWEA bit is written to zero  during a transfer, the TWI will transm it the last byte of the trans-\nfer. State 0xC0 or state 0xC8 will be entere d, depending on whether the Master Receiver\ntransmits a NACK or ACK after the final byte. The TWI is switched to the not addressed Slavemode, and will ignore the Mast er if it continues th e transfer. Thus the Ma ster Receiver receives\nall \u201c1\u201d as serial data. State 0xC8 is entered if the Master demands additional data bytes (bytransmitting ACK), even though the Slave has transmitted the last byte (TWEA zero and expect-ing NACK from the Master).\nWhile TWEA is zero, the TWI does not respond to its own slave address. However, the Two-wire\nSerial Bus is still monitored an d address recognition may resume  at any time by setting TWEA.\nThis implies that the TWEA bit may be used to temporarily isolate the TWI from the Two-wireSerial Bus.TWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE\nvalue Device\u2019s Own Slave Address\nTWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE\nvalue 0 100 01 0 XDevice 3 Device n\nSDA\nSCL........ R1 R2VCC\nDevice 2\nMASTER\nRECEIVERDevice 1\nSLAVE\nTRANSMITTER\n\n182\n2486Z\u2013AVR\u201302/11ATmega8(L)In all sleep modes other than Idle mode, the clock system to the TWI is turned off. If the TWEA\nbit is set, the interface can still acknowledge its own slave ad dress or the general call address by\nusing the Two-wire Serial Bus clock as a clock source. The part will then wake up from sleepand the TWI will hold the SCL clock will low during the wake up and until the TWINT Flag is\ncleared (by writing it to one). Further data tr ansmission will be carried out as normal, with the\nAVR clocks running as normal. Observe that if the AVR is set up with a long start-up time, theSCL line may be held low for a long ti me, blocking other data transmissions.\nNote that the Two-wire Serial Interface Data Register \u2013 TWDR does not reflect the last byte\npresent on the bus when waking up from these sleep modes.\nTable 69.  Status Codes for Slave Transmitter Mode\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the Two-wire Serial Bus\nand Two-wire Serial Interface\nHardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xA8 Own SLA+R has been received;\nACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-\nceived\n0xB0 Arbitration lost in SLA+R/W as\nMaster; own SLA+R has been \nreceived; ACK has been returnedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe received\nData byte will be transmitted and ACK should be re-ceived\n0xB8 Data byte in TWDR has been \ntransmitted; ACK has been receivedLoad data byte or\nLoad data byteX\nX0\n01\n10\n1Last data byte will be transmitted and NOT ACK should \nbe receivedData byte will be transmitted and ACK should be re-\nceived\n0xC0 Data byte in TWDR has been \ntransmitted; NOT ACK has been \nreceivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCA\nSwitched to the not addressed Slave mode;\nown SLA will be recognized;GCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus becomes free\n0xC8 Last data byte in TWDR has been\ntransmitted (TWEA = \u201c0\u201d); ACKhas been receivedNo TWDR action or\nNo TWDR action or\nNo TWDR action or\nNo TWDR action0\n0\n1\n10\n0\n0\n01\n1\n1\n10\n1\n0\n1Switched to the not addressed Slave mode;\nno recognition of own SLA or GCASwitched to the not addressed Slave mode;\nown SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d\nSwitched to the not addressed Slave mode;\nno recognition of own SLA or GCA;a START condition will be transmitted when the bus \nbecomes free\nSwitched to the not addressed Slave mode;own SLA will be recognized;\nGCA will be recognized if TWGCE = \u201c1\u201d;\na START condition will be transmitted when the bus becomes free\n\n183\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 85.  Formats and States in the Slave Transmitter Mode\nMiscellaneous States There are two status codes that do not correspond to a defined TWI state, see Table 70 .\nStatus 0xF8 indicates that no relevant inform ation is available because the TWINT Flag is not\nset. This occurs between other states, and when the TWI is not involved in a serial transfer.\nStatus 0x00 indicates that a bus error has occurred during a Two-wire Serial Bus transfer. A bus\nerror occurs when a START or STOP condition occurs at an illegal position in the format frame.Examples of such illegal positions are during the serial transfer of an address byte, a data byte,\nor an acknowledge bit. When a bus error occurs, TWINT is set. To recover from a bus error, theTWSTO Flag must set and TWINT must be cleared by  writing a logic one to it. This causes the\nTWI to enter the not addressed Slave mode and to clear the TWSTO Flag (no other bits inTWCR are affected). The SDA and SCL lines are released, and no STOP condition istransmitted.S SLA R A DATA A\n$A8 $B8\nA\n$B0Reception of the own\nslave address and one ormore data bytes\nLast data byte transmitted.\nSwitched to not addressedslave (TWEA = '0')Arbitration lost as master\nand addressed as slave\nnFrom master to slave\nFrom slave to masterAny number of data bytes\nand their associated acknowledge bits\nThis number (contained in TWSR) corresponds\nto a defined state of the Two-Wire Serial Bus. The prescaler bits are zero or masked to zeroP or S DATA\n$C0\nDATA AA\n$C8P or S All 1'sA\nTable 70.  Miscellaneous States\nStatus Code\n(TWSR)Prescaler Bits\nare 0Status of the Two-wire Serial\nBus and Two-wire Serial Inter-\nface HardwareApplication Software Response\nNext Action Taken by TWI HardwareTo/from TWDRTo TWCR\nSTA STO TWINT TWEA\n0xF8 No relevant state information\navailable; TWINT = \u201c0\u201dNo TWDR action No TWCR action Wait or proceed current transfer\n0x00 Bus error due to an illegal\nSTART or STOP conditionNo TWDR action 0 1 1 X Only the internal hardware is affected, no STOP condi-\ntion is sent on the bus. In all cases, the bus is released \nand TWSTO is cleared.\n\n184\n2486Z\u2013AVR\u201302/11ATmega8(L)Combining Several \nTWI ModesIn some cases, several TWI modes must be combined in order to complete the desired action.\nConsider for example reading data from a serial  EEPROM. Typically, such a transfer involves\nthe following steps:\n1. The transfer must be initiated2. The EEPROM must be instructed what location should be read\n3. The reading must be performed4. The transfer must be finished\nNote that data is transmitted both from Master to Slave and vice versa. The Master must instruct\nthe Slave what location it wants to read, r equiring the use of the MT mode. Subsequently, data\nmust be read from the Slave, implying the use of  the MR mode. Thus, the transfer direction must\nbe changed. The Master must keep control of the bus during all these steps, and the stepsshould be carried out as an atomical operation. If th is principle is violated in a multimaster sys-\ntem, another Master can alter the data pointer in the EEPROM between steps 2 and 3, and theMaster will read the wrong data lo cation. Such a change in transfe r direction is accomplished by\ntransmitting a REPEATED START between the trans mission of the address byte and reception\nof the data. After a REPEATED START, the Master keeps ownership of the bus. The followingfigure shows the flow in this transfer.\nFigure 86.  Combining Several TWI Modes to Access a Serial EEPROM\nMulti-master \nSystems and ArbitrationIf multiple masters are connected to the same bus, transmissions may be initiated simultane-\nously by one or more of them. The TWI standar d ensures that such situations are handled in\nsuch a way that one of the mast ers will be allowed to proceed wit h the transfer, and that no data\nwill be lost in the process. An example of an ar bitration situation is depicted below, where two\nmasters are trying to transmit data to a Slave Receiver.\nFigure 87.  An Arbitration Example\nSeveral different scenarios may arise during arbitration, as described below:\n\u0081 Two or more masters are performing identical communication with the same Slave. In this \ncase, neither the Slave nor any of the masters will know about the bus contentionMaster Transmitter Master Receiver\nS = START Rs = REPEATED START P = STOP\nTransmitted from master to slave Transmitted from slave to masterS SLA+W A ADDRESS ARs SLA+R A DATA AP\nDevice 1\nMASTER\nTRANSMITTERDevice 2\nMASTER\nTRANSMITTERDevice 3\nSLAVE\nRECEIVERDevice n\nSDA\nSCL........ R1 R2VCC\n\n185\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Two or more masters are accessing the same Slave with different data or direction bit. In this \ncase, arbitration will occur, either in the READ /WRITE bit or in the data bits. The masters \ntrying to output a one on SDA while another Master outputs a zero will lose the arbitration. \nLosing masters will switch to no t addressed Slave mode or wa it until the bus is free and \ntransmit a new START condition, depending on application software action\n\u0081 Two or more masters are accessing different slav es. In this case, arbitration will occur in the \nSLA bits. Masters trying to ou tput a one on SDA while anot her Master outputs a zero will \nlose the arbitration. Masters lo sing arbitration in SLA will switch  to Slave mode to check if \nthey are being addressed by the winning Master. If addressed, they will switch to SR or ST \nmode, depending on the value of the READ/WRITE bit. If they are not being addressed, they will switch to not addressed Slav e mode or wait until the bu s is free and transmit a new \nSTART condition, depending on application software action\nThis is summarized in Figure 88 . Possible status values are given in circles.\nFigure 88.  Possible Status Codes Caused by Arbitration\nOwn\nAddress / General Call\nreceivedArbitration lost in SLA\nTWI bus will be released and not addressed slave mode will be enteredA START condition will be transmitted when the bus becomes free NoArbitration lost in Data\nDirectionYes\nWrite Data byte will be received and NOT ACK will be returned\nData byte will be received and ACK will be returned\nLast data byte will be transmitted and NOT ACK should be receivedData byte will be transmitted and ACK should be received Read\nB068/7838SLA START Data STOP\n\n186\n2486Z\u2013AVR\u201302/11ATmega8(L)Analog \nComparatorThe Analog Comparator compares the input values on the positive pin AIN0 and negative pin\nAIN1. When the voltage on the positive pin AIN0 is higher than the voltage on the negative pinAIN1, the Analog Comparator Output, ACO, is set. The comparator\u2019s output can be set to triggerthe Timer/Counter1 Input Capture function. In addition, the comparator can trigger a separate\ninterrupt, exclusive to the Analog Comparator. Th e user can select Interrupt triggering on com-\nparator output rise, fall or toggle. A block diagram of the comparator and its surrounding logic isshown in Figure 89 .\nFigure 89.  Analog Comparator Block Diagram\n(2)\nNotes: 1. See Table 72 on page 188\n2. Refer to \u201cPin Configurations\u201d on page 2  and Table 28 on page 63  for Analog Comparator pin\nplacement\nSpecial Function IO \nRegister \u2013 SFIOR\n\u0081 Bit 3 \u2013 ACME: Analog Comparator Multiplexer Enable\nWhen this bit is written logic one and the ADC is  switched off (ADEN in ADCSRA is zero), the\nADC multiplexer selects the negative input to the Analog Comparator. When this bit is writtenlogic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detaileddescription of this bit, see \u201cAnalog Comparator Multiplexed Input\u201d on page 188 .\nAnalog Comparator \nControl and Status Register \u2013 ACSRACBGBANDGAP\nREFERENCE\nADC MULTIPLEXER\nOUTPUTACME\nADEN\n(1)\nBit 7 6 5 4 3 2 1 0\n\u2013 \u2013 \u2013 \u2013 ACME PUD PSR2 PSR10 SFIOR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 76543210\nACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 ACSR\nRead/Write R/W R/W R R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00 N / A 00000\n\n187\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 7 \u2013 ACD: Analog Comparator Disable\nWhen this bit is written logic one , the power to the Analog Comparator is switched off. This bit\ncan be set at any time to tu rn off the Analog Com parator. This will reduce power consumption in\nActive and Idle mode. When changing the ACD bit, the Analog Comparator Interrupt must bedisabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit ischanged.\n\u0081 Bit 6 \u2013 ACBG: Analog Comparator Bandgap Select\nWhen this bit is set, a fixed bandgap reference vo ltage replaces the positive input to the Analog\nComparator. When this bit is cleared, AIN0 is ap plied to the positive input of the Analog Compar-\nator. See \u201cInternal Voltage Reference\u201d on page 42.\n\u0081 Bit 5 \u2013 ACO: Analog Comparator Output\nThe output of the Analog Comparator is synchronized and then directly connected to ACO. The\nsynchronization introduces a delay of 1 - 2 clock cycles.\n\u0081 Bit 4 \u2013 ACI: Analog Comparator Interrupt Flag\nThis bit is set by hardware when a comparator output event triggers the interrupt mode defined\nby ACIS1 and ACIS0. The Analog Comparator Interr upt routine is executed if the ACIE bit is set\nand the I-bit in SREG is set. ACI is cleared by  hardware when executing the corresponding inter-\nrupt Handling Vector. Alternatively, ACI is cleared by writing a logic one to the flag.\n\u0081 Bit 3 \u2013 ACIE: Analog Comparator Interrupt Enable\nWhen the ACIE bit is written logic one and the I-bi t in the Status Register is set, the Analog Com-\nparator interrupt is activated. When written logic zero, the interrupt is disabled.\n\u0081 Bit 2 \u2013 ACIC: Analog Comparator Input Capture Enable\nWhen written logic one, this bit enables the Input Capture function in Timer/Counter1 to be trig-\ngered by the Analog Comparator. The comparator output is in this case directly connected to theInput Capture front-end logic, making the comp arator utilize the noise canceler and edge select\nfeatures of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connectionbetween the Analog Comparator and the Input Capture function exists. To make the comparatortrigger the Timer/Counter1 Input Capture interrupt, the TICIE1 bit in the Timer Interrupt MaskRegister (TIMSK) must be set.\n\u0081 Bits 1,0 \u2013 ACIS1, ACIS0: Analog Comparator Interrupt Mode Select\nThese bits determine which comparator events that trigger the Analog Comparator interrupt. The\ndifferent settings are shown in Table 71 .\nWhen changing the ACIS1/ACIS0 bits, the Analog Comparator Interrupt must be disabled by\nclearing its Interrupt Enable bit in the ACSR Register. Otherwise an interrupt can occur when thebits are changed.Table 71.  ACIS1/ACIS0 Settings\nACIS1 ACIS0 Interrupt Mode\n0 0 Comparator Interrupt on Output Toggle01 R e s e r v e d\n1 0 Comparator Interrupt on Falling Output Edge\n1 1 Comparator Interrupt on Rising Output Edge\n\n188\n2486Z\u2013AVR\u201302/11ATmega8(L)Analog \nComparator \nMultiplexed InputIt is possible to select any of the ADC7..0(1) pins to replace the negative input to the Analog\nComparator. The ADC multiplexer is used to select this input, and consequently the ADC mustbe switched off to utilize this fe ature. If the Analog Comparator Multiplexer Enable bit (ACME in\nSFIOR) is set and the ADC is switched off (A DEN in ADCSRA is zero), MUX2..0 in ADMUX\nselect the input pin to replace the negative input to the Analog Comparator, as shown in Table\n72. If ACME is cleared or ADEN is set, AIN1  is applied to the negative input to the Analog\nComparator.\nNote: 1. ADC7..6 are only available in TQFP and QFN/MLF PackageTable 72.  Analog Comparator Multiplexed Input(1)\nACME ADEN MUX2..0 Analog Comparator Negative Input\n0 x xxx AIN11 1 xxx AIN1\n1 0 000 ADC0\n1 0 001 ADC11 0 010 ADC2\n1 0 011 ADC3\n1 0 100 ADC4\n1 0 101 ADC5\n1 0 110 ADC61 0 111 ADC7\n\n189\n2486Z\u2013AVR\u201302/11ATmega8(L)\nAnalog-to-\nDigital \nConverter\nFeatures \u008110-bit Resolution\n\u00810.5 LSB Integral Non-linearity\n\u0081\u00b12 LSB Absolute Accuracy\n\u008113\u00b5s - 260\u00b5s Conversion Time\n\u0081Up to 15 kSPS at Maximum Resolution\n\u00816 Multiplexed Single Ended Input Channels\n\u00812 Additional Multiplexed Single Ended Input Channels (TQFP and QFN/MLF Package only)\n\u0081Optional Left Adjustment for ADC Result Readout\n\u00810 - VCC ADC Input Voltage Range\n\u0081Selectable 2.56V ADC Reference Voltage\n\u0081Free Running or Single Conversion Mode\n\u0081Interrupt on ADC Co nversion Complete\n\u0081Sleep Mode Noise Canceler\nThe ATmega8 features a 10-bit successive approximation ADC. The ADC is connected to an 8-\nchannel Analog Multiplexer which allows eight single-ended voltage inputs constructed from thepins of Port C. The single-ended voltage inputs refer to 0V (GND).\nThe ADC contains a Sample and Hold circuit whic h ensures that the input voltage to the ADC is\nheld at a constant level during conversion. A block diagram of the ADC is shown in Figure 90 on\npage 190 .\nThe ADC has a separate analog supply voltage pin, AV\nCC. AVCC must not differ more than \u00b10.3V\nfrom VCC. See the paragraph \u201cADC Noise Canceler\u201d on page 195  on how to connect this pin.\nInternal reference voltages of nominally 2.56V or AVCC are provided On-chip. The voltage refer-\nence may be externally decoupled at the AREF pi n by a capacitor for better noise performance.\n\n190\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 90.  Analog to Digital Converter Block Schematic Operation\nThe ADC converts an analog input voltage to a 10-bit digital value through successive approxi-\nmation. The minimum value represents GND and the maximum value represents the voltage onthe AREF pin minus 1 LSB. Optionally, AV\nCC or an internal 2.56V reference voltage may be con-\nnected to the AREF pin by writing to the REFSn bits in the ADMUX Register. The internalvoltage reference may thus be decoupled by an external capacitor at the AREF pin to improvenoise immunity.\nThe analog input channel is selected by writing to the MUX bits in ADMUX. Any of the ADC input\npins, as well as GND and a fixed bandgap voltage reference, can be selected as single endedinputs to the ADC. The ADC is enabled by sett ing the ADC Enable bit, ADEN in ADCSRA. Volt-\nage reference and input channel se lections will not go into effect  until ADEN is set. The ADC\ndoes not consume power when ADEN is cleared, so it is recommended to switch off the ADCbefore entering power saving sleep modes.\nThe ADC generates a 10-bit result which is pr esented in the ADC Data Registers, ADCH and\nADCL. By default, the result is presented right adjusted, but can optionally be presented leftadjusted by setting the ADLAR bit in ADMUX.ADC CONVERSION\nCOMPLETE IRQ\n8-BIT DATA BUS\n15 0\nADC MULTIPLEXER\nSELECT (ADMUX)ADC CTRL. & STATUS\nREGISTER (ADCSRA)ADC DATA REGISTER\n(ADCH/ADCL)\nMUX2ADIE\nADFR ADSC ADEN ADIFADIF\nMUX1 MUX0\nADPS0 ADPS1 ADPS2MUX3\nCONVERSION LOGIC\n10-BIT DAC\n+-SAMPLE & HOLD\nCOMPARATORINTERNAL 2.56V \nREFERENCEMUX DECODER\nAVCC\nADC7\nADC6ADC5ADC4ADC3ADC2ADC1ADC0REFS0 REFS1 ADLAR\nCHANNEL SELECTIONADC[9:0]\nADC MULTIPLEXER\nOUTPUTAREF\nBANDGAP\nREFERENCEPRESCALER\nGND\nINPUT\nMUX\n\n191\n2486Z\u2013AVR\u201302/11ATmega8(L)\nIf the result is left adjusted and no more than 8-bit precision is required, it is sufficient to read\nADCH. Otherwise, ADCL must be read first, then ADCH, to ensure that the content of the Data\nRegisters belongs to the same conversion. Once ADCL is read, ADC access to Data Registersis blocked. This means that if ADCL has been read, and a conversion completes before ADCH isread, neither register is updated and the result fr om the conversion is lost. When ADCH is read,\nADC access to the ADCH and AD CL Registers is re-enabled.\nThe ADC has its own interrupt which can be triggered when a conversion completes. When ADC\naccess to the Data Registers is prohibited between reading of ADCH and ADCL, the interruptwill trigger even if the result is lost.\nStarting a \nConversionA single conversion is started by writing a l ogical one to the ADC Start Conversion bit, ADSC.\nThis bit stays high as long as the conversi on is in progress and will be cleared by hardware\nwhen the conversion is completed. If a different  data channel is selected while a conversion is in\nprogress, the ADC will finish the current conv ersion before performing  the channel change.\nIn Free Running mode, the ADC is constantly sampling and updating the ADC Data Register.\nFree Running mode is selected by writing the ADFR bit in ADCSRA to one. The first conversionmust be started by writing a logical one to the ADSC bit in ADCSRA. In this mode the ADC will\nperform successive conversions independently of  whether the ADC Interrupt Flag, ADIF is\ncleared or not.\nPrescaling and \nConversion TimingFigure 91.  ADC Prescaler\nBy default, the successive approximation circ uitry requires an input clock frequency between\n50kHz and 200kHz to get maximum resolution. If a lower resolution than 10 bits is needed, theinput clock frequency to the ADC can be higher  than 200kHz to get a higher sample rate.\nThe ADC module contains a prescaler, which generates an acceptable ADC clock frequency\nfrom any CPU frequency above 100kHz. The prescaling is set by the ADPS bits in ADCSRA.The prescaler starts counting from the moment the ADC is switched on by setting the ADEN bitin ADCSRA. The prescaler keeps running for as lo ng as the ADEN bit is set, and is continuously\nreset when ADEN is low.\nWhen initiating a single ended conversion by se tting the ADSC bit in ADCSRA, the conversion\nstarts at the following rising edge of the ADC clock cycle. A normal conversion takes 13 ADCclock cycles. The first conversion after the ADC is  switched on (ADEN in ADCSRA is set) takes\n25 ADC clock cycles in order to initialize the analog circuitry.7-BIT ADC PRESCALER\nADC CLOCK SOURCECK\nADPS0\nADPS1\nADPS2CK/128 CK/2CK/4CK/8CK/16CK/32CK/64ResetADEN\nSTART\n\n192\n2486Z\u2013AVR\u201302/11ATmega8(L)The actual sample-and-hold takes place 1.5 ADC clock cycles after the start of a normal conver-\nsion and 13.5 ADC clock cycles after the start of an first conv ersion. When a conversion is\ncomplete, the result is written to the ADC Data Registers, and ADIF is set. In single conversionmode, ADSC is cleared simultaneously. The software may then set ADSC again, and a newconversion will be init iated on the first rising ADC clock edge.\nIn Free Running mode, a new conversion will be  started immediately after the conversion com-\npletes, while ADSC remains high. For a summary of conversion times, see Table 73 on page\n193.\nFigure 92.  ADC Timing Diagram, First Conversion (Single Conversion Mode)\nFigure 93.  ADC Timing Diagram, Single Conversion MSB of Result\nLSB of ResultADC Clock\nADSC\nSample & HoldADIF\nADCHADCLCycle Number\nADEN1 21 2 13 14 15 16 17 18 19 20 21 22 23 24 25 1 2First ConversionNext\nConversion\n3\nMUX and REFS\nUpdateMUX and REFS\nUpdateConversion\nComplete\n1 2 3 4 5 6 7 8 9 10 11 12 13\nMSB of Result\nLSB of ResultADC Clock\nADSCADIFADCHADCLCycle Number 12One Conversion Next Conversion\n3\nSample & Hold\nMUX and REFS\nUpdateConversion\nCompleteMUX and REFSUpdate\n\n193\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 94.  ADC Timing Diagram, Free Running Conversion\nTable 73.  ADC Conversion Time\nConditionSample & Hold (Cycles \nfrom Start of Conversion)Conversion Time \n(Cycles)\nExtended conversion 13.5 25Normal conversions, single ended 1.5 1311 12 13\nMSB of Result\nLSB of ResultADC Clock\nADSCADIFADCHADCLCycle Number12One Conversion Next Conversion\n34\nConversion\nCompleteSample &Hold\nMUX and REFS\nUpdate\n\n194\n2486Z\u2013AVR\u201302/11ATmega8(L)Changing Channel \nor Reference \nSelectionThe MUXn and REFS1:0 bits in the ADMUX Register are single buffered through a temporary\nregister to which the CPU has random access. This ensures that the channels and referenceselection only takes place at a safe point dur ing the conversion. The channel and reference\nselection is continuously updated until a conversion is started. Once the conversion starts, thechannel and reference selection is locked to ensure a sufficient sampling time for the ADC. Con-tinuous updating resumes in the last ADC clock cycle before the conversion completes (ADIF inADCSRA is set). Note that the conversion star ts on the following rising  ADC clock edge after\nADSC is written. The user is thus advised not to write new channel or reference selection values\nto ADMUX until one ADC clock cycle after ADSC is written.\nIf both ADFR and ADEN is written to one, an interrupt event can occur at any time. If the\nADMUX Register is changed in this period, the user cannot tell if the next conversion is basedon the old or the new settings. ADMUX can be safely updated in the following ways:\n1. When ADFR or ADEN is cleared2. During conversion, minimum one ADC clock cycle after the trigger event3. After a conversion, before the Interrupt Flag used as trigger source is cleared\nWhen updating ADMUX in one of these conditions, the new settings will affect the next ADC\nconversion.\nADC Input Channels When changing channel selections, the user should observe the following guidelines to ensure\nthat the correct channel is selected:\nIn Single Conversion mode, always select the channel before starting the conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the conversion to complete before changing the channel selection.\nIn Free Running mode, always select the channel before starting the first conversion. The chan-\nnel selection may be changed one ADC clock cycle after writing one to ADSC. However, the\nsimplest method is to wait for the first conversion to complete, and then change the channelselection. Since the next conver sion has already started automati cally, the next result will reflect\nthe previous channel selection.  Subsequent conversions will refl ect the new channel selection.\nADC Voltage \nReferenceThe reference voltage for the ADC (V\nREF) indicates the conversion range for the ADC. Single\nended channels that exceed VREF will result in code s close to 0x3FF. VREF can be selected as\neither AVCC, internal 2.56V reference, or external AREF pin.\nAVCC is connected to the ADC through a passive switch. The internal 2.56V reference is gener-\nated from the internal bandgap reference (VBG) through an internal amplifier. In either case, the\nexternal AREF pin is directly connected to the ADC, and the reference voltage can be made\nmore immune to noise by connecting a capacitor between the AREF pin and ground. VREF can\nalso be measured at the AREF pin with a high impedant voltmeter. Note that VREF is a high\nimpedant source, and only a capacitive load should be connected in a system.\nIf the user has a fixed voltage source connected to the AREF pin, the user may not use the other\nreference voltage options in the ap plication, as they will be shorte d to the external voltage. If no\nexternal voltage is applied to the AREF pin, the user may switch between AVCC and 2.56V as\nreference selection. The first ADC conversion result after switching reference voltage source\nmay be inaccurate, and the user is advised to discard this result.\n\n195\n2486Z\u2013AVR\u201302/11ATmega8(L)\nADC Noise \nCancelerThe ADC features a noise canceler that enables conversion during sleep mode to reduce noise\ninduced from the CPU core and other I/O peripherals. The noise canceler can be used with ADCNoise Reduction and Idle mode. To make use of this feature, the following procedure should beused:\n1. Make sure that the ADC is enabled and is not busy converting. Single Conversion\nmode must be selected and the ADC conversion complete interrupt must be enabled\n2. Enter ADC Noise Reduction mode (or Id le mode). The ADC will start a conversion\nonce the CPU has been halted\n3. If no other interrupts occur before the ADC conversion completes, the ADC interrupt\nwill wake up the CPU and execute the ADC Conv ersion Complete in terrupt routine. If\nanother interrupt wakes up the CPU before the ADC conversion is complete, thatinterrupt will be executed, and an ADC Conv ersion Complete interrupt request will be\ngenerated when the ADC conversion complete s. The CPU will remain in Active mode\nuntil a new sleep command is executed\nNote that the ADC will not be automatically turned off when entering other sleep modes than Idle\nmode and ADC Noise Reduction mode. The user is advised to write zero to ADEN before enter-\ning such sleep modes to avoid excessive power consumption.\nAnalog Input Circuitry The analog input circuitry for sing le ended channels is  illustrated in Figure 95. An analog source\napplied to ADCn is subjected to the pin capacit ance and input leakage of that pin, regardless of\nwhether that channel is selected as input for the ADC. When the channel is selected, the sourcemust drive the S/H capacitor through the seri es resistance (combined resistance in the input\npath).\nThe ADC is optimized for analog signals wit h an output impedance of approximately 10 k \u03a9 or\nless. If such a source is used, the sampling time will be negligible. If a source with higher imped-ance is used, the sampling time  will depend on how long time the source nee ds to charge the\nS/H capacitor, with can vary widely. The user is recommended to only use low impedant sourceswith slowly varying signals, since this minimizes the required charge transfer to the S/Hcapacitor.\nSignal components higher than the Nyquist frequency (f\nADC/2) should not be present for either\nkind of channels, to avoid distortion from unpredictable signal convolution. The user is advisedto remove high frequency components with a low-pass filter before applying the signals as\ninputs to the ADC.\nFigure 95.  Analog Input Circuitry\nADCnIIH\n1..100k \u03a9\nCS/H= 14pF\nVCC/2IIL\n\n196\n2486Z\u2013AVR\u201302/11ATmega8(L)Analog Noise \nCanceling TechniquesDigital circuitry inside and outside the device ge nerates EMI which might affect the accuracy of\nanalog measurements. If conversion accuracy is critical, the noise level can be reduced byapplying the following techniques:\n1. Keep analog signal paths as short as possible. Make sure analog tracks run over the\nground plane, and keep them well away from high-speed switching digital tracks.\n2. The AV\nCC pin on the device should be connected to the digital VCC supply voltage via\nan LC network as shown in Figure 96 .\n3. Use the ADC noise canceler function to reduce induced noise from the CPU.\n4. If any ADC [3..0] port pins are used as digital outputs, it is essential that these do not\nswitch while a conversion is in progre ss. However, using the Two-wire Interface\n(ADC4 and ADC5) will only affect the conver sion on ADC4 and ADC5 and not the\nother ADC channels.\nFigure 96.  ADC Power Connections\nADC Accuracy \nDefinitionsAn n-bit single-ended ADC converts a voltage linearly between GND and VREF in 2n steps\n(LSBs). The lowest code is read as 0, and the highest code is read as 2n-1.\nSeveral parameters describe the deviation from the ideal behavior:\n\u0081 Offset: The deviation of the first transition (0x000 to 0x001) compared to the ideal transition \n(at 0.5 LSB). Ideal value: 0 LSBGND VCC PC5 (ADC5/SCL) PC4 (ADC4/SDA) PC3 (ADC3) PC2 (ADC2)\nPC1 (ADC1)\nPC0 (ADC0)\nADC7\nGND\nAREF\nAVCCADC6\nPB510\u03bcH\n100nFAnalog Ground Plane\n\n197\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 97.  Offset Error\n\u0081 Gain error: After adjusting for offset, the gain error is found as the deviation of the last \ntransition (0x3FE to 0x3FF) compared to the ideal transition (at 1.5 LSB below maximum). Ideal value: 0 LSB\nFigure 98.  Gain ErrorOutput Code\nVREF Input VoltageIdeal ADC\nActual ADC\nOffset\nError\nOutput Code\nVREF Input VoltageIdeal ADC\nActual ADCGain\nError\n\n198\n2486Z\u2013AVR\u201302/11ATmega8(L)\u0081 Integral Non-linearity (INL): Afte r adjusting for offset and gain error, the INL is the maximum \ndeviation of an actual transition compared to an ideal transition for any code. Ideal value: 0 LSB\nFigure 99.  Integral Non-linearity (INL)\n\u0081 Differential Non-linearity (DNL ): The maximum deviation of the actual code width (the \ninterval between two adjacent transitions) from the ideal code width (1 LSB). Ideal value: 0 LSB.\nFigure 100.  Differential Non-linearity (DNL)\n\u0081 Quantization Error: Due to the quantization of the input voltage into a finite number of codes, \na range of input voltages (1 LSB wide) will code to the same  value. Always \u00b10.5 LSB.\n\u0081 Absolute accuracy: The maximum deviation of an  actual (unadjusted) transition compared to \nan ideal transition for any code. This is the compound effect of offset, gain error, differential error, non-linearity, and quantization error. Ideal value: \u00b10.5 LSB.Output Code\nVREFInput VoltageIdeal ADC\nActual ADCINL\nOutput Code\n0x3FF\n0x000\n0 VREFInput VoltageDNL1 LSB\n\n199\n2486Z\u2013AVR\u201302/11ATmega8(L)\nADC Conversion \nResultAfter the conversion is complete (ADIF is high ), the conversion result can be found in the ADC\nResult Registers (ADCL, ADCH).\nFor single ended conversion, the result is:\nwhere VIN is the voltage on the selected input pin and VREF the selected voltage reference (see\nTable 74  and Table 75 ). 0x000 represents ground, and 0x3FF represents the selected reference\nvoltage minus one LSB.\nADC Multiplexer \nSelection Register \u2013 ADMUX\n\u0081 Bit 7:6 \u2013 REFS1:0: Reference Selection Bits\nThese bits select the voltage reference for the ADC, as shown in Table 74 . If these bits are\nchanged during a conversion, the change will not go in effect until this conversion is complete(ADIF in ADCSRA is set). The internal voltage reference options may not be used if an externalreference voltage is being applied to the AREF pin.\n\u0081\n Bit 5 \u2013 ADLAR: ADC Left Adjust Result\nThe ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register.\nWrite one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing theADLAR bit will affect t he ADC Data Register immediately,  regardless of any ongoing conver-\nsions. For a complete description of this bit, see \u201cThe ADC Data Register \u2013 ADCL and ADCH\u201d on\npage 201 .\n\u0081 Bits 3:0 \u2013 MUX3:0: Analog Channel Selection Bits\nThe value of these bits selects which analog inputs are connected to the ADC. See Table 75  for\ndetails.\n If these bits are changed during a conversion , the change will not go in effect until this\nconversion is complete (ADIF in ADCSRA is set).ADCVIN1024\u22c5\nVREF--------------------------=\nB i t 76543210\nREFS1 REFS0 ADLAR \u2013 MUX3 MUX2 MUX1 MUX0 ADMUX\nRead/Write R/W R/W R/W R R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nTable 74.  Voltage Reference Selections for ADC\nREFS1 REFS0 Voltage Reference Selection\n0 0 AREF , Internal Vref turned off\n01 AVCC with external capacitor at AREF pin\n10 R e s e r v e d\n1 1 Internal 2.56V Voltage Reference with external capacitor at AREF pin\nTable 75.  Input Channel Selections\nMUX3..0 Single Ended Input\n0000 ADC0\n0001 ADC10010 ADC2\n0011 ADC3\n0100 ADC40101 ADC5\n\n200\n2486Z\u2013AVR\u201302/11ATmega8(L)ADC Control and \nStatus Register A \u2013 ADCSRA\n\u0081 Bit 7 \u2013 ADEN: ADC Enable\nWriting this bit to one enables the ADC. By writi ng it to zero, the ADC is turned off. Turning the\nADC off while a conversion is in prog ress, will terminate this conversion.\n\u0081 Bit 6 \u2013 ADSC: ADC Start Conversion\nIn Single Conversion mode, write this bit to one to start each conversion. In Free Running mode,\nwrite this bit to one to start the first conversion. The first conversion after ADSC has been writtenafter the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled,will take 25 ADC clock cycles instead of the norma l 13. This first conversi on performs initializa-\ntion of the ADC.\nADSC will read as one as long as a conversion is in progress. When the co nversion is complete,\nit returns to zero. Writing zero to this bit has no effect.\n\u0081 Bit 5 \u2013 ADFR: ADC Free Running Select\nWhen this bit is set (one) the ADC operates in Free Running mode. In this mode, the ADC sam-\nples and updates the Data Regi sters continuously. Clearing th is bit (zero) will terminate Free\nRunning mode.\n\u0081 Bit 4 \u2013 ADIF: ADC Interrupt Flag\nThis bit is set when an ADC conversion completes and the Data Registers are updated. The\nADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set.\nADIF is cleared by hardware when executing th e corresponding interrupt Handling Vector. Alter-\nnatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a Read-Modify-Write on ADCSRA, a pending interrupt can be dis abled. This also applies if the SBI and CBI\ninstructions are used.\n\u0081 Bit 3 \u2013 ADIE: ADC Interrupt Enable\nWhen this bit is written to one and the I-bit in SREG is set, the ADC Conversion Complete Inter-\nrupt is activated.0110 ADC6\n0111 ADC7\n1000\n1001\n1010\n1011\n1100\n1101\n1110 1.30V (VBG)\n1111 0V (GND)Table 75.  Input Channel Selections (Continued)\nMUX3..0 Single Ended Input\nB i t 76543210\nADEN ADSC ADFR ADIF ADIE ADPS2 ADPS1 ADPS0 ADCSRA\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n\n201\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bits 2:0 \u2013 ADPS2:0: ADC Prescaler Select Bits\nThese bits determine the division factor between the XTAL frequency and the input clock to the\nADC.\nThe ADC Data \nRegister \u2013 ADCL and ADCH\nADLAR = 0\nADLAR = 1\nWhen an ADC conversion is complete, the result is found in these two registers.\nWhen ADCL is read, the ADC Data  Register is not updated unt il ADCH is read. Consequently, if\nthe result is left adjusted and no more than 8-bit precision is required, it is sufficient to read\nADCH. Otherwise, ADCL must be read first, then ADCH.\nThe ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from\nthe registers. If ADLAR is set, the result is left adjusted. If ADLA R is cleared (default), the result\nis right adjusted.\n\u0081 ADC9:0: ADC Conversion result\nThese bits represent the result from the conversion, as detailed in \u201cADC Conversion Result\u201d on\npage 199 .Table 76.  ADC Prescaler Selections \nADPS2 ADPS1 ADPS0 Division Factor\n000 2\n001 2\n010 4011 8\n100 1 6\n101 3 2110 6 4\n1 1 1 128\nB i t 1 51 41 31 21 11 0 9 8\n\u2013 \u2013 \u2013 \u2013 \u2013 \u2013 ADC9 ADC8 ADCH\nADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADC1 ADC0 ADCL\n76543210\nR e a d / W r i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e 00000000\n00000000\nB i t 1 51 41 31 21 11 0 9 8\nADC9 ADC8 ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADCHADC1 ADC0 \u2013 \u2013\u2013\u2013\u2013\u2013 ADCL\n76543210\nR e a d / W r i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e 00000000\n00000000\n\n202\n2486Z\u2013AVR\u201302/11ATmega8(L)Boot Loader \nSupport \u2013 Read-\nWhile-Write Self-\nProgrammingThe Boot Loader Support provides a real Read- While-Write Self-Programming mechanism for\ndownloading and uploading program code by the M CU itself. This feature a llows flexible applica-\ntion software updates controlled by the MCU using a Flash-resident Boot Loader program. TheBoot Loader program can use any available data interface and associated protocol to read codeand write (program) that code into the Flash memory, or read the code from the Program mem-ory. The program code within the Boot Loader section has the capability to write into the entireFlash, including the Boot Loader Memory. The B oot Loader can thus even modify itself, and it\ncan also erase itself from the code if the feature is not needed anymore. The size of the BootLoader Memory is configurable with fuses and t he Boot Loader has two separate sets of Boot\nLock Bits which can be set indepe ndently. This gives the user a uni que flexibility to select differ-\nent levels of protection.\nBoot Loader \nFeatures\u0081Read-While-Write Self-Programming\n\u0081Flexible Boot Memory Size\n\u0081High Security (Separate Boot Lock  Bits for a Flexible Protection)\n\u0081Separate Fuse to Select Reset Vector\n\u0081Optimized Page(1) Size\n\u0081Code Efficien t Algorithm\n\u0081Efficient Read-Mod ify-Write Support\nNote: 1. A page is a section in the Flash consisting of several bytes (see Table 89 on page 218 ) used\nduring programming. The page organization does not affect normal operation\nApplication and \nBoot Loader Flash SectionsThe Flash memory is organized in two main sections, the Application section and the Boot\nloader section (see Figure 102 on page 204 ). The size of the different sections is configured by\nthe BOOTSZ Fuses as shown in Table 82 on page 213  and Figure 102 on page 204 . These two\nsections can have different level of protection since they have different sets of Lock Bits.\nApplication Section The application section is the section of the Flash that is used for storing the application code.\nThe protection level for the application section can be selected by the application boot Lock Bits(Boot Lock Bits 0), see Table 78 on page 205 . The application section can never store any Boot\nLoader code since the SPM instruction is dis abled when executed from the application section.\nBLS \u2013 Boot Loader \nSectionWhile the application section is used for storing the application code, the The Boot Loader soft-\nware must be located in the BLS since the SPM instruction can initiate a programming whenexecuting from the BLS only. The SPM instruct ion can access the entire Flash, including the\nBLS itself. The protection level for the Boot Loader section can be selected by the Boot LoaderLock Bits (Boot Lock Bits 1), see Table 79 on page 205 .\nRead-While-Write \nand No Read-\nWhile-Write Flash SectionsWhether the CPU supports Read-While-Write or if the CPU is halted during a Boot Loader soft-\nware update is dependent on which address that is being programmed. In addition to the twosections that are configurable by the BOOTSZ  Fuses as described above, the Flash is also\ndivided into two fixed sections, the Read-Whi le-Write (RWW) section and the No Read-While-\nWrite (NRWW) section. The limit between the RWW- and NRWW sections is given in Table 83\non page 214  and Figure 102 on page 204 . The main difference between the two sections is:\n\u0081 When erasing or writing a page located inside the RWW section, the NRWW section can be \nread during the operation\n\u0081 When erasing or writing a page located inside the NRWW section, the CPU is halted during \nthe entire operation\nNote that the user software can never read any code that is located inside the RWW section dur-\ning a Boot Loader software operation. The syntax \u201cRead-While-Write section\u201d refers to whichsection that is being programmed (erased or written), not which section that actually is beingread during a Boot Loader software update.\n\n203\n2486Z\u2013AVR\u201302/11ATmega8(L)\nRWW \u2013 Read-While-\nWrite SectionIf a Boot Loader software update is programming a page inside the RWW section, it is possible\nto read code from the Flash, but only code that is located in the NRWW section. During an on-going programming, the software must ensure that the RWW section never is being read. If theuser software is trying to read code that is  located inside the RWW section (that is, by a\ncall/rjmp/lpm or an interrupt) during programming, the software might end up in an unknownstate. To avoid this, the interrupts should either be disabled or moved to the Boot Loader Sec-tion. The Boot Loader Section is always loca ted in the NRWW section.  The RWW Section Busy\nbit (RWWSB) in the Store Program memory Cont rol Register (SPMCR) will be read as logical\none as long as the RWW section is blocked for reading. After a programming is completed, theRWWSB must be cleared by software before reading code located in the RWW section. See\n\u201cStore Program Memory Control Register \u2013 SPMCR\u201d on page 206.  for details on how to clear\nRWWSB.\nNRWW \u2013 No Read-\nWhile-Write SectionThe code located in the NRWW section can be read when the Boot Loader software is updating\na page in the RWW section. When the Boot Loader code updates the NRWW section, the CPUis halted during the entire page erase or page write operation.\nFigure 101.  Read-While-Write vs. No Read-While-WriteTable 77.  Read-While-Write Features\nWhich Section does the Z-\npointer Address during the \nProgramming?Which Section Can be \nRead during \nProgramming?Is the CPU \nHalted?Read-While-\nWrite \nSupported?\nRWW section NRWW section No Yes\nNRWW section None Yes No\nRead-While-Write\n(RWW) Section\nNo Read-While-Write \n(NRWW) SectionZ-pointer\nAddresses RWWsectionZ-pointerAddresses NRWWsection\nCPU is Haltedduring the Operation\nCode Located in \nNRWW SectionCan be Read duringthe Operation\n\n204\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 102.  Memory Sections(1)\nNote: 1. The parameters in the figure are given in Table 82 on page 213\nBoot Loader Lock \nBitsIf no Boot Loader capability is n eeded, the entire Flash is available for application code. The\nBoot Loader has two separate sets of Boot Lock  Bits which can be set independently. This gives\nthe user a unique flexibility to sele ct different levels  of protection.\nThe user can select:\n\u0081 To protect the entire Flash from a software update by the MCU\u0081 To protect only the Boot Loader Flash section from a software update by the MCU\u0081 To protect only the Application Flash section from a software update by the MCU\u0081 Allow software update in the entire Flash\nSee Table 78 on page 205  and Table 79 on page 205  for further details. The Boot Lock Bits can\nbe set in software and in Serial or Parallel Programming mode, but they can be cleared by a chiperase command only. The general Write Lock (Lock bit mode 2) does not control the program-ming of the Flash memory by SPM instruction. Si milarly, the general Read/Write Lock (Lock bit\nmode 3) does not control reading nor writing by LPM/SPM, if it is attempted.$0000\nFlashendProgram Memory\nBOOTSZ = '11'\nApplication Flash Section\nBoot Loader Flash Section\nFlashendProgram Memory\nBOOTSZ = '10'\n$0000Program Memory\nBOOTSZ = '01'Program Memory\nBOOTSZ = '00'Application Flash Section\nBoot Loader Flash Section$0000\nFlashendApplication Flash Section\nFlashendEnd RWW\nStart NRWWApplication flash Section\nBoot Loader Flash Section\nBoot Loader Flash SectionEnd RWW\nStart NRWWEnd RWW\nStart NRWW\n$0000\nEnd RWW, End Application\nStart NRWW, Start Boot LoaderApplication Flash Section Application Flash Section\nApplication Flash Section\nRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionRead-While-Write Section No Read-While-Write Section Read-While-Write Section No Read-While-Write SectionEnd Application\nStart Boot LoaderEnd Application\nStart Boot Loader\nEnd Application\nStart Boot Loader\n\n205\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed\nEntering the Boot \nLoader ProgramEntering the Boot Loader takes place by a jump or call from the application program. This may\nbe initiated by a trigger such as a command received via USART, or SPI interface. Alternatively,the Boot Reset Fuse can be programmed so that the Reset Vector is pointing to the Boot Flashstart address after a reset. In this case, the Boot Loader is started after a reset. After the applica-tion code is loaded, the program can start execut ing the application code. Note that the fuses\ncannot be changed by the MCU itself. This means that once the Boot Reset Fuse is pro-grammed, the Reset Vector will always point to the Boot Loader Reset and the fuse can only bechanged through the serial or parallel programming interface.Table 78.  Boot Lock Bit0 Protection Modes (Application Section)\n(1)\nBLB0 \nModeBLB02 \nModeBLB01 \nMode Protection\n11 1No restrictions for SPM or LPM accessing the Application \nsection\n2 1 0 SPM is not allowed to write to the Application section\n30 0SPM is not allowed to write to the Application section, and LPM \nexecuting from the Boot Loader section is not allowed to read \nfrom the Application section. If Interrupt Vectors are placed in \nthe Boot Loader section, interrup ts are disabled while executing \nfrom the Application section\n40 1LPM executing from the Boot Load er section is not allowed to \nread from the Application section.  If Interrupt Vectors are placed \nin the Boot Loader section, interrupts are disabled while \nexecuting from the Application section\nTable 79.  Boot Lock Bit1 Protection Modes (Boot Loader Section)(1)\nBLB1 \nModeBLB12 \nModeBLB11 \nMode Protection\n11 1No restrictions for SPM or LPM accessing the Boot Loader \nsection\n2 1 0 SPM is not allowed to write to the Boot Loader section\n30 0SPM is not allowed to write to the Boot Loader section, and LPM \nexecuting from the Application section is not allowed to read \nfrom the Boot Loader section. If  Interrupt Vectors are placed in \nthe Application section, interr upts are disabled while executing \nfrom the Boot Loader section\n40 1LPM executing from the Application section is not allowed to \nread from the Boot Loader section. If Interrupt Vectors are placed in the Application sectio n, interrupts are disabled while \nexecuting from the Boot Loader section\n\n206\n2486Z\u2013AVR\u201302/11ATmega8(L)Note: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed\nStore Program \nMemory Control Register \u2013 SPMCRThe Store Program memory Control Register contains the control bits needed to control the Boot\nLoader operations.\n\u0081 Bit 7 \u2013 SPMIE: SPM Interrupt Enable\nWhen the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM\nready interrupt will be enabled. The SPM ready In terrupt will be ex ecuted as long as the SPMEN\nbit in the SPMCR Register is cleared.\n\u0081 Bit 6 \u2013 RWWSB: Read-While-Write Section Busy\nWhen a Self-Programming (page erase or page write) operation to the RWW section is initiated,\nthe RWWSB will be set (one) by hardware. When the RWWSB bit is set, the RWW section can-\nnot be accessed. The RWWSB bit will be cleared if the RWWSRE bit is written to one after a\nSelf-Programming operation is completed. Alter natively the RWWSB bit will automatically be\ncleared if a page load operation is initiated.\n\u0081 Bit 5 \u2013 Res: Reserved Bit\nThis bit is a reserved bit in the ATmega8 and always read as zero.\n\u0081 Bit 4 \u2013 RWWSRE: Read-While-Write Section Read Enable\nWhen programming (page erase or page write) to the RWW section, the RWW section is\nblocked for reading (the RWWSB will be set by hardware). To re-enable the RWW section, theuser software must wait unt il the programming is complet ed (SPMEN will be cl eared). Then, if\nthe RWWSRE bit is written to one at the same time as SPMEN, the next  SPM instruction within\nfour clock cycles re-enables the RWW secti on. The RWW section cannot be re-enabled while\nthe Flash is busy with a page erase or a page writ e (SPMEN is set). If the RWWSRE bit is writ-\nten while the Flash is being loaded, the Flas h load operation will abort and the data loaded will\nbe lost (The page buffer will be cleared when the Read-While-Wri te section is re-enabled).\n\u0081 Bit 3 \u2013 BLBSET: Boot Lock Bit Set\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles sets Boot Lock Bits, according to the data in R0. The data in R1 and the address in the Z-pointer are ignored. The BLBSET bit will automatically be clear ed upon completion of the lock bit\nset, or if no SPM instruction is executed within four clock cycles.\nAn LPM instruction within thre e cycles after BLBSET and SPMEN  are set in the SPMCR Regis-\nter, will read either the Lock Bits or the Fuse  Bits (depending on Z0 in the Z-pointer) into the\ndestination register. See \u201cReading the Fuse and Lock Bits from Software\u201d on page 210  for\ndetails.Table 80.  Boot Reset Fuse\n(1)\nBOOTRST Reset Address\n1 Reset Vector = Application Reset (address 0x0000)\n0 Reset Vector = Boot Loader Reset (see Table 82 on page 213 )\nB i t 765 4 3210\nSPMIE RWWSB \u2013 RWWSRE BLBSET PGWRT PGERS SPMEN SPMCR\nRead/Write R/W R R R/W R/W R/W R/W R/W\nInitial Value 0 0 0 0 0 0 0 0\n\n207\n2486Z\u2013AVR\u201302/11ATmega8(L)\n\u0081 Bit 2 \u2013 PGWRT: Page Write\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes page write, with the data stored in the temporary buffer. The page address istaken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGWRT bitwill auto-clear upon completion of a page write, or if no SPM instruction is executed within fourclock cycles. The CPU is halted during the entire page write operation if the NRWW section isaddressed.\n\u0081 Bit 1 \u2013 PGERS: Page Erase\nIf this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock\ncycles executes page erase. The page address is taken from the high part of the Z-pointer. The\ndata in R1 and R0 ar e ignored. The PGERS bi t will auto-clear upon comp letion of a page erase,\nor if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire\npage write operation if the NRWW section is addressed.\n\u0081 Bit 0 \u2013 SPMEN: Store Program Memory Enable\nThis bit enables the SPM instruction for the next four clock cycles. If written to one together with\neither RWWSRE, BLBSET, PGWRT\u2019 or PGERS, t he following SPM instruction will have a spe-\ncial meaning, see description abo ve. If only SPMEN is written, the following SPM instruction will\nstore the value in R1:R0 in the temporary page buffer addressed by the Z-pointer. The LSB ofthe Z-pointer is ignored. The SPMEN bit will aut o-clear upon completion of an SPM instruction,\nor if no SPM instruction is executed within four  clock cycles. During page erase and page write,\nthe SPMEN bit remains high until the operation is completed.\nWriting any other combination than \u201c10001\u201d, \u201c01001\u201d, \u201c00101\u201d, \u201c00011\u201d or \u201c00001\u201d in the lower\nfive bits will have no effect.\nAddressing the \nFlash During Self-ProgrammingThe Z-pointer is used to address the SPM commands.\nSince the Flash is organized in pages (see Table 89 on page 218 ), the Program Counter can be\ntreated as having two different sect ions. One section, consisting of  the least significant bits, is\naddressing the words within a page, while the most significant bits are addressing the pages.This is shown in Figure 103 on page 208 . Note that the page erase and page write operations\nare addressed independently. Therefore it is of major importance that the Boot Loader softwareaddresses the same page in both the page erase and page write operation. Once a program-ming operation is initiated, the address is latched and the Z-pointer can be used for otheroperations.\nThe only SPM operation that does not use the Z- pointer is Setting the Boot Loader Lock Bits.\nThe content of the Z-pointer is  ignored and will have no effect  on the operation. The LPM\ninstruction does also use the Z-pointer to store the address. Since this instruction addresses theFlash byte by byte, also the LSB (bit Z0) of the Z-pointer is used.B i t 1 51 41 31 21 11 0 9 8\nZH (R31) Z15 Z14 Z13 Z12 Z11 Z10 Z9 Z8Z L  ( R 3 0 ) Z 7Z 6Z 5Z 4Z 3Z 2Z 1Z 0\n76543210\n\n208\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 103.  Addressing the Flash during SPM(1)\nNotes: 1. The different variables used in the figure are listed in Table 84 on page 214\n2. PCPAGE and PCWORD are listed in Table 89 on page 218\nSelf-Programming \nthe FlashThe Program memory is updated in a page by page fashion. Before programming a page with\nthe data stored in the temporary page buffer, the page must be erased. The temporary page buf-fer is filled one word at a time using SPM and the buffer can be filled either before the pageerase command or between a page erase and a page write operation:\nAlternative 1, fill the buff er before a page erase.\n\u0081 Fill temporary page buffer\u0081 Perform a page erase\u0081 Perform a page write\nAlternative 2, fill the bu ffer after page erase.\n\u0081 Perform a page erase\u0081 Fill temporary page buffer\u0081 Perform a page write\nIf only a part of the page needs to be changed, the rest of the page must be stored (for example\nin the temporary page buffer) before the erase, and then be rewritten. When using alternative 1,the boot loader provides an effective Read-Modify-Write feature which allows the user softwareto first read the page, do the necessary changes, and then write back the modified data. If alter-native 2 is used, it is not possible to read the old data while loading since the page is already\nerased. The temporary page buffer can be accessed in a random sequence. It is essential thatthe page address used in both the page erase and page write operation is addressing the samepage. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on page 212  for an assembly\ncode example.PROGRAM MEMORY01 15\nZ - REGISTERBIT\n0ZPAGEMSB\nWORD ADDRESS\nWITHIN A PAGEPAGE ADDRESS\nWITHIN THE FLASHZPCMSB\nINSTRUCTION WORDPAGEPCWORD[PAGEMSB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCMSB PAGEMSB\nPROGRAM\nCOUNTER\n\n209\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPerforming Page \nErase by SPMTo execute page erase, set up the address in the Z-pointer, write \u201cX0000011\u201d to SPMCR and\nexecute SPM within four clock cycles after wr iting SPMCR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE in the Z-register. Other bits in the Z-pointer willbe ignored during this operation.\n\u0081 Page Erase to the RWW section: The NRWW section can be read during the page erase\u0081 Page Erase to the NRWW section: The CPU is halted during the operationNote: If an interrupt occurs in the timed sequence, the four cycle access cannot be guaranteed.\nIn order to ensure atomic operation, disable interrupts before writing to SPMCSR.\nFilling the Temporary \nBuffer (Page Loading)To write an instruction word, set up the address in the Z-pointer and data in R1:R0, write\n\u201c00000001\u201d to SPMCR and execute SPM within four clock cycles after writing SPMCR. The con-tent of PCWORD in the Z-register is used to address the data in the temporary page buffer. Thetemporary buffer will auto-erase after a page writ e operation or by writ ing the RWWSRE bit in\nSPMCR. It is also erased after a System Reset. No te that it is not possible to write more than\none time to each address without erasing the temporary buffer.\nNote: If the EEPROM is written in the middle of an  SPM page Load operation, all data loaded will be lost\nPerforming a Page \nWriteTo execute page write, set up the address in the Z-pointer, write \u201cX0000101\u201d to SPMCR and\nexecute SPM within four clock cycles after wr iting SPMCR. The data in R1 and R0 is ignored.\nThe page address must be written to PCPAGE. Other bits in the Z-pointer must be written tozero during this operation.\n\u0081 Page Write to the RWW section: The NRWW section can be read during the page write\u0081 Page Write to the NRWW section: The CPU is halted during the operation\nUsing the SPM \nInterruptIf the SPM interrupt is en abled, the SPM interrupt will genera te a constant in terrupt when the\nSPMEN bit in SPMCR is cleared. This means t hat the interrupt can be used instead of polling\nthe SPMCR Register in software. When using the SPM interrupt, the Interrupt Vectors should bemoved to the BLS section to avoid that an in terrupt is accessing the RWW section when it is\nblocked for reading. How to move the interrupts is described in \u201cInterrupts\u201d on page 46 .\nConsideration While \nUpdating BLSSpecial care must be taken if the user allows the Boot Loader section to be updated by leaving\nBoot Lock bit11 unprogrammed. An accidental write to the Boot Loader itself can corrupt theentire Boot Loader, and further software updates might  be impossible. If it is not necessary to\nchange the Boot Loader software itself, it is recommended to program the Boot Lock bit11 toprotect the Boot Loader software from any internal software changes.\nPrevent Reading the \nRWW Section During Self-ProgrammingDuring Self-Programming (either page erase or page write), the RWW section is always blocked\nfor reading. The user software itself must prevent that this section is addressed during the selfprogramming ope ration. The RWWSB in the SPMCR will be set as long as the RWW section is\nbusy. During Self-Programming the Interrupt Vector table should be moved to the BLS asdescribed in \u201cInterrupts\u201d on page 46 , or the interrupts must be disabled. Before addressing the\nRWW section after the programming is completed, the user software must clear the RWWSB bywriting the RWWSRE. See \u201cSimple Assembly Code Example for a Boot Loader\u201d on page 212  for\nan example.\nSetting the Boot \nLoader Lock Bits by SPMTo set the Boot Loader Lock Bits, write the desired data to R0, write \u201cX0001001\u201d to SPMCR and\nexecute SPM within four clock cycles after writ ing SPMCR. The only accessible Lock Bits are\nthe Boot Lock Bits that may prevent the Application and Boot Loader section from any softwareupdate by the MCU.\nB i t 76543210\nR0 1 1 BLB12 BLB11 BLB02 BLB01 1 1\n\n210\n2486Z\u2013AVR\u201302/11ATmega8(L)See Table 78 on page 205  and Table 79 on page 205  for how the different settings of the Boot\nLoader Bits affect the Flash access.\nIf bits 5..2 in R0 are cleared (zero), the corresponding Boot Lock bit will be programmed if an\nSPM instruction is executed within four cy cles after BLBSET and SPMEN are set in SPMCR.\nThe Z-pointer is don\u2019t ca re during this operation, but for fu ture compatibility it  is recommended to\nload the Z-pointer with 0x0001 (s ame as used for reading the Lock  Bits). For future compatibility\nIt is also recommended to set bits 7, 6, 1, and 0 in R0 to \u201c1\u201d when writing the Lock Bits. Whenprogramming the Lock Bits the entire Flash can be read during the operation.\nEEPROM Write \nPrevents Writing to SPMCRNote that an EEPROM write oper ation will block all software progra mming to Flash. Reading the\nFuses and Lock Bits from software will also be prevented during  the EEPROM write operation. It\nis recommended that the user checks the status bit (EEWE) in the EECR Register and verifiesthat the bit is cleared before writing to the SPMCR Register.\nReading the Fuse and \nLock Bits from SoftwareIt is possible to read both the Fuse and Lock Bits from software. To read the Lock Bits, load the\nZ-pointer with 0x0001 and set the BLBSET and SPMEN bits in SPMCR. When an LPM instruc-tion is executed within  three CPU cycles after the BLBSET and SPMEN bits are set in SPMCR,\nthe value of the Lock Bits will be loaded in t he destination register. The BLBSET and SPMEN\nbits will auto-clear upon completion of reading th e Lock Bits or if no LP M instruction is executed\nwithin three CPU cycles or no SPM instruction is executed within four  CPU cycles. When BLB-\nSET and SPMEN are cleared, LPM will work as described in the Instruction set Manual .\nThe algorithm for reading the Fuse Low bits is similar to the one described above for reading the\nLock Bits. To read the Fuse Low bits, load th e Z-pointer with 0x0000 and set the BLBSET and\nSPMEN bits in SPMCR. When an LPM instruction is executed within three cycles after the BLB-SET and SPMEN bits are set in the SPMCR, the va lue of the Fuse Low bits (FLB) will be loaded\nin the destination register as shown below. Refer to Table 88 on page 217  for a detailed descrip-\ntion and mapping of the fuse low bits.\nSimilarly, when reading the Fuse High bits, load 0x0003 in the Z-pointer. When an LPM instruc-\ntion is executed within three cycles after the BLBSET and SPME N bits are set in the SPMCR,\nthe value of the Fuse High bits (FHB) will be lo aded in the destination r egister as shown below.\nRefer to Table 87 on page 216  for detailed description and mapping of the fuse high bits.\nFuse and Lock Bits that are programmed, will be read as zero. Fuse and Lock Bits that are\nunprogrammed, will be  read as one.\nPreventing Flash \nCorruptionDuring periods of low V\nCC, the Flash program can be corrupted because the supply voltage is too\nlow for the CPU and the Flash to operate properly. These issues are the same as for board levelsystems using the Flash, and the same design solutions should be applied.\nA Flash program corruption can be caused by two situ ations when the voltage is too low. First, a\nregular write sequence to the Flash requires a minimum voltage to operate correctly. Secondly,the CPU itself can execute instruct ions incorrectly, if the supply voltage for executing instructions\nis too low.B i t 76543210\nRd \u2013 \u2013 BLB12 BLB11 BLB02 BLB01 LB2 LB1\nB i t 76543210\nRd FLB7 FLB6 FLB5 FLB4 FLB3 FLB2 FLB1 FLB0\nB i t 76543210\nRd FHB7 FHB6 FHB5 FHB4 FHB3 FHB2 FHB1 FHB0\n\n211\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFlash corruption can easily be avoided by following these design recommendations (one is\nsufficient):\n1. If there is no need for a Boot Loader update in the system, program the Boot Loader Lock\nBits to prevent any Boot Loader software updates\n2. Keep the AVR RESET active (low) during pe riods of insufficient power supply voltage.\nThis can be done by enabling the internal Brown-out Detector (BOD) if the operating volt-age matches the detection level. If not, an external low V\nCC Reset Protection circuit can\nbe used. If a reset occurs wh ile a write operation is in pr ogress, the write operation will be\ncompleted provided that the power supply voltage is sufficient\n3. Keep the AVR core in Power-down sleep mode during periods of low VCC. This will pre-\nvent the CPU from attempting to decode and execute instructions, effectively protectingthe SPMCR Register and thus the Flash from unintentional writes\nProgramming Time for \nFlash when using SPMThe calibrated RC Oscillator is used to time Flash accesses. Table 81  shows the typical pro-\ngramming time for Flash accesses from the CPU.\nNote: 1. Minimum and maximum programming time is per individual operationTable 81.  SPM Programming Time(1)\nSymbol Min Programming Ti me Max Programming Time\nFlash write (page erase, page write, \nand write Lock Bits by SPM)3.7ms 4.5ms\n\n212\n2486Z\u2013AVR\u201302/11ATmega8(L)Simple Assembly \nCode Example for a Boot Loader;-the routine writes one page of data from RAM to Flash\n; the first data location in RAM is pointed to by the Y pointer\n; the first data location in Flash is pointed to by the Z-pointer\n;-error handling is not included;-the routine must be placed inside the boot space\n; (at least the Do_spm sub routine). Only code inside NRWW section can\n; be read during self-programming (page erase and page write).;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24), \n; loophi (r25), spmcrval (r20)\n; storing and restoring of registers is not included in the routine; register usage can be optimized at the expense of code size\n;-It is assumed that either the interrupt table is moved to the Boot\n; loader section or that the interrupts are disabled.\n.equ PAGESIZEB = PAGESIZE*2 ;PAGESIZEB is page size in BYTES, not words\n.org SMALLBOOTSTART\nWrite_page:\n; page erase\nldi spmcrval, (1<<PGERS) | (1<<SPMEN)\nrcallDo_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)rcallDo_spm\n; transfer data from RAM to Flash page buffer\nldi looplo, low(PAGESIZEB) ;init loop variable\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nWrloop:\nld r0, Y+\nld r1, Y+\nldi spmcrval, (1<<SPMEN)rcallDo_spm\nadiw ZH:ZL, 2\nsbiw loophi:looplo, 2 ;use subi for PAGESIZEB<=256brne Wrloop\n; execute page write\nsubi ZL, low(PAGESIZEB) ;restore pointer\nsbci ZH, high(PAGESIZEB) ;not required for PAGESIZEB<=256ldi spmcrval, (1<<PGWRT) | (1<<SPMEN)\nrcallDo_spm\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\nrcallDo_spm\n; read back and check, optional\nldi looplo, low(PAGESIZEB) ;init loop variableldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\nsubi YL, low(PAGESIZEB) ;restore pointer\nsbci YH, high(PAGESIZEB)\nRdloop:\nlpm r0, Z+\nld r1, Y+cpse r0, r1\nrjmp Error\nsbiw loophi:looplo, 1 ;use subi for PAGESIZEB<=256brne Rdloop\n\n213\n2486Z\u2013AVR\u201302/11ATmega8(L)\n; return to RWW section\n; verify that RWW section is safe to read\nReturn:\nin temp1, SPMCR\nsbrs temp1, RWWSB ; If RWWSB is set, the RWW section is not \nready yet\nret\n; re-enable the RWW section\nldi spmcrval, (1<<RWWSRE) | (1<<SPMEN)\nrcallDo_spmrjmp Return\nDo_spm:\n; check for previous SPM complete\nWait_spm:\nin temp1, SPMCRsbrc temp1, SPMEN\nrjmp Wait_spm\n; input: spmcrval determines SPM action; disable interrupts if enabled, store status\nin temp2, SREG\ncli; check that no EEPROM write access is present\nWait_ee:\nsbic EECR, EEWErjmp Wait_ee\n; SPM timed sequence\nout SPMCR, spmcrvalspm\n; restore SREG (to enable interrupts if originally enabled)\nout SREG, temp2ret\nATmega8 Boot Loader \nParametersIn Table 82  through Table 84 on page 214 , the parameters used in the description of the self\nprogramming are given.\nNote: The different BOOTSZ Fuse configurations are shown in Figure 102 on page 204Table 82.  Boot Size Configuration\nBOOTSZ1 BOOTSZ0Boot \nSize PagesApplication\nFlash \nSectionBoot \nLoader\nFlash \nSectionEnd\nApplication\nSectionBoot Reset \nAddress (Start Boot \nLoader \nSection)\n11128 \nwords40x000 - \n0xF7F0xF80 - \n0xFFF0xF7F 0xF80 \n10256 \nwords80x000 - \n0xEFF0xF00 - \n0xFFF0xEFF 0xF00\n01512 \nwords160x000 - \n0xDFF0xE00 - \n0xFFF0xDFF 0xE00\n001024 \nwords320x000 - \n0xBFF0xC00 - \n0xFFF0xBFF 0xC00\n\n214\n2486Z\u2013AVR\u201302/11ATmega8(L)For details about these two section, see \u201cNRWW \u2013 No Read-While-Write Section\u201d on page 203\nand \u201cRWW \u2013 Read-While-Write Section\u201d on page 203 .\nNote: 1. Z15:Z13: always ignored\nZ0: should be zero for all SPM commands, byte select for the LPM instruction.\nSee \u201cAddressing the Flash During Self-Programming\u201d on page 207  for details about the use of\nZ-pointer during Self-ProgrammingTable 83.  Read-While-Write Limit\nSection Pages Address\nRead-While-Write secti on (RWW) 96 0x000 - 0xBFF\nNo Read-While-Write section (NRWW) 32 0xC00 - 0xFFF\nTable 84.  Explanation of Different Variables used in Figure 103 on page 208  and the Mapping\nto the Z-pointer\nVariableCorresponding\nZ-value(1)Description\nPCMSB 11 Most significant bit in the Program Counter. \n(The Program Counter is 12 bits PC[11:0])\nPAGEMSB 4 Most significant bit which is used to address the \nwords within one page (32 words in a page requires 5 bits PC [4:0])\nZPCMSB Z12 Bit in Z-register that is mapped to PCMSB. \nBecause Z0 is not used, the ZPCMSB equals PCMSB + 1\nZPAGEMSB Z5 Bit in Z-register that is mapped to PAGEMSB. \nBecause Z0 is not used, the ZPAGEMSB equals PAGEMSB + 1\nPCPAGE PC[11:5] Z12:Z6 Program counter page address: Page select, \nfor page erase and page write\nPCWORD PC[4:0] Z5:Z1 Program counter word address: Word select, for \nfilling temporary buffer (must be zero during \npage write operation)\n\n215\n2486Z\u2013AVR\u201302/11ATmega8(L)\nMemory \nProgramming\nProgram And Data \nMemory Lock BitsThe ATmega8 provides six Lock Bits which can be left unprogrammed (\u201c1\u201d) or can be pro-\ngrammed (\u201c0\u201d) to obtain the additional features listed in Table 86 . The Lock Bits can only be\nerased to \u201c1\u201d with the Chip Erase command.\nNote: 1. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmedTable 85.  Lock Bit Byte \nLock Bit Byte Bit No. De scription Default Value(1)\n7 \u2013 1 (unprogrammed)\n6 \u2013 1 (unprogrammed)\nBLB12 5 Boot lock bit 1 (unprogrammed)\nBLB11 4 Boot lock bit 1 (unprogrammed)BLB02 3 Boot lock bit 1 (unprogrammed)\nBLB01 2 Boot lock bit 1 (unprogrammed)\nLB2 1 Lock bit 1 (unprogrammed)\nLB1 0 Lock bit 1 (unprogrammed)\nTable 86.  Lock Bit Protection Modes(2) \nMemory Lock Bits Protection Type\nLB Mode LB2 LB1\n1 1 1 No memory lock features enabled\n21 0Further programming of the Flash and EEPROM is \ndisabled in Parallel and Serial Programming mode. The \nFuse Bits are locked in both Serial and Parallel \nProgramming mode (1)\n30 0Further programming and verification of the Flash and \nEEPROM is disabled in parallel and Serial Programming \nmode. The Fuse Bits are locked in both Serial and Parallel Programming modes \n(1)\nBLB0 Mode BLB02 BLB01\n11 1No restrictions for SPM or LPM accessing the Application \nsection\n2 1 0 SPM is not allowed to write to the Application section\n30 0SPM is not allowed to write to  the Application section, and \nLPM executing from the Boot  Loader section is not \nallowed to read from the Application section. If Interrupt \nVectors are placed in the Boot  Loader section, interrupts \nare disabled while executing from the Application section\n40 1LPM executing from the Boot  Loader section is not \nallowed to read from the Application section. If Interrupt Vectors are placed in the Boot  Loader section, interrupts \nare disabled while executing from the Application section\n\n216\n2486Z\u2013AVR\u201302/11ATmega8(L)Notes: 1. Program the Fuse Bits before programming the Lock Bits\n2. \u201c1\u201d means unprogrammed, \u201c0\u201d means programmed\nFuse Bits The ATmega8 has two fuse bytes. Table 87  and Table 88 on page 217  describe briefly the func-\ntionality of all the fuses and how they are mapped into the fuse bytes. Note that the fuses areread as logical zero, \u201c0\u201d, if they are programmed.\nNotes: 1. The SPIEN Fuse is not accessible in Serial Programming mode\n2. The CKOPT Fuse functiona lity depends on the setting of the CKSEL bits, see \u201cClock Sources\u201d\non page 26  for details\n3. The default value of BOOTSZ1..0 results in maximum Boot Size. See Table 82 on page 213\n4. When programming the RSTDISBL Fuse Para llel Programming has to be used to change\nfuses or perform further programmingBLB1 Mode BLB12 BLB11\n11 1No restrictions for SPM or LPM accessing the Boot Loader \nsection\n2 1 0 SPM is not allowed to write to the Boot Loader section\n30 0SPM is not allowed to write to the Boot Loader section, \nand LPM executing from the Application section is not \nallowed to read from the Boot Loader section. If Interrupt \nVectors are placed in the Application section, interrupts \nare disabled while executing from the Boot Loader section\n40 1LPM executing from the Application section is not allowed \nto read from the Boot Loader se ction. If Interrupt Vectors \nare placed in the Application section, interrupts are disabled while executing from the Boot Loader sectionTable 86.  Lock Bit Protection Modes(2)  (Continued)\nMemory Lock Bits Protection Type\nTable 87.  Fuse High Byte\nFuse High\nByteBit \nNo. Description Default Value\nRSTDISBL(4)7Select if PC6 is I/O pin or RESET pin1 (unprogrammed, PC6 is \nRESET-pin)\nWDTON 6WDT always on1 (unprogrammed, WDT \nenabled by WDTCR)\nSPIEN(1)5Enable Serial Program and Data \nDownloading0 (programmed, SPI prog. \nenabled)\nCKOPT(2)4 Oscillator options 1 (unprogrammed)\nEESAVE 3EEPROM memory is preserved \nthrough the Chip Erase1 (unprogrammed, \nEEPROM not preserved)\nBOOTSZ1 2Select Boot Size (see Table 82 on \npage 213  for details) 0 (programmed)(3)\nBOOTSZ0 1Select Boot Size (see Table 82 on \npage 213  for details) 0 (programmed)(3)\nBOOTRST 0 Select Reset Vector 1 (unprogrammed)\n\n217\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNotes: 1. The default value of SUT1..0 results in maximum start-up time. See Table 10 on page 30  for\ndetails\n2. The default setting of CKSEL3..0 result s in internal RC Oscillator @ 1MHz. See Table 2 on\npage 26  for details\nThe status of the Fuse Bits is not affected by Chip Erase. Note that the Fuse Bits are locked if\nlock bit1 (LB1) is programmed. Program the Fuse Bits before programming the Lock Bits.\nLatching of Fuses The fuse values are latched when the device enters Programming mode and changes of the\nfuse values will have no effect until the part leaves Programming mode. This does not apply tothe EESAVE Fuse which will take effect once it is  programmed. The fuse s are also latched on\nPower-up in Normal mode.Table 88.  Fuse Low Byte\nFuse Low \nByteBit \nNo. Description Default Value\nBODLEVEL 7 Brown out detector trigger level 1 (unprogrammed)\nBODEN 6 Brown out detector enable 1 (unprogrammed, BOD disabled)\nSUT1 5 Select start-up time 1 (unprogrammed)(1)\nSUT0 4 Select start-up time 0 (programmed)(1)\nCKSEL3 3 Select Clock source 0 (programmed)(2)\nCKSEL2 2 Select Clock source 0 (programmed)(2)\nCKSEL1 1 Select Clock source 0 (programmed)(2)\nCKSEL0 0 Select Clock source 1 (unprogrammed)(2)\n\n218\n2486Z\u2013AVR\u201302/11ATmega8(L)Signature Bytes All Atmel microcontrollers have a 3-byte signat ure code which identifies the device. This code\ncan be read in both Serial and Parallel mode, al so when the device is locked. The three bytes\nreside in a separate address space.\nFor the ATmega8 the signature bytes are:\n1. 0x000: 0x1E (indicates manufactured by Atmel)2. 0x001: 0x93 (indicates 8KB Flash memory)3. 0x002: 0x07 (indicates ATmega8 device)\nCalibration Byte The ATmega8 stores four different calibration values for the internal RC Oscillator. These bytes\nresides in the signature row High byte of the addresses 0x0000, 0x0001, 0x0002, and 0x0003for 1MHz, 2MHz, 4MHz, and 8Mhz re spectively. During Reset, the 1MHz value is automatically\nloaded into the OSCCAL Register. If other frequencies are used, the calibration value has to beloaded manually, see \u201cOscillator Calibration Register \u2013 OSCCAL\u201d on page 31  for details.\nPage Size\nTable 89.  No. of Words in a Page and no. of Pages in the Flash\nFlash Size Page Size PCWORD No. of Pages PCPAGE PCMSB\n4K words (8 Kbytes) 32 words PC[4:0] 128 PC[11:5] 11\nTable 90.  No. of Words in a Page and no. of Pages in the EEPROM\nEEPROM Size Page Size PCWORD No. of Pages PCPAGE EEAMSB\n512 bytes 4 bytes EEA[1:0] 128 EEA[8:2] 8\n\n219\n2486Z\u2013AVR\u201302/11ATmega8(L)\nParallel \nProgramming \nParameters, Pin \nMapping, and CommandsThis section describes how to parallel program and verify Flash Program memory, EEPROM\nData memory, Memory Lock Bits, and Fuse Bits in the ATmega8. Pulses are assumed to be atleast 250ns unless otherwise noted.\nSignal Names In this section, some pins of the ATmega8 are referenced by signal names describing their func-\ntionality during parallel programming, see Figure 104  and Table 91 . Pins not described in the\nfollowing table are referenced by pin names.\nThe XA1/XA0 pins determine the action executed  when the XTAL1 pin is given a positive pulse.\nThe bit coding is shown in Table 93 on page 220 .\nWhen pulsing WR\n or OE , the command loaded determines the action executed. The different\nCommands are shown in Table 94 on page 220 .\nFigure 104.  Parallel Programming\nTable 91.  Pin Name Mapping \nSignal Name in \nProgramming Mode Pin Name I/O Function\nRDY/BSY PD1 O0: Device is busy programming, 1: Device \nis ready for new command\nOE PD2 I Output Enable (Active low)\nWR PD3 I Write Pulse (Active low)\nBS1 PD4 IByte Select 1 (\u201c0\u201d selects Low byte, \u201c1\u201d \nselects High byte)\nXA0 PD5 I XTAL Action Bit 0\nXA1 PD6 I XTAL Action Bit 1VCC+5V\nGNDXTAL1PD1\nPD2PD3PD4PD5PD6\n PC[1:0]:PB[5:0]DATA\nRESETPD7\n+12 VBS1\nXA0XA1OERDY/BSY\nPAGEL\nPC2WR\nBS2AVCC+5V\n\n220\n2486Z\u2013AVR\u201302/11ATmega8(L)PAGEL PD7 IProgram memory and EEPROM Data \nPage Load\nBS2 PC2 IByte Select 2 (\u201c0\u201d selects Low byte, \u201c1\u201d \nselects 2\u2019nd High byte)\nDATA {PC[1:0]: PB[5:0]} I/OBi-directional Data bus (Output when OE  is \nlow)\nTable 92.  Pin Values used to Enter Programming Mode\nPin Symbol Value\nPAGEL Prog_enable[3] 0\nXA1 Prog_enable[2] 0\nXA0 Prog_enable[1] 0BS1 Prog_enable[0] 0\nTable 93.  XA1 and XA0 Coding\nXA1 XA0 Action when XTAL1 is Pulsed\n0 0 Load Flash or EEPROM Address (High or low address byte determined by BS1)\n0 1 Load Data (High or Low data byte for Flash determined by BS1)1 0 Load Command\n1 1 No Action, Idle\nTable 94.  Command Byte Bit Coding\nCommand Byte Command Executed\n1000 0000 Chip Erase0100 0000 Write Fuse Bits\n0010 0000 Write Lock Bits\n0001 0000 Write Flash0001 0001 Write EEPROM\n0000 1000 Read Signature Bytes and Calibration byte\n0000 0100 Read Fuse and Lock Bits0000 0010 Read Flash\n0000 0011 Read EEPROMTable 91.  Pin Name Mapping  (Continued)\nSignal Name in \nProgramming Mode Pin Name I/O Function\n\n221\n2486Z\u2013AVR\u201302/11ATmega8(L)\nParallel \nProgramming\nEnter Programming \nModeThe following algorithm puts the devi ce in Parallel Programming mode:\n1. Apply 4.5V - 5.5V between VCC and GND, and wait at least 100\u00b5s\n2. Set RESET  to \u201c0\u201d and toggle XTAL1 at least 6 times\n3. Set the Prog_enable pins listed in Table 92 on page 220  to \u201c0000\u201d and wait at least\n100ns\n4. Apply 11.5V - 12.5V to RESET . Any activity on Prog_enable pins within 100ns after +12V\nhas been applied to RESET , will cause the device to fail entering Programming mode\nNote, if the RESET  pin is disabled by programming the RSTDISBL Fuse, it may not be possible\nto follow the proposed algorithm above. The same  may apply when External Crystal or External\nRC configuration is selected because it is not possible to apply qualified XTAL1 pulses. In suchcases, the following algorithm should be followed:\n1. Set Prog_enable pins listed in Table 92 on page 220  to \u201c0000\u201d\n2. Apply 4.5V - 5.5V between V\nCC and GND simultaneously as 11.5V - 12.5V is applied to\nRESET\n3. Wait 100ns\n4. Re-program the fuses to ensure that External Clock is selected as clock source\n(CKSEL3:0 = 0\u2019b0000) and RESET  pin is activated (RSTDISBL unprogrammed). If Lock\nBits are programmed, a chip erase command must be executed before changing thefuses\n5. Exit Programming mode by power the device down or by bringing RESET\n pin to 0\u2019b0\n6. Entering Programming mode with the original algorithm, as described above\nConsiderations for \nEfficient ProgrammingThe loaded command and address are retained in the device during programming. For efficient\nprogramming, the following should be considered.\n\u0081 The command needs only be loaded once when writing or reading multiple memory \nlocations\n\u0081 Skip writing the data value 0xFF , that is t he contents of the enti re EEPROM (unless the \nEESAVE Fuse is programmed) and Flash after a Chip Erase\n\u0081 Address High byte needs only be loaded before programming or reading a new 256 word \nwindow in Flash or 256 byte EEPROM. This consideration also applies to Signature bytes reading\nChip Erase The Chip Erase will erase the Flash and EEPROM\n(1) memories plus Lock Bits. The Lock Bits are\nnot reset until the Program memory has been completely erased. The Fuse Bits are notchanged. A Chip Erase must be performed before the Flash and/or the EEPROM arereprogrammed.\nNote: 1. The EEPRPOM memory is preserved duri ng chip erase if the EESAVE Fuse is programmed\nLoad Command \u201cChip Erase\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading2. Set BS1 to \u201c0\u201d3. Set DATA to \u201c1000 0000\u201d. This is the command for Chip Erase4. Give XTAL1 a positive pulse. This loads the command5. Give WR\n a negative pulse. This starts the Chip Erase. RDY/BSY  goes low\n6. Wait until RDY/BSY  goes high before loading a new command\n\n222\n2486Z\u2013AVR\u201302/11ATmega8(L)Programming the \nFlashThe Flash is organized in pages, see Table 89 on page 218 . When programming the Flash, the\nprogram data is latched into a page buffer. This allows one page of program data to be pro-grammed simultaneously. The following procedure describes how to program the entire Flashmemory:\nA. Load Command \u201cWrite Flash\u201d\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading2. Set BS1 to \u201d0\u201d3. Set DATA to \u201c0001 0000\u201d. This is the command for Write Flash4. Give XTAL1 a positive pulse. This loads the command\nB. Load Address Low byte\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading2. Set BS1 to \u201c0\u201d. This selects low address3. Set DATA = Address Low byte (0x00 - 0xFF)4. Give XTAL1 a positive pulse. This loads the address Low byte\nC. Load Data Low byte\n1. Set XA1, XA0 to \u201c01\u201d. This enables data loading2. Set DATA = Data Low byte (0x00 - 0xFF)3. Give XTAL1 a positive pulse. This loads the data byte\nD. Load Data High byte\n1. Set BS1 to \u201c1\u201d. This selects high data byte2. Set XA1, XA0 to \u201c01\u201d. This enables data loading3. Set DATA = Data High byte (0x00 - 0xFF)4. Give XTAL1 a positive pulse. This loads the data byte\nE. Latch Data\n1. Set BS1 to \u201c1\u201d. This selects high data byte2. Give PAGEL a positive pulse. This latches the data bytes (see Figure 106 on page 224\nfor signal waveforms)\nF. Repeat B through E until the entire buffer is filled or until all data within the page is loadedWhile the lower bits in the address are mapped to words within the page, the higher bits address\nthe pages within the FLASH. This is illustrated in Figure 105 on page 223 . Note that if less than\neight bits are required to address words in the page (pagesize <256), the most significant bit(s)in the address Low byte are used to address the page when performing a page write.\nG. Load Address High byte\n1. Set XA1, XA0 to \u201c00\u201d. This enables address loading2. Set BS1 to \u201c1\u201d. This selects high address3. Set DATA = Address High byte (0x00 - 0xFF)4. Give XTAL1 a positive pulse. This loads the address High byte\nH. Program Page\n1. Set BS1 = \u201c0\u201d2. Give WR\n a negative pulse. This starts programming of the entire page of data. RDY/BSY\ngoes low\n3. Wait until RDY/BSY  goes high. (See Figure 106 on page 224  for signal waveforms)\n\n223\n2486Z\u2013AVR\u201302/11ATmega8(L)\nI. Repeat B through H until the entire Flash is programmed or until all data has been\nprogrammed.\nJ. End Page Programming\n1. Set XA1, XA0 to \u201c10\u201d. This enables command loading2. Set DATA to \u201c0000 0000\u201d. This is the command for No Operation3. Give XTAL1 a positive pulse. This loads the command, and the internal write signals are\nreset\nFigure 105.  Addressing the Flash which is Organized in Pages\n(1)\nNote: 1. PCPAGE and PCWORD are listed in Table 89 on page 218PROGRAM MEMORYWORD ADDRESS\nWITHIN A PAGEPAGE ADDRESS\nWITHIN THE FLASH\nINSTRUCTION WORDPAGEPCWORD[PAGEMSB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCMSB PAGEMSB\nPROGRAM\nCOUNTER\n\n224\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 106.  Programming the Flash Waveforms(1)\nNote: 1. \u201cXX\u201d is don\u2019t care. The letters re fer to the programming description above\nProgramming the \nEEPROMThe EEPROM is organized in pages, see Table 90 on page 218 . When programming the\nEEPROM, the program data is latche d into a page buffer. This al lows one page of data to be\nprogrammed simultaneously. The programming algorithm for the EEPROM Data memory is asfollows (refer to \u201cProgramming the Flash\u201d on page 222  for details on Command, Address and\nData loading):\n1. A: Load Command \u201c0001 0001\u201d2. G: Load Address High byte (0x00 - 0xFF)3. B: Load Address Low byte (0x00 - 0xFF)4. C: Load Data (0x00 - 0xFF)5. E: Latch data (give PAGEL a positive pulse)\nK: Repeat 3 through 5 until the entire buffer is filled\nL: Program EEPROM page\n1. Set BS1 to \u201c0\u201d2. Give WR\n a negative pulse. This starts pr ogramming of the EEPROM page. RDY/BSY\ngoes low\n3. Wait until to RDY/BSY  goes high before programming the next page (see Figure 107 on\npage 225  for signal waveforms)RDY/BSYWR\nOERESET +12V\nPAGEL\nBS20x10 ADDR. LOW ADDR. HIGHDATADATA LOW DATA HIGH ADDR. LOW DATA LOW DATA HIGH\nXA1\nXA0\nBS1\nXTAL1XX XX XXAB CDE B C DE G HF\n\n225\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 107.  Programming the EEPROM Waveforms\nReading the Flash The algorithm for reading the Flash memory is as follows (refer to \u201cProgramming the Flash\u201d on\npage 222  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0010\u201d2. G: Load Address High byte (0x00 - 0xFF)3. B: Load Address Low byte (0x00 - 0xFF)4. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The Flash word Low byte can now be read at DATA\n5. Set BS1 to \u201c1\u201d. The Flash word High byte can now be read at DATA6. Set OE\n to \u201c1\u201d\nReading the EEPROM The algorithm for reading the EEPROM memory is as follows (refer to \u201cProgramming the Flash\u201d\non page 222  for details on Command and Address loading):\n1. A: Load Command \u201c0000 0011\u201d2. G: Load Address High byte (0x00 - 0xFF)3. B: Load Address Low byte (0x00 - 0xFF)4. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The EEPROM  Data byte can now be read at DATA\n5. Set OE  to \u201c1\u201d\nProgramming the \nFuse Low BitsThe algorithm for programming the Fuse Low bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 222  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d2. C: Load Data Low byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit3. Set BS1 and BS2 to \u201c0\u201d4. Give WR\n a negative pulse and wait for RDY/BSY  to go highRDY/BSYWR\nOERESET +12V\nPAGEL\nBS20x11 ADDR. HIGHDATAADDR. LOW DATA ADDR. LOW DATA XX\nXA1XA0\nBS1\nXTAL1XXAG B C EBC E LK\n\n226\n2486Z\u2013AVR\u201302/11ATmega8(L)Programming the \nFuse High BitsThe algorithm for programming the Fuse high bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 222  for details on Command and Data loading):\n1. A: Load Command \u201c0100 0000\u201d2. C: Load Data Low byte. Bit n = \u201c0\u201d programs and bit n = \u201c1\u201d erases the Fuse bit3. Set BS1 to \u201c1\u201d and BS2 to \u201c0\u201d. This selects high data byte4. Give WR\n a negative pulse and wait for RDY/BSY  to go high\n5. Set BS1 to \u201c0\u201d. This selects low data byte\nProgramming the Lock \nBitsThe algorithm for programming the Lock Bits is as follows (refer to \u201cProgramming the Flash\u201d on\npage 222  for details on Command and Data loading):\n1. A: Load Command \u201c0010 0000\u201d2. C: Load Data Low byte. Bit n = \u201c0\u201d programs the Lock bit3. Give WR\n a negative pulse and wait for RDY/BSY  to go high\nThe Lock Bits can only be cleared by executing Chip Erase.\nReading the Fuse and \nLock BitsThe algorithm for reading the Fuse and Lock Bits is as follows (refer to \u201cProgramming the Flash\u201d\non page 222  for details on Command loading):\n1. A: Load Command \u201c0000 0100\u201d2. Set OE\n to \u201c0\u201d, BS2 to \u201c0\u201d, and BS1 to \u201c0\u201d. The status of the Fuse Low bits can now be\nread at DATA (\u201c0\u201d means programmed)\n3. Set OE  to \u201c0\u201d, BS2 to \u201c1\u201d, and BS1 to \u201c1\u201d. The status of the Fuse High bits can now be\nread at DATA (\u201c0\u201d means programmed)\n4. Set OE  to \u201c0\u201d, BS2 to \u201c0\u201d, and BS1 to \u201c1\u201d. The status of the Lock Bits can now be read at\nDATA (\u201c0\u201d means programmed)\n5. Set OE  to \u201c1\u201d\nFigure 108.  Mapping Between BS1, BS2 and the Fuse- and Lock Bits During Read\nFuse low byte\nLock bits 0\n1\nBS2Fuse high byte0\n1\nBS1DATA\n\n227\n2486Z\u2013AVR\u201302/11ATmega8(L)\nReading the Signature \nBytesThe algorithm for reading the Signatur e bytes is as follows (refer to \u201cProgramming the Flash\u201d on\npage 222  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d2. B: Load Address Low byte (0x00 - 0x02)3. Set OE\n to \u201c0\u201d, and BS1 to \u201c0\u201d. The selected Signature byte can now be read at DATA.\n4. Set OE  to \u201c1\u201d\nReading the \nCalibration ByteThe algorithm for reading the Calibrati on bytes is as follows (refer to \u201cProgramming the Flash\u201d on\npage 222  for details on Command and Address loading):\n1. A: Load Command \u201c0000 1000\u201d2. B: Load Address Low byte, (0x00 - 0x03)3. Set OE\n to \u201c0\u201d, and BS1 to \u201c1\u201d. The Calibration byte can now be read at DATA\n4. Set OE  to \u201c1\u201d\nParallel Programming \nCharacteristicsFigure 109.  Parallel Programming Timing, Including some General Timing Requirements\nFigure 110.  Parallel Programming Timing, Loading Sequence with Timing Requirements(1)\nNote: 1. The timing requirements shown in Figure 109  (that is, tDVXH , tXHXL, and tXLDX) also apply to\nloading operationData & Contol\n(DATA, XA0/1, BS1, BS2)XTAL1tXHXL\ntWL WHtDVXH tXLDX\ntPLWL\ntWLRHWR\nRDY/BSYPAGEL tPHPLtPLBXtBVPHtXLWL\ntWLBXtBVWL\nWLRL\nXTAL1\nPAGELtPLXH XLXHttXLPH\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRESS\n(LOW BYTE)LOAD DATA \n(LOW BYTE)LOAD DATA\n(HIGH BYTE)LOAD DATA LOAD ADDRESS\n(LOW BYTE)\n\n228\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 111.  Parallel Programming Timing, Reading Sequence (within the same Page) with Tim-\ning Requirements(1)\nNote: 1. The timing requirements shown in Figure 109 on page 227  (that is, tDVXH , tXHXL, and tXLDX)\nalso apply to reading operation\nTable 95.  Parallel Programming Characteristics, VCC = 5V \u00b110% \nSymbol Parameter Min Typ Max Units\nVPP Programming Enable Voltage 11.5 12.5 V\nIPP Programming Enable Current 250 \u03bcA\ntDVXH Data and Control Valid before XTAL1 High 67\nnstXLXH XTAL1 Low to XTAL1 High 200\ntXHXL XTAL1 Pulse Width High 150\ntXLDX Data and Control Hold after XTAL1 Low 67\ntXLWL XTAL1 Low to WR  Low 0\ntXLPH XTAL1 Low to PAGEL high 0\ntPLXH PAGEL low to XTAL1 high 150\ntBVPH BS1 Valid before PAGEL High 67\ntPHPL PAGEL Pulse Width High 150\ntPLBX BS1 Hold after PAGEL Low 67\ntWLBX BS2/1 Hold after WR  Low 67\ntPLWL PAGEL Low to WR  Low 67\ntBVWL BS1 Valid to WR  Low 67\ntWLWH WR Pulse Width Low 150\ntWLRL WR Low to RDY/BSY  Low 0 1 \u03bcs\ntWLRH WR Low to RDY/BSY  High(1)3.7 4.5\nms\ntWLRH_CE WR Low to RDY/BSY  High for Chip Erase(2)7.5 9XTAL1\nOE\nADDR0 (Low Byte) DATA (Low Byte) DATA (High Byte) ADDR1 (Low Byte) DATABS1\nXA0\nXA1LOAD ADDRESS\n(LOW BYTE)READ DATA \n(LOW BYTE)READ DATA\n(HIGH BYTE)LOAD ADDRESS\n(LOW BYTE)\ntBVDV\ntOLDVtXLOL\ntOHDZ\n\n229\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNotes: 1.  tWLRH is valid for the Write Flash, Write EEPROM , Write Fuse Bits and Write Lock Bits\ncommands\n2.  tWLRH_CE is valid for the Chip Erase commandtXLOL XTAL1 Low to OE  Low 0\nnstBVDV BS1 Valid to DATA valid 0 250\ntOLDV OE Low to DATA Valid 250\ntOHDZ OE High to DATA Tri-stated 250Table 95.  Parallel Programming Characteristics, VCC = 5V \u00b110%  (Continued)\nSymbol Parameter Min Typ Max Units\n\n230\n2486Z\u2013AVR\u201302/11ATmega8(L)Serial \nDownloadingBoth the Flash and EEPROM memo ry arrays can be programmed using the serial SPI bus while\nRESET  is pulled to GND. The serial interface consists of pins SCK, MOSI (input) and MISO (out-\nput). After RESET  is set low, the Programming Enable instruction needs to be executed first\nbefore program/erase operations can be executed. NOTE, in Table 96 , the pin mapping for SPI\nprogramming is listed. Not all parts use the SPI pins dedicated for the internal SPI interface.\nSerial \nProgramming Pin Mapping\nFigure 112.  Serial Programming and Verify(1)\nNotes: 1. If the device is clocked by the Internal Oscillator, it is no need to connect a clock source to the\nXTAL1 pin\n2. VCC - 0.3 < AVCC < VCC + 0.3, however, AVCC should always be within 2.7V - 5.5V\nWhen programming the EEPROM, an auto-erase cycle is built into the self-timed programming\noperation (in the Serial mode ONLY) and there is no need to first execute the Chip Eraseinstruction. The Chip Erase operation turns the content of every memory location in both theProgram and EEPROM arrays into 0xFF.\nDepending on CKSEL Fuses, a valid clock must be present. The minimum low and high periods\nfor the Serial Clock (SCK) input are defined as follows:\nLow:> 2 CPU clock cycles for f\nck <12MHz, 3 CPU clock cycles for fck >=12MHz\nHigh:> 2 CPU clock cycles for fck <12MHz, 3 CPU clock cycles for fck >=12MHzTable 96.  Pin Mapping Serial Programming\nSymbol Pins I/O Description\nMOSI PB3 I Serial data in\nMISO PB4 O Serial data out\nSCK PB5 I Serial clock\nVCC\nGNDXTAL1SCKMISOMOSI\nRESETPB3\nPB4PB5+2.7V - 5.5V\nAVCC+2.7V - 5.5V (2)\n\n231\n2486Z\u2013AVR\u201302/11ATmega8(L)\nSerial Programming \nAlgorithmWhen writing serial data to the ATmega8, data is clocked on the rising edge of SCK.\nWhen reading data from the ATmega8, data is clocked on the falling edge of SCK. See Figure\n113 on page 232  for timing details.\nTo program and verify the ATmega8 in the Serial Programming mode, the following sequence is\nrecommended (see four byte instruction formats in Table 98 on page 233 ):\n1. Power-up sequence:\nApply power between VCC and GND while RESET  and SCK are set to \u201c0\u201d. In some sys-\ntems, the programmer can not guarantee that SCK is held low during Power-up. In thiscase, RESET\n must be given a positive pulse of at least two CPU clock cycles duration\nafter SCK has been set to \u201c0\u201d\n2. Wait for at least 20ms and enable Serial Programming by sending the Programming\nEnable serial instruction to pin MOSI\n3. The Serial Programming instructions will not wo rk if the communication is out of synchro-\nnization. When in sync. the se cond byte (0x53), will echo back when issuing the third\nbyte of the Programming Enable instruction. Whether the echo is correct or not, all fourbytes of the instruction must be transmitted. If the 0x53 did not echo back, give RESET\n a\npositive pulse and issue a new Programming Enable command\n4. The Flash is programmed one page at a time. The page size is found in Table 89 on\npage 218 . The memory page is loaded one byte at a time by supplying the 5 LSB of the\naddress and data together with the Load Program memory Page instruction. To ensurecorrect loading of the page, the data Low byte must be loaded before data High byte isapplied for a given address. The Program memory Page is stored by loading the WriteProgram memory Page instruction with the 7M SB of the address. If polling is not used,\nthe user must wait at least t\nWD_FLASH  before issuing the next page (see Table 97 on page\n232).\nNote: If other commands than polling (read) are ap plied before any write operation (FLASH,\nEEPROM, Lock Bits, Fuses) is completed, it ma y result in inco rrect programming\n5. The EEPROM array is programmed one byte at  a time by supplyin g the address and data\ntogether with th e appropriate Writ e instruction. An EEPROM me mory location is first\nautomatically erased before new data is written. If polling is not used, the user must waitat least t\nWD_EEPROM  before issuing the next byte (see Table 97 on page 232 ). In a chip\nerased device, no 0xFFs in the data file(s) need to be programmed\n6. Any memory location can be verified by using the Read instruction which returns the con-\ntent at the selected address at serial output MISO\n7. At the end of the programming session, RESET  can be set high to commence normal\noperation\n8. Power-off sequence (if needed):\nSet RESET  to \u201c1\u201d\nTur n VCC power off\nData Polling Flash When a page is being programmed into the Flash, reading an address location within the page\nbeing programmed will give the value 0xFF. At th e time the device is ready for a new page, the\nprogrammed value will read correctly.  This is used to determine w hen the next page can be writ-\nten. Note that the entire page is written simultaneously and any address within the page can beused for polling. Data po lling of the Flash will not work for the value 0xFF,  so when programming\nthis value, the user will have to wait for at least t\nWD_FLASH  before programming the next page. As\na chip-erased device contains 0xFF in all locations, programming of addresses that are meant tocontain 0xFF, can be skipped. See Table 97 on page 232  for t\nWD_FLASH  value.\n\n232\n2486Z\u2013AVR\u201302/11ATmega8(L)Data Polling EEPROM When a new byte has been written and is being programmed into  EEPROM, reading the\naddress location being programmed will give the value 0xFF. At the time the device is ready for\na new byte, the programmed value will read corr ectly. This is used to determine when the next\nbyte can be written. This will not work for the value 0xFF, but th e user should have the following\nin mind: As a chip-erased device contains 0xFF in all locations, progra mming of addresses that\nare meant to contain 0xFF, can be skipped. This does not apply if the EEPROM is Re-pro-\ngrammed without chip-erasing the device. In this case, data polling cannot be used for the value\n0xFF, and the user will have  to wait at least tWD_EEPROM  before programming the next byte. See\nTable 97  for tWD_EEPROM  value.\nFigure 113.  Serial Programming WaveformsTable 97.  Minimum Wait Delay Befo re Writing the Next Flash or EEPROM Location\nSymbol Minimum Wait Delay\ntWD_FUSE 4.5ms\ntWD_FLASH 4.5ms\ntWD_EEPROM 9.0ms\ntWD_ERASE 9.0ms\nMSB\nMSBLSB\nLSB\nSERIAL CLOCK INPUT\n(SCK)SERIAL DATA INPUT\n (MOSI)\n(MISO)\nSAMPLESERIAL DATA OUTPUT\n\n233\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNote: a = address high bits\nb = address low bits\nH = 0 \u2013 Low byte, 1 \u2013 High byte\no = data out\ni = data in\nx = don\u2019t careTable 98.  Serial Programming Instruction Set\nInstructionInstruction Format\nOperation Byte 1 Byte 2 Byte 3 Byte 4\nProgramming Enable 1010 1100 0101 0011 xxxx xxxx xxxx xxxx Enable Serial Programming after \nRESET  goes low\nChip Erase 1010 1100 100x xxxx xxxx xxxx xxxx xxxx Chip Erase EEPROM and Flash\nRead Program Memory 0010 H000 0000 aaaa bbbb bbbb oooo oooo Read H (high or low) data o from \nProgram memory at word address \na:b\nLoad Program Memory \nPage0100 H000 0000 xxxx xxx b bbbb iiii iiii Write H (high or low) data i to \nProgram memory page at word \naddress b. Data Low byte must be \nloaded before Data High byte is \napplied within the same address\nWrite Program Memory \nPage0100 1100 0000 aaaa bbb x xxxx xxxx xxxx Write Program memory Page at \naddress a:b\nRead EEPROM Memory 1010 0000 00xx xxx a bbbb bbbb oooo oooo Read data o from EEPROM \nmemory at address a:b\nWrite EEPROM Memory 1100 0000 00xx xxx a bbbb bbbb iiii iiii Write data i to EEPROM memory \nat address a:b\nRead Lock Bits 0101 1000 0000 0000 xxxx xxxx xx oo oooo Read Lock Bits. \u201c0\u201d = programmed, \n\u201c1\u201d = unprogrammed. See Table \n85 on page 215  for details\nWrite Lock Bits 1010 1100 111x xxxx xxxx xxxx 11 ii iiii Write Lock Bits. Set bits = \u201c0\u201d to \nprogram Lock Bits. See Table 85 \non page 215  for details\nRead Signature Byte 0011 0000 00xx xxxx xxxx xx bb oooo oooo Read Signature Byte o at address \nb\nWrite Fuse Bits 1010 1100 1010 0000 xxxx xxxx iiii iiii Set bits = \u201c0\u201d to program, \u201c1\u201d to \nunprogram. See Table 88 on \npage 217  for details\nWrite Fuse High Bits 1010 1100 1010 1000 xxxx xxxx iiii iiii Set bits = \u201c0\u201d to program, \u201c1\u201d to \nunprogram. See Table 87 on \npage 216  for details\nRead Fuse Bits 0101 0000 0000 0000 xxxx xxxx oooo oooo Read Fuse Bits. \u201c0\u201d = programmed, \n\u201c1\u201d = unprogrammed. See Table \n88 on page 217  for details\nRead Fuse High Bits 0101 1000 0000 1000 xxxx xxxx oooo oooo Read Fuse high bits. \u201c0\u201d = pro-\ngrammed, \u201c1\u201d = unprogrammed. See \nTable 87 on page 216  for \ndetails\nRead Calibration Byte 0011 1000 00xx xxxx 0000 00 bb oooo oooo Read Calibration Byte\n\n234\n2486Z\u2013AVR\u201302/11ATmega8(L)SPI Serial \nProgramming CharacteristicsFor characteristics of the SPI module, see \u201cSPI Timing Characteristics\u201d on page 239 .\n\n235\n2486Z\u2013AVR\u201302/11ATmega8(L)\nElectrical Characteristics\nNote: Typical values contained in this datasheet are based on simulations and characterization of other AVR microcontrollers man u-\nfactured on the same process technology. Min and Max va lues will be available after the device is characterized.\nDC CharacteristicsAbsolute Maximum Ratings*\nOperating Temperature.................................. -55 \u00b0C to +125 \u00b0C *NOTICE: Stresses beyond those listed under \u201cAbsolute \nMaximum Ratings\u201d may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or \nother conditions beyond those indicated in the operational sections of th is specification is not \nimplied. Exposure to absolute maximum rating \nconditions for extended periods may affect device reliability.Storage Temperature ..................................... -65\u00b0C to +150\u00b0C\nVoltage on any Pin except RESET\nwith respect to Ground ................................-0.5V to VCC+0.5V\nVoltage on RESET with respect to Ground......-0.5V to +13.0V\nMaximum Operating Voltage ............................................ 6.0VDC Current per I/O Pin ................................................ 40.0mA\nDC Current \nVCC and GND Pins................................. 300.0mA\nTA = -40 \u00b0C to +85 \u00b0C, VCC = 2.7V to 5.5V (unless otherwise noted) \nSymbol Parameter Condition Min Typ Max Units\nVILInput Low Voltage except \nXTAL1 and RESET  pinsVCC = 2.7V - 5.5V -0.5 0.2 VCC(1)\nVVIHInput High Voltage except \nXTAL1 and RESET  pinsVCC = 2.7V - 5.5V 0.6VCC(2)VCC + 0.5\nVIL1Input Low Voltage \nXTAL1 pinVCC = 2.7V - 5.5V -0.5 0.1VCC(1)\nVIH1Input High Voltage\nXTAL 1 pinVCC = 2.7V - 5.5V 0.8VCC(2)VCC + 0.5\nVIL2Input Low Voltage\nRESET  pinVCC = 2.7V - 5.5V -0.5 0.2 VCC\nVIH2Input High Voltage\nRESET  pinVCC = 2.7V - 5.5V 0.9VCC(2)VCC + 0.5\nVIL3Input Low Voltage\nRESET  pin as I/OVCC = 2.7V - 5.5V -0.5 0.2VCC\nVIH3Input High Voltage\nRESET  pin as I/OVCC = 2.7V - 5.5V0.6VCC(2)\n0.7VCC(2)VCC + 0.5\nVOLOutput Low Voltage(3)\n(Ports B,C,D)IOL = 20mA, VCC = 5V\nIOL = 10mA, VCC = 3V0.9\n0.6\nVOHOutput High Voltage(4)\n(Ports B,C,D)IOH = -20mA, VCC = 5V\nIOH = -10mA, VCC = 3V4.2\n2.2\nIILInput Leakage\nCurrent I/O PinVcc = 5.5V, pin low\n(absolute value)1\n\u00b5A\nIIHInput Leakage\nCurrent I/O PinVcc = 5.5V, pin high\n(absolute value)1\nRRST Reset Pull-up Resistor 30 80 k \u03a9\n\n236\n2486Z\u2013AVR\u201302/11ATmega8(L)Notes: 1. \u201cMax\u201d means the highest value where the pin is guaranteed to be read as low\n2. \u201cMin\u201d means the lowest value where t he pin is guaranteed to be read as high\n3. Although each I/O port can sink more than the test condit ions (20mA at Vcc = 5V, 10mA at  Vcc = 3V) under steady state\nconditions (non-transient), th e following must be observed:\nPDIP , TQFP , and QFN/MLF Package:1] The sum of all IOL, for a ll ports, should not exceed 300mA.\n2] The sum of all IOL, for port s C0 - C5 should not exceed 100mA.\n3] The sum of all IOL, for ports B0 - B7, C6, D0 - D7 and XTAL2, should not exceed 200mA.If IOL exceeds the test condition, VOL may exceed the related specification. Pins are not guar anteed to sink current greater\nthan the listed test condition\n4. Although each I/O port can source more than the test cond itions (20mA at Vcc = 5V, 10mA at Vcc = 3V) under steady state\nconditions (non-transient), th e following must be observed:\nPDIP , TQFP , and QFN/MLF Package:\n1] The sum of all IOH, for a ll ports, should not exceed 300mA.\n2] The sum of all IOH, for port C0 - C5, should not exceed 100mA.\n3] The sum of all IOH, for ports B0 - B7, C6 , D0 - D7 and XTAL2, should not exceed 200mA.\nIf IOH exceeds the test condition, VOH may exceed the rela ted specification. Pins are not guaranteed to source current\ngreater than the listed test condition\n5. Minimum V\nCC for Power-down is 2.5VRpu I/O Pin Pull-up Resistor 20 50 k \u03a9\nICCPower Supply CurrentActive 4MHz, VCC = 3V\n(ATmega8L)35\nmAActive 8MHz, VCC = 5V\n(ATmega8)11 15\nIdle 4MHz, VCC = 3V\n(ATmega8L)12\nIdle 8MHz, VCC = 5V\n(ATmega8)4.5 7\nPower-down mode(5)WDT enabled, VCC = 3V < 22 28\n\u00b5A\nWDT disabled, VCC = 3V < 1 3\nVACIOAnalog Comparator \nInput Offset VoltageVCC = 5V\nVin = VCC/240 mV\nIACLKAnalog Comparator \nInput Leakage CurrentVCC = 5V\nVin = VCC/2-50 50 nA\ntACPDAnalog Comparator \nPropagation DelayVCC = 2.7V\nVCC = 5.0V750\n500nsTA = -40 \u00b0C to +85 \u00b0C, VCC = 2.7V to 5.5V (unless otherwise noted)  (Continued)\nSymbol Parameter Condition Min Typ Max Units\n\n237\n2486Z\u2013AVR\u201302/11ATmega8(L)\nExternal Clock \nDrive WaveformsFigure 114.  External Clock Drive Waveforms\nExternal Clock \nDrive\nNotes: 1. R should be in the range 3k \u03a9 - 100k \u03a9, and C should be at least 20pF . The C values given in\nthe table includes pin capacitance. This will vary with package type\n2. The frequency will vary with package type and board layoutVIL1VIH1\nTable 99.  External Clock Drive\nSymbol ParameterVCC = 2.7V to 5.5VVCC = 4.5V to 5.5V\nUnits Min Max Min Max\n1/tCLCL Oscillator Frequency 0 8 0 16 MHz\ntCLCL Clock Period 125 62.5\nns tCHCX High Time 50 25\ntCLCX Low Time 50 25\ntCLCH Rise Time 1.6 0.5\n\u03bcs\ntCHCL Fall Time 1.6 0.5\n\u0394tCLCLChange in period from one \nclock cycle to the next22 %\nTable 100.  External RC Oscillator, Typical Frequencies\nR [k \u03a9](1)C [pF] f(2)\n33 22 650kHz\n10 22 2.0MHz\n\n238\n2486Z\u2013AVR\u201302/11ATmega8(L)Two-wire Serial Interface Characteristics\nTable 101  describes the requirements for devices connected to the Two-wire Serial Bus. The ATmega8 Two-wire Serial\nInterface meets or exceeds these requirements under the noted conditions.\nTiming symbols refer to Figure 115 on page 239 .\nNotes: 1. In ATmega8, this parameter is characterized and not 100% tested\n2. Required only for fSCL > 100kHz\n3. Cb = capacitance of one bus line in pF\n4. fCK = CPU clock frequencyTable 101.  Two-wire Serial Bus Requirements \nSymbol Parameter Condition Min Max Units\nVIL Input Low-voltage -0.5 0.3VCC\nVVIH Input High-voltage 0.7VCC VCC + 0.5\nVhys(1)Hysteresis of Schmitt Trigger Inputs 0.05VCC(2)\u2013\nVOL(1)Output Low-voltage 3mA sink Current 0 0.4\ntr(1)Rise Time for both SDA and SCL 20 + 0.1Cb(3)(2)300\nns tof(1)Output Fall Time from VIHmin to VILmax 10pF < Cb < 400pF(3)20 + 0.1Cb(3)(2)250\ntSP(1)Spikes Suppressed by Input Filter 0 50(2)\nIi Input Current each I/O Pin 0.1VCC < Vi < 0.9VCC -10 10 \u00b5A\nCi(1)Capacitance for each I/O Pin \u2013 10 pF\nfSCL SCL Clock Frequency fCK(4) > max(16fSCL, 250kHz)(5)0 400 kHz\nRp Value of Pull-up resistorfSCL \u2264 100kHz\nfSCL > 100kHz\ntHD;STA Hold Time (repeated) START ConditionfSCL \u2264 100kHz 4.0 \u2013\n\u00b5sfSCL > 100kHz 0.6 \u2013\ntLOW Low Period of the SCL ClockfSCL \u2264 100kHz(6)4.7 \u2013\nfSCL > 100kHz(7)1.3 \u2013\ntHIGH High period of the SCL clockfSCL \u2264 100kHz 4.0 \u2013\nfSCL > 100kHz 0.6 \u2013\ntSU;STA Set-up time for a repeated START conditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 0.6 \u2013\ntHD;DAT Data hold timefSCL \u2264 100kHz 0 3.45\nfSCL > 100kHz 0 0.9\ntSU;DAT Data setup timefSCL \u2264 100kHz 250 \u2013\nns\nfSCL > 100kHz 100 \u2013\ntSU;STO Setup time for STOP conditionfSCL \u2264 100kHz 4.0 \u2013\n\u00b5sfSCL > 100kHz 0.6 \u2013\ntBUFBus free time between a STOP and START \nconditionfSCL \u2264 100kHz 4.7 \u2013\nfSCL > 100kHz 1.3 \u2013VCC0.4V\u2013\n3mA----------------------------1000ns\nCb-------------------\n\u03a9\nVCC0.4V\u2013\n3mA----------------------------300ns\nCb--------------- -\n\n239\n2486Z\u2013AVR\u201302/11ATmega8(L)\n5. This requirement applies to all ATmega8 Two-wire Serial Inte rface operation. Other devices connected to the Two-wire Serial\nBus need only obey the general fSCL requirement\n6. The actual low period generated by the ATmega8 Two-wire Serial Interface is (1/fSCL - 2/fCK), thus fCK must be greater than\n6MHz for the low time requirement to be strictly met at fSCL = 100kHz\n7. The actual low period generated by the ATmega8 Two-wire Serial Interface is (1/fSCL - 2/fCK), thus the low time requirement\nwill not be strictly met for fSCL > 308kHz when fCK = 8MHz. Still, ATmega8 devices connected to the bus may communicate at\nfull speed (400kHz) with other ATmega8 devices, as well as any other device with a proper tLOW acceptance margin\nFigure 115.  Two-wire Serial Bus Timing\nSPI Timing \nCharacteristicsSee Figure 116 on page 240  and Figure 117 on page 240  for details.\nNote: 1. In SPI Programming mode the minimum SCK high/low period is:\n- 2tCLCL for fCK < 12MHz\n- 3tCLCL for fCK > 12MHztSU;STAtLOWtHIGH\ntLOWtof\ntHD;STA tHD;DAT tSU;DATtSU;STO\ntBUFSCL\nSDAtr\nTable 102.  SPI Timing Parameters\nDescription Mode Min Typ Max\n1 SCK period MasterSee Table 50 on \npage 126\nns2 SCK high/low Master 50% duty cycle\n3 Rise/Fall time Master 3.6\n4 Setup Master 105 Hold Master 10\n6 Out to SCK Master 0.5 \u0081 t\nSCK\n7 SCK to out Master 10\n8 SCK to out high Master 10\n9S S  low to out Slave 15\n10 SCK period Slave 4 \u0081 tck\n11 SCK high/low(1)Slave 2 \u0081 tck\n12 Rise/Fall time Slave 160013 Setup Slave 1014 Hold Slave 10\n15 SCK to out Slave 15\n16 SCK to SS\n high Slave 20\n17 SS  high to tri-state Slave 10\n18 SS  low to SCK Salve 2 \u0081 tck\n\n240\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 116.  SPI interface timing requirements (Master Mode)\nFigure 117.  SPI interface timing requirements (Slave Mode)MOSI\n(Data Output)SCK\n(CPOL = 1)\nMISO\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...61\n22\n3 45\n8 7\nMISO\n(Data Output)SCK\n(CPOL = 1)\nMOSI\n(Data Input)SCK\n(CPOL = 0)SS\nMSBL SB\nLSB MSB...\n...10\n11 11\n12 13 14\n17 159\nX1618\n\n241\n2486Z\u2013AVR\u201302/11ATmega8(L)\nADC Characteristics\nNotes: 1. Values are guidelines only\n2. Minimum for AVCC is 2.7V\n3. Maximum for AVCC is 5.5V\n4. Maximum conversion time is 1/50kHz \u00d7 25 = 0.5msTable 103.  ADC Characteristics\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nResolution Single Ended Conversion 10 Bits\nAbsolute accuracy \n(including INL, DNL, Quantization Error, Gain, \nand Offset Error)Single Ended Conversion\nV\nREF = 4V, VCC = 4V\nADC clock = 200kHz1.75\nLSBSingle Ended Conversion\nVREF = 4V, VCC = 4V\nADC clock = 1MHz3\nIntegral Non-linearity (INL)Single Ended Conversion\nVREF = 4V, VCC = 4V\nADC clock = 200kHz 0.75\nDifferential Non-linearity \n(DNL)Single Ended Conversion\nVREF = 4V, VCC = 4V\nADC clock = 200kHz 0.5\nGain Error Single Ended Conversion\nVREF = 4V, VCC = 4V\nADC clock = 200kHz1\nOffset Error Single Ended Conversion\nVREF = 4V, VCC = 4V\nADC clock = 200kHz1\nConversion Time(4)Free Running Conversion 13 260 \u00b5s\nClock Frequency 50 1000 kHz\nAVCCAnalog Supply Voltage VCC - 0.3(2)VCC + 0.3(3)\nVVREF Reference Voltage 2.0 AVCC\nVIN Input voltage GND VREF\nInput bandwidth 38.5 kHz\nVINT Internal Voltage Reference 2.3 2.56 2.9 V\nRREF Reference Input Resistance 32 k \u03a9\nRAIN Analog Input Resistance 55 100 M \u03a9\n\n242\n2486Z\u2013AVR\u201302/11ATmega8(L)ATmega8 \nTypical \nCharacteristicsThe following charts show typical behavior. T hese figures are not tested during manufacturing.\nAll current consumption measurements are performed with all I/O pins configured as inputs andwith internal pull-ups enabled. A sine wave generator  with Rail-to-Rail output is used as clock\nsource.\nThe power consumption in Power-down mode is independent of clock selection.The current consumption is a function of several factors such as: operating voltage, operating\nfrequency, loading of I/O pins, switching rate  of I/O pins, code executed and ambient tempera-\nture. The dominating factors are operating voltage and frequency.\nThe current drawn from capacitive loaded pi ns may be estimated (for one pin) as:\nC\nL \u00d7 VCC \u00d7 f\nwhere CL = load capacitance, VCC = operating voltage and f = average switching frequency of I/O\npin.\nThe parts are characterized at frequencies higher than test limits. Parts are not guaranteed to\nfunction properly at frequencies higher than the ordering code indicates.\nThe difference between current consumption in Power-down mode with Watchdog Timer\nenabled and Power-down mode with Watchdog Timer disabled represents the differential cur-\nrent drawn by the Watchdog Timer.\nActive Supply Current Figure 118.  Active Supply Current vs. Frequency (0.1MHz - 1.0MHz)\n00.511.522.53\n0 0.1 0.2 0. 3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (mA)5.5V\n5.0V\n4.5V\n3.3V\n3.0V\n2.7V4.0V\n\n243\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 119.  Active Supply Current vs. Frequency (1MHz - 20MHz)\nFigure 120.  Active Supply Current vs. VCC (Internal RC Oscillator, 8MHz)051015202530\n0246 8 10 12 14 16 1 8 20\nFrequency (MHz)ICC (mA)5.5V\n5.0V4.5V\n3.3V\n2.7V3.0V\n024681012141618\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C-40\u00b0C\n\n244\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 121.  Active Supply Current vs. VCC (Internal RC Oscillator, 4MHz)\nFigure 122.  Active Supply Current vs. VCC (Internal RC Oscillator, 2MHz)024681012\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C-40\u00b0C\n0123456\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C\n-40\u00b0C\n\n245\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 123.  Active Supply Current vs. VCC (Internal RC Oscillator, 1MHz)\nFigure 124.  Active Supply Current vs. VCC (32kHz External Oscillator)00.511.522.533.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C\n-40\u00b0C\n020406080100120\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C\n\n246\n2486Z\u2013AVR\u201302/11ATmega8(L)Idle Supply Current Figure 125.  Idle Supply Current vs. Frequency (0.1MHz - 1.0MHz)\nFigure 126.  Idle Supply Current vs. Frequency (1MHz - 20MHz)00.10.20.30.40.50.60.7\n0 0.1 0.2 0. 3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (mA)5.5V\n4.5V\n4.0V\n3.3V\n3.0V\n2.7V5.0V\n02468101214\n0246 8 10 12 14 16 1 8 20\nFrequency (MHz)ICC (mA)5.5V\n4.5V\n4.0V\n3.3V\n3.0V\n2.7V5.0V\n\n247\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 127.  Idle Supply Current vs. VCC (Internal RC O scillator, 8MHz)\nFigure 128.  Idle Supply Current vs. VCC (Internal RC O scillator, 4MHz)012345678\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.54\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C25\u00b0C-40\u00b0C\n\n248\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 129.  Idle Supply Current vs. VCC (Internal RC O scillator, 2MHz)\nFigure 130.  Idle Supply Current vs. VCC (Internal RC O scillator, 1MHz)00.20.40.60.811.21.41.61.8\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C\n25\u00b0C-40\u00b0C\n00.10.20.30.40.50.60.70.80.91\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n249\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 131.  Idle Supply Current vs. VCC (32kHz External Oscillator)\nPower-down Supply \nCurrentFigure 132.  Power-down Supply  Current vs. VCC (Watchdog Timer Disabled)0510152025303540\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C\n00.511.522.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)85\u00b0C\n25\u00b0C-40\u00b0C\n\n250\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 133.  Power-down Supply  Current vs. VCC (Watchdog Timer Enabled)\nPower-save Supply \nCurrentFigure 134.  Power-save Supply  Current vs. VCC (Watchdog Timer Disabled)01020304050607080\n2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (\u00b5A)85\u00b0C\n25\u00b0C\n-40\u00b0C\n0510152025\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C\n\n251\n2486Z\u2013AVR\u201302/11ATmega8(L)\nStandby Supply \nCurrentFigure 135.  Standby Supply Current vs. VCC (455kHz Resonator, Watchdog Timer Disabled)\nFigure 136.  Standby Supply Current vs. VCC (1MHz Resonator, Watchdog Timer Disabled)01020304050607080\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n010203040506070\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n252\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 137.  Standby Supply Current vs. VCC (2MHz Resonator, Watchdog Timer Disabled)\nFigure 138.  Standby Supply Current vs. VCC (2MHz Xtal, Watchdog Timer Disabled)0102030405060708090\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n0102030405060708090\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n253\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 139.  Standby Supply Current vs. VCC (4MHz Resonator, Watchdog Timer Disabled)\nFigure 140.  Standby Supply Current vs. VCC (4MHz Xtal, Watchdog Timer Disabled)020406080100120140\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n020406080100120140\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n254\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 141.  Standby Supply Current vs. VCC (6MHz Resonator, Watchdog Timer Disabled)\nFigure 142.  Standby Supply Current vs. VCC (6MHz Xtal, Watchdog Timer Disabled)020406080100120140160\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n020406080100120140160180200\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)\n\n255\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPin Pull-up Figure 143.  I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 5V)\nFigure 144.  I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 2.7V)020406080100120140160\n012 3 45 6\nVOP (V)IIO (\u00b5A)85\u00b0C\n25\u00b0C\n-40\u00b0C\n0102030405060708090\n0 0.5 1 1.5 2 2.5 3\nVOP (V)IIO (\u00b5A)85\u00b0C 25\u00b0C\n-40\u00b0C\n\n256\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 145.  Reset Pull-up Resistor Current vs. Reset Pin Voltage (VCC = 5V)\nFigure 146.  Reset Pull-up Resistor Current vs. Reset Pin Voltage (VCC = 2.7V)020406080100\n012\nVRESET (V)IRESET (\u00b5A)85\u00b0C25\u00b0C- 40\u00b0C\n051015202530354045\n0 0.5 1 1.5 2 2.5\nVRESET (V)IRESET (\u00b5A)85\u00b0C25\u00b0C-40\u00b0C\n\n257\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPin Driver Strength Figure 147.  I/O Pin Source Current vs. Output Voltage (VCC = 5V)\nFigure 148.  I/O Pin Source Current vs. Output Voltage (VCC = 2.7V)01020304050607080\nVOH (V)IOH (mA)85\u00b0C25\u00b0C-40\u00b0C\n051015202530\n0 0.5 1 1.5 2 2.5 3\nVOH (V)IOH (mA)85\u00b0C25\u00b0C-40\u00b0C\n\n258\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 149.  I/O Pin Sink Current vs. Output Voltage (VCC = 5V)\nFigure 150.  I/O Pin Sink Current vs. Output Voltage (VCC = 2.7V)0102030405060708090\n0 0.5 1 1.5 2 2.5\nVOL (V)IOL (mA)85\u00b0C25\u00b0C-40\u00b0C\n05101520253035\n0 0.5 1 1.5 2 2.5\nVOL (V)IOL (mA)85\u00b0C25\u00b0C-40\u00b0C\n\n259\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 151.  Reset Pin as I/O \u2013 Pin Source Current vs. Output Voltage (VCC = 5V)\nFigure 152.  Reset Pin as I/O \u2013 Pin Source Current vs. Output Voltage (VCC = 2.7V)00.511.522.533.54\n2 2.5 33 .5 4 4.5\nVOH (V)Current (mA)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.544.55\n0 0.5 1 1.5 2 2.5\nVOH (V)Current (mA)85\u00b0C25\u00b0C -40\u00b0C\n\n260\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 153.  Reset Pin as I/O \u2013 Pin Sink Current vs. Output Voltage (VCC = 5V)\nFigure 154.  Reset Pin as I/O \u2013 Pin Sink Current vs. Output Voltage (VCC = 2.7V)02468101214\n0 0.5 1 1.5 2 2.5\nVOL (V)Current (mA)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.533.544.5\n0 0.5 1 1.5 2 2.5\nVOL (V)Current (mA)85\u00b0C25\u00b0C-40\u00b0C\n\n261\n2486Z\u2013AVR\u201302/11ATmega8(L)\nPin Thresholds and \nHysteresisFigure 155.  I/O Pin Input Threshold Voltage vs. VCC (VIH, I/O Pin Read as \u201c1\u201d)\nFigure 156.  I/O Pin Input Threshold Voltage vs. VCC (VIL, I/O Pin Read as \u201c0\u201d)00.511.522.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.52\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C25\u00b0C-40\u00b0C\n\n262\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 157.  I/O Pin Input Hysteresis vs. VCC\nFigure 158.  Reset Pin as I/O \u2013 Input Threshold Voltage vs. VCC (VIH, I/O Pin Read as \u201c1\u201d)00.10.20.30.40.50.60.7\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Input Hysteresis (V)85\u00b0C\n25\u00b0C-40\u00b0C\n00.511.522.533.54\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C\n25\u00b0C-40\u00b0C\n\n263\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 159.  Reset Pin as I/O \u2013 Input Threshold Voltage vs. VCC (VIL, I/O Pin Read as \u201c0\u201d)\nFigure 160.  Reset Pin as I/O \u2013 Pin Hysteresis vs. VCC00.511.522.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C\n25\u00b0C\n-40\u00b0C\n00.511.52\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Input Hysteresis (V)85\u00b0C\n25\u00b0C-40\u00b0C\n\n264\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 161.  Reset Input Threshold Voltage vs. VCC (VIH, Reset Pin Read as \u201c1\u201d)\nFigure 162.  Reset Input Threshold Voltage vs. VCC (VIL, Reset Pin Read as \u201c0\u201d)00.511.522.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C25\u00b0C-40\u00b0C\n00.511.522.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Threshold (V)85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n265\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 163.  Reset Input Pin Hysteresis vs. VCC\nBod Thresholds and \nAnalog Comparator OffsetFigure 164.  BOD Thresholds vs. Temperature (BOD Level is 4.0V)00.20.40.60.81\n2 2.5 33 .5 4 4.5 5 5.5\nVCC (V)Input Hysteresis (V)\n85\u00b0C25\u00b0C-40\u00b0C\n3.73.83.944.14.24.3\n-50 -40 - 30 -20 -10 0 10 20 304 05 06 07 0 80 90 100\nTemper ature (\u00b0C)Threshold (V)Rising V CC\nFalling V CC\n\n266\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 165.  BOD Thresholds vs. Temperature (BOD Level is 2.7V)\nFigure 166.  Bandgap Voltage vs. VCC2.42.52.62.72.8\n-50 -40 - 30 -20 -10 0 10 20 304 05 06 07 0 80 90 100\nTemper ature (\u00b0C)Threshold (V)Rising V CC\nFalling V CC\n1.291.2951.31.3051.311.315\n2.5 33 .5 4 4.5 5 5.5\nVcc (V)Bandgap Volt age (V)-40\u00b0C\n25\u00b0C85\u00b0C\n\n267\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 167.  Analog Comparator Offset Voltage vs. Common Mode Voltage (VCC = 5V)\nFigure 168.  Analog Comparator Offset Voltage vs. Common Mode Voltage (VCC = 2.7V)-0.006-0.005-0.004-0.00 3-0.002-0.00100.0010.0020.003\n0 0.5 1 1.5 2 2.5 33 .5 4 4.5 5\nCommon Mode Volt age (V)Comp arator Off set Volt age (V)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n-0.005-0.004-0.00 3-0.002-0.00100.0010.0020.003\n0 0.5 1 1.5 2 2.5 3\nCommon Mode Volt age (V)Comp arator Off set Volt age (V)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n268\n2486Z\u2013AVR\u201302/11ATmega8(L)Internal Oscillator \nSpeedFigure 169.  Watchdog Oscillator Frequency vs. VCC\nFigure 170.  Calibrated 8MHz RC Oscillator Frequency vs. Temperature110011201140116011801200122012401260\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)FRC (kHz)85\u00b0C25\u00b0C-40\u00b0C\n6.56.76.97.17.37.57.77.98.18.38.5\n-60 -40 -20 0 20 40 60 80 100\nTemper ature (\u00b0C)FRC (MHz)5.5V\n2.7V4.0V\n\n269\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 171.  Calibrated 8MHz RC Oscillator Frequency vs. VCC\nFigure 172.  Calibrated 8MHz RC Oscillator Frequency vs. Osccal Value6.56.76.97.17.37.57.77.98.18.38.5\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)FRC (MHz)85\u00b0C25\u00b0C-40\u00b0C\n46810121416\n01 6 324 8 64 80 96 112 12 8144 160 176 192 20 8224 240\nOSCCAL VALUEFRC (MHz)\n\n270\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 173.  Calibrated 4MHz RC Oscillator Frequency vs. Temperature\nFigure 174.  Calibrated 4MHz RC Oscillator Frequency vs. VCC3.53.63.73.83.944.14.2\n-60 -40 -20 0 20 40 60 80 100\nTemper ature (\u00b0C)FRC (MHz)5.5V\n2.7V4.0V\n3.53.63.73.83.944.14.2\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)FRC (MHz)85\u00b0C25\u00b0C-40\u00b0C\n\n271\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 175.  Calibrated 4MHz RC Oscillator Frequency vs. Osccal Value\nFigure 176.  Calibrated 2MHz RC Oscillator Frequency vs. Temperature2345678\n01 6 324 8 64 80 96 112 12 8144 160 176 192 20 8224 240\nOSCCAL VALUEFRC (MHz)\n1.81.851.91.9522.052.1\n-60 -40 -20 0 20 40 60 80 100\nTemper ature (\u00b0C)FRC (MHz)5.5V\n2.7V4.0V\n\n272\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 177.  Calibrated 2MHz RC Oscillator Frequency vs. VCC\nFigure 178.  Calibrated 2MHz RC Oscillator Frequency vs. Osccal Value1.71.81.922.12.2\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)FRC (MHz)85\u00b0C25\u00b0C-40\u00b0C\n0.81.31.82.32.83.33.8\n01 6 324 8 64 80 96 112 12 8144 160 176 192 20 8224 240\nOSCCAL VALUEFRC (MHz)\n\n273\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 179.  Calibrated 1MHz RC Oscillator Frequency vs. Temperature\nFigure 180.  Calibrated 1MHz RC Oscillator Frequency vs. VCC0.90.920.940.960.9811.021.04\n-60 -40 -20 0 20 40 60 80 100\nTemper ature (\u00b0C)FRC (MHz)5.5V\n2.7V4.0V\n0.90.9511.051.1\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)FRC (MHz)85\u00b0C25\u00b0C-40\u00b0C\n\n274\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 181.  Calibrated 1MHz RC Oscillator Frequency vs. Osccal Value\nCurrent Consumption \nof Peripheral UnitsFigure 182.  Brown-out Detector Current vs. VCC0.50.70.91.11.31.51.71.9\n01 6 324 8 64 80 96 112 12 8144 160 176 192 20 8224 240\nOSCCAL VALUEFRC (MHz)\n051015202530\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C\n85\u00b0C-40\u00b0C\n\n275\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 183.  ADC Current vs. VCC (AREF = AVCC)\nFigure 184.  AREF External Reference Current vs. VCC050100150200250300350400450\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)85\u00b0C25\u00b0C-40\u00b0C\n050100150200250\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n276\n2486Z\u2013AVR\u201302/11ATmega8(L)Figure 185.  32kHz TOSC Current vs. VCC (Watchdog Timer Disabled)\nFigure 186.  Watchdog Timer Current vs. VCC0510152025\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C\n01020304050607080\n22 . 5 33 . 5 44 . 555 . 5VCC (V)ICC (\u00b5A)85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n277\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 187.  Analog Comparator Current vs. VCC\nFigure 188.  Programming Current vs. VCC0102030405060708090100\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (\u00b5A)25\u00b0C85\u00b0C\n-40\u00b0C\n01234567\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)ICC (mA)25\u00b0C\n85\u00b0C-40\u00b0C\n\n278\n2486Z\u2013AVR\u201302/11ATmega8(L)Current Consumption \nin Reset and Reset PulsewidthFigure 189.  Reset Supply Current vs. V\nCC (0.1MHz - 1.0MHz, Excluding Current Through The\nReset Pull-up)\nFigure 190.  Reset Supply Current vs. VCC (1MHz - 20MHz, Excluding Current Through The\nReset Pull-up)00.511.522.533.54\n0 0.1 0.2 0. 3 0.4 0.5 0.6 0.7 0. 8 0.9 1\nFrequency (MHz)ICC (mA)5.5V\n5.0V\n4.5V\n3.3V\n3.0V\n2.7V4.0V\n0510152025\n0246 8 10 12 14 16 1 8 20\nFrequency (MHz)ICC (mA)5.5V\n5.0V\n4.5V\n3.3V\n3.0V\n2.7V\n\n279\n2486Z\u2013AVR\u201302/11ATmega8(L)\nFigure 191.  Reset Pulse Width vs. VCC\n0200400600800100012001400\n2.5 33 .5 4 4.5 5 5.5\nVCC (V)Pulsewidth (n s)\n85\u00b0C\n25\u00b0C\n-40\u00b0C\n\n280\n2486Z\u2013AVR\u201302/11ATmega8(L)Register Summary \nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n0x3F (0x5F) SREG I T H S V N Z C 11\n0x3E (0x5E) SPH \u2013 \u2013 \u2013 \u2013 \u2013 SP10 SP9 SP8 13\n0x3D (0x5D) SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 13\n0x3C (0x5C) Reserved\n0x3B (0x5B) GICR INT1 INT0 \u2013 \u2013 \u2013 \u2013 IVSEL IVCE 49, 67 \n0x3A (0x5A) GIFR INTF1 INTF0 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 67\n0x39 (0x59) TIMSK OCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 \u2013 TOIE0 72, 100, 119\n0x38 (0x58) TIFR OCF2 TOV2 ICF1 OCF1A OCF1B TOV1 \u2013T O V 0 72, 101, 119\n0x37 (0x57) SPMCR SPMIE RWWSB \u2013 RWWSRE BLBSET PGWRT PGERS SPMEN 206\n0x36 (0x56) TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013T W I E 165\n0x35 (0x55) MCUCR SE SM2 SM1 SM0 ISC11 ISC10 ISC01 ISC00 33, 66\n0x34 (0x54) MCUCSR \u2013 \u2013 \u2013 \u2013 WDRF BORF EXTRF PORF 41\n0x33 (0x53) TCCR0 \u2013 \u2013 \u2013 \u2013 \u2013 CS02 CS01 CS00 71\n0x32 (0x52) TCNT0 Timer/Counter0 (8 Bits) 72\n0x31 (0x51) OSCCAL Oscillator Calibration Register 31\n0x30 (0x50) SFIOR \u2013 \u2013 \u2013 \u2013 ACME PUD PSR2 PSR10 58, 74, 120, 186\n0x2F (0x4F) TCCR1A COM1A1 COM1A0 COM1B1 COM1B0 FOC1A FOC1B WGM11 WGM10 96\n0x2E (0x4E) TCCR1B ICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 98\n0x2D (0x4D) TCNT1H Timer/Counter1 \u2013 Counter Register High byte 99\n0x2C (0x4C) TCNT1L Timer/Counter1 \u2013 Counter Register Low byte 99\n0x2B (0x4B) OCR1AH Timer/Counter1 \u2013 Output Compare Register A High byte 99\n0x2A (0x4A) OCR1AL Timer/Counter1 \u2013 Output Compare Register A Low byte 99\n0x29 (0x49) OCR1BH Timer/Counter1 \u2013 Output Compare Register B High byte 99\n0x28 (0x48) OCR1BL Timer/Counter1 \u2013 Output Compare Register B Low byte 99\n0x27 (0x47) ICR1H Timer/Counter1 \u2013 Input Capture Register High byte 100\n0x26 (0x46) ICR1L Timer/Counter1 \u2013 Input Capture Register Low byte 100\n0x25 (0x45) TCCR2 FOC2 WGM20 COM21 COM20 WGM21 CS22 CS21 CS20 114\n0x24 (0x44) TCNT2 Timer/Counter2 (8 Bits) 116\n0x23 (0x43) OCR2 Timer/Counter2 Output Compare Register 116\n0x22 (0x42) ASSR \u2013 \u2013 \u2013 \u2013 AS2 TCN2UB OCR2UB TCR2UB 117\n0x21 (0x41) WDTCR \u2013 \u2013 \u2013 WDCE WDE WDP2 WDP1 WDP0 43\n0x20(1) (0x40)(1)UBRRH URSEL \u2013 \u2013 \u2013 UBRR[11:8] 152\nUCSRC URSEL UMSEL UPM1 UPM0 USBS UCSZ1 UCSZ0 UCPOL 150\n0x1F (0x3F) EEARH \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013E E A R 8 20\n0x1E (0x3E) EEARL EEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 20\n0x1D (0x3D) EEDR  EEPROM Data Register 20\n0x1C (0x3C) EECR \u2013 \u2013 \u2013 \u2013 EERIE EEMWE EEWE EERE 20\n0x1B (0x3B) Reserved\n0x1A (0x3A) Reserved\n0x19 (0x39) Reserved\n0x18 (0x38) PORTB PORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 65\n0x17 (0x37) DDRB DDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 65\n0x16 (0x36) PINB PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 65\n0x15 (0x35) PORTC \u2013 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 65\n0x14 (0x34) DDRC \u2013 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 65\n0x13 (0x33) PINC \u2013 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 65\n0x12 (0x32) PORTD PORTD7 PORTD6 PORTD 5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 65\n0x11 (0x31) DDRD DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 65\n0x10 (0x30) PIND PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 65\n0x0F (0x2F) SPDR  SPI Data Register 127\n0x0E (0x2E) SPSR SPIF WCOL \u2013 \u2013 \u2013 \u2013 \u2013S P I 2 X 126\n0x0D (0x2D) SPCR SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 125\n0x0C (0x2C) UDR  USART I/O Data Register 148\n0x0B (0x2B) UCSRA RXC TXC UDRE FE DOR PE U2X MPCM 148\n0x0A (0x2A) UCSRB RXCIE TXCIE UDRIE RXEN TXEN UCSZ2 RXB8 TXB8 149\n0x09 (0x29) UBRRL  USART Baud Rate Register Low byte 152\n0x08 (0x28) ACSR ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 186\n0x07 (0x27) ADMUX REFS1 REFS0 ADLAR \u2013 MUX3 MUX2 MUX1 MUX0 199\n0x06 (0x26) ADCSRA ADEN ADSC ADFR ADIF ADIE ADPS2 ADPS1 ADPS0 200\n0x05 (0x25) ADCH ADC Data Register High byte 201\n0x04 (0x24) ADCL ADC Data Register Low byte 201\n0x03 (0x23) TWDR Two-wire Serial Interface Data Register 167\n0x02 (0x22) TWAR TWA6 TWA5 TW A4 TWA3 TWA2 TW A1 TWA0 TWGCE 167\n\n281\n2486Z\u2013AVR\u201302/11ATmega8(L)\nNotes: 1. Refer to the USART description ( \u201cUSART\u201d on page 129 ) for details on how to access UBRRH and UCSRC ( \u201cAccessing\nUBRRH/UCSRC Registers\u201d on page 146 )\n2. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory addresses\nshould never be written\n3. Some of the Status Flags are cleared by writing a logical one to them. Note that the CBI and  SBI instructions will operate on\nall bits in the I/O Register, writing a one back into any flag read as set, thus clearing the flag. The CBI and SBI instruction s\nwork with registers 0x00 to 0x1F only0x01 (0x21) TWSR TWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 166\n0x00 (0x20) TWBR Two-wire Serial Interface Bit Rate Register 165Register Summary  (Continued)\nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n282\n2486Z\u2013AVR\u201302/11ATmega8(L)Instruction Set Summary \nMnemonics Operands Description Operation Flags #Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \u2190 Rd + Rr Z, C, N, V, H 1\nADC Rd, Rr Add with Carry two Registers Rd \u2190 Rd + Rr + C Z, C, N, V, H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \u2190 Rdh:Rdl + K Z, C, N, V, S 2\nSUB Rd, Rr Subtract two Registers Rd \u2190 Rd - Rr Z, C, N, V, H 1\nSUBI Rd, K Subtract Constant from Register Rd \u2190 Rd - K Z, C, N, V, H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \u2190 Rd - Rr - C Z, C, N, V, H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \u2190 Rd - K - C Z, C, N ,V, H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \u2190 Rdh:Rdl - K Z, C, N, V, S 2\nAND Rd, Rr Logical AND Registers Rd \u2190 Rd \u2022 Rr Z, N, V 1\nANDI Rd, K Logical AND Register and Constant Rd \u2190 Rd \u2022 K Z, N, V 1\nOR Rd, Rr Logical OR Registers Rd \u2190 Rd v Rr Z, N, V 1\nORI Rd, K Logical OR Register and Constant Rd \u2190 Rd v K Z, N, V 1\nEOR Rd, Rr Exclusive OR Registers Rd \u2190 Rd \u2295 Rr Z, N, V 1\nCOM Rd One\u2019s Complement Rd \u2190 0xFF \u2212 Rd Z, C, N, V 1\nNEG Rd Two\u2019s Complement Rd \u2190 0x00 \u2212 Rd Z, C, N, V, H 1\nSBR Rd,K Set Bit(s) in Register Rd \u2190 Rd v K Z, N, V 1\nCBR Rd,K Clear Bit(s) in Register Rd \u2190 Rd \u2022 (0xFF - K) Z, N, V 1\nINC Rd Increment Rd \u2190 Rd + 1 Z, N, V 1\nDEC Rd Decrement Rd \u2190 Rd \u2212 1 Z, N, V 1\nTST Rd Test for Zero or Minus Rd \u2190 Rd \u2022 Rd Z, N, V 1\nCLR Rd Clear Register Rd \u2190 Rd \u2295 Rd Z, N, V 1\nSER Rd Set Register Rd \u2190 0xFF None 1\nMUL Rd, Rr Multiply Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nMULS Rd, Rr Multiply Signed R1:R0 \u2190 Rd x Rr Z, C 2\nMULSU Rd, Rr Multiply Signed with Unsigned R1:R0 \u2190 Rd x Rr Z, C 2\nFMUL Rd, Rr Fractional Multiply Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULS Rd, Rr Fractional Multiply Signed R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nFMULSU Rd, Rr Fractional Multiply Signed with Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z, C 2\nBRANCH INSTRUCTIONS\nRJMP k Relative Jump PC  \u2190 PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \u2190 Z None 2\nRCALL k Relative Subroutine Call PC \u2190 PC + k + 1 None 3\nICALL Indirect Call to (Z) PC \u2190 ZN o n e 3\nRET Subroutine Return PC \u2190 STACK None 4\nRETI Interrupt Return PC \u2190 STACK I 4\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC  \u2190 PC + 2 or 3 None 1 / 2 / 3\nCP Rd,Rr Compare Rd \u2212 Rr Z, N, V, C, H 1 \nCPC Rd,Rr Compare with Carry Rd \u2212 Rr \u2212 C Z, N, V, C, H 1\nCPI Rd,K Compare Register with Immediate Rd \u2212 K Z, N, V, C, H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \u2190PC+k + 1 None 1 / 2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \u2190PC+k + 1 None 1 / 2\nBREQ  k Branch if Equal if (Z = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRCS  k Branch if Carry Set if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLO  k Branch if Lower if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRMI  k Branch if Minus if (N = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRPL  k Branch if Plus if (N = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRGE  k Branch if Greater or Equal, Signed if (N \u2295 V= 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLT  k Branch if Less Than Zero, Signed if (N \u2295 V= 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \u2190 PC + k  + 1 None 1 / 2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \u2190 PC + k + 1 None 1 / 2\n\n283\n2486Z\u2013AVR\u201302/11ATmega8(L)\nMnemonics Operands Description Operation Flags #Clocks\nBRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \u2190 PC + k + 1 None 1 / 2\nDATA TRANSFER INSTRUCTIONS\nMOV Rd, Rr Move Between Registers Rd \u2190 Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \u2190 Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \u2190 KN o n e 1\nLD Rd, X Load Indirect Rd \u2190 (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \u2190 (X), X \u2190 X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \u2190 X - 1, Rd \u2190 (X) None 2\nLD Rd, Y Load Indirect Rd \u2190 (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \u2190 (Y), Y \u2190 Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \u2190 Y - 1, Rd \u2190 (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \u2190 (Y + q) None 2\nLD Rd, Z Load Indirect Rd \u2190 (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \u2190 (Z), Z \u2190 Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \u2190 Z - 1, Rd \u2190 (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \u2190 (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \u2190 (k) None 2\nST X, Rr Store Indirect (X)  \u2190 Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X)  \u2190 Rr, X \u2190 X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \u2190 X - 1, (X) \u2190 Rr None 2\nST Y, Rr Store Indirect (Y) \u2190 Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \u2190 Rr, Y \u2190 Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \u2190 Y - 1, (Y) \u2190 Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \u2190 Rr None 2\nST Z, Rr Store Indirect (Z) \u2190 Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \u2190 Rr, Z \u2190 Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \u2190 Z - 1, (Z) \u2190 Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \u2190 Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \u2190 Rr None 2\nLPM Load Program Memory R0 \u2190 (Z) None 3\nLPM Rd, Z Load Program Memory Rd \u2190 (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \u2190 (Z), Z \u2190 Z+1 None 3\nSPM Store Program Memory (Z) \u2190 R1:R0 None -\nIN Rd, P In Port Rd \u2190 PN o n e 1\nOUT P, Rr Out Port P \u2190 Rr None 1\nPUSH Rr Push Register on Stack STACK \u2190 Rr None 2\nPOP Rd Pop Register from Stack Rd \u2190 STACK None 2\nBIT AND BIT-TEST INSTRUCTIONSSBI P,b Set Bit in I/O Register I/O(P,b) \u2190 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \u2190 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \u2190 Rd(n), Rd(0) \u2190 0 Z, C, N, V 1\nLSR Rd Logical Shift Right Rd(n) \u2190 Rd(n+1), Rd(7) \u2190 0 Z, C, N, V 1\nROL Rd Rotate Left Through Carry Rd(0) \u2190C,Rd(n+1) \u2190 Rd(n),C \u2190Rd(7) Z, C, N, V 1\nROR Rd Rotate Right Through Carry Rd(7) \u2190C,Rd(n) \u2190 Rd(n+1),C \u2190Rd(0) Z, C, N, V 1\nASR Rd Arithmetic Shift Right Rd(n) \u2190 Rd(n+1), n=0..6 Z, C, N, V 1\nSWAP Rd Swap Nibbles Rd(3..0) \u2190Rd(7..4),Rd(7..4) \u2190Rd(3..0) None 1\nBSET s Flag Set SREG(s) \u2190 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \u2190 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \u2190 Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \u2190 TN o n e 1\nSEC Set Carry C \u2190 1C 1\nCLC Clear Carry C \u2190 0 C 1\nSEN Set Negative Flag N \u2190 1N 1\nCLN Clear Negative Flag N \u2190 0 N 1\nSEZ Set Zero Flag Z \u2190 1Z 1\nCLZ Clear Zero Flag Z \u2190 0 Z 1\nSEI Global Interrupt Enable I \u2190 1I 1\nCLI Global Interrupt Disable I  \u2190 0 I 1\nSES Set Signed Test Flag S \u2190 1S 1\nCLS Clear Signed Test Flag S \u2190 0 S 1\nSEV Set Twos Complement Overflow. V \u2190 1V 1\nCLV Clear Twos Complement Overflow V \u2190 0 V 1\nSET Set T in SREG T \u2190 1T 1Instruction Set Summary  (Continued)\n\n284\n2486Z\u2013AVR\u201302/11ATmega8(L)Mnemonics Operands Description Operation Flags #Clocks\nCLT Clear T in SREG T \u2190 0 T 1\nSEH Set Half Carry Flag in SREG H \u2190 1H 1\nCLH Clear Half Carry Flag in SREG H \u2190 0 H 1\nMCU CONTROL INSTRUCTIONS\nNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1\nWDR Watchdog Reset (see specific  descr. for WDR/timer) None 1Instruction Set Summary  (Continued)\n\n285\n2486Z\u2013AVR\u201302/11ATmega8(L)\nOrdering Information\nNotes: 1. This device can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering info rmation\nand minimum quantities\n2. Pb-free packaging complies to the European Directive for Re striction of Hazardous Substances (RoHS directive). Also\nHalide free and fully Green\n3. Tape & ReelSpeed (MHz) Power Supply (V) Ordering Code(2)Package(1)Operation Range\n8 2.7 - 5.5ATmega8L-8AU\nATmega8L-8AUR(3)\nATmega8L-8PU\nATmega8L-8MU\nATmega8L-8MUR(3)32A32A28P3\n32M1-A\n32M1-A Industrial\n(-40\n\u00b0C to 85 \u00b0C)\n16 4.5 - 5.5ATmega8-16AU\nATmega8-16AUR(3)\nATmega8-16PU\nATmega8-16MU\nATmega8-16MUR(3)32A32A\n28P332M1-A\n32M1-A\nPackage Type\n32A 32-lead, Thin (1.0mm) Plastic Quad Flat Package (TQFP)\n28P3 28-lead, 0.300\u201d Wide, Plastic Dual Inline Package (PDIP)\n32M1-A 32-pad, 5 \u00d7 5 \u00d7 1.0 body, Lead Pitch 0.50mm Quad  Flat No-Lead/Micro Lead Frame Package (QFN/MLF)\n\n286\n2486Z\u2013AVR\u201302/11ATmega8(L)Packaging Information\n32A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n32A, 32-lead, 7 x 7 mm Body Size, 1.0 mm Body Thickne ss,\n0.8 mm Le ad Pitch, Thin Profile Pl astic Quad Flat Package (TQFP) C 32A2010-10-20PIN 1 IDENTIFIER\n0\u00b0~7\u00b0PIN 1 \nLC\nA1 A2 AD1\nDeE1 EB\nNote s:\n 1. Thi s package conform s to JEDEC reference M S-026, V ariation ABA. \n 2. Dimen sions D1 and E1 do not incl ude mold protr usion.  Allow able \n  protr usion is 0.25 mm per side. Dimen sions D1 and E1 are maximum \n  p l astic body size dimen sions including mold mi smatch.\n 3. Lead copl anarity is 0.10 mm m aximum. A \u2013 \u2013 1.20\n A1 0.05 \u2013 0.15 A2  0.95 1.00 1.05            D 8.75 9.00 9.25\n D1 6.90 7.00 7.10 Note 2 E 8.75 9.00 9.25\n E1 6.90 7.00 7.10 Note 2 B           0. 30 \u2013 0.45\n C 0.09 \u2013 0.20 L 0.45 \u2013  0.75 e  0. 80 TYPCOMMON DIMEN SIONS\n(Unit of Me asu\nre = mm)\nSYMBOL MIN NOM MAX NOTE\n\n287\n2486Z\u2013AVR\u201302/11ATmega8(L)\n28P3\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n28P3 , 28-lead (0.300\"/7.62 mm Wide) Plastic Dual \nInline Package (PDIP)  B 28P309/28/01PIN\n1\nE1\nA1\nB\nREFEB1\nCLSEATING PLANEA\n0\u00ba ~ 15\u00ba  D\ne\neBB2\n(4 PLACES)\nCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nA \u2013 \u2013 4.5724\nA1 0.508 \u2013 \u2013D 34.544 \u2013          34.798    Note 1E 7.620 \u2013  8.255E1  7.112 \u2013  7.493 Note 1B 0.381 \u2013 0.533B1 1.143 \u2013 1.397B2 0.762 \u2013 1.143L 3.175 \u2013 3.429C 0.203 \u2013 0.356eB \u2013 \u2013 10.160\n  e                             2.540 TYP Note: 1. Dimensions D and E1 do not include mold Flash or Protrusion.\nMold Flash or Protrusion shall not exceed 0.25 mm (0.010\"). \n\n288\n2486Z\u2013AVR\u201302/11ATmega8(L)32M1-A\n  2325 Orch ard Parkway\n  San Jose, CA  951 31TITLE DRAWING NO.\nRREV.  \n32M1-A , 32-pad, 5 x 5 x 1.0 mm Body, Le ad Pitch 0.50 mm, E 32M1-A5/25/06\n 3.10 mm Expo sed Pad, Micro Le ad Frame P ackage (MLF) COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTED1D\nE1 E\ne bA3\nA2\nA1\n A\nD2\nE20.08C\nL1\n2\n3P\nP01\n2\n3\n A 0. 80 0.90 1.00\n A1 \u2013 0.02 0.05\n A2 \u2013 0.65 1.00\n A3  0.20 REF\n b 0.1 8 0.23 0.30\n D  \n D1  \n D2 2.95 3.10 3.25\n4.90 5.00 5.104.70 4.75 4. 80\n4.70 4.75 4. 804.90 5.00 5.10\nE\n E1  E2 2.95 3.10 3.25\n e  0.50 B SC\n  L 0. 30 0.40 0.50\n  P \u2013 \u2013 0.60    \u2013 \u2013 12o \nNote:  JEDEC Standard MO-220, Fig. 2 (Anvil Singulation), VHHD-2. TOP VIEWSIDE VIEW\nBOTTOM VIEW\n0Pin 1 ID\nPin #1 Notch\n(0.20 R)\nK 0.20 \u2013 \u2013KK\n\n289\n2486Z\u2013AVR\u201302/11ATmega8(L)\nErrata The revision letter in this section refers to the revision of the ATmega8 device.\nATmega8 \nRev. D to I, M\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081Signature may be Erased in  Serial Programming Mode\n\u0081CKOPT Does not Enable Internal Capacitors on XTALn/TOSCn Pins  when 32KHz Oscillator is \nUsed to Clock the Asyn chronous Timer/Counter2\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix / WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. Signature may be Erased in Serial Programming Mode\nIf the signature bytes are read before a chiperase command is completed, the signature may\nbe erased causing the device ID and calibration bytes to disappear. This is critical, espe-cially, if the part is runni ng on internal RC oscillator.\nProblem Fix / Workaround:Ensure that the chiperase command has exceeded before applying the next command.\n4. CKOPT Does not Enable Internal Capacitors on XTALn/TOSCn Pins when 32KHz\nOscillator is Used to Clock the Asynchronous Timer/Counter2\nWhen the internal RC Oscillator is used as the main clock source, it is possible to run the\nTimer/Counter2 asyn chronously by connecti ng a 32KHz Oscillator between XTAL1/TOSC1\nand XTAL2/TOSC2. But when th e internal RC Oscillator is selected as the main clock\nsource, the CKOPT Fuse does not control the internal capacitors on XTAL1/TOSC1 and\nXTAL2/TOSC2. As long as there are no ca pacitors connected to XTAL1/TOSC1 and\nXTAL2/TOSC2, safe o peration of the Oscilla tor is not guaranteed.\nProblem Fix / WorkaroundUse external capacitors in the range of 20pF - 36pF on XTAL1/TOSC1 and XTAL2/TOSC2.\nThis will be fixed in ATmega8 Re v. G where the CKOPT Fuse will  control internal capacitors\nalso when internal RC Oscillator is selected as main clock source. For ATmega8 Rev. G,CKOPT = 0 (programmed) will enable the internal capacitors on XTAL1 and XTAL2. Cus-tomers who want compatibility between Rev. G and older revisions, must ensure thatCKOPT is unprogrammed (CKOPT = 1).\n\n290\n2486Z\u2013AVR\u201302/11ATmega8(L)5. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\n\n291\n2486Z\u2013AVR\u201302/11ATmega8(L)\nDatasheet \nRevision \nHistoryPlease note that the referring page numbers in th is section are referred to this document. The\nreferring revision in this  section are referring to  the document revision.\nChanges from Rev. \n2486Y- 10/10 to \nRev. 2486Z- 02/111. Updated the datasheet according to the Atmel new Brand Style Guide.\n2. Updated \u201cOrdering Information\u201d on page 285 . Added Ording Information for\n\u201cTape&Reel\u201d devices\nChanges from Rev. \n2486X- 06/10 to Rev. 2486Y- 10/101. Max Rise/Fall time in Table 102 on page 239  has been corrected from 1.6ns to 1600ns.\n2. Note is added to \u201cPerforming Page Erase by SPM\u201d on page 209 .\n3. Updated/corrected several short-cuts and added some new ones.4. Updated last page according to new standard.\nChanges from Rev. \n2486W- 02/10 to \nRev. 2486X- 06/101. Updated \u201cDC Characteristics\u201d on page 235  with new VOL maximum value (0.9V and\n0.6V).\nChanges from Rev. \n2486V- 05/09 to Rev. 2486W- 02/101. Updated \u201cADC Characteristics\u201d on page 241  with VINT maximum value (2.9V).\nChanges from Rev. \n2486U- 08/08 to \nRev. 2486V- 05/091. Updated \u201cErrata\u201d on page 289 .\n2. Updated the last page with Atmel\u2019s new adresses.\nChanges from Rev. \n2486T- 05/08 to Rev. 2486U- 08/081. Updated \u201cDC Characteristics\u201d on page 235  with ICC typical values.\nChanges from Rev. \n2486S- 08/07 to \nRev. 2486T- 05/081. Updated Table 98 on page 233 .\n2. Updated \u201cOrdering Information\u201d on page 285 .\n- Commercial Ordering Code removed.- No Pb-free packaging option removed.\n\n292\n2486Z\u2013AVR\u201302/11ATmega8(L)Changes from Rev. \n2486R- 07/07 to \nRev. 2486S- 08/071. Updated \u201cFeatures\u201d on page 1 .\n2. Added \u201cData Retention\u201d on page 7 .\n3. Updated \u201cErrata\u201d on page 289 .\n4. Updated \u201cSlave Mode\u201d on page 125 .\nChanges from Rev. \n2486Q- 10/06 to Rev. 2486R- 07/071. Added text to Table 81 on page 211 .\n2. Fixed typo in \u201cPeripheral Features\u201d on page 1 .\n3. Updated Table 16 on page 42 .\n4. Updated Table 75 on page 199 .\n5. Removed redundancy and updated typo in Notes section of \u201cDC Characteristics\u201d on\npage 235 .\nChanges from Rev. \n2486P- 02/06 to \nRev. 2486Q- 10/061. Updated \u201cTimer/Counter Oscillator\u201d on page 32 .\n2. Updated \u201cFast PWM Mode\u201d on page 88 .\n3. Updated code example in \u201cUSART Initialization\u201d on page 134 .\n4. Updated Table 37 on page 96 , Table 39 on page 97 , Table 42 on page 115 , Table 44 on\npage 115 , and Table 98 on page 233 .\n5. Updated \u201cErrata\u201d on page 289 .\nChanges from Rev. \n2486O-10/04 to \nRev. 2486P- 02/061. Added \u201cResources\u201d on page 7 .\n2. Updated \u201cExternal Clock\u201d on page 32 .\n3. Updated \u201cSerial Peripheral Interface \u2013 SPI\u201d on page 121 .\n4. Updated Code Example in \u201cUSART Initialization\u201d on page 134 .\n5. Updated Note in \u201cBit Rate Generator Unit\u201d on page 164 .\n6. Updated Table 98 on page 233 .\n7. Updated Note in Table 103 on page 241 .\n8. Updated \u201cErrata\u201d on page 289 .\nChanges from Rev. \n2486N-09/04 to Rev. 2486O-10/041. Removed to instances of \u201canalog ground\u201d. Replaced by \u201cground\u201d.\n2. Updated Table 7 on page 29 , Table 15 on page 38 , and Table 100 on page 237 .\n3. Updated \u201cCalibrated Internal RC Oscillator\u201d on page 30  with the 1MHz default value.\n\n293\n2486Z\u2013AVR\u201302/11ATmega8(L)\n4.Table 89 on page 218  and Table 90 on page 218  moved to new section \u201cPage Size\u201d on\npage 218 .\n5. Updated descripton for bit 4 in \u201cStore Program Memory Control Register \u2013 SPMCR\u201d\non page 206 .\n6. Updated \u201cOrdering Information\u201d on page 285 .\nChanges from Rev. \n2486M-12/03 to Rev. 2486N-09/041. Added note to MLF package in \u201cPin Configurations\u201d on page 2 .\n2. Updated \u201cInternal Voltage Reference Characteristics\u201d on page 42 .\n3. Updated \u201cDC Characteristics\u201d on page 235 .\n4. ADC4 and ADC5 support 10-bit accuracy. Document updated to reflect this.\nUpdated features in \u201cAnalog-to-Digital Converter\u201d on page 189 . \nUpdated \u201cADC Characteristics\u201d on page 241 .\n5. Removed reference to \u201cExternal RC Oscillator application note\u201d from \u201cExternal RC\nOscillator\u201d on page 28 .\nChanges from Rev. \n2486L-10/03 to \nRev. 2486M-12/031. Updated \u201cCalibrated Internal RC Oscillator\u201d on page 30 .\nChanges from Rev. \n2486K-08/03 to Rev. 2486L-10/031. Removed \u201cPreliminary\u201d and TBDs from the datasheet.\n2. Renamed ICP to ICP1 in the datasheet.3. Removed instructions CALL and JMP from the datasheet.4. Updated t\nRST in Table 15 on page 38 , VBG in Table 16 on page 42 , Table 100 on page\n237 and Table 102 on page 239 .\n5. Replaced text \u201cXTAL1 and XTAL2 should be left unconnected (NC)\u201d after Table 9  in\n\u201cCalibrated Internal RC Oscillator\u201d on page 30 . Added text regarding XTAL1/XTAL2\nand CKOPT Fuse in \u201cTimer/Counter Oscillator\u201d on page 32 .\n6. Updated Watchdog Timer code examples in \u201cTimed Sequences for Changing the\nConfiguration of the Watchdog Timer\u201d on page 45 .\n7. Removed bit 4, ADHSM, from \u201cSpecial Function IO Register \u2013 SFIOR\u201d on page 58 .\n8. Added note 2 to Figure 103 on page 208 .\n9. Updated item 4 in the \u201cSerial Programming Algorithm\u201d on page 231 .\n10. Added tWD_FUSE  to Table 97 on page 232  and updated Read Calibration Byte, Byte 3, in\nTable 98 on page 233 .\n11. Updated Absolute Maximum Ratings* and DC Characteristics in \u201cElectrical Character-\nistics\u201d on page 235 .\n\n294\n2486Z\u2013AVR\u201302/11ATmega8(L)Changes from Rev. \n2486J-02/03 to \nRev. 2486K-08/031. Updated VBOT values in Table 15 on page 38 .\n2. Updated \u201cADC Characteristics\u201d on page 241 .\n3. Updated \u201cATmega8 Typical Characteristics\u201d on page 242 .\n4. Updated \u201cErrata\u201d on page 289 .\nChanges from Rev. \n2486I-12/02 to Rev. 2486J-02/031. Improved the description of \u201cAsynchronous Timer Clock \u2013 clkASY\u201d on page 26 .\n2. Removed reference to the \u201cMultipurpose Oscillator\u201d application note and the \u201c32kHz\nCrystal Oscillator\u201d application note, which do not exist.\n3. Corrected OCn waveforms in Figure 38 on page 89 .\n4. Various minor Timer 1 corrections.5. Various minor TWI corrections. 6. Added note under \u201cFilling the Temporary Buffer (Page Loading)\u201d on page 209  about\nwriting to the EEPROM during an SPM Page load.\n7. Removed ADHSM completely.8. Added section \u201cEEPROM Write during Power-down Sleep Mode\u201d on page 23 .\n9. Removed XTAL1 and XTAL2 description on page 5  because they were already\ndescribed as part of \u201cPort B (PB7..PB0) XTAL1/XTAL2/TOSC1/TOSC2\u201d on page 5 .\n10. Improved the table under \u201cSPI Timing Characteristics\u201d on page 239  and removed the\ntable under \u201cSPI Serial Programming Characteristics\u201d on page 234 .\n11. Corrected PC6 in \u201cAlternate Functions of Port C\u201d on page 61 .\n12. Corrected PB6 and PB7 in \u201cAlternate Functions of Port B\u201d on page 58 .\n13. Corrected 230.4 Mbps to 230.4 kbps under \u201cExamples of Baud Rate Setting\u201d on page\n153.\n14. Added information about PWM symmetry for Timer 2 in \u201cPhase Correct PWM Mode\u201d\non page 111 .\n15. Added thick lines around accessible registers in Figure 76 on page 163 .\n16. Changed \u201cwill be ignored\u201d to \u201cmust be written to zero\u201d for unused Z-pointer bits\nunder \u201cPerforming a Page Write\u201d on page 209 .\n17. Added note for RSTDISBL Fuse in Table 87 on page 216 .\n18. Updated drawings in \u201cPackaging Information\u201d on page 286 .\n\n295\n2486Z\u2013AVR\u201302/11ATmega8(L)\nChanges from Rev. \n2486H-09/02 to \nRev. 2486I-12/021. Added errata for Rev D, E, and F on page 289 .\nChanges from Rev. \n2486G-09/02 to \nRev. 2486H-09/021. Changed the Endurance on the Flash to 10,000 Write/Erase Cycles.\nChanges from Rev. 2486F-07/02 to \nRev. 2486G-09/021. Updated Table 103, \u201cADC Characteristics,\u201d on page 241 .\nChanges from Rev. \n2486E-06/02 to \nRev. 2486F-07/021. Changes in \u201cDigital Input Enable and Sleep Modes\u201d on page 55 .\n2. Addition of OCS2 in \u201cMOSI/OC2 \u2013 Port B, Bit 3\u201d on page 59 .\n3. The following tables have been updated:\nTable 51, \u201cCPOL and CPHA Functionality,\u201d on page 127 , Table 59, \u201cUCPOL Bit Settings,\u201d\non page 152 , Table 72, \u201cAnalog Comparator Multiplexed Input(1),\u201d on page 188 , Table 73,\n\u201cADC Conversion Time,\u201d on page 193 , Table 75, \u201cInput Channel Selections,\u201d on page 199 ,\nand Table 84, \u201cExplanation of Different Variables used in Figure 103 on page 208 and the\nMapping to the Z-pointer,\u201d on page 214 .\n4. Changes in \u201cReading the Calibration Byte\u201d on page 227 .\n5. Corrected Errors in Cross References.\nChanges from Rev. \n2486D-03/02 to \nRev. 2486E-06/021. Updated Some Preliminary Test Limits and Characterization Data\nThe following tables have been updated:Table 15, \u201cReset Characteristics,\u201d on page 38 , Table 16, \u201cInternal Voltage Reference Char-\nacteristics,\u201d on page 42 , DC Characteristics on page 235 , Table , \u201cADC Characteristics,\u201d on\npage 241 .\n2. Changes in External Clock Frequency\nAdded the description at the end of \u201cExternal Clock\u201d on page 32 .\nAdded period changing data in Table 99, \u201cExternal Clock Drive,\u201d on page 237 .\n3. Updated TWI Chapter\nMore details regarding use of the TWI bit rate prescaler and a Table 65, \u201cTWI Bit Rate Pres-\ncaler,\u201d on page 167 .\nChanges from Rev. \n2486C-03/02 to Rev. 2486D-03/021. Updated Typical Start-up Times.\nThe following tables has been updated:Table 5, \u201cStart-up Times for the Crysta l Oscillator Clock Selection,\u201d on page 28 , Table 6,\n\u201cStart-up Times for the Low-frequency Crystal Oscillator Clock Selection,\u201d on page 28 ,\nTable 8, \u201cStart-up Times for the External RC Oscillator Clock Selection,\u201d on page 29 , and\nTable 12, \u201cStart-up Times for the External Clock Selection,\u201d on page 32 .\n2. Added \u201cATmega8 Typical Characteristics\u201d on page 242 .\n\n296\n2486Z\u2013AVR\u201302/11ATmega8(L)Changes from Rev. \n2486B-12/01 to \nRev. 2486C-03/021. Updated TWI Chapter.\nMore details regarding use of the TWI Powe r-down operation and using the TWI as Master\nwith low TWBRR values are added into the datasheet.\nAdded the note at the end of the \u201cBit Rate Generator Unit\u201d on page 164 .\nAdded the description at the end of \u201cAddress Match Unit\u201d on page 164 .\n2. Updated Description of OSCCAL Calibration Byte.\nIn the datasheet, it was not explained how to take advantage of the calibration bytes for 2, 4,\nand 8MHz Oscillator selections. This is  now added in the following sections:\nImproved description of \u201cOscillator Calibration Regi ster \u2013 OSCCAL\u201d on page 31  and \u201cCali-\nbration Byte\u201d on page 218 .\n3. Added Some Preliminary Test Li mits and Characterization Data.\nRemoved some of the TBD\u2019s in the following tables and pages:\nTable 3 on page 26 , Table 15 on page 38 , Table 16 on page 42 , Table 17 on page 44 , \u201cTA =\n-40\u00b0C to +85\u00b0C, VCC = 2.7V to 5.5V (unless otherwise noted)\u201d on page 235 , Table 99 on\npage 237 , and Table 102 on page 239 .\n4. Updated Programming Figures.\nFigure 104 on page 219  and Figure 112 on page 230  are updated to also reflect that AVCC\nmust be connected during Programming mode.\n5. Added a Description on how to Enter Parallel Programming  Mode if RESET Pin is Dis-\nabled or if External Oscillators are Selected.\nAdded a note in section \u201cEnter Programming Mode\u201d on page 221 .\n\ni\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTable of Contents\nFeatures 1\nPin Configurations 2\nOverview 3\nBlock Diagram 3\nDisclaimer 4Pin Descriptions 5\nResources 7\nData Retention 7\nAbout Code Examples 8\nAtmel AVR CPU Core  9\nIntroduction 9\nArchitectural Overview 9\nArithmetic Logic Unit \u2013 ALU 11Status Register 11\nGeneral Purpose Register File 12\nStack Pointer 13Instruction Execution Timing 13\nReset and Interrupt Handling 14\nAVR ATmega8 Memories 17\nIn-System Reprogrammable Flash Program Memory 17\nSRAM Data Memory 18\nData Memory Access Times 19\nEEPROM Data Memory 19I/O Memory 24\nSystem Clock and Clock Options 25\nClock Systems and their Distribution 25\nClock Sources 26\nCrystal Oscillator 27Low-frequency Crys tal Oscillator 28\nExternal RC Oscillator 28\nCalibrated Internal RC Oscillator 30External Clock 32\nTimer/Counter Oscillator 32\nPower Management and Sleep Modes 33\nIdle Mode 34\n\nii\n2486Z\u2013AVR\u201302/11ATmega8(L)ADC Noise Reduction Mode 34\nPower-down Mode 34\nPower-save Mode 34\nStandby Mode 35Minimizing Power Consumption 35\nSystem Control and Reset 37\nInternal Voltage Reference 42\nWatchdog Timer 43\nTimed Sequences for Changing the Configuration of the Watchdog Timer 45\nInterrupts 46\nInterrupt Vectors in ATmega8 46\nI/O Ports 51\nIntroduction 51Ports as Genera l Digital I/O 52\nAlternate Port Functions 56\nRegister Description for I/O Ports 65\nExternal Interrupts 66\n8-bit Timer/Counter0 69\nOverview 69\nTimer/Counter Clock Sources 70Counter Unit 70\nOperation 70\nTimer/Counter Timing Diagrams 708-bit Timer/Counter Register Description 71\nTimer/Counter0 and Time r/Counter1 Prescalers 73\n16-bit Timer/Counter1 75\nOverview 75\nAccessing 16-bit Registers 77\nTimer/Counter Clock Sources 80Counter Unit 80\nInput Capture Unit 81\nOutput Compare Units 83Compare Match Output Unit 85\nModes of Operation 87\nTimer/Counter Timing Diagrams 9416-bit Timer/Counter Re gister Description 96\n8-bit Timer/Counter2 with PWM and Asynchronous Operation 102\nOverview 102\n\niii\n2486Z\u2013AVR\u201302/11ATmega8(L)\nTimer/Counter Clock Sources 103\nCounter Unit 104\nOutput Compare Unit 105\nCompare Match Output Unit 107Modes of Operation 108\nTimer/Counter Timing Diagrams 112\n8-bit Timer/Counter Register Description 114Asynchronous Operation of the Timer/Counter 117\nTimer/Counter Prescaler 120\nSerial Peripheral Interface \u2013 SPI 121\nSS Pin Functionality 125\nData Modes 127\nUSART 129\nOverview 129Clock Generation 130\nFrame Formats 133\nUSART Initialization 134Data Transmission \u2013 The USART Transmitter 136\nData Reception \u2013 The USART Receiver 138\nAsynchronous Data Reception 142Multi-processor Communication Mode 145\nAccessing UBRRH/UCSRC Registers 146\nUSART Register Description 148Examples of Baud Rate Setting 153\nTwo-wire Serial Interface 157\nFeatures 157\nTwo-wire Serial Interface Bus Definition 157\nData Transfer and Frame Format 158\nMulti-master Bus Systems, Arbitration and Synchronization 161\nOverview of the TWI Module 163TWI Register Description 165\nUsing the TWI 168\nTransmission Modes 171Multi-master Systems and Arbitration 184\nAnalog Comparator 186\nAnalog Comparator Multiplexed Input 188\nAnalog-to-Digital Converter 189\nFeatures 189\nStarting a Conversion 191\nPrescaling and Conversion Timing 191Changing Channel or Reference Selection 194\n\niv\n2486Z\u2013AVR\u201302/11ATmega8(L)ADC Noise Canceler 195\nADC Conversion Result 199\nBoot Loader Support \u2013 Read-While -Write Self-Programming 202\nBoot Loader Features 202\nApplication and Boot Loader Flash Sections 202\nRead-While-Write and No Read-W hile-Write Flash Sections 202\nBoot Loader Lock Bits 204\nEntering the Boot Loader Program 205\nAddressing the Flash During Self-Programming 207Self-Programming the Flash 208\nMemory Programming 215\nProgram And Data Memory Lock Bits 215\nFuse Bits 216\nSignature Bytes 218Calibration Byte 218\nPage Size 218\nParallel Programming Parameters, Pin Mapping, and Commands 219Parallel Programming 221\nSerial Downloading 230\nSerial Programming Pin Mapping 230\nElectrical Characteristics 235\nAbsolute Maximum Ratings* 235DC Characteristics 235\nExternal Clock Drive Waveforms 237\nExternal Clock Drive 237Two-wire Serial Interface Characteristics 238\nSPI Timing Characteristics 239\nADC Characteristics 241\nATmega8 Typical Characteristics 242\nRegister Summary 280\nInstruction Set Summary 282Ordering Information 285\nPackaging Information 286\n32A 286\n28P3 287\n32M1-A 288\nErrata 289\n\nv\n2486Z\u2013AVR\u201302/11ATmega8(L)\nATmega8 \nRev. D to I, M 289\nDatasheet Revision History 291\nChanges from Rev. 2486Y- 10/10 to Rev. 2486Z- 02/11 291\nChanges from Rev. 2486X- 06/10 to Rev. 2486Y- 10/10 291\nChanges from Rev. 2486W- 02/10 to Rev. 2486X- 06/10 291\nChanges from Rev. 2486V- 05/09 to Rev. 2486W- 02/10 291Changes from Rev. 2486U- 08/08 to Rev. 2486V- 05/09 291\nChanges from Rev. 2486T- 05/08 to Rev. 2486U- 08/08 291\nChanges from Rev. 2486S- 08/07 to Rev. 2486T- 05/08 291Changes from Rev. 2486R- 07/07 to Rev. 2486S- 08/07 292\nChanges from Rev. 2486Q- 10/06 to Rev. 2486R- 07/07 292\nChanges from Rev. 2486P- 02/06 to Rev. 2486Q- 10/06 292Changes from Rev. 2486O-10/04 to Rev. 2486P- 02/06 292\nChanges from Rev. 2486N-09/04 to Rev. 2486O-10/04 292\nChanges from Rev. 2486M-12/03 to Rev. 2486N-09/04 293Changes from Rev. 2486L-10/03 to Rev. 2486M-12/03 293\nChanges from Rev. 2486K-08/03 to Rev. 2486L-10/03 293\nChanges from Rev. 2486J-02/03 to Rev. 2486K-08/03 294Changes from Rev. 2486I-12/02 to Rev. 2486J-02/03 294\nChanges from Rev. 2486H-09/02 to Rev. 2486I-12/02 295\nChanges from Rev. 2486G-09/02 to Rev. 2486H-09/02 295Changes from Rev. 2486F-07/02 to Rev. 2486G-09/02 295\nChanges from Rev. 2486E-06/02 to Rev. 2486F-07/02 295\nChanges from Rev. 2486D-03/02 to Rev. 2486E-06/02 295Changes from Rev. 2486C-03/02 to Rev. 2486D-03/02 295\nChanges from Rev. 2486B-12/01 to Rev. 2486C-03/02 296\nTable of Contents i\n\n2486Z\u2013AVR\u201302/11Atmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel:  (+1)(408) 441-0311\nFax: (+1)(408) 487-2600 \nwww.atmel.comAtmel Asia Limited\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHONG KONG\nTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4\nD-85748 Garching b. MunichGERMANY\nTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033JAPAN\nTel: (+81)(3) 3523-3551\nFax: (+81)(3) 3523-7581\n\u00a9 2011 Atmel Corporation. All rights reserved. / Rev. CORP0XXXX\nAtmel\n\u00ae, Atmel logo and combinations thereof, AVR\u00ae and others are registered trademarks or trademarks of Atmel Corporation or its \nsubsidiaries. Other terms and product names may be trademarks of others.\nDisclaimer:  The information in this document is provided in connection wi th Atmel products. No license, ex press or implied, by estoppel or  otherwise, to \nany intellectual property right is granted by this document or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN THE ATMEL \nTERMS AND CONDITIONS OF SALES LOCATED ON THE ATMEL WEBSITE,  ATMEL ASSUMES NO LIABILITY WHATSOEVER AND DISCLAIMS ANY \nEXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRO DUCTS INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURP OSE, OR NON-INFRINGEMENT. IN NO EVEN T SHALL ATMEL BE LIABLE FOR ANY DIRECT, \nINDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDENTAL DAMAGES (INCLUDING, WITHOUT LIMITATI ON, DAMAGES FOR LOSS AND PROF-\nITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF THE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATMEL \nHAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no representations or warranties with respect to the accuracy or com-\npleteness of the contents of th is document and reserves the right to make changes  to specifications and product descriptions at  any time without notice. \nAtmel does not make any commitment to update the information cont ained herein. Unless specifically  provided otherwise, Atmel pr oducts are not suit-\nable for, and shall not be used in, automotive applications. Atme l products are not intended, authorized, or warranted for use as components in applica-\ntions intended to support or sustain life.", "ATMEGA16.pdf": "Features\n\u2022High-performance, Low-power Atmel\u00ae AVR\u00ae 8-bit Microcontroller\n\u0081Advanced RISC Architecture\n\u2013 131 Powerful Instructions \u2013 Most  Single-clock Cycle Execution\n\u2013 32 \u00d7 8 General Purpose Working Registers\u2013 Fully Static Operation\n\u2013 Up to 16 MIPS Throughput at 16 MHz\n\u2013 On-chip 2-cycle Multiplier\n\u0081High Endurance Non-volatile Memory segments\n\u2013 16 Kbytes of In-System Self-pro grammable Flash program memory\n\u2013 512 Bytes EEPROM\n\u2013 1 Kbyte Internal SRAM\n\u2013 Write/Erase Cycles: 10,000 Flash/1 00,000 EEPROM\n\u2013 Data retention: 20 years at 85\u00b0C/100 years at 25\u00b0C(1)\n\u2013 Optional Boot Code Section with Independent Lock Bits\nIn-System Programming by On-chip Boot Program\nTrue Read-While-W rite Operation\n\u2013 Programming Lock for Software Security\n\u0081JTAG (IEEE std. 1149.1 Compliant) Interface\n\u2013 Boundary-scan Capabilities A ccording to the JTAG Standard\n\u2013 Extensive On-chip Debug Support\n\u2013 Programming of Flash, EEPROM, Fuses, an d Lock Bits through the JTAG Interface\n\u0081Peripheral Features\n\u2013 Two 8-bit Timer/Counters with Se parate Prescalers and Compare Modes\n\u2013 One 16-bit Timer/Counter with Separate Prescaler, Compare Mode, and Capture \nMode\n\u2013 Real Time Counter with Separate Oscillator\n\u2013 Four PWM Channels\u2013 8-channel, 10-bit ADC\n8 Single-ended Channels\n7 Differential Channels in TQFP Package Only2 Differential Channels with Prog rammable Gain at 1x, 10x, or 200x\n\u2013 Byte-oriented Two-wi re Serial Interface\n\u2013 Programmable Serial USART\u2013 Master/Slave SPI Serial Interface\n\u2013 Programmable Watchdog Timer with Separate On-chip Oscillator\n\u2013 On-chip Analog Comparator\n\u0081Special Microcontroller Features\n\u2013 Power-on Reset and Programmable Brown-out Detection\n\u2013 Internal Calibrated RC Oscillator\u2013 External and Internal Interrupt Sources\n\u2013 Six Sleep Modes: Idle, ADC Noise Reduction, Power-save, Power-down, Standby \nand Extended Standby\n\u0081I/O and Packages\n\u2013 32 Programmable I/O Lines\n\u2013 40-pin PDIP, 44-lead TQFP, and 44-pad QFN/MLF\n\u0081Operating Voltages\n\u2013 2.7V - 5.5V for ATmega16L\n\u2013 4.5V - 5.5V for ATmega16\n\u0081Speed Grades\n\u2013 0 - 8 MHz for ATmega16L\n\u2013 0 - 16 MHz for ATmega16\n\u0081Power Consumption @ 1 MHz, 3V, and 25 \u00b0C for ATmega16L\n\u2013 Active: 1.1 mA\u2013 Idle Mode: 0.35 mA\n\u2013 Power-down Mode: < 1 \u00b5A8-bit  \nMicrocontroller with 16K Bytes In-SystemProgrammable \nFlash\nATmega16\nATmega16L\nSummary\nRev. 2466TS\u2013AVR\u201307/10\n\n2\n2466TS\u2013AVR\u201307/10ATmega16(L)Pin \nConfigurationsFigure 1.  Pinout ATmega16\nDisclaimer Typical values contained in this datasheet ar e based on simulations and characterization of\nother AVR microcontrollers manufactured on the same process technology. Min and Max valueswill be available after the device is characterized.(XCK/T0)  PB0\n(T1)  PB1\n(INT2/AIN0)  PB2\n(OC0/AIN1)  PB3\n(SS)  PB4\n(MOSI)  PB5(MISO)  PB6\n(SCK)  PB7\nRESET\nVCC\nGND\nXTAL2XTAL1\n(RXD)  PD0\n(TXD)  PD1\n(INT0)  PD2(INT1)  PD3\n(OC1B)  PD4(OC1A)  PD5\n(ICP1)  PD6PA0  (ADC0)\nPA1  (ADC1)PA2  (ADC2)PA3  (ADC3)PA4  (ADC4)PA5  (ADC5)PA6  (ADC6)PA7  (ADC7)AREFGNDAVCCPC7  (TOSC2)PC6  (TOSC1)PC5  (TDI)PC4  (TDO)PC3  (TMS)PC2  (TCK)PC1  (SDA)PC0  (SCL)PD7  (OC2)\nPA4  (ADC4)PA5  (ADC5)PA6  (ADC6)PA7  (ADC7)AREFGNDAVCCPC7  (TOSC2)PC6  (TOSC1)PC5  (TDI)PC4  (TDO)(MOSI)  PB5\n(MISO)  PB6\n(SCK)  PB7\nRESET\nVCC\nGND\nXTAL2XTAL1\n(RXD)  PD0\n(TXD)  PD1\n(INT0)  PD2\n(INT1)  PD3\n(OC1B)  PD4(OC1A)  PD5\n(ICP1)  PD6\n(OC2)  PD7\nVCC\nGND\n(SCL)  PC0\n(SDA)  PC1\n(TCK)  PC2\n(TMS)  PC3PB4  (SS)\nPB3  (AIN1/OC0)PB2  (AIN0/INT2)PB1  (T1)PB0  (XCK/T0)GNDVCCPA0  (ADC0)PA1  (ADC1)PA2  (ADC2)PA3  (ADC3)PDIP\nTQFP/QFN/MLF\nNOTE: \nBottom pad should be soldered to ground.\n\n3\n2466TS\u2013AVR\u201307/10ATmega16(L)\nOverview The ATmega16 is a low-power CMOS 8-bit microcontroller based on the AVR enhanced RISC\narchitecture. By executing powerful instructi ons in a single clock cycle, the ATmega16 achieves\nthroughputs approaching 1 MIPS per MHz allowing the system designer to optimize power con-sumption versus processing speed.\nBlock Diagram Figure 2.  Block Diagram\nINTERNAL\nOSCILLATOROSCILLATOR\nWATCHDOG\nTIMER\nMCU CTRL.\n& TIMINGOSCILLATORTIMERS/\nCOUNTERS\nINTERRUPT\nUNITSTACK\nPOINTER\nEEPROMSRAM\nSTATUS\nREGISTER\nUSARTPROGRAM\nCOUNTER\nPROGRAM\nFLASH\nINSTRUCTION\nREGISTER\nINSTRUCTION\nDECODER\nPROGRAMMING\nLOGICSPIADC\nINTERFACE\nCOMP .\nINTERFACEPORTA DRIVERS/BUFFERS\nPORTA DIGITAL INTERFACE\nGENERAL\nPURPOSE\nREGISTERS\nX\nY\nZ\nALU\n+\n-PORTC DRIVERS/BUFFERS\nPORTC DIGITAL INTERFACE\nPORTB DIGITAL INTERFACE\nPORTB DRIVERS/BUFFERSPORTD DIGITAL INTERFACE\nPORTD DRIVERS/BUFFERSXTAL1\nXTAL2\nRESET\nCONTROL\nLINESVCC\nGND\nMUX &\nADC\nAREFPA0 - PA7 PC0 - PC7\nPD0 - PD7 PB0 - PB7AVR CPUTWIAVCC\nINTERNAL\nCALIBRATED\nOSCILLATOR\n\n4\n2466TS\u2013AVR\u201307/10ATmega16(L)The AVR core combines a rich instruction set with 32 general purpose working registers. All the\n32 registers are directly connected to the Arithmetic Logic Unit (ALU), allowing two independentregisters to be accessed in one single instruction executed  in one clock cycle. The resulting\narchitecture is more code efficient while achiev ing throughputs up to ten times faster than con-\nventional CISC microcontrollers.\nThe ATmega16 provides the following features: 16 Kbytes of In-System Programmable Flash\nProgram memory with Re ad-While-Write capabilities, 512 bytes EEPROM, 1 Kbyte SRAM, 32\ngeneral purpose I/O lines, 32 general purpose working registers, a JTAG interface for Boundary-scan, On-chip Debugging support and programming , three flexible Timer/Counters with com-\npare modes, Internal and External Interrupts , a serial programmable USART, a byte oriented\nTwo-wire Serial Interface, an 8-channel, 10-bi t ADC with optional differential input stage with\nprogrammable gain (TQFP package only), a programmable Watchdog Timer with Internal Oscil-lator, an SPI serial port, and six software selectable power saving modes. The Idle mode stopsthe CPU while allowing the USART,  Two-wire interface, A/D Converter, SRAM, Timer/Counters,\nSPI port, and interrupt system to continue functioning. The Power-down mode saves the registercontents but freezes the Oscillator,  disabling all other ch ip functions until the next External Inter-\nrupt or Hardware Reset. In Power-save mode, the Asynchronous Timer continues to run,allowing the user to maintain a timer base while the rest of the device is sleeping. The ADCNoise Reduction mode stops the CPU and all I /O modules except Asynchronous Timer and\nADC, to minimize switching noise during ADC conversions. In Standby mode, the crystal/reso-nator Oscillator is running while the rest of the dev ice is sleeping. This allows very fast start-up\ncombined with low-power consum ption. In Extended Standby mode,  both the main Oscillator\nand the Asynchronous Timer continue to run. \nThe device is manufactured using Atmel\u2019s high density nonvolatile memory technology. The On-\nchip ISP Flash allows the prog ram memory to be repr ogrammed in-system th rough an SPI serial\ninterface, by a conventional nonvolatile memory programmer, or by an On-chip Boot programrunning on the AVR core. The boot program can use any interface to download the application\nprogram in the Application Flash memory. Software in the Boot Flash section will continue to runwhile the Application Flash section is updated, providing true Read-While-Write operation. By\ncombining an 8-bit RISC CPU with In-System Self-Programmable Flash on a monolithic chip,the Atmel ATmega16 is a powerful microcontroller th at provides a highly-flexible and cost-effec-\ntive solution to many embedded control applications.\nThe ATmega16 AVR is supported with a full su ite of program and system development tools\nincluding: C compilers, macro assemblers, program debugger/simulators, in-circuit emulators,and evaluation kits.\nPin Descriptions\nVCC Digital supply voltage.\nGND Ground.\nPort A (PA7..PA0) Port A serves as the analog inputs to the A/D Converter.\nPort A also serves as an 8-bit bi-directional I/O por t, if the A/D Converter is not used. Port pins\ncan provide internal pull-up resistors (selected for each bit). The Port A output buffers have sym-metrical drive characteristics with both high sink and source capability. When pins PA0 to PA7are used as inputs and are externally pulled low, they will source current if the internal pull-upresistors are activated. The Port A pins are tri-stated when a reset condition becomes active,even if the clock is not running.\n\n5\n2466TS\u2013AVR\u201307/10ATmega16(L)\nPort B (PB7..PB0) Port B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort B output buffers have symmetrical drive characteristics with both high sink and source\ncapability. As inputs, Port B pi ns that are externally  pulled low will source current if the pull-up\nresistors are activated. The Port B pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort B also serves the functions of various special features of the ATmega16 as listed on page\n58.\nPort C (PC7..PC0) Port C is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort C output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port C pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port C pins are tri-stated when a reset condition becomes active,even if the clock is not running. If the JTAG interface is enabled, the pull-up resistors on pinsPC5(TDI), PC3(TMS) and PC 2(TCK) will be activated even if a reset occurs.\nPort C also serves the functions of the JTAG interface and other special features of the\nATmega16 as listed on page 61 .\nPort D (PD7..PD0) Port D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The\nPort D output buffers have symmetrical drive c haracteristics with bot h high sink and source\ncapability. As inputs, Port D pi ns that are externally pulled lo w will source current if the pull-up\nresistors are activated. The Port D pins are tri-stated when a reset condition becomes active,even if the clock is not running.\nPort D also serves the functions of various special features of the ATmega16 as listed on page\n63. \nRESET\nReset Input. A low level on this pin for longer than the minimum pulse length will generate a\nreset, even if the clock is not running. The minimum pulse length is given in Table 15 on page\n38. Shorter pulses are not guaranteed to generate a reset.\nXTAL1 Input to the inverting Oscillato r amplifier and input to the in ternal clock operating circuit.\nXTAL2 Output from the invert ing Oscillator amplifier.\nAVCC AVCC is the supply voltage pin for Port A and the A/D Converter. It should be externally con-\nnected to VCC, even if the ADC is not used. If the ADC is used, it should be connected to VCC\nthrough a low-pass filter. \nAREF AREF is the analog reference pin for the A/D Converter.\n\n6\n2466TS\u2013AVR\u201307/10ATmega16(L)Resources A comprehensive set of development tools, app lication notes and datasheets are available for\ndownload on http:// www.atmel.com/avr.\nNote: 1.\nData Retention Reliability Qualification results show that the pr ojected data retention failure rate is much less\nthan 1 PPM over 20 years at 85\u00b0C or 100 years at 25\u00b0C.\n\n7\n2466TS\u2013AVR\u201307/10ATmega16(L)\nRegister Summary\nAddress Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n$3F ($5F) SREG I T H S V N Z C 9\n$3E ($5E) SPH \u2013 \u2013 \u2013 \u2013 \u2013 SP10 SP9 SP8 12\n$3D ($5D) SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 12\n$3C ($5C) OCR0 Timer/Counter0 Output Compare Register 85\n$3B ($5B) GICR INT1 INT0 INT2 \u2013 \u2013 \u2013 IVSEL IVCE 48, 69 \n$3A ($5A) GIFR INTF1 INTF0 INTF2 \u2013 \u2013 \u2013 \u2013 \u20137 0\n$39 ($59) TIMSK OCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 OCIE0 TOIE0 85, 115, 133$38 ($58) TIFR OCF2 TOV2 ICF1 OCF1A OCF1B TOV1 OCF0 TOV0 86, 115, 133\n$37 ($57) SPMCR SPMIE RWWSB\n\u2013 RWWSRE BLBSET PGWRT PGERS SPMEN 250\n$36 ($56) TWCR TWINT TWEA TWSTA TWSTO TWWC TWEN \u2013 TWIE 180\n$35 ($55) MCUCR SM2 SE SM1 SM0 ISC11 ISC10 ISC01 ISC00 32, 68\n$34 ($54) MCUCSR JTD ISC2 \u2013 JTRF WDRF BORF EXTRF PORF 41, 69, 231\n$33 ($53) TCCR0 FOC0 WGM00 COM01 COM00 WGM01 CS02 CS01 CS00 83$32 ($52) TCNT0 Timer/Counter0 (8 Bits) 85\n$31\n(1) ($51)(1)OSCCAL Oscillator Calibration Register 30\nOCDR On-Chip Debug Register 227\n$30 ($50) SFIOR ADTS2 ADTS1 ADTS0 \u2013 ACME PUD PSR2 PSR10 57,88,134,201,221\n$2F ($4F) TCCR1A COM1A1 COM1A0 COM1B1 COM1B0 FOC1A FOC1B WGM11 WGM10 110\n$2E ($4E) TCCR1B ICNC1 ICES1 \u2013 WGM13 WGM12 CS12 CS11 CS10 113\n$2D ($4D) TCNT1H Timer/Counter1 \u2013 Counter Register High Byte 114\n$2C ($4C) TCNT1L Timer/Counter1 \u2013 Counter Register Low Byte 114\n$2B ($4B) OCR1AH Timer/Counter1 \u2013 Output Compare Register A High Byte 114\n$2A ($4A) OCR1AL Timer/Counter1 \u2013 Output Compare Register A Low Byte 114\n$29 ($49) OCR1BH Timer/Counter1 \u2013 Output Compare Register B High Byte 114\n$28 ($48) OCR1BL Timer/Counter1 \u2013 Output Compare Register B Low Byte 114\n$27 ($47) ICR1H Timer/Counter1 \u2013 Input Capture Register High Byte 114\n$26 ($46) ICR1L Timer/Counter1 \u2013 Input Capture Register Low Byte 114\n$25 ($45) TCCR2 FOC2 WGM20 COM21 COM20 WGM21 CS22 CS21 CS20 128\n$24 ($44) TCNT2 Timer/Counter2 (8 Bits) 130\n$23 ($43) OCR2 Timer/Counter2 Output Compare Register 130\n$22 ($42) ASSR \u2013 \u2013 \u2013 \u2013 AS2 TCN2UB OCR2UB TCR2UB 131\n$21 ($41) WDTCR \u2013 \u2013 \u2013 WDTOE WDE WDP2 WDP1 WDP0 43\n$20(2) ($40)(2)UBRRH URSEL \u2013 \u2013 \u2013 UBRR[11:8] 167\nUCSRC URSEL UMSEL UPM1 UPM0 USBS UCSZ1 UCSZ0 UCPOL 166\n$1F ($3F) EEARH \u2013 \u2013 \u2013 \u2013 \u2013 \u2013 \u2013E E A R 8 1 9\n$1E ($3E) EEARL EEPROM Address Register Low Byte 19\n$1D ($3D) EEDR EEPROM Data Register 19\n$1C ($3C) EECR \u2013 \u2013 \u2013 \u2013 EERIE EEMWE EEWE EERE 19\n$1B ($3B) PORTA PORTA7 PORTA6 PORTA5 PORTA4 PORTA3 PORTA2 PORTA1 PORTA0 66$1A ($3A) DDRA DDA7 DDA6 DDA5 DDA4 DDA3 DDA2 DDA1 DDA0 66\n$19 ($39) PINA PINA7 PINA6 PINA5 PINA4 PINA3 PINA2 PINA1 PINA0 66\n$18 ($38) PORTB PORTB7 PORTB6 PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 66$17 ($37) DDRB DDB7 DDB6 DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 66\n$16 ($36) PINB PINB7 PINB6 PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 66\n$15 ($35) PORTC PORTC7 PORTC6 PORTC5 PORTC4 PORTC3 PORTC2 PORTC1 PORTC0 67$14 ($34) DDRC DDC7 DDC6 DDC5 DDC4 DDC3 DDC2 DDC1 DDC0 67\n$13 ($33) PINC PINC7 PINC6 PINC5 PINC4 PINC3 PINC2 PINC1 PINC0 67\n$12 ($32) PORTD PORTD7 PORTD6 PORTD5 PORTD4 PORTD3 PORTD2 PORTD1 PORTD0 67$11 ($31) DDRD DDD7 DDD6 DDD5 DDD4 DDD3 DDD2 DDD1 DDD0 67\n$10 ($30) PIND PIND7 PIND6 PIND5 PIND4 PIND3 PIND2 PIND1 PIND0 67\n$0F ($2F) SPDR  SPI Data Register 142\n$0E ($2E) SPSR SPIF WCOL\n\u2013 \u2013 \u2013 \u2013 \u2013 SPI2X 142\n$0D ($2D) SPCR SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0 140\n$0C ($2C) UDR  USART I/O Data Register 163\n$0B ($2B) UCSRA RXC TXC UDRE FE DOR PE U2X MPCM 164\n$0A ($2A) UCSRB RXCIE TXCIE UDRIE RXEN TXEN UCSZ2 RXB8 TXB8 165\n$09 ($29) UBRRL  USART Baud Rate Register Low Byte 167\n$08 ($28) ACSR ACD ACBG ACO ACI ACIE ACIC ACIS1 ACIS0 202\n$07 ($27) ADMUX REFS1 REFS0 ADLAR MUX4 MUX3 MUX2 MUX1 MUX0 217\n$06 ($26) ADCSRA ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 219$05 ($25) ADCH ADC Data Register High Byte 220\n$04 ($24) ADCL ADC Data Register Low Byte 220\n$03 ($23) TWDR Two-wire Serial Interface Data Register 182\n$02 ($22) TWAR TWA6 TWA5 TWA4 TWA3 TWA2 TWA1 TWA0 TWGCE 182\n\n8\n2466TS\u2013AVR\u201307/10ATmega16(L)Notes: 1. When the OCDEN Fuse is unprogrammed, the OSCCAL Regist er is always accessed on this address. Refer to the debug-\nger specific documentation for details  on how to use the OCDR Register.\n2. Refer to the USART description for details on how to access UBRRH and UCSRC.3. For compatibility with future devices, reserved bits should be written to zero if accessed. Reserved I/O memory addresses\nshould never be written.\n4. Some of the Status Flags are cleared by writing a logical one to them. Note that the CBI and  SBI instructions will operate on\nall bits in the I/O Register, writing a one back into any flag read as set, thus clearing the flag. The CBI and SBI instruction s\nwork with registers $00 to $1F only.$01 ($21) TWSR TWS7 TWS6 TWS5 TWS4 TWS3 \u2013 TWPS1 TWPS0 181\n$00 ($20) TWBR Two-wire Serial Interface Bit Rate Register 180Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n\n9\n2466TS\u2013AVR\u201307/10ATmega16(L)\nInstruction Set Summary\nMnemonics Operands Description Operation Flags#Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \u2190 Rd + Rr Z,C,N,V,H 1\nADC Rd, Rr Add with Carry two Registers Rd \u2190 Rd + Rr + C Z,C,N,V,H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \u2190 Rdh:Rdl + K Z,C,N,V,S 2\nSUB Rd, Rr Subtract two Registers Rd \u2190 Rd - Rr Z,C,N,V,H 1\nSUBI Rd, K Subtract Constant from Register Rd \u2190 Rd - K Z,C,N,V,H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \u2190 Rd - Rr - C Z,C,N,V,H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \u2190 Rd - K - C Z,C,N,V,H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \u2190 Rdh:Rdl - K Z,C,N,V,S 2\nAND Rd, Rr Logical AND Registers Rd \u2190 Rd \u2022 Rr Z,N,V 1\nANDI Rd, K Logical AND Register and Constant Rd \u2190 Rd \u2022 K Z,N,V 1\nOR Rd, Rr Logical OR Registers Rd \u2190 Rd v Rr Z,N,V 1\nORI Rd, K Logical OR Register and Constant Rd \u2190 Rd v K Z,N,V 1\nEOR Rd, Rr Exclusive OR Registers Rd \u2190 Rd \u2295 Rr Z,N,V 1\nCOM Rd One\u2019s Complement Rd \u2190 $FF \u2212 Rd Z,C,N,V 1\nNEG Rd Two\u2019s Complement Rd \u2190 $00 \u2212 Rd Z,C,N,V,H 1\nSBR Rd,K Set Bit(s) in Register Rd \u2190 Rd v K Z,N,V 1\nCBR Rd,K Clear Bit(s) in Register Rd \u2190 Rd \u2022 ($FF - K) Z,N,V 1\nINC Rd Increment Rd \u2190 Rd + 1 Z,N,V 1\nDEC Rd Decrement Rd \u2190 Rd \u2212 1 Z,N,V 1\nTST Rd Test for Zero or Minus Rd \u2190 Rd \u2022 Rd Z,N,V 1\nCLR Rd Clear Register Rd  \u2190 Rd \u2295 Rd Z,N,V 1\nSER Rd Set Register Rd \u2190 $FF None 1\nMUL Rd, Rr Multiply Unsigned R1:R0 \u2190 Rd x Rr Z,C 2\nMULS Rd, Rr Multiply Signed R1:R0 \u2190 Rd x Rr Z,C 2\nMULSU Rd, Rr Multiply Signed with Unsigned R1:R0 \u2190 Rd x Rr Z,C 2\nFMUL Rd, Rr Fractional Multiply Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nFMULS Rd, Rr Fractional Multiply Signed R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nFMULSU Rd, Rr Fractional Multiply Signed with Unsigned R1:R0 \u2190 (Rd x Rr) << 1 Z,C 2\nBRANCH INSTRUCTIONS\nRJMP k Relative Jump PC  \u2190 PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \u2190 Z None 2\nJMP k Direct Jump PC  \u2190 kN o n e 3\nRCALL k Relative Subroutine Call PC \u2190 PC + k + 1 None 3\nICALL Indirect Call to (Z) PC \u2190 ZN o n e 3\nCALL k Direct Subroutine Call PC \u2190 kN o n e 4\nRET Subroutine Return PC \u2190 STACK None 4\nRETI Interrupt Return PC \u2190 STACK I 4\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC  \u2190 PC + 2 or 3 None 1 / 2 / 3\nCP Rd,Rr Compare Rd \u2212 Rr Z, N,V,C,H 1 \nCPC Rd,Rr Compare with Carry Rd \u2212 Rr \u2212 C Z, N,V,C,H 1\nCPI Rd,K Compare Register with Immediate Rd \u2212 K Z, N,V,C,H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \u2190 PC + 2 or 3 None 1 / 2 / 3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \u2190PC+k + 1 None 1 / 2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \u2190PC+k + 1 None 1 / 2\nBREQ  k Branch if Equal if (Z = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRCS  k Branch if Carry Set if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLO  k Branch if Lower if (C = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRMI  k Branch if Minus if (N = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRPL  k Branch if Plus if (N = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRGE  k Branch if Greater or Equal, Signed if (N \u2295 V= 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRLT  k Branch if Less Than Zero, Signed if (N \u2295 V= 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \u2190 PC + k  + 1 None 1 / 2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \u2190 PC + k + 1 None 1 / 2\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \u2190 PC + k + 1 None 1 / 2\n\n10\n2466TS\u2013AVR\u201307/10ATmega16(L)BRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \u2190 PC + k + 1 None 1 / 2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \u2190 PC + k + 1 None 1 / 2\nDATA TRANSFER INSTRUCTIONS\nMOV Rd, Rr Move Between Registers Rd \u2190 Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \u2190 Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \u2190 KN o n e 1\nLD Rd, X Load Indirect Rd \u2190 (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \u2190 (X), X \u2190 X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \u2190 X - 1, Rd \u2190 (X) None 2\nLD Rd, Y Load Indirect Rd \u2190 (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \u2190 (Y), Y \u2190 Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \u2190 Y - 1, Rd \u2190 (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \u2190 (Y + q) None 2\nLD Rd, Z Load Indirect Rd \u2190 (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \u2190 (Z), Z \u2190 Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \u2190 Z - 1, Rd \u2190 (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \u2190 (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \u2190 (k) None 2\nST X, Rr Store Indirect (X)  \u2190 Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X)  \u2190 Rr, X \u2190 X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \u2190 X - 1, (X) \u2190 Rr None 2\nST Y, Rr Store Indirect (Y) \u2190 Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \u2190 Rr, Y \u2190 Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \u2190 Y - 1, (Y) \u2190 Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \u2190 Rr None 2\nST Z, Rr Store Indirect (Z) \u2190 Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \u2190 Rr, Z \u2190 Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \u2190 Z - 1, (Z) \u2190 Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \u2190 Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \u2190 Rr None 2\nLPM Load Program Memory R0 \u2190 (Z) None 3\nLPM Rd, Z Load Program Memory Rd \u2190 (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \u2190 (Z), Z \u2190 Z+1 None 3\nSPM Store Program Memory (Z) \u2190 R1:R0 None -\nIN Rd, P In Port Rd \u2190 PN o n e 1\nOUT P, Rr Out Port P \u2190 Rr None 1\nPUSH Rr Push Register on Stack STACK \u2190 Rr None 2\nPOP Rd Pop Register from Stack Rd \u2190 STACK None 2\nBIT AND BIT-TEST INSTRUCTIONSSBI P,b Set Bit in I/O Register I/O(P,b) \u2190 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \u2190 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \u2190 Rd(n), Rd(0) \u2190 0 Z,C,N,V 1\nLSR Rd Logical Shift Right Rd(n) \u2190 Rd(n+1), Rd(7) \u2190 0 Z,C,N,V 1\nROL Rd Rotate Left Through Carry Rd(0) \u2190C,Rd(n+1) \u2190 Rd(n),C \u2190Rd(7) Z,C,N,V 1\nROR Rd Rotate Right Through Carry Rd(7) \u2190C,Rd(n) \u2190 Rd(n+1),C \u2190Rd(0) Z,C,N,V 1\nASR Rd Arithmetic Shift Right Rd(n) \u2190 Rd(n+1), n=0..6 Z,C,N,V 1\nSWAP Rd Swap Nibbles Rd(3..0) \u2190Rd(7..4),Rd(7..4) \u2190Rd(3..0) None 1\nBSET s Flag Set SREG(s) \u2190 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \u2190 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \u2190 Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \u2190 TN o n e 1\nSEC Set Carry C \u2190 1C 1\nCLC Clear Carry C \u2190 0 C 1\nSEN Set Negative Flag N \u2190 1N 1\nCLN Clear Negative Flag N \u2190 0 N 1\nSEZ Set Zero Flag Z \u2190 1Z 1\nCLZ Clear Zero Flag Z \u2190 0 Z 1\nSEI Global Interrupt Enable I \u2190 1I 1\nCLI Global Interrupt Disable I  \u2190 0 I 1\nSES Set Signed Test Flag S \u2190 1S 1\nCLS Clear Signed Test Flag S \u2190 0 S 1\nSEV Set Twos Complement Overflow. V \u2190 1V 1\nCLV Clear Twos Complement Overflow V \u2190 0 V 1\nSET Set T in SREG T \u2190 1T 1\nCLT Clear T in SREG T \u2190 0 T 1\nSEH Set Half Carry Flag in SREG H \u2190 1H 1Mnemonics Operands Description Operation Flags#Clocks\n\n11\n2466TS\u2013AVR\u201307/10ATmega16(L)\nCLH Clear Half Carry Flag in SREG H \u2190 0 H 1\nMCU CONTROL INSTRUCTIONS\nNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1WDR Watchdog Reset (see specific  descr. for WDR/timer) None 1\nBREAK Break For On-Chip Debug Only None N/AMnemonics Operands Description Operation Flags#Clocks\n\n12\n2466TS\u2013AVR\u201307/10ATmega16(L)Ordering Information\nNote: 1. Pb-free packaging complies to the European Directive fo r Restriction of Hazardous Substances (RoHS directive). Also\nHalide free and fully Green.Speed (MHz) Power Supply Ordering Code Package Operation Range\n8 2.7V - 5.5VATmega16L-8AU(1)\nATmega16L-8PU(1)\nATmega16L-8MU(1)44A\n40P644M1Industrial\n(-40\noC to 85oC)\n16 4.5V - 5.5VATmega16-16AU(1)\nATmega16-16PU(1)\nATmega16-16MU(1)44A\n40P6\n44M1Industrial\n(-40oC to 85oC)\nPackage Type\n44A 44-lead, Thin (1.0 mm) Plastic Gull Wing Quad Flat Package (TQFP)\n40P6 40-pin, 0.600\u201d Wide, Plastic Dual Inline Package (PDIP)\n44M1 44-pad, 7 \u00d7 7 \u00d7 1.0 mm body, lead pitch 0.50 mm, Qu ad Flat No-Lead/Micro Lead Frame Package (QFN/MLF)\n\n13\n2466TS\u2013AVR\u201307/10ATmega16(L)\nPackaging Information\n44A\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n44A,  44-lead, 10 x 10 mm Body Size, 1.0 mm Body Thickness,\n0.8 mm Lead Pitch, Thin Profile Plastic Quad Flat Package (TQFP) B 44A10/5/2001PIN 1 IDENTIFIER\n0\u02da~7\u02daPIN 1 \nLC\nA1 A2 AD1\nDe E1 EB\nCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. This package conforms to JEDEC reference MS-026, Variation ACB. \n2. Dimensions D1 and E1 do not include mold protrusion. Allowable \nprotrusion is 0.25 mm per side. Dimensions D1 and E1 are maximum plastic body size dimensions including mold mismatch.\n3. Lead coplanarity is 0.10 mm maximum.A \u2013 \u2013 1.20\nA1 0.05 \u2013 0.15A2  0.95 1.00 1.05           D 11.75 12.00 12.25D1 9.90 10.00 10.10 Note 2E 11.75 12.00 12.25E1 9.90 10.00 10.10 Note 2B           0.30 \u2013 0.45C 0.09 \u2013 0.20L 0.45 \u2013  0.75e 0.80 TYP\n\n14\n2466TS\u2013AVR\u201307/10ATmega16(L)40P6\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n40P6 , 40-lead (0.600\"/15.24 mm Wide) Plastic Dual \nInline Package (PDIP)  B 40P609/28/01PIN\n1\nE1\nA1\nB\nREFEB1\nCLSEATING PLANEA\n0\u00ba ~ 15\u00ba  D\ne\neBCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nA \u2013 \u2013 4.826\nA1 0.381 \u2013 \u2013D 52.070 \u2013 52.578 Note 2E 15.240 \u2013 15.875E1 13.462 \u2013 13.970 Note 2B 0.356 \u2013 0.559B1 1.041 \u2013 1.651L 3.048 \u2013 3.556C 0.203 \u2013      0.381     eB 15.494 \u2013 17.526e 2.540 TYPNotes: 1. This package conforms to JEDEC reference MS-011, Variation AC. \n2. Dimensions D and E1 do not include mold Flash or Protrusion.\nMold Flash or Protrusion shall not exceed 0.25 mm (0.010\").\n\n15\n2466TS\u2013AVR\u201307/10ATmega16(L)\n44M1\nTITLE DRAWING NO. GPC REV.\n   Package Drawing Contact:\n packagedrawings@atmel.com 44M1 ZWS H44M1, 44-pad, 7 x 7 x 1.0 mm Body,  Lead \nPitch 0.50 mm, 5.20 mm Exposed Pad, Thermally Enhanced Plastic Very Thin Quad Flat No Lead Package (VQFN)  9/26/08COMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 0.80 0.90 1.00\n A1 \u2013 0.02 0.05\n A3  0.20 REF\n b 0.18 0.23 0.30\n D  \n D2 5.00 5.20 5.40\n6.90 7.00 7.106.90 7.00 7.10\n E\n E2 5.00 5.20 5.40\n e  0.50 BSC\n L 0.59 0.64 0.69\nK 0.20 0.26 0.41Note:  JEDEC Standard MO-220, Fig. 1 (SAW Singulation) VKKD-3. TOP VIEW\nSIDE VIEW\nBOTTOM VIEWD\nEMarked Pin# 1 ID\nE2D2\nb ePin #1 CornerLA1\nA3\nASEATING PLANE\nPin #1 \nTriangle\nPin #1 \nChamfer(C 0.30)Option A\nOption B\nPin #1 \nNotch(0.20 R)Option CK\nK1\n2\n3\n\n16\n2466TS\u2013AVR\u201307/10ATmega16(L)Errata The revision letter in this section refers to the revision of the ATmega16 device.\nATmega16(L) Rev. \nM\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\nATmega16(L) Rev. \nL\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\n\n17\n2466TS\u2013AVR\u201307/10ATmega16(L)\nProblem Fix/Workaround\nWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\nATmega16(L) Rev. \nK\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n\n18\n2466TS\u2013AVR\u201307/10ATmega16(L) Problem Fix / Workaround\nAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\nATmega16(L) Rev. \nJ\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\n\n19\n2466TS\u2013AVR\u201307/10ATmega16(L)\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\nATmega16(L) Rev. \nI\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n\n20\n2466TS\u2013AVR\u201307/10ATmega16(L)4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\nATmega16(L) Rev. \nH\u0081First Analog Comparator conversion may be delayed\n\u0081Interrupts may be lost when writing the timer registers in the asynchronous timer\n\u0081IDCODE masks data from TDI input\n\u0081Reading EEPROM by using ST or STS to set EER E bit triggers unexp ected interr upt request\n1. First Analog Comparator conversion may be delayed\nIf the device is powered by a slow rising VCC, the first Analog Comparator conversion will\ntake longer than expected on some devices.\nProblem Fix/WorkaroundWhen the device has been powered or reset, disable then enable theAnalog Comparator\nbefore the first conversion.\n2. Interrupts may be lost when writing the timer registers in the asynchronous timer\nThe interrupt will be lost if a timer register th at is synchronized to the asynchronous timer\nclock is written when the asynchronous Timer/Counter register(TCNTx) is 0x00.\n Problem Fix / WorkaroundAlways check that the asynchronous Timer/Counter register neither have the value 0xFF nor\n0x00 before writing to the asynchronous Timer Control Register(TCCRx), asynchronousTimer Counter Register(TCNTx), or asynchronous Output Compare Register(OCRx).\n3. IDCODE masks data from TDI input\nThe JTAG instruction IDCODE is not working correctly. Data to succeeding devices are\nreplaced by all-ones during Update-DR.\nProblem Fix / Workaround\n\u2013 If ATmega16 is the only device in the scan chain, the problem is not visible.\u2013 Select the Device ID Register of the ATmega16 by issuing the IDCODE instruction or\nby entering the Test-Logic-Reset state of the TAP controller to read out the contentsof its Device ID Register and possibly data from succeeding devices of the scan\nchain. Issue the BYPASS instruction to th e ATmega16 while reading the Device ID\nRegisters of preceding device s of the boundary scan chain.\n\u2013 If the Device IDs of all devices in the boundary scan chain must be captured\nsimultaneously, the ATmega16 must be the fist device in the chain.\n4. Reading EEPROM by using ST or STS to set EERE bit triggers unexpected interrupt\nrequest.\nReading EEPROM by using the ST  or STS command to set th e EERE bit in the EECR reg-\nister triggers an unexpecte d EEPROM interrupt request.\nProblem Fix / WorkaroundAlways use OUT or SBI  to set EERE in EECR.\n\n21\n2466TS\u2013AVR\u201307/10ATmega16(L)\nDatasheet \nRevision \nHistoryPlease note that the referring page numbers in this section are referred to this document. The\nreferring revision in this section are referring to the document revision.\nRev. 2466T-07/10 1.  Corrected use of comma in formula Rp in Table 120, \u201cTwo-wire Serial Bus Require-\nments,\u201d on page 294 .\n2.  Updated document according to Atmel\u2019s Technical Terminology3. Note 6 and Note 7 under Table 120, \u201cTwo-wire Serial Bus Requirements,\u201d on page 294\nhave been removed.\nRev. 2466S-05/09 1.  Updated \u201cErrata\u201d on page 340 .\n2.  Updated the last page with Atmel\u2019s new adresses.\nRev. 2466R-06/08 1. Added \u201cNot recommended for new designs\u201d note in Figure  on page 1 .\nRev. 2466Q-05/08 1. Updated \u201cFast PWM Mode\u201d on page 77  in \u201c8-bit Timer/Counter0 with PWM\u201d on page\n71:\n\u2013 Removed the last section describing how to achieve a frequency with 50% duty \ncycle waveform output in fast PWM mode.\n2. Removed note from Feature list in \u201cAnalog to Digital Converter\u201d on page 204 .\n3. Removed note from Table 84 on page 218 .\n4. Updated \u201cOrdering Information\u201d on page 336 :\n- Commercial ordering codes removed.- Non Pb-free package option removed.\nRev. 2466P-08/07 1. Updated \u201cFeatures\u201d on page 1 .\n2. Added \u201cData Retention\u201d on page 6 .\n3. Updated \u201cErrata\u201d on page 340 .\n4. Updated \u201cSlave Mode\u201d on page 140 .\nRev. 2466O-03/07 1. Updated \u201cCalibrated Internal RC Oscillator\u201d on page 29 .\n2. Updated C code example in \u201cUSART Initialization\u201d on page 149 .\n3. Updated \u201cATmega16 Boundary-scan Order\u201d on page 241 .\n4. Removed \u201cpremilinary\u201d from \u201cADC Characteristics\u201d on page 297 .\n5. Updated from V to mV in \u201cI/O Pin Input Hysteresis vs. VCC\u201d on page 317 .\n6. Updated from V to mV in \u201cReset Input Pin Hysteresis vs. VCC\u201d on page 318 .\n\n22\n2466TS\u2013AVR\u201307/10ATmega16(L)Rev. 2466N-10/06 1. Updated \u201cTimer/Counter Oscillator\u201d on page 31 .\n2. Updated \u201cFast PWM Mode\u201d on page 102 .\n3. Updated Table 38 on page 83 , Table 40 on page 84 , Table 45 on page 111 , Table 47 on\npage 112 , Table 50 on page 128  and Table 52 on page 129 .\n4. Updated C code example in \u201cUSART Initialization\u201d on page 149 .\n5. Updated \u201cErrata\u201d on page 340 .\nRev. 2466M-04/06 1. Updated typos.\n2. Updated \u201cSerial Peripheral Interface \u2013 SPI\u201d on page 135 .\n3. Updated Table 86 on page 221 , Table 116 on page 276  ,Table 121 on page 295  and\nTable 122 on page 297 .\nRev. 2466L-06/05 1. Updated note in \u201cBit Rate Generator Unit\u201d on page 178 .\n2. Updated values for VINT in \u201cADC Characteristics\u201d on page 297 .\n3. Updated \u201cSerial Programming Instruction set\u201d on page 276 .\n4. Updated USART init C-code example in \u201cUSART\u201d on page 144 .\nRev. 2466K-04/05 1. Updated \u201cOrdering Information\u201d on page 336 .\n2. MLF-package alternative changed to \u201cQuad Flat No-Lead/Micro Lead Frame Package\nQFN/MLF\u201d.\n3. Updated \u201cElectrical Characteristics\u201d on page 291 .\nRev. 2466J-10/04 1. Updated \u201cOrdering Information\u201d on page 336 .\nRev. 2466I-10/04 1. Removed references to analog ground.\n2. Updated Table 7 on page 28 , Table 15 on page 38 , Table 16 on page 42 , Table 81 on\npage 209 , Table 116 on page 276 , and Table 119 on page 293 .\n3. Updated \u201cPinout ATmega16\u201d on page 2 .\n4. Updated features in \u201cAnalog to Digital Converter\u201d on page 204 .\n5. Updated \u201cVersion\u201d on page 229 .\n6. Updated \u201cCalibration Byte\u201d on page 261 .\n7. Added \u201cPage Size\u201d on page 262 .\nRev. 2466H-12/03 1. Updated \u201cCalibrated Internal RC Oscillator\u201d on page 29 .\n\n23\n2466TS\u2013AVR\u201307/10ATmega16(L)\nRev. 2466G-10/03 1. Removed \u201cPreliminary\u201d from the datasheet.\n2. Changed ICP to ICP1 in the datasheet.3. Updated \u201cJTAG Interface and On-chip Debug System\u201d on page 36 .\n4. Updated assembly and C code examples in \u201cWatchdog Timer Control Register \u2013\nWDTCR\u201d on page 43 .\n5. Updated Figure 46 on page 103 .\n6. Updated Table 15 on page 38 , Table 82 on page 217  and Table 115 on page 276 .\n7. Updated \u201cTest Access Port \u2013 TAP\u201d on page 222  regarding JTAGEN.\n8. Updated description for the JTD bit on page 231 .\n9. Added note 2 to Figure 126 on page 252 .\n10. Added a note regarding JTAGEN fuse to Table 105 on page 260 .\n11. Updated Absolute Maximum Ratings* and DC Characteristics in \u201cElectrical Character-\nistics\u201d on page 291 .\n12. Updated \u201cATmega16 Typical Characteristics\u201d on page 299 .\n13. Fixed typo for 16 MHz QFN/MLF package in \u201cOrdering Information\u201d on page 336 .\n14. Added a proposal for solving problems regarding the JTAG instruction IDCODE in\n\u201cErrata\u201d on page 340 .\nRev. 2466F-02/03 1. Added note about masking out unused bits when reading the Program Counter in\n\u201cStack Pointer\u201d on page 12 .\n2. Added Chip Erase as a first step in \u201cProgramming the Flash\u201d on page 288  and \u201cPro-\ngramming the EEPROM\u201d on page 289 .\n3. Added the section \u201cUnconnected pins\u201d on page 55 .\n4. Added tips on how to disable the OCD system in \u201cOn-chip Debug System\u201d on page\n34.\n5. Removed reference to the \u201cMulti-purpose Oscillator\u201d application note and \u201c32 kHz\nCrystal Oscillator\u201d application note, which do not exist.\n6. Added information about PWM symmetry for Timer0 and Timer2.7. Added note in \u201cFilling the Temporary Buffer (Page Loading)\u201d on page 253  about writ-\ning to the EEPROM during an SPM Page Load.\n8. Removed ADHSM completely.\n\n24\n2466TS\u2013AVR\u201307/10ATmega16(L)9. Added Table 73, \u201cTWI Bit Rate Prescaler,\u201d on page 182  to describe the TWPS bits in\nthe \u201cTWI Status Register \u2013 TWSR\u201d on page 181 .\n10. Added section \u201cDefault Clock Source\u201d on page 25 .\n11. Added note about frequency variation when using an external clock. Note added in\n\u201cExternal Clock\u201d on page 31 . An extra row and a note added in Table 118 on page 293 . \n12. Various minor TWI corrections.13. Added \u201cPower Consumption\u201d data in \u201cFeatures\u201d on page 1 .\n14. Added section \u201cEEPROM Write During Power-down Sleep Mode\u201d on page 22 .\n15. Added note about Differential Mode with Auto Triggering in \u201cPrescaling and Conver-\nsion Timing\u201d on page 207 .\n16. Added updated \u201cPackaging Information\u201d on page 337 .\nRev. 2466E-10/02 1. Updated \u201cDC Characteristics\u201d on page 291 .\nRev. 2466D-09/02 1. Changed all Flash write/erase cycles from 1,000 to 10,000.\n2. Updated the following tables: Table 4 on page 26 , Table 15 on page 38 , Table 42 on\npage 85 , Table 45 on page 111 , Table 46 on page 111 , Table 59 on page 143 , Table 67\non page 167 , Table 90 on page 235 , Table 102 on page 258 , \u201cDC Characteristics\u201d on\npage 291 , Table 119 on page 293 , Table 121 on page 295 , and Table 122 on page 297 .\n3. Updated \u201cErrata\u201d on page 340 .\nRev. 2466C-03/02 1. Updated typical EEPROM programming time, Table 1 on page 20 .\n2. Updated typical start-up time in the following tables:\nTable 3 on page 25 , Table 5 on page 27 , Table 6 on page 28 , Table 8 on page 29 , Table 9\non page 29 , and Table 10 on page 29 .\n3. Updated Table 17 on page 43  with typical WDT Time-out.\n4. Added Some Preliminary Test Li mits and Characterization Data.\nRemoved some of the TBD's in the following tables and pages:Table 15 on page 38 , Table 16 on page 42 , Table 116 on page 272 (table removed in docu-\nment review #D), \u201cElectrical Characteri stics\u201d on page 291 , Table 119 on page 293 , Table\n121 on page 295 , and Table 122 on page 297 .\n5. Updated TWI Chapter.\nAdded the note at the end of the \u201cBit Rate Generator Unit\u201d on page 178 .\n6. Corrected description of ADSC bit in \u201cADC Control and Status Register A \u2013 ADCSRA\u201d\non page 219 .\n7. Improved description on how to do a polarity check of the ADC doff results in \u201cADC\nConversion Result\u201d on page 216 .\n\n25\n2466TS\u2013AVR\u201307/10ATmega16(L)\n8. Added JTAG version number for rev. H in Table 87 on page 229 .\n9. Added not regarding OCDEN Fuse below Table 105 on page 260 .\n10. Updated Programming Figures:\nFigure 127 on page 262  and Figure 136 on page 273  are updated to also reflect that AVCC\nmust be connected during Programming mode. Figure 131 on page 269  added to illustrate\nhow to program the fuses.\n11. Added a note regarding usage of the \u201cPROG_PAGELOAD ($6)\u201d on page 280  and\n\u201cPROG_PAGEREAD ($7)\u201d on page 280 .\n12. Removed alternative algortihm for leaving JTAG Programming mode. \nSee \u201cLeaving Programming Mode\u201d on page 288.\n13. Added Calibrated RC Oscillator characterization curves in section \u201cATmega16 Typi-\ncal Characteristics\u201d on page 299 .\n14. Corrected ordering code for QFN/MLF package (16MHz) in \u201cOrdering Information\u201d on\npage 336 .\n15. Corrected Table 90, \u201cScan Signals for the Oscillators(1)(2)(3),\u201d on page 235 .\n\n2466TS\u2013AVR\u201307/10Headquarters International\nAtmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel: 1(408) 441-0311\nFax: 1(408) 487-2600Atmel Asia\nUnit 1-5 & 16, 19/F\nBEA Tower, Millennium City 5\n418 Kwun Tong RoadKwun Tong, Kowloon\nHong Kong\nTel: (852) 2245-6100Fax: (852) 2722-1369Atmel Europe\nLe Krebs\n8, Rue Jean-Pierre Timbaud\nBP 30978054 Saint-Quentin-en-\nYvelines Cedex\nFranceTel: (33) 1-30-60-70-00 \nFax: (33) 1-30-60-71-11Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033Japan\nTel: (81) 3-3523-3551\nFax: (81) 3-3523-7581\nProduct Contact\nWeb Sitewww.atmel.comTechnical Support\navr@atmel.comSales Contact\nwww.atmel.com/contacts\nLiterature Requests\nwww.atmel.com/literature\nDisclaimer:  The information in this document is provided in connection with  Atmel products. No license, express or implied, by estoppel or  otherwise, to any\nintellectual property right is granted by this document  or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN ATMEL \u2019S TERMS AND CONDI-\nTIONS OF SALE LOCATED ON ATMEL \u2019S WEB SITE, ATMEL ASSUMES NO LI ABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTOR Y\nWARRANTY RELATING TO ITS PRODUCTS INCLUDING,  BUT NOT LIMITED TO, THE IMPLIED WARRANTY  OF MERCHANTABILITY, FITNESS FOR A PARTICU LAR\nPURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR I NCIDEN-\nTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING  OUT OF\nTHE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATME L HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH DAMAGES.  Atmel makes no\nrepresentations or warranties with respect to the accuracy or comp leteness of the contents of this document and reserves the rig ht to make changes to specifications\nand product descriptions at any time without notice. Atmel does  not make any commitment to update the information contained her ein. Unless specifically provided\notherwise, Atmel products are not suitable for, and shall not be used in, automotive applications. Atmel\u2019s products are not int ended, authorized, or warranted for use\nas components in applications in tended to support or sustain life.\n\u00a9 2010 Atmel Corporation. All rights reserved. Atmel\u00ae, Atmel logo and combinations thereof, AVR\u00ae and others are registered trademarks or\ntrademarks of Atmel Corporation or its subsidiaries. Other terms and product names may be trademarks of others."}